/*! For license information please see bundle.js.LICENSE.txt */
(() => {
    var t = {
            205: (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, { PhysicsLoader: () => s });
                const i = (() => { try { if ("object" == typeof WebAssembly && "function" == typeof WebAssembly.instantiate) { const t = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0)); if (t instanceof WebAssembly.Module) return new WebAssembly.Instance(t) instanceof WebAssembly.Instance } } catch (t) { console.error(t.message) } return !1 })(),
                    r = (t, e) => {
                        ((t, e) => {
                            var n = document.createElement("script");
                            n.onload = () => { e() }, n.onerror = () => { throw new Error(`failed to load ${t}`) }, n.async = !0, n.src = t, document.head.appendChild(n)
                        })(i ? `/2021/wp-content/themes/hivcd2021/dice/ammo/ammo.wasm.js` : `/2021/wp-content/themes/hivcd2021/dice/ammo/ammo.js`, (() => e()))
                    },
                    s = (t, e) => { "undefined" != typeof window && (window.__loadPhysics = !0), r(t, (() => { Ammo().then((() => { e() })) })) }
            },
            784: (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, { DotScreenShader: () => kR, EffectComposer: () => OR, ExtendedGroup: () => UL, ExtendedMesh: () => EA, ExtendedObject3D: () => iL, FLAT: () => s, FirstPersonControls: () => TR, GlitchPass: () => HR, JoyStick: () => MR, PhysicsLoader: () => IL.PhysicsLoader, PointerDrag: () => AR, PointerLock: () => ER, Project: () => zL, RenderPass: () => zR, Scene3D: () => eL, ShaderPass: () => DR, THREE: () => i, ThirdPersonControls: () => SR, Types: () => o });
                var i = {};
                n.r(i), n.d(i, { ACESFilmicToneMapping: () => ot, AddEquation: () => R, AddOperation: () => et, AdditiveAnimationBlendMode: () => Je, AdditiveBlending: () => T, AlphaFormat: () => Ht, AlwaysDepth: () => q, AlwaysStencilFunc: () => Ln, AmbientLight: () => Ou, AmbientLightProbe: () => rd, AnimationClip: () => iu, AnimationLoader: () => uu, AnimationMixer: () => Bd, AnimationObjectGroup: () => Dd, AnimationUtils: () => Wh, ArcCurve: () => Ec, ArrayCamera: () => Ka, ArrowHelper: () => Tp, Audio: () => fd, AudioAnalyser: () => bd, AudioContext: () => ed, AudioListener: () => md, AudioLoader: () => nd, AxesHelper: () => Ep, AxisHelper: () => Mm, BackSide: () => x, BasicDepthPacking: () => cn, BasicShadowMap: () => m, BinaryTextureLoader: () => Lm, Bone: () => Ol, BooleanKeyframeTrack: () => Jh, BoundingBoxHelper: () => Sm, Box2: () => jd, Box3: () => mi, Box3Helper: () => _p, BoxBufferGeometry: () => Ss, BoxGeometry: () => Ss, BoxHelper: () => xp, BufferAttribute: () => Fr, BufferGeometry: () => rs, BufferGeometryLoader: () => Wu, ByteType: () => Rt, Cache: () => su, Camera: () => Rs, CameraHelper: () => gp, CanvasRenderer: () => Cm, CanvasTexture: () => dc, CatmullRomCurve3: () => Ic, CineonToneMapping: () => st, CircleBufferGeometry: () => mc, CircleGeometry: () => mc, ClampToEdgeWrapping: () => gt, Clock: () => ld, Color: () => Dr, ColorKeyframeTrack: () => Kh, CompressedTexture: () => uc, CompressedTextureLoader: () => du, ConeBufferGeometry: () => gc, ConeGeometry: () => gc, CubeCamera: () => Is, CubeReflectionMapping: () => ct, CubeRefractionMapping: () => ht, CubeTexture: () => Ds, CubeTextureLoader: () => mu, CubeUVReflectionMapping: () => pt, CubeUVRefractionMapping: () => mt, CubicBezierCurve: () => Oc, CubicBezierCurve3: () => Fc, CubicInterpolant: () => qh, CullFaceBack: () => u, CullFaceFront: () => d, CullFaceFrontBack: () => p, CullFaceNone: () => h, Curve: () => Sc, CurvePath: () => vu, CustomBlending: () => L, CustomToneMapping: () => at, CylinderBufferGeometry: () => fc, CylinderGeometry: () => fc, Cylindrical: () => Vd, DataTexture: () => Fl, DataTexture2DArray: () => lo, DataTexture3D: () => co, DataTextureLoader: () => fu, DataUtils: () => Rp, DecrementStencilOp: () => vn, DecrementWrapStencilOp: () => xn, DefaultLoadingManager: () => au, DepthFormat: () => qt, DepthStencilFormat: () => Xt, DepthTexture: () => pc, DirectionalLight: () => Bu, DirectionalLightHelper: () => pp, DiscreteInterpolant: () => Yh, DodecahedronBufferGeometry: () => yc, DodecahedronGeometry: () => yc, DoubleSide: () => _, DstAlphaFactor: () => H, DstColorFactor: () => G, DynamicBufferAttribute: () => pm, DynamicCopyUsage: () => On, DynamicDrawUsage: () => Cn, DynamicReadUsage: () => Dn, EdgesGeometry: () => Mc, EdgesHelper: () => Tm, EllipseCurve: () => Tc, EqualDepth: () => Z, EqualStencilFunc: () => Mn, EquirectangularReflectionMapping: () => ut, EquirectangularRefractionMapping: () => dt, Euler: () => Qi, EventDispatcher: () => Hn, ExtrudeBufferGeometry: () => vh, ExtrudeGeometry: () => vh, FaceColors: () => nm, FileLoader: () => hu, FlatShading: () => b, Float16BufferAttribute: () => jr, Float32Attribute: () => bm, Float32BufferAttribute: () => qr, Float64Attribute: () => wm, Float64BufferAttribute: () => Xr, FloatType: () => Nt, Fog: () => ol, FogExp2: () => sl, Font: () => Ku, FontLoader: () => $u, FrontSide: () => y, Frustum: () => ks, GLBufferAttribute: () => zd, GLSL1: () => zn, GLSL3: () => Un, GammaEncoding: () => nn, GreaterDepth: () => K, GreaterEqualDepth: () => J, GreaterEqualStencilFunc: () => An, GreaterStencilFunc: () => Tn, GridHelper: () => lp, Group: () => Qa, HalfFloatType: () => Bt, HemisphereLight: () => bu, HemisphereLightHelper: () => ap, HemisphereLightProbe: () => id, IcosahedronBufferGeometry: () => xh, IcosahedronGeometry: () => xh, ImageBitmapLoader: () => Zu, ImageLoader: () => pu, ImageUtils: () => ni, ImmediateRenderObject: () => Zd, IncrementStencilOp: () => gn, IncrementWrapStencilOp: () => yn, InstancedBufferAttribute: () => Vu, InstancedBufferGeometry: () => Gu, InstancedInterleavedBuffer: () => Fd, InstancedMesh: () => jl, Int16Attribute: () => vm, Int16BufferAttribute: () => kr, Int32Attribute: () => xm, Int32BufferAttribute: () => Vr, Int8Attribute: () => mm, Int8BufferAttribute: () => zr, IntType: () => It, InterleavedBuffer: () => ll, InterleavedBufferAttribute: () => hl, Interpolant: () => jh, InterpolateDiscrete: () => Ve, InterpolateLinear: () => We, InterpolateSmooth: () => je, InvertStencilOp: () => _n, JSONLoader: () => Pm, KeepStencilOp: () => mn, KeyframeTrack: () => Zh, LOD: () => Rl, LatheBufferGeometry: () => _h, LatheGeometry: () => _h, Layers: () => $i, LensFlare: () => Dm, LessDepth: () => X, LessEqualDepth: () => Y, LessEqualStencilFunc: () => Sn, LessStencilFunc: () => wn, Light: () => _u, LightProbe: () => Uu, Line: () => Ql, Line3: () => Yd, LineBasicMaterial: () => ql, LineCurve: () => zc, LineCurve3: () => Uc, LineDashedMaterial: () => Gh, LineLoop: () => nc, LinePieces: () => tm, LineSegments: () => ec, LineStrip: () => $p, LinearEncoding: () => tn, LinearFilter: () => Mt, LinearInterpolant: () => Xh, LinearMipMapLinearFilter: () => At, LinearMipMapNearestFilter: () => Tt, LinearMipmapLinearFilter: () => Et, LinearMipmapNearestFilter: () => St, LinearToneMapping: () => it, Loader: () => lu, LoaderUtils: () => ku, LoadingManager: () => ou, LogLuvEncoding: () => sn, LoopOnce: () => He, LoopPingPong: () => Ge, LoopRepeat: () => ke, LuminanceAlphaFormat: () => Wt, LuminanceFormat: () => Vt, MOUSE: () => l, Material: () => Er, MaterialLoader: () => Hu, Math: () => Qn, MathUtils: () => Qn, Matrix3: () => ti, Matrix4: () => Gi, MaxEquation: () => D, Mesh: () => ws, MeshBasicMaterial: () => Nr, MeshDepthMaterial: () => ja, MeshDistanceMaterial: () => qa, MeshFaceMaterial: () => rm, MeshLambertMaterial: () => Hh, MeshMatcapMaterial: () => kh, MeshNormalMaterial: () => Uh, MeshPhongMaterial: () => Fh, MeshPhysicalMaterial: () => Oh, MeshStandardMaterial: () => Bh, MeshToonMaterial: () => zh, MinEquation: () => I, MirroredRepeatWrapping: () => vt, MixOperation: () => tt, MultiMaterial: () => sm, MultiplyBlending: () => A, MultiplyOperation: () => $, NearestFilter: () => yt, NearestMipMapLinearFilter: () => wt, NearestMipMapNearestFilter: () => _t, NearestMipmapLinearFilter: () => bt, NearestMipmapNearestFilter: () => xt, NeverDepth: () => j, NeverStencilFunc: () => bn, NoBlending: () => M, NoColors: () => em, NoToneMapping: () => nt, NormalAnimationBlendMode: () => Ze, NormalBlending: () => S, NotEqualDepth: () => Q, NotEqualStencilFunc: () => En, NumberKeyframeTrack: () => Qh, Object3D: () => pr, ObjectLoader: () => ju, ObjectSpaceNormalMap: () => dn, OctahedronBufferGeometry: () => bh, OctahedronGeometry: () => bh, OneFactor: () => B, OneMinusDstAlphaFactor: () => k, OneMinusDstColorFactor: () => V, OneMinusSrcAlphaFactor: () => U, OneMinusSrcColorFactor: () => F, OrthographicCamera: () => Du, PCFShadowMap: () => f, PCFSoftShadowMap: () => g, PMREMGenerator: () => qp, ParametricBufferGeometry: () => wh, ParametricGeometry: () => wh, Particle: () => am, ParticleBasicMaterial: () => hm, ParticleSystem: () => lm, ParticleSystemMaterial: () => um, Path: () => yu, PerspectiveCamera: () => Cs, Plane: () => zs, PlaneBufferGeometry: () => Ws, PlaneGeometry: () => Ws, PlaneHelper: () => bp, PointCloud: () => om, PointCloudMaterial: () => cm, PointLight: () => Iu, PointLightHelper: () => ip, Points: () => lc, PointsMaterial: () => ic, PolarGridHelper: () => cp, PolyhedronBufferGeometry: () => vc, PolyhedronGeometry: () => vc, PositionalAudio: () => _d, PropertyBinding: () => Id, PropertyMixer: () => wd, QuadraticBezierCurve: () => Hc, QuadraticBezierCurve3: () => kc, Quaternion: () => hi, QuaternionKeyframeTrack: () => tu, QuaternionLinearInterpolant: () => $h, REVISION: () => a, RGBADepthPacking: () => hn, RGBAFormat: () => Gt, RGBAIntegerFormat: () => $t, RGBA_ASTC_10x10_Format: () => we, RGBA_ASTC_10x5_Format: () => xe, RGBA_ASTC_10x6_Format: () => _e, RGBA_ASTC_10x8_Format: () => be, RGBA_ASTC_12x10_Format: () => Me, RGBA_ASTC_12x12_Format: () => Se, RGBA_ASTC_4x4_Format: () => ue, RGBA_ASTC_5x4_Format: () => de, RGBA_ASTC_5x5_Format: () => pe, RGBA_ASTC_6x5_Format: () => me, RGBA_ASTC_6x6_Format: () => fe, RGBA_ASTC_8x5_Format: () => ge, RGBA_ASTC_8x6_Format: () => ve, RGBA_ASTC_8x8_Format: () => ye, RGBA_BPTC_Format: () => Te, RGBA_ETC2_EAC_Format: () => he, RGBA_PVRTC_2BPPV1_Format: () => ae, RGBA_PVRTC_4BPPV1_Format: () => oe, RGBA_S3TC_DXT1_Format: () => ee, RGBA_S3TC_DXT3_Format: () => ne, RGBA_S3TC_DXT5_Format: () => ie, RGBDEncoding: () => ln, RGBEEncoding: () => rn, RGBEFormat: () => jt, RGBFormat: () => kt, RGBIntegerFormat: () => Qt, RGBM16Encoding: () => an, RGBM7Encoding: () => on, RGB_ETC1_Format: () => le, RGB_ETC2_Format: () => ce, RGB_PVRTC_2BPPV1_Format: () => se, RGB_PVRTC_4BPPV1_Format: () => re, RGB_S3TC_DXT1_Format: () => te, RGFormat: () => Jt, RGIntegerFormat: () => Kt, RawShaderMaterial: () => Nh, Ray: () => ki, Raycaster: () => Ud, RectAreaLight: () => Fu, RedFormat: () => Yt, RedIntegerFormat: () => Zt, ReinhardToneMapping: () => rt, RepeatWrapping: () => ft, ReplaceStencilOp: () => fn, ReverseSubtractEquation: () => P, RingBufferGeometry: () => Mh, RingGeometry: () => Mh, SRGB8_ALPHA8_ASTC_10x10_Format: () => Fe, SRGB8_ALPHA8_ASTC_10x5_Format: () => Ne, SRGB8_ALPHA8_ASTC_10x6_Format: () => Be, SRGB8_ALPHA8_ASTC_10x8_Format: () => Oe, SRGB8_ALPHA8_ASTC_12x10_Format: () => ze, SRGB8_ALPHA8_ASTC_12x12_Format: () => Ue, SRGB8_ALPHA8_ASTC_4x4_Format: () => Ee, SRGB8_ALPHA8_ASTC_5x4_Format: () => Ae, SRGB8_ALPHA8_ASTC_5x5_Format: () => Le, SRGB8_ALPHA8_ASTC_6x5_Format: () => Re, SRGB8_ALPHA8_ASTC_6x6_Format: () => Ce, SRGB8_ALPHA8_ASTC_8x5_Format: () => Pe, SRGB8_ALPHA8_ASTC_8x6_Format: () => Ie, SRGB8_ALPHA8_ASTC_8x8_Format: () => De, Scene: () => al, SceneUtils: () => Im, ShaderChunk: () => js, ShaderLib: () => Xs, ShaderMaterial: () => Ls, ShadowMaterial: () => Dh, Shape: () => xu, ShapeBufferGeometry: () => Sh, ShapeGeometry: () => Sh, ShapePath: () => Ju, ShapeUtils: () => mh, ShortType: () => Ct, Skeleton: () => Hl, SkeletonHelper: () => ep, SkinnedMesh: () => Bl, SmoothShading: () => w, Sphere: () => Di, SphereBufferGeometry: () => Th, SphereGeometry: () => Th, Spherical: () => Gd, SphericalHarmonics3: () => zu, SplineCurve: () => Gc, SpotLight: () => Au, SpotLightHelper: () => Kd, Sprite: () => Tl, SpriteMaterial: () => ul, SrcAlphaFactor: () => z, SrcAlphaSaturateFactor: () => W, SrcColorFactor: () => O, StaticCopyUsage: () => Bn, StaticDrawUsage: () => Rn, StaticReadUsage: () => In, StereoCamera: () => ad, StreamCopyUsage: () => Fn, StreamDrawUsage: () => Pn, StreamReadUsage: () => Nn, StringKeyframeTrack: () => eu, SubtractEquation: () => C, SubtractiveBlending: () => E, TOUCH: () => c, TangentSpaceNormalMap: () => un, TetrahedronBufferGeometry: () => Eh, TetrahedronGeometry: () => Eh, TextBufferGeometry: () => Ah, TextGeometry: () => Ah, Texture: () => ri, TextureLoader: () => gu, TorusBufferGeometry: () => Lh, TorusGeometry: () => Lh, TorusKnotBufferGeometry: () => Rh, TorusKnotGeometry: () => Rh, Triangle: () => Sr, TriangleFanDrawMode: () => $e, TriangleStripDrawMode: () => Qe, TrianglesDrawMode: () => Ke, TubeBufferGeometry: () => Ch, TubeGeometry: () => Ch, UVMapping: () => lt, Uint16Attribute: () => ym, Uint16BufferAttribute: () => Gr, Uint32Attribute: () => _m, Uint32BufferAttribute: () => Wr, Uint8Attribute: () => fm, Uint8BufferAttribute: () => Ur, Uint8ClampedAttribute: () => gm, Uint8ClampedBufferAttribute: () => Hr, Uniform: () => Od, UniformsLib: () => qs, UniformsUtils: () => As, UnsignedByteType: () => Lt, UnsignedInt248Type: () => Ut, UnsignedIntType: () => Dt, UnsignedShort4444Type: () => Ot, UnsignedShort5551Type: () => Ft, UnsignedShort565Type: () => zt, UnsignedShortType: () => Pt, VSMShadowMap: () => v, Vector2: () => $n, Vector3: () => ui, Vector4: () => oi, VectorKeyframeTrack: () => nu, Vertex: () => dm, VertexColors: () => im, VideoTexture: () => hc, WebGL1Renderer: () => rl, WebGLCubeRenderTarget: () => Ns, WebGLMultipleRenderTargets: () => li, WebGLMultisampleRenderTarget: () => ci, WebGLRenderTarget: () => ai, WebGLRenderTargetCube: () => Rm, WebGLRenderer: () => il, WebGLUtils: () => Ja, WireframeGeometry: () => Ph, WireframeHelper: () => Em, WrapAroundEnding: () => Ye, XHRLoader: () => Am, ZeroCurvatureEnding: () => qe, ZeroFactor: () => N, ZeroSlopeEnding: () => Xe, ZeroStencilOp: () => pn, sRGBEncoding: () => en });
                var r = {};
                n.r(r), n.d(r, { AsyncCompress: () => Lg, AsyncDecompress: () => Wg, AsyncDeflate: () => _g, AsyncGunzip: () => Ig, AsyncGzip: () => Lg, AsyncInflate: () => Sg, AsyncUnzipInflate: () => vv, AsyncUnzlib: () => Hg, AsyncZipDeflate: () => uv, AsyncZlib: () => Og, Compress: () => Ag, DecodeUTF8: () => Qg, Decompress: () => Vg, Deflate: () => xg, EncodeUTF8: () => $g, Gunzip: () => Pg, Gzip: () => Ag, Inflate: () => Mg, Unzip: () => yv, UnzipInflate: () => gv, UnzipPassThrough: () => fv, Unzlib: () => Ug, Zip: () => dv, ZipDeflate: () => hv, ZipPassThrough: () => cv, Zlib: () => Bg, compress: () => Rg, compressSync: () => Cg, decompress: () => jg, decompressSync: () => qg, deflate: () => bg, deflateSync: () => wg, gunzip: () => Dg, gunzipSync: () => Ng, gzip: () => Rg, gzipSync: () => Cg, inflate: () => Tg, inflateSync: () => Eg, strFromU8: () => ev, strToU8: () => tv, unzip: () => xv, unzipSync: () => _v, unzlib: () => kg, unzlibSync: () => Gg, zip: () => pv, zipSync: () => mv, zlib: () => Fg, zlibSync: () => zg });
                var s = {};
                n.r(s), n.d(s, { ActionSprite: () => cR, Button: () => uR, DrawSprite: () => pR, DrawTexture: () => dR, SimpleSprite: () => lR, SpriteSheet: () => hR, TextSprite: () => gR, TextTexture: () => fR, TextureAtlas: () => yR, destroy: () => sR, getParent: () => rR, initEvents: () => mR, physics: () => wR, setSize: () => iR, updateEvents: () => aR });
                var o = {};
                n.r(o);
                const a = "130",
                    l = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
                    c = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
                    h = 0,
                    u = 1,
                    d = 2,
                    p = 3,
                    m = 0,
                    f = 1,
                    g = 2,
                    v = 3,
                    y = 0,
                    x = 1,
                    _ = 2,
                    b = 1,
                    w = 2,
                    M = 0,
                    S = 1,
                    T = 2,
                    E = 3,
                    A = 4,
                    L = 5,
                    R = 100,
                    C = 101,
                    P = 102,
                    I = 103,
                    D = 104,
                    N = 200,
                    B = 201,
                    O = 202,
                    F = 203,
                    z = 204,
                    U = 205,
                    H = 206,
                    k = 207,
                    G = 208,
                    V = 209,
                    W = 210,
                    j = 0,
                    q = 1,
                    X = 2,
                    Y = 3,
                    Z = 4,
                    J = 5,
                    K = 6,
                    Q = 7,
                    $ = 0,
                    tt = 1,
                    et = 2,
                    nt = 0,
                    it = 1,
                    rt = 2,
                    st = 3,
                    ot = 4,
                    at = 5,
                    lt = 300,
                    ct = 301,
                    ht = 302,
                    ut = 303,
                    dt = 304,
                    pt = 306,
                    mt = 307,
                    ft = 1e3,
                    gt = 1001,
                    vt = 1002,
                    yt = 1003,
                    xt = 1004,
                    _t = 1004,
                    bt = 1005,
                    wt = 1005,
                    Mt = 1006,
                    St = 1007,
                    Tt = 1007,
                    Et = 1008,
                    At = 1008,
                    Lt = 1009,
                    Rt = 1010,
                    Ct = 1011,
                    Pt = 1012,
                    It = 1013,
                    Dt = 1014,
                    Nt = 1015,
                    Bt = 1016,
                    Ot = 1017,
                    Ft = 1018,
                    zt = 1019,
                    Ut = 1020,
                    Ht = 1021,
                    kt = 1022,
                    Gt = 1023,
                    Vt = 1024,
                    Wt = 1025,
                    jt = Gt,
                    qt = 1026,
                    Xt = 1027,
                    Yt = 1028,
                    Zt = 1029,
                    Jt = 1030,
                    Kt = 1031,
                    Qt = 1032,
                    $t = 1033,
                    te = 33776,
                    ee = 33777,
                    ne = 33778,
                    ie = 33779,
                    re = 35840,
                    se = 35841,
                    oe = 35842,
                    ae = 35843,
                    le = 36196,
                    ce = 37492,
                    he = 37496,
                    ue = 37808,
                    de = 37809,
                    pe = 37810,
                    me = 37811,
                    fe = 37812,
                    ge = 37813,
                    ve = 37814,
                    ye = 37815,
                    xe = 37816,
                    _e = 37817,
                    be = 37818,
                    we = 37819,
                    Me = 37820,
                    Se = 37821,
                    Te = 36492,
                    Ee = 37840,
                    Ae = 37841,
                    Le = 37842,
                    Re = 37843,
                    Ce = 37844,
                    Pe = 37845,
                    Ie = 37846,
                    De = 37847,
                    Ne = 37848,
                    Be = 37849,
                    Oe = 37850,
                    Fe = 37851,
                    ze = 37852,
                    Ue = 37853,
                    He = 2200,
                    ke = 2201,
                    Ge = 2202,
                    Ve = 2300,
                    We = 2301,
                    je = 2302,
                    qe = 2400,
                    Xe = 2401,
                    Ye = 2402,
                    Ze = 2500,
                    Je = 2501,
                    Ke = 0,
                    Qe = 1,
                    $e = 2,
                    tn = 3e3,
                    en = 3001,
                    nn = 3007,
                    rn = 3002,
                    sn = 3003,
                    on = 3004,
                    an = 3005,
                    ln = 3006,
                    cn = 3200,
                    hn = 3201,
                    un = 0,
                    dn = 1,
                    pn = 0,
                    mn = 7680,
                    fn = 7681,
                    gn = 7682,
                    vn = 7683,
                    yn = 34055,
                    xn = 34056,
                    _n = 5386,
                    bn = 512,
                    wn = 513,
                    Mn = 514,
                    Sn = 515,
                    Tn = 516,
                    En = 517,
                    An = 518,
                    Ln = 519,
                    Rn = 35044,
                    Cn = 35048,
                    Pn = 35040,
                    In = 35045,
                    Dn = 35049,
                    Nn = 35041,
                    Bn = 35046,
                    On = 35050,
                    Fn = 35042,
                    zn = "100",
                    Un = "300 es";
                class Hn {
                    addEventListener(t, e) {
                        void 0 === this._listeners && (this._listeners = {});
                        const n = this._listeners;
                        void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
                    }
                    hasEventListener(t, e) { if (void 0 === this._listeners) return !1; const n = this._listeners; return void 0 !== n[t] && -1 !== n[t].indexOf(e) }
                    removeEventListener(t, e) { if (void 0 === this._listeners) return; const n = this._listeners[t]; if (void 0 !== n) { const t = n.indexOf(e); - 1 !== t && n.splice(t, 1) } }
                    dispatchEvent(t) {
                        if (void 0 === this._listeners) return;
                        const e = this._listeners[t.type];
                        if (void 0 !== e) {
                            t.target = this;
                            const n = e.slice(0);
                            for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
                            t.target = null
                        }
                    }
                }
                const kn = [];
                for (let t = 0; t < 256; t++) kn[t] = (t < 16 ? "0" : "") + t.toString(16);
                let Gn = 1234567;
                const Vn = Math.PI / 180,
                    Wn = 180 / Math.PI;

                function jn() {
                    const t = 4294967295 * Math.random() | 0,
                        e = 4294967295 * Math.random() | 0,
                        n = 4294967295 * Math.random() | 0,
                        i = 4294967295 * Math.random() | 0;
                    return (kn[255 & t] + kn[t >> 8 & 255] + kn[t >> 16 & 255] + kn[t >> 24 & 255] + "-" + kn[255 & e] + kn[e >> 8 & 255] + "-" + kn[e >> 16 & 15 | 64] + kn[e >> 24 & 255] + "-" + kn[63 & n | 128] + kn[n >> 8 & 255] + "-" + kn[n >> 16 & 255] + kn[n >> 24 & 255] + kn[255 & i] + kn[i >> 8 & 255] + kn[i >> 16 & 255] + kn[i >> 24 & 255]).toUpperCase()
                }

                function qn(t, e, n) { return Math.max(e, Math.min(n, t)) }

                function Xn(t, e) { return (t % e + e) % e }

                function Yn(t, e, n) { return (1 - n) * t + n * e }

                function Zn(t) { return 0 == (t & t - 1) && 0 !== t }

                function Jn(t) { return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)) }

                function Kn(t) { return Math.pow(2, Math.floor(Math.log(t) / Math.LN2)) }
                var Qn = Object.freeze({
                    __proto__: null,
                    DEG2RAD: Vn,
                    RAD2DEG: Wn,
                    generateUUID: jn,
                    clamp: qn,
                    euclideanModulo: Xn,
                    mapLinear: function(t, e, n, i, r) { return i + (t - e) * (r - i) / (n - e) },
                    inverseLerp: function(t, e, n) { return t !== e ? (n - t) / (e - t) : 0 },
                    lerp: Yn,
                    damp: function(t, e, n, i) { return Yn(t, e, 1 - Math.exp(-n * i)) },
                    pingpong: function(t, e = 1) { return e - Math.abs(Xn(t, 2 * e) - e) },
                    smoothstep: function(t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t) },
                    smootherstep: function(t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10) },
                    randInt: function(t, e) { return t + Math.floor(Math.random() * (e - t + 1)) },
                    randFloat: function(t, e) { return t + Math.random() * (e - t) },
                    randFloatSpread: function(t) { return t * (.5 - Math.random()) },
                    seededRandom: function(t) { return void 0 !== t && (Gn = t % 2147483647), Gn = 16807 * Gn % 2147483647, (Gn - 1) / 2147483646 },
                    degToRad: function(t) { return t * Vn },
                    radToDeg: function(t) { return t * Wn },
                    isPowerOfTwo: Zn,
                    ceilPowerOfTwo: Jn,
                    floorPowerOfTwo: Kn,
                    setQuaternionFromProperEuler: function(t, e, n, i, r) {
                        const s = Math.cos,
                            o = Math.sin,
                            a = s(n / 2),
                            l = o(n / 2),
                            c = s((e + i) / 2),
                            h = o((e + i) / 2),
                            u = s((e - i) / 2),
                            d = o((e - i) / 2),
                            p = s((i - e) / 2),
                            m = o((i - e) / 2);
                        switch (r) {
                            case "XYX":
                                t.set(a * h, l * u, l * d, a * c);
                                break;
                            case "YZY":
                                t.set(l * d, a * h, l * u, a * c);
                                break;
                            case "ZXZ":
                                t.set(l * u, l * d, a * h, a * c);
                                break;
                            case "XZX":
                                t.set(a * h, l * m, l * p, a * c);
                                break;
                            case "YXY":
                                t.set(l * p, a * h, l * m, a * c);
                                break;
                            case "ZYZ":
                                t.set(l * m, l * p, a * h, a * c);
                                break;
                            default:
                                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                        }
                    }
                });
                class $n {
                    constructor(t = 0, e = 0) { this.x = t, this.y = e }
                    get width() { return this.x }
                    set width(t) { this.x = t }
                    get height() { return this.y }
                    set height(t) { this.y = t }
                    set(t, e) { return this.x = t, this.y = e, this }
                    setScalar(t) { return this.x = t, this.y = t, this }
                    setX(t) { return this.x = t, this }
                    setY(t) { return this.y = t, this }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() { return new this.constructor(this.x, this.y) }
                    copy(t) { return this.x = t.x, this.y = t.y, this }
                    add(t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this) }
                    addScalar(t) { return this.x += t, this.y += t, this }
                    addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this }
                    addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this }
                    sub(t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this) }
                    subScalar(t) { return this.x -= t, this.y -= t, this }
                    subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this }
                    multiply(t) { return this.x *= t.x, this.y *= t.y, this }
                    multiplyScalar(t) { return this.x *= t, this.y *= t, this }
                    divide(t) { return this.x /= t.x, this.y /= t.y, this }
                    divideScalar(t) { return this.multiplyScalar(1 / t) }
                    applyMatrix3(t) {
                        const e = this.x,
                            n = this.y,
                            i = t.elements;
                        return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
                    }
                    min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this }
                    max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this }
                    clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this }
                    clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this }
                    clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }
                    floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }
                    ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }
                    round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }
                    roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this }
                    negate() { return this.x = -this.x, this.y = -this.y, this }
                    dot(t) { return this.x * t.x + this.y * t.y }
                    cross(t) { return this.x * t.y - this.y * t.x }
                    lengthSq() { return this.x * this.x + this.y * this.y }
                    length() { return Math.sqrt(this.x * this.x + this.y * this.y) }
                    manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) }
                    normalize() { return this.divideScalar(this.length() || 1) }
                    angle() { return Math.atan2(-this.y, -this.x) + Math.PI }
                    distanceTo(t) { return Math.sqrt(this.distanceToSquared(t)) }
                    distanceToSquared(t) {
                        const e = this.x - t.x,
                            n = this.y - t.y;
                        return e * e + n * n
                    }
                    manhattanDistanceTo(t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) }
                    setLength(t) { return this.normalize().multiplyScalar(t) }
                    lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this }
                    lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this }
                    equals(t) { return t.x === this.x && t.y === this.y }
                    fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this }
                    toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t }
                    fromBufferAttribute(t, e, n) { return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this }
                    rotateAround(t, e) {
                        const n = Math.cos(e),
                            i = Math.sin(e),
                            r = this.x - t.x,
                            s = this.y - t.y;
                        return this.x = r * n - s * i + t.x, this.y = r * i + s * n + t.y, this
                    }
                    random() { return this.x = Math.random(), this.y = Math.random(), this }
                }
                $n.prototype.isVector2 = !0;
                class ti {
                    constructor() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") }
                    set(t, e, n, i, r, s, o, a, l) { const c = this.elements; return c[0] = t, c[1] = i, c[2] = o, c[3] = e, c[4] = r, c[5] = a, c[6] = n, c[7] = s, c[8] = l, this }
                    identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this }
                    copy(t) {
                        const e = this.elements,
                            n = t.elements;
                        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
                    }
                    extractBasis(t, e, n) { return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this }
                    setFromMatrix4(t) { const e = t.elements; return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this }
                    multiply(t) { return this.multiplyMatrices(this, t) }
                    premultiply(t) { return this.multiplyMatrices(t, this) }
                    multiplyMatrices(t, e) {
                        const n = t.elements,
                            i = e.elements,
                            r = this.elements,
                            s = n[0],
                            o = n[3],
                            a = n[6],
                            l = n[1],
                            c = n[4],
                            h = n[7],
                            u = n[2],
                            d = n[5],
                            p = n[8],
                            m = i[0],
                            f = i[3],
                            g = i[6],
                            v = i[1],
                            y = i[4],
                            x = i[7],
                            _ = i[2],
                            b = i[5],
                            w = i[8];
                        return r[0] = s * m + o * v + a * _, r[3] = s * f + o * y + a * b, r[6] = s * g + o * x + a * w, r[1] = l * m + c * v + h * _, r[4] = l * f + c * y + h * b, r[7] = l * g + c * x + h * w, r[2] = u * m + d * v + p * _, r[5] = u * f + d * y + p * b, r[8] = u * g + d * x + p * w, this
                    }
                    multiplyScalar(t) { const e = this.elements; return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this }
                    determinant() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            i = t[2],
                            r = t[3],
                            s = t[4],
                            o = t[5],
                            a = t[6],
                            l = t[7],
                            c = t[8];
                        return e * s * c - e * o * l - n * r * c + n * o * a + i * r * l - i * s * a
                    }
                    invert() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            i = t[2],
                            r = t[3],
                            s = t[4],
                            o = t[5],
                            a = t[6],
                            l = t[7],
                            c = t[8],
                            h = c * s - o * l,
                            u = o * a - c * r,
                            d = l * r - s * a,
                            p = e * h + n * u + i * d;
                        if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const m = 1 / p;
                        return t[0] = h * m, t[1] = (i * l - c * n) * m, t[2] = (o * n - i * s) * m, t[3] = u * m, t[4] = (c * e - i * a) * m, t[5] = (i * r - o * e) * m, t[6] = d * m, t[7] = (n * a - l * e) * m, t[8] = (s * e - n * r) * m, this
                    }
                    transpose() { let t; const e = this.elements; return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this }
                    getNormalMatrix(t) { return this.setFromMatrix4(t).invert().transpose() }
                    transposeIntoArray(t) { const e = this.elements; return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this }
                    setUvTransform(t, e, n, i, r, s, o) {
                        const a = Math.cos(r),
                            l = Math.sin(r);
                        return this.set(n * a, n * l, -n * (a * s + l * o) + s + t, -i * l, i * a, -i * (-l * s + a * o) + o + e, 0, 0, 1), this
                    }
                    scale(t, e) { const n = this.elements; return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this }
                    rotate(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t),
                            i = this.elements,
                            r = i[0],
                            s = i[3],
                            o = i[6],
                            a = i[1],
                            l = i[4],
                            c = i[7];
                        return i[0] = e * r + n * a, i[3] = e * s + n * l, i[6] = e * o + n * c, i[1] = -n * r + e * a, i[4] = -n * s + e * l, i[7] = -n * o + e * c, this
                    }
                    translate(t, e) { const n = this.elements; return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this }
                    equals(t) {
                        const e = this.elements,
                            n = t.elements;
                        for (let t = 0; t < 9; t++)
                            if (e[t] !== n[t]) return !1;
                        return !0
                    }
                    fromArray(t, e = 0) { for (let n = 0; n < 9; n++) this.elements[n] = t[n + e]; return this }
                    toArray(t = [], e = 0) { const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t }
                    clone() { return (new this.constructor).fromArray(this.elements) }
                }
                let ei;
                ti.prototype.isMatrix3 = !0;
                class ni {
                    static getDataURL(t) {
                        if (/^data:/i.test(t.src)) return t.src;
                        if ("undefined" == typeof HTMLCanvasElement) return t.src;
                        let e;
                        if (t instanceof HTMLCanvasElement) e = t;
                        else {
                            void 0 === ei && (ei = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), ei.width = t.width, ei.height = t.height;
                            const n = ei.getContext("2d");
                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = ei
                        }
                        return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
                    }
                }
                let ii = 0;
                class ri extends Hn {
                    constructor(t = ri.DEFAULT_IMAGE, e = ri.DEFAULT_MAPPING, n = gt, i = gt, r = Mt, s = Et, o = Gt, a = Lt, l = 1, c = tn) { super(), Object.defineProperty(this, "id", { value: ii++ }), this.uuid = jn(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new $n(0, 0), this.repeat = new $n(1, 1), this.center = new $n(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ti, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.version = 0, this.onUpdate = null }
                    updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t;
                        if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                        const n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
                        if (void 0 !== this.image) {
                            const i = this.image;
                            if (void 0 === i.uuid && (i.uuid = jn()), !e && void 0 === t.images[i.uuid]) {
                                let e;
                                if (Array.isArray(i)) { e = []; for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(si(i[t].image)) : e.push(si(i[t])) } else e = si(i);
                                t.images[i.uuid] = { uuid: i.uuid, url: e }
                            }
                            n.image = i.uuid
                        }
                        return e || (t.textures[this.uuid] = n), n
                    }
                    dispose() { this.dispatchEvent({ type: "dispose" }) }
                    transformUv(t) {
                        if (this.mapping !== lt) return t;
                        if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                            case ft:
                                t.x = t.x - Math.floor(t.x);
                                break;
                            case gt:
                                t.x = t.x < 0 ? 0 : 1;
                                break;
                            case vt:
                                1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                        }
                        if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                            case ft:
                                t.y = t.y - Math.floor(t.y);
                                break;
                            case gt:
                                t.y = t.y < 0 ? 0 : 1;
                                break;
                            case vt:
                                1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                        }
                        return this.flipY && (t.y = 1 - t.y), t
                    }
                    set needsUpdate(t) {!0 === t && this.version++ }
                }

                function si(t) { return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? ni.getDataURL(t) : t.data ? { data: Array.prototype.slice.call(t.data), width: t.width, height: t.height, type: t.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) }
                ri.DEFAULT_IMAGE = void 0, ri.DEFAULT_MAPPING = lt, ri.prototype.isTexture = !0;
                class oi {
                    constructor(t = 0, e = 0, n = 0, i = 1) { this.x = t, this.y = e, this.z = n, this.w = i }
                    get width() { return this.z }
                    set width(t) { this.z = t }
                    get height() { return this.w }
                    set height(t) { this.w = t }
                    set(t, e, n, i) { return this.x = t, this.y = e, this.z = n, this.w = i, this }
                    setScalar(t) { return this.x = t, this.y = t, this.z = t, this.w = t, this }
                    setX(t) { return this.x = t, this }
                    setY(t) { return this.y = t, this }
                    setZ(t) { return this.z = t, this }
                    setW(t) { return this.w = t, this }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            case 3:
                                this.w = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            case 3:
                                return this.w;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() { return new this.constructor(this.x, this.y, this.z, this.w) }
                    copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this }
                    add(t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this) }
                    addScalar(t) { return this.x += t, this.y += t, this.z += t, this.w += t, this }
                    addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this }
                    addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this }
                    sub(t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this) }
                    subScalar(t) { return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this }
                    subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this }
                    multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this }
                    multiplyScalar(t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this }
                    applyMatrix4(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = this.w,
                            s = t.elements;
                        return this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r, this
                    }
                    divideScalar(t) { return this.multiplyScalar(1 / t) }
                    setAxisAngleFromQuaternion(t) { this.w = 2 * Math.acos(t.w); const e = Math.sqrt(1 - t.w * t.w); return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this }
                    setAxisAngleFromRotationMatrix(t) {
                        let e, n, i, r;
                        const s = .01,
                            o = .1,
                            a = t.elements,
                            l = a[0],
                            c = a[4],
                            h = a[8],
                            u = a[1],
                            d = a[5],
                            p = a[9],
                            m = a[2],
                            f = a[6],
                            g = a[10];
                        if (Math.abs(c - u) < s && Math.abs(h - m) < s && Math.abs(p - f) < s) {
                            if (Math.abs(c + u) < o && Math.abs(h + m) < o && Math.abs(p + f) < o && Math.abs(l + d + g - 3) < o) return this.set(1, 0, 0, 0), this;
                            e = Math.PI;
                            const t = (l + 1) / 2,
                                a = (d + 1) / 2,
                                v = (g + 1) / 2,
                                y = (c + u) / 4,
                                x = (h + m) / 4,
                                _ = (p + f) / 4;
                            return t > a && t > v ? t < s ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(t), i = y / n, r = x / n) : a > v ? a < s ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(a), n = y / i, r = _ / i) : v < s ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(v), n = x / r, i = _ / r), this.set(n, i, r, e), this
                        }
                        let v = Math.sqrt((f - p) * (f - p) + (h - m) * (h - m) + (u - c) * (u - c));
                        return Math.abs(v) < .001 && (v = 1), this.x = (f - p) / v, this.y = (h - m) / v, this.z = (u - c) / v, this.w = Math.acos((l + d + g - 1) / 2), this
                    }
                    min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this }
                    max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this }
                    clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this }
                    clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this }
                    clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }
                    floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this }
                    ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this }
                    round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this }
                    roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this }
                    negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this }
                    dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w }
                    lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }
                    length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }
                    manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) }
                    normalize() { return this.divideScalar(this.length() || 1) }
                    setLength(t) { return this.normalize().multiplyScalar(t) }
                    lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this }
                    lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this }
                    equals(t) { return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w }
                    fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this }
                    toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t }
                    fromBufferAttribute(t, e, n) { return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this }
                    random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this }
                }
                oi.prototype.isVector4 = !0;
                class ai extends Hn {
                    constructor(t, e, n = {}) { super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new oi(0, 0, t, e), this.scissorTest = !1, this.viewport = new oi(0, 0, t, e), this.texture = new ri(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = { width: t, height: e, depth: 1 }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Mt, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null }
                    setTexture(t) { t.image = { width: this.width, height: this.height, depth: this.depth }, this.texture = t }
                    setSize(t, e, n = 1) { this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e) }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { return this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.image = {...this.texture.image }, this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this }
                    dispose() { this.dispatchEvent({ type: "dispose" }) }
                }
                ai.prototype.isWebGLRenderTarget = !0;
                class li extends ai {
                    constructor(t, e, n) {
                        super(t, e);
                        const i = this.texture;
                        this.texture = [];
                        for (let t = 0; t < n; t++) this.texture[t] = i.clone()
                    }
                    setSize(t, e, n = 1) {
                        if (this.width !== t || this.height !== e || this.depth !== n) {
                            this.width = t, this.height = e, this.depth = n;
                            for (let i = 0, r = this.texture.length; i < r; i++) this.texture[i].image.width = t, this.texture[i].image.height = e, this.texture[i].image.depth = n;
                            this.dispose()
                        }
                        return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
                    }
                    copy(t) { this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this.texture.length = 0; for (let e = 0, n = t.texture.length; e < n; e++) this.texture[e] = t.texture[e].clone(); return this }
                }
                li.prototype.isWebGLMultipleRenderTargets = !0;
                class ci extends ai {
                    constructor(t, e, n) { super(t, e, n), this.samples = 4 }
                    copy(t) { return super.copy.call(this, t), this.samples = t.samples, this }
                }
                ci.prototype.isWebGLMultisampleRenderTarget = !0;
                class hi {
                    constructor(t = 0, e = 0, n = 0, i = 1) { this._x = t, this._y = e, this._z = n, this._w = i }
                    static slerp(t, e, n, i) { return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, i) }
                    static slerpFlat(t, e, n, i, r, s, o) {
                        let a = n[i + 0],
                            l = n[i + 1],
                            c = n[i + 2],
                            h = n[i + 3];
                        const u = r[s + 0],
                            d = r[s + 1],
                            p = r[s + 2],
                            m = r[s + 3];
                        if (0 === o) return t[e + 0] = a, t[e + 1] = l, t[e + 2] = c, void(t[e + 3] = h);
                        if (1 === o) return t[e + 0] = u, t[e + 1] = d, t[e + 2] = p, void(t[e + 3] = m);
                        if (h !== m || a !== u || l !== d || c !== p) {
                            let t = 1 - o;
                            const e = a * u + l * d + c * p + h * m,
                                n = e >= 0 ? 1 : -1,
                                i = 1 - e * e;
                            if (i > Number.EPSILON) {
                                const r = Math.sqrt(i),
                                    s = Math.atan2(r, e * n);
                                t = Math.sin(t * s) / r, o = Math.sin(o * s) / r
                            }
                            const r = o * n;
                            if (a = a * t + u * r, l = l * t + d * r, c = c * t + p * r, h = h * t + m * r, t === 1 - o) {
                                const t = 1 / Math.sqrt(a * a + l * l + c * c + h * h);
                                a *= t, l *= t, c *= t, h *= t
                            }
                        }
                        t[e] = a, t[e + 1] = l, t[e + 2] = c, t[e + 3] = h
                    }
                    static multiplyQuaternionsFlat(t, e, n, i, r, s) {
                        const o = n[i],
                            a = n[i + 1],
                            l = n[i + 2],
                            c = n[i + 3],
                            h = r[s],
                            u = r[s + 1],
                            d = r[s + 2],
                            p = r[s + 3];
                        return t[e] = o * p + c * h + a * d - l * u, t[e + 1] = a * p + c * u + l * h - o * d, t[e + 2] = l * p + c * d + o * u - a * h, t[e + 3] = c * p - o * h - a * u - l * d, t
                    }
                    get x() { return this._x }
                    set x(t) { this._x = t, this._onChangeCallback() }
                    get y() { return this._y }
                    set y(t) { this._y = t, this._onChangeCallback() }
                    get z() { return this._z }
                    set z(t) { this._z = t, this._onChangeCallback() }
                    get w() { return this._w }
                    set w(t) { this._w = t, this._onChangeCallback() }
                    set(t, e, n, i) { return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this }
                    clone() { return new this.constructor(this._x, this._y, this._z, this._w) }
                    copy(t) { return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this }
                    setFromEuler(t, e) {
                        if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                        const n = t._x,
                            i = t._y,
                            r = t._z,
                            s = t._order,
                            o = Math.cos,
                            a = Math.sin,
                            l = o(n / 2),
                            c = o(i / 2),
                            h = o(r / 2),
                            u = a(n / 2),
                            d = a(i / 2),
                            p = a(r / 2);
                        switch (s) {
                            case "XYZ":
                                this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                                break;
                            case "YXZ":
                                this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                                break;
                            case "ZXY":
                                this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                                break;
                            case "ZYX":
                                this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                                break;
                            case "YZX":
                                this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p;
                                break;
                            case "XZY":
                                this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p;
                                break;
                            default:
                                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                        }
                        return !1 !== e && this._onChangeCallback(), this
                    }
                    setFromAxisAngle(t, e) {
                        const n = e / 2,
                            i = Math.sin(n);
                        return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
                    }
                    setFromRotationMatrix(t) {
                        const e = t.elements,
                            n = e[0],
                            i = e[4],
                            r = e[8],
                            s = e[1],
                            o = e[5],
                            a = e[9],
                            l = e[2],
                            c = e[6],
                            h = e[10],
                            u = n + o + h;
                        if (u > 0) {
                            const t = .5 / Math.sqrt(u + 1);
                            this._w = .25 / t, this._x = (c - a) * t, this._y = (r - l) * t, this._z = (s - i) * t
                        } else if (n > o && n > h) {
                            const t = 2 * Math.sqrt(1 + n - o - h);
                            this._w = (c - a) / t, this._x = .25 * t, this._y = (i + s) / t, this._z = (r + l) / t
                        } else if (o > h) {
                            const t = 2 * Math.sqrt(1 + o - n - h);
                            this._w = (r - l) / t, this._x = (i + s) / t, this._y = .25 * t, this._z = (a + c) / t
                        } else {
                            const t = 2 * Math.sqrt(1 + h - n - o);
                            this._w = (s - i) / t, this._x = (r + l) / t, this._y = (a + c) / t, this._z = .25 * t
                        }
                        return this._onChangeCallback(), this
                    }
                    setFromUnitVectors(t, e) { let n = t.dot(e) + 1; return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize() }
                    angleTo(t) { return 2 * Math.acos(Math.abs(qn(this.dot(t), -1, 1))) }
                    rotateTowards(t, e) { const n = this.angleTo(t); if (0 === n) return this; const i = Math.min(1, e / n); return this.slerp(t, i), this }
                    identity() { return this.set(0, 0, 0, 1) }
                    invert() { return this.conjugate() }
                    conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this }
                    dot(t) { return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w }
                    lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w }
                    length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) }
                    normalize() { let t = this.length(); return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this }
                    multiply(t, e) { return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t) }
                    premultiply(t) { return this.multiplyQuaternions(t, this) }
                    multiplyQuaternions(t, e) {
                        const n = t._x,
                            i = t._y,
                            r = t._z,
                            s = t._w,
                            o = e._x,
                            a = e._y,
                            l = e._z,
                            c = e._w;
                        return this._x = n * c + s * o + i * l - r * a, this._y = i * c + s * a + r * o - n * l, this._z = r * c + s * l + n * a - i * o, this._w = s * c - n * o - i * a - r * l, this._onChangeCallback(), this
                    }
                    slerp(t, e) {
                        if (0 === e) return this;
                        if (1 === e) return this.copy(t);
                        const n = this._x,
                            i = this._y,
                            r = this._z,
                            s = this._w;
                        let o = s * t._w + n * t._x + i * t._y + r * t._z;
                        if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this;
                        const a = 1 - o * o;
                        if (a <= Number.EPSILON) { const t = 1 - e; return this._w = t * s + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this }
                        const l = Math.sqrt(a),
                            c = Math.atan2(l, o),
                            h = Math.sin((1 - e) * c) / l,
                            u = Math.sin(e * c) / l;
                        return this._w = s * h + this._w * u, this._x = n * h + this._x * u, this._y = i * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this
                    }
                    slerpQuaternions(t, e, n) { this.copy(t).slerp(e, n) }
                    equals(t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w }
                    fromArray(t, e = 0) { return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this }
                    toArray(t = [], e = 0) { return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t }
                    fromBufferAttribute(t, e) { return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this }
                    _onChange(t) { return this._onChangeCallback = t, this }
                    _onChangeCallback() {}
                }
                hi.prototype.isQuaternion = !0;
                class ui {
                    constructor(t = 0, e = 0, n = 0) { this.x = t, this.y = e, this.z = n }
                    set(t, e, n) { return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this }
                    setScalar(t) { return this.x = t, this.y = t, this.z = t, this }
                    setX(t) { return this.x = t, this }
                    setY(t) { return this.y = t, this }
                    setZ(t) { return this.z = t, this }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() { return new this.constructor(this.x, this.y, this.z) }
                    copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this }
                    add(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this) }
                    addScalar(t) { return this.x += t, this.y += t, this.z += t, this }
                    addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this }
                    addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this }
                    sub(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) }
                    subScalar(t) { return this.x -= t, this.y -= t, this.z -= t, this }
                    subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this }
                    multiply(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this) }
                    multiplyScalar(t) { return this.x *= t, this.y *= t, this.z *= t, this }
                    multiplyVectors(t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this }
                    applyEuler(t) { return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(pi.setFromEuler(t)) }
                    applyAxisAngle(t, e) { return this.applyQuaternion(pi.setFromAxisAngle(t, e)) }
                    applyMatrix3(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.elements;
                        return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
                    }
                    applyNormalMatrix(t) { return this.applyMatrix3(t).normalize() }
                    applyMatrix4(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.elements,
                            s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                        return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s, this
                    }
                    applyQuaternion(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.x,
                            s = t.y,
                            o = t.z,
                            a = t.w,
                            l = a * e + s * i - o * n,
                            c = a * n + o * e - r * i,
                            h = a * i + r * n - s * e,
                            u = -r * e - s * n - o * i;
                        return this.x = l * a + u * -r + c * -o - h * -s, this.y = c * a + u * -s + h * -r - l * -o, this.z = h * a + u * -o + l * -s - c * -r, this
                    }
                    project(t) { return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix) }
                    unproject(t) { return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld) }
                    transformDirection(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.elements;
                        return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
                    }
                    divide(t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this }
                    divideScalar(t) { return this.multiplyScalar(1 / t) }
                    min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this }
                    max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this }
                    clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this }
                    clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this }
                    clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }
                    floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this }
                    ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this }
                    round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this }
                    roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this }
                    negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }
                    dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z }
                    lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z }
                    length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }
                    manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }
                    normalize() { return this.divideScalar(this.length() || 1) }
                    setLength(t) { return this.normalize().multiplyScalar(t) }
                    lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this }
                    lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this }
                    cross(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t) }
                    crossVectors(t, e) {
                        const n = t.x,
                            i = t.y,
                            r = t.z,
                            s = e.x,
                            o = e.y,
                            a = e.z;
                        return this.x = i * a - r * o, this.y = r * s - n * a, this.z = n * o - i * s, this
                    }
                    projectOnVector(t) { const e = t.lengthSq(); if (0 === e) return this.set(0, 0, 0); const n = t.dot(this) / e; return this.copy(t).multiplyScalar(n) }
                    projectOnPlane(t) { return di.copy(this).projectOnVector(t), this.sub(di) }
                    reflect(t) { return this.sub(di.copy(t).multiplyScalar(2 * this.dot(t))) }
                    angleTo(t) { const e = Math.sqrt(this.lengthSq() * t.lengthSq()); if (0 === e) return Math.PI / 2; const n = this.dot(t) / e; return Math.acos(qn(n, -1, 1)) }
                    distanceTo(t) { return Math.sqrt(this.distanceToSquared(t)) }
                    distanceToSquared(t) {
                        const e = this.x - t.x,
                            n = this.y - t.y,
                            i = this.z - t.z;
                        return e * e + n * n + i * i
                    }
                    manhattanDistanceTo(t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z) }
                    setFromSpherical(t) { return this.setFromSphericalCoords(t.radius, t.phi, t.theta) }
                    setFromSphericalCoords(t, e, n) { const i = Math.sin(e) * t; return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this }
                    setFromCylindrical(t) { return this.setFromCylindricalCoords(t.radius, t.theta, t.y) }
                    setFromCylindricalCoords(t, e, n) { return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this }
                    setFromMatrixPosition(t) { const e = t.elements; return this.x = e[12], this.y = e[13], this.z = e[14], this }
                    setFromMatrixScale(t) {
                        const e = this.setFromMatrixColumn(t, 0).length(),
                            n = this.setFromMatrixColumn(t, 1).length(),
                            i = this.setFromMatrixColumn(t, 2).length();
                        return this.x = e, this.y = n, this.z = i, this
                    }
                    setFromMatrixColumn(t, e) { return this.fromArray(t.elements, 4 * e) }
                    setFromMatrix3Column(t, e) { return this.fromArray(t.elements, 3 * e) }
                    equals(t) { return t.x === this.x && t.y === this.y && t.z === this.z }
                    fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this }
                    toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t }
                    fromBufferAttribute(t, e, n) { return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this }
                    random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this }
                }
                ui.prototype.isVector3 = !0;
                const di = new ui,
                    pi = new hi;
                class mi {
                    constructor(t = new ui(1 / 0, 1 / 0, 1 / 0), e = new ui(-1 / 0, -1 / 0, -1 / 0)) { this.min = t, this.max = e }
                    set(t, e) { return this.min.copy(t), this.max.copy(e), this }
                    setFromArray(t) {
                        let e = 1 / 0,
                            n = 1 / 0,
                            i = 1 / 0,
                            r = -1 / 0,
                            s = -1 / 0,
                            o = -1 / 0;
                        for (let a = 0, l = t.length; a < l; a += 3) {
                            const l = t[a],
                                c = t[a + 1],
                                h = t[a + 2];
                            l < e && (e = l), c < n && (n = c), h < i && (i = h), l > r && (r = l), c > s && (s = c), h > o && (o = h)
                        }
                        return this.min.set(e, n, i), this.max.set(r, s, o), this
                    }
                    setFromBufferAttribute(t) {
                        let e = 1 / 0,
                            n = 1 / 0,
                            i = 1 / 0,
                            r = -1 / 0,
                            s = -1 / 0,
                            o = -1 / 0;
                        for (let a = 0, l = t.count; a < l; a++) {
                            const l = t.getX(a),
                                c = t.getY(a),
                                h = t.getZ(a);
                            l < e && (e = l), c < n && (n = c), h < i && (i = h), l > r && (r = l), c > s && (s = c), h > o && (o = h)
                        }
                        return this.min.set(e, n, i), this.max.set(r, s, o), this
                    }
                    setFromPoints(t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]); return this }
                    setFromCenterAndSize(t, e) { const n = gi.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this }
                    setFromObject(t) { return this.makeEmpty(), this.expandByObject(t) }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { return this.min.copy(t.min), this.max.copy(t.max), this }
                    makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this }
                    isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z }
                    getCenter(t) { return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) }
                    getSize(t) { return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min) }
                    expandByPoint(t) { return this.min.min(t), this.max.max(t), this }
                    expandByVector(t) { return this.min.sub(t), this.max.add(t), this }
                    expandByScalar(t) { return this.min.addScalar(-t), this.max.addScalar(t), this }
                    expandByObject(t) {
                        t.updateWorldMatrix(!1, !1);
                        const e = t.geometry;
                        void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), vi.copy(e.boundingBox), vi.applyMatrix4(t.matrixWorld), this.union(vi));
                        const n = t.children;
                        for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);
                        return this
                    }
                    containsPoint(t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z) }
                    containsBox(t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z }
                    getParameter(t, e) { return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z)) }
                    intersectsBox(t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z) }
                    intersectsSphere(t) { return this.clampPoint(t.center, gi), gi.distanceToSquared(t.center) <= t.radius * t.radius }
                    intersectsPlane(t) { let e, n; return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant }
                    intersectsTriangle(t) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(Si), Ti.subVectors(this.max, Si), yi.subVectors(t.a, Si), xi.subVectors(t.b, Si), _i.subVectors(t.c, Si), bi.subVectors(xi, yi), wi.subVectors(_i, xi), Mi.subVectors(yi, _i);
                        let e = [0, -bi.z, bi.y, 0, -wi.z, wi.y, 0, -Mi.z, Mi.y, bi.z, 0, -bi.x, wi.z, 0, -wi.x, Mi.z, 0, -Mi.x, -bi.y, bi.x, 0, -wi.y, wi.x, 0, -Mi.y, Mi.x, 0];
                        return !!Li(e, yi, xi, _i, Ti) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Li(e, yi, xi, _i, Ti) && (Ei.crossVectors(bi, wi), e = [Ei.x, Ei.y, Ei.z], Li(e, yi, xi, _i, Ti)))
                    }
                    clampPoint(t, e) { return e.copy(t).clamp(this.min, this.max) }
                    distanceToPoint(t) { return gi.copy(t).clamp(this.min, this.max).sub(t).length() }
                    getBoundingSphere(t) { return this.getCenter(t.center), t.radius = .5 * this.getSize(gi).length(), t }
                    intersect(t) { return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this }
                    union(t) { return this.min.min(t.min), this.max.max(t.max), this }
                    applyMatrix4(t) { return this.isEmpty() || (fi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), fi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), fi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), fi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), fi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), fi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), fi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), fi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(fi)), this }
                    translate(t) { return this.min.add(t), this.max.add(t), this }
                    equals(t) { return t.min.equals(this.min) && t.max.equals(this.max) }
                }
                mi.prototype.isBox3 = !0;
                const fi = [new ui, new ui, new ui, new ui, new ui, new ui, new ui, new ui],
                    gi = new ui,
                    vi = new mi,
                    yi = new ui,
                    xi = new ui,
                    _i = new ui,
                    bi = new ui,
                    wi = new ui,
                    Mi = new ui,
                    Si = new ui,
                    Ti = new ui,
                    Ei = new ui,
                    Ai = new ui;

                function Li(t, e, n, i, r) {
                    for (let s = 0, o = t.length - 3; s <= o; s += 3) {
                        Ai.fromArray(t, s);
                        const o = r.x * Math.abs(Ai.x) + r.y * Math.abs(Ai.y) + r.z * Math.abs(Ai.z),
                            a = e.dot(Ai),
                            l = n.dot(Ai),
                            c = i.dot(Ai);
                        if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1
                    }
                    return !0
                }
                const Ri = new mi,
                    Ci = new ui,
                    Pi = new ui,
                    Ii = new ui;
                class Di {
                    constructor(t = new ui, e = -1) { this.center = t, this.radius = e }
                    set(t, e) { return this.center.copy(t), this.radius = e, this }
                    setFromPoints(t, e) {
                        const n = this.center;
                        void 0 !== e ? n.copy(e) : Ri.setFromPoints(t).getCenter(n);
                        let i = 0;
                        for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
                        return this.radius = Math.sqrt(i), this
                    }
                    copy(t) { return this.center.copy(t.center), this.radius = t.radius, this }
                    isEmpty() { return this.radius < 0 }
                    makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this }
                    containsPoint(t) { return t.distanceToSquared(this.center) <= this.radius * this.radius }
                    distanceToPoint(t) { return t.distanceTo(this.center) - this.radius }
                    intersectsSphere(t) { const e = this.radius + t.radius; return t.center.distanceToSquared(this.center) <= e * e }
                    intersectsBox(t) { return t.intersectsSphere(this) }
                    intersectsPlane(t) { return Math.abs(t.distanceToPoint(this.center)) <= this.radius }
                    clampPoint(t, e) { const n = this.center.distanceToSquared(t); return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e }
                    getBoundingBox(t) { return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t) }
                    applyMatrix4(t) { return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this }
                    translate(t) { return this.center.add(t), this }
                    expandByPoint(t) {
                        Ii.subVectors(t, this.center);
                        const e = Ii.lengthSq();
                        if (e > this.radius * this.radius) {
                            const t = Math.sqrt(e),
                                n = .5 * (t - this.radius);
                            this.center.add(Ii.multiplyScalar(n / t)), this.radius += n
                        }
                        return this
                    }
                    union(t) { return Pi.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(Ci.copy(t.center).add(Pi)), this.expandByPoint(Ci.copy(t.center).sub(Pi)), this }
                    equals(t) { return t.center.equals(this.center) && t.radius === this.radius }
                    clone() { return (new this.constructor).copy(this) }
                }
                const Ni = new ui,
                    Bi = new ui,
                    Oi = new ui,
                    Fi = new ui,
                    zi = new ui,
                    Ui = new ui,
                    Hi = new ui;
                class ki {
                    constructor(t = new ui, e = new ui(0, 0, -1)) { this.origin = t, this.direction = e }
                    set(t, e) { return this.origin.copy(t), this.direction.copy(e), this }
                    copy(t) { return this.origin.copy(t.origin), this.direction.copy(t.direction), this }
                    at(t, e) { return e.copy(this.direction).multiplyScalar(t).add(this.origin) }
                    lookAt(t) { return this.direction.copy(t).sub(this.origin).normalize(), this }
                    recast(t) { return this.origin.copy(this.at(t, Ni)), this }
                    closestPointToPoint(t, e) { e.subVectors(t, this.origin); const n = e.dot(this.direction); return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin) }
                    distanceToPoint(t) { return Math.sqrt(this.distanceSqToPoint(t)) }
                    distanceSqToPoint(t) { const e = Ni.subVectors(t, this.origin).dot(this.direction); return e < 0 ? this.origin.distanceToSquared(t) : (Ni.copy(this.direction).multiplyScalar(e).add(this.origin), Ni.distanceToSquared(t)) }
                    distanceSqToSegment(t, e, n, i) {
                        Bi.copy(t).add(e).multiplyScalar(.5), Oi.copy(e).sub(t).normalize(), Fi.copy(this.origin).sub(Bi);
                        const r = .5 * t.distanceTo(e),
                            s = -this.direction.dot(Oi),
                            o = Fi.dot(this.direction),
                            a = -Fi.dot(Oi),
                            l = Fi.lengthSq(),
                            c = Math.abs(1 - s * s);
                        let h, u, d, p;
                        if (c > 0)
                            if (h = s * a - o, u = s * o - a, p = r * c, h >= 0)
                                if (u >= -p)
                                    if (u <= p) {
                                        const t = 1 / c;
                                        h *= t, u *= t, d = h * (h + s * u + 2 * o) + u * (s * h + u + 2 * a) + l
                                    } else u = r, h = Math.max(0, -(s * u + o)), d = -h * h + u * (u + 2 * a) + l;
                        else u = -r, h = Math.max(0, -(s * u + o)), d = -h * h + u * (u + 2 * a) + l;
                        else u <= -p ? (h = Math.max(0, -(-s * r + o)), u = h > 0 ? -r : Math.min(Math.max(-r, -a), r), d = -h * h + u * (u + 2 * a) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-r, -a), r), d = u * (u + 2 * a) + l) : (h = Math.max(0, -(s * r + o)), u = h > 0 ? r : Math.min(Math.max(-r, -a), r), d = -h * h + u * (u + 2 * a) + l);
                        else u = s > 0 ? -r : r, h = Math.max(0, -(s * u + o)), d = -h * h + u * (u + 2 * a) + l;
                        return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(Oi).multiplyScalar(u).add(Bi), d
                    }
                    intersectSphere(t, e) {
                        Ni.subVectors(t.center, this.origin);
                        const n = Ni.dot(this.direction),
                            i = Ni.dot(Ni) - n * n,
                            r = t.radius * t.radius;
                        if (i > r) return null;
                        const s = Math.sqrt(r - i),
                            o = n - s,
                            a = n + s;
                        return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e)
                    }
                    intersectsSphere(t) { return this.distanceSqToPoint(t.center) <= t.radius * t.radius }
                    distanceToPlane(t) { const e = t.normal.dot(this.direction); if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null; const n = -(this.origin.dot(t.normal) + t.constant) / e; return n >= 0 ? n : null }
                    intersectPlane(t, e) { const n = this.distanceToPlane(t); return null === n ? null : this.at(n, e) }
                    intersectsPlane(t) { const e = t.distanceToPoint(this.origin); return 0 === e || t.normal.dot(this.direction) * e < 0 }
                    intersectBox(t, e) {
                        let n, i, r, s, o, a;
                        const l = 1 / this.direction.x,
                            c = 1 / this.direction.y,
                            h = 1 / this.direction.z,
                            u = this.origin;
                        return l >= 0 ? (n = (t.min.x - u.x) * l, i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, i = (t.min.x - u.x) * l), c >= 0 ? (r = (t.min.y - u.y) * c, s = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c, s = (t.min.y - u.y) * c), n > s || r > i ? null : ((r > n || n != n) && (n = r), (s < i || i != i) && (i = s), h >= 0 ? (o = (t.min.z - u.z) * h, a = (t.max.z - u.z) * h) : (o = (t.max.z - u.z) * h, a = (t.min.z - u.z) * h), n > a || o > i ? null : ((o > n || n != n) && (n = o), (a < i || i != i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
                    }
                    intersectsBox(t) { return null !== this.intersectBox(t, Ni) }
                    intersectTriangle(t, e, n, i, r) {
                        zi.subVectors(e, t), Ui.subVectors(n, t), Hi.crossVectors(zi, Ui);
                        let s, o = this.direction.dot(Hi);
                        if (o > 0) {
                            if (i) return null;
                            s = 1
                        } else {
                            if (!(o < 0)) return null;
                            s = -1, o = -o
                        }
                        Fi.subVectors(this.origin, t);
                        const a = s * this.direction.dot(Ui.crossVectors(Fi, Ui));
                        if (a < 0) return null;
                        const l = s * this.direction.dot(zi.cross(Fi));
                        if (l < 0) return null;
                        if (a + l > o) return null;
                        const c = -s * Fi.dot(Hi);
                        return c < 0 ? null : this.at(c / o, r)
                    }
                    applyMatrix4(t) { return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this }
                    equals(t) { return t.origin.equals(this.origin) && t.direction.equals(this.direction) }
                    clone() { return (new this.constructor).copy(this) }
                }
                class Gi {
                    constructor() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") }
                    set(t, e, n, i, r, s, o, a, l, c, h, u, d, p, m, f) { const g = this.elements; return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = o, g[13] = a, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = m, g[15] = f, this }
                    identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }
                    clone() { return (new Gi).fromArray(this.elements) }
                    copy(t) {
                        const e = this.elements,
                            n = t.elements;
                        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
                    }
                    copyPosition(t) {
                        const e = this.elements,
                            n = t.elements;
                        return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
                    }
                    setFromMatrix3(t) { const e = t.elements; return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this }
                    extractBasis(t, e, n) { return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this }
                    makeBasis(t, e, n) { return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this }
                    extractRotation(t) {
                        const e = this.elements,
                            n = t.elements,
                            i = 1 / Vi.setFromMatrixColumn(t, 0).length(),
                            r = 1 / Vi.setFromMatrixColumn(t, 1).length(),
                            s = 1 / Vi.setFromMatrixColumn(t, 2).length();
                        return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                    }
                    makeRotationFromEuler(t) {
                        t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                        const e = this.elements,
                            n = t.x,
                            i = t.y,
                            r = t.z,
                            s = Math.cos(n),
                            o = Math.sin(n),
                            a = Math.cos(i),
                            l = Math.sin(i),
                            c = Math.cos(r),
                            h = Math.sin(r);
                        if ("XYZ" === t.order) {
                            const t = s * c,
                                n = s * h,
                                i = o * c,
                                r = o * h;
                            e[0] = a * c, e[4] = -a * h, e[8] = l, e[1] = n + i * l, e[5] = t - r * l, e[9] = -o * a, e[2] = r - t * l, e[6] = i + n * l, e[10] = s * a
                        } else if ("YXZ" === t.order) {
                            const t = a * c,
                                n = a * h,
                                i = l * c,
                                r = l * h;
                            e[0] = t + r * o, e[4] = i * o - n, e[8] = s * l, e[1] = s * h, e[5] = s * c, e[9] = -o, e[2] = n * o - i, e[6] = r + t * o, e[10] = s * a
                        } else if ("ZXY" === t.order) {
                            const t = a * c,
                                n = a * h,
                                i = l * c,
                                r = l * h;
                            e[0] = t - r * o, e[4] = -s * h, e[8] = i + n * o, e[1] = n + i * o, e[5] = s * c, e[9] = r - t * o, e[2] = -s * l, e[6] = o, e[10] = s * a
                        } else if ("ZYX" === t.order) {
                            const t = s * c,
                                n = s * h,
                                i = o * c,
                                r = o * h;
                            e[0] = a * c, e[4] = i * l - n, e[8] = t * l + r, e[1] = a * h, e[5] = r * l + t, e[9] = n * l - i, e[2] = -l, e[6] = o * a, e[10] = s * a
                        } else if ("YZX" === t.order) {
                            const t = s * a,
                                n = s * l,
                                i = o * a,
                                r = o * l;
                            e[0] = a * c, e[4] = r - t * h, e[8] = i * h + n, e[1] = h, e[5] = s * c, e[9] = -o * c, e[2] = -l * c, e[6] = n * h + i, e[10] = t - r * h
                        } else if ("XZY" === t.order) {
                            const t = s * a,
                                n = s * l,
                                i = o * a,
                                r = o * l;
                            e[0] = a * c, e[4] = -h, e[8] = l * c, e[1] = t * h + r, e[5] = s * c, e[9] = n * h - i, e[2] = i * h - n, e[6] = o * c, e[10] = r * h + t
                        }
                        return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                    }
                    makeRotationFromQuaternion(t) { return this.compose(ji, t, qi) }
                    lookAt(t, e, n) { const i = this.elements; return Zi.subVectors(t, e), 0 === Zi.lengthSq() && (Zi.z = 1), Zi.normalize(), Xi.crossVectors(n, Zi), 0 === Xi.lengthSq() && (1 === Math.abs(n.z) ? Zi.x += 1e-4 : Zi.z += 1e-4, Zi.normalize(), Xi.crossVectors(n, Zi)), Xi.normalize(), Yi.crossVectors(Zi, Xi), i[0] = Xi.x, i[4] = Yi.x, i[8] = Zi.x, i[1] = Xi.y, i[5] = Yi.y, i[9] = Zi.y, i[2] = Xi.z, i[6] = Yi.z, i[10] = Zi.z, this }
                    multiply(t, e) { return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t) }
                    premultiply(t) { return this.multiplyMatrices(t, this) }
                    multiplyMatrices(t, e) {
                        const n = t.elements,
                            i = e.elements,
                            r = this.elements,
                            s = n[0],
                            o = n[4],
                            a = n[8],
                            l = n[12],
                            c = n[1],
                            h = n[5],
                            u = n[9],
                            d = n[13],
                            p = n[2],
                            m = n[6],
                            f = n[10],
                            g = n[14],
                            v = n[3],
                            y = n[7],
                            x = n[11],
                            _ = n[15],
                            b = i[0],
                            w = i[4],
                            M = i[8],
                            S = i[12],
                            T = i[1],
                            E = i[5],
                            A = i[9],
                            L = i[13],
                            R = i[2],
                            C = i[6],
                            P = i[10],
                            I = i[14],
                            D = i[3],
                            N = i[7],
                            B = i[11],
                            O = i[15];
                        return r[0] = s * b + o * T + a * R + l * D, r[4] = s * w + o * E + a * C + l * N, r[8] = s * M + o * A + a * P + l * B, r[12] = s * S + o * L + a * I + l * O, r[1] = c * b + h * T + u * R + d * D, r[5] = c * w + h * E + u * C + d * N, r[9] = c * M + h * A + u * P + d * B, r[13] = c * S + h * L + u * I + d * O, r[2] = p * b + m * T + f * R + g * D, r[6] = p * w + m * E + f * C + g * N, r[10] = p * M + m * A + f * P + g * B, r[14] = p * S + m * L + f * I + g * O, r[3] = v * b + y * T + x * R + _ * D, r[7] = v * w + y * E + x * C + _ * N, r[11] = v * M + y * A + x * P + _ * B, r[15] = v * S + y * L + x * I + _ * O, this
                    }
                    multiplyScalar(t) { const e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this }
                    determinant() {
                        const t = this.elements,
                            e = t[0],
                            n = t[4],
                            i = t[8],
                            r = t[12],
                            s = t[1],
                            o = t[5],
                            a = t[9],
                            l = t[13],
                            c = t[2],
                            h = t[6],
                            u = t[10],
                            d = t[14];
                        return t[3] * (+r * a * h - i * l * h - r * o * u + n * l * u + i * o * d - n * a * d) + t[7] * (+e * a * d - e * l * u + r * s * u - i * s * d + i * l * c - r * a * c) + t[11] * (+e * l * h - e * o * d - r * s * h + n * s * d + r * o * c - n * l * c) + t[15] * (-i * o * c - e * a * h + e * o * u + i * s * h - n * s * u + n * a * c)
                    }
                    transpose() { const t = this.elements; let e; return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this }
                    setPosition(t, e, n) { const i = this.elements; return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this }
                    invert() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            i = t[2],
                            r = t[3],
                            s = t[4],
                            o = t[5],
                            a = t[6],
                            l = t[7],
                            c = t[8],
                            h = t[9],
                            u = t[10],
                            d = t[11],
                            p = t[12],
                            m = t[13],
                            f = t[14],
                            g = t[15],
                            v = h * f * l - m * u * l + m * a * d - o * f * d - h * a * g + o * u * g,
                            y = p * u * l - c * f * l - p * a * d + s * f * d + c * a * g - s * u * g,
                            x = c * m * l - p * h * l + p * o * d - s * m * d - c * o * g + s * h * g,
                            _ = p * h * a - c * m * a - p * o * u + s * m * u + c * o * f - s * h * f,
                            b = e * v + n * y + i * x + r * _;
                        if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const w = 1 / b;
                        return t[0] = v * w, t[1] = (m * u * r - h * f * r - m * i * d + n * f * d + h * i * g - n * u * g) * w, t[2] = (o * f * r - m * a * r + m * i * l - n * f * l - o * i * g + n * a * g) * w, t[3] = (h * a * r - o * u * r - h * i * l + n * u * l + o * i * d - n * a * d) * w, t[4] = y * w, t[5] = (c * f * r - p * u * r + p * i * d - e * f * d - c * i * g + e * u * g) * w, t[6] = (p * a * r - s * f * r - p * i * l + e * f * l + s * i * g - e * a * g) * w, t[7] = (s * u * r - c * a * r + c * i * l - e * u * l - s * i * d + e * a * d) * w, t[8] = x * w, t[9] = (p * h * r - c * m * r - p * n * d + e * m * d + c * n * g - e * h * g) * w, t[10] = (s * m * r - p * o * r + p * n * l - e * m * l - s * n * g + e * o * g) * w, t[11] = (c * o * r - s * h * r - c * n * l + e * h * l + s * n * d - e * o * d) * w, t[12] = _ * w, t[13] = (c * m * i - p * h * i + p * n * u - e * m * u - c * n * f + e * h * f) * w, t[14] = (p * o * i - s * m * i - p * n * a + e * m * a + s * n * f - e * o * f) * w, t[15] = (s * h * i - c * o * i + c * n * a - e * h * a - s * n * u + e * o * u) * w, this
                    }
                    scale(t) {
                        const e = this.elements,
                            n = t.x,
                            i = t.y,
                            r = t.z;
                        return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
                    }
                    getMaxScaleOnAxis() {
                        const t = this.elements,
                            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                            i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                        return Math.sqrt(Math.max(e, n, i))
                    }
                    makeTranslation(t, e, n) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this }
                    makeRotationX(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
                    }
                    makeRotationY(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
                    }
                    makeRotationZ(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                    }
                    makeRotationAxis(t, e) {
                        const n = Math.cos(e),
                            i = Math.sin(e),
                            r = 1 - n,
                            s = t.x,
                            o = t.y,
                            a = t.z,
                            l = r * s,
                            c = r * o;
                        return this.set(l * s + n, l * o - i * a, l * a + i * o, 0, l * o + i * a, c * o + n, c * a - i * s, 0, l * a - i * o, c * a + i * s, r * a * a + n, 0, 0, 0, 0, 1), this
                    }
                    makeScale(t, e, n) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this }
                    makeShear(t, e, n, i, r, s) { return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this }
                    compose(t, e, n) {
                        const i = this.elements,
                            r = e._x,
                            s = e._y,
                            o = e._z,
                            a = e._w,
                            l = r + r,
                            c = s + s,
                            h = o + o,
                            u = r * l,
                            d = r * c,
                            p = r * h,
                            m = s * c,
                            f = s * h,
                            g = o * h,
                            v = a * l,
                            y = a * c,
                            x = a * h,
                            _ = n.x,
                            b = n.y,
                            w = n.z;
                        return i[0] = (1 - (m + g)) * _, i[1] = (d + x) * _, i[2] = (p - y) * _, i[3] = 0, i[4] = (d - x) * b, i[5] = (1 - (u + g)) * b, i[6] = (f + v) * b, i[7] = 0, i[8] = (p + y) * w, i[9] = (f - v) * w, i[10] = (1 - (u + m)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
                    }
                    decompose(t, e, n) {
                        const i = this.elements;
                        let r = Vi.set(i[0], i[1], i[2]).length();
                        const s = Vi.set(i[4], i[5], i[6]).length(),
                            o = Vi.set(i[8], i[9], i[10]).length();
                        this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], Wi.copy(this);
                        const a = 1 / r,
                            l = 1 / s,
                            c = 1 / o;
                        return Wi.elements[0] *= a, Wi.elements[1] *= a, Wi.elements[2] *= a, Wi.elements[4] *= l, Wi.elements[5] *= l, Wi.elements[6] *= l, Wi.elements[8] *= c, Wi.elements[9] *= c, Wi.elements[10] *= c, e.setFromRotationMatrix(Wi), n.x = r, n.y = s, n.z = o, this
                    }
                    makePerspective(t, e, n, i, r, s) {
                        void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                        const o = this.elements,
                            a = 2 * r / (e - t),
                            l = 2 * r / (n - i),
                            c = (e + t) / (e - t),
                            h = (n + i) / (n - i),
                            u = -(s + r) / (s - r),
                            d = -2 * s * r / (s - r);
                        return o[0] = a, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = h, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
                    }
                    makeOrthographic(t, e, n, i, r, s) {
                        const o = this.elements,
                            a = 1 / (e - t),
                            l = 1 / (n - i),
                            c = 1 / (s - r),
                            h = (e + t) * a,
                            u = (n + i) * l,
                            d = (s + r) * c;
                        return o[0] = 2 * a, o[4] = 0, o[8] = 0, o[12] = -h, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
                    }
                    equals(t) {
                        const e = this.elements,
                            n = t.elements;
                        for (let t = 0; t < 16; t++)
                            if (e[t] !== n[t]) return !1;
                        return !0
                    }
                    fromArray(t, e = 0) { for (let n = 0; n < 16; n++) this.elements[n] = t[n + e]; return this }
                    toArray(t = [], e = 0) { const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t }
                }
                Gi.prototype.isMatrix4 = !0;
                const Vi = new ui,
                    Wi = new Gi,
                    ji = new ui(0, 0, 0),
                    qi = new ui(1, 1, 1),
                    Xi = new ui,
                    Yi = new ui,
                    Zi = new ui,
                    Ji = new Gi,
                    Ki = new hi;
                class Qi {
                    constructor(t = 0, e = 0, n = 0, i = Qi.DefaultOrder) { this._x = t, this._y = e, this._z = n, this._order = i }
                    get x() { return this._x }
                    set x(t) { this._x = t, this._onChangeCallback() }
                    get y() { return this._y }
                    set y(t) { this._y = t, this._onChangeCallback() }
                    get z() { return this._z }
                    set z(t) { this._z = t, this._onChangeCallback() }
                    get order() { return this._order }
                    set order(t) { this._order = t, this._onChangeCallback() }
                    set(t, e, n, i = this._order) { return this._x = t, this._y = e, this._z = n, this._order = i, this._onChangeCallback(), this }
                    clone() { return new this.constructor(this._x, this._y, this._z, this._order) }
                    copy(t) { return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this }
                    setFromRotationMatrix(t, e = this._order, n = !0) {
                        const i = t.elements,
                            r = i[0],
                            s = i[4],
                            o = i[8],
                            a = i[1],
                            l = i[5],
                            c = i[9],
                            h = i[2],
                            u = i[6],
                            d = i[10];
                        switch (e) {
                            case "XYZ":
                                this._y = Math.asin(qn(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                                break;
                            case "YXZ":
                                this._x = Math.asin(-qn(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
                                break;
                            case "ZXY":
                                this._x = Math.asin(qn(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(a, r));
                                break;
                            case "ZYX":
                                this._y = Math.asin(-qn(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(a, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
                                break;
                            case "YZX":
                                this._z = Math.asin(qn(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(o, d));
                                break;
                            case "XZY":
                                this._z = Math.asin(-qn(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
                                break;
                            default:
                                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                        }
                        return this._order = e, !0 === n && this._onChangeCallback(), this
                    }
                    setFromQuaternion(t, e, n) { return Ji.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Ji, e, n) }
                    setFromVector3(t, e = this._order) { return this.set(t.x, t.y, t.z, e) }
                    reorder(t) { return Ki.setFromEuler(this), this.setFromQuaternion(Ki, t) }
                    equals(t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order }
                    fromArray(t) { return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this }
                    toArray(t = [], e = 0) { return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t }
                    toVector3(t) { return t ? t.set(this._x, this._y, this._z) : new ui(this._x, this._y, this._z) }
                    _onChange(t) { return this._onChangeCallback = t, this }
                    _onChangeCallback() {}
                }
                Qi.prototype.isEuler = !0, Qi.DefaultOrder = "XYZ", Qi.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
                class $i {
                    constructor() { this.mask = 1 }
                    set(t) { this.mask = 1 << t | 0 }
                    enable(t) { this.mask |= 1 << t | 0 }
                    enableAll() { this.mask = -1 }
                    toggle(t) { this.mask ^= 1 << t | 0 }
                    disable(t) { this.mask &= ~(1 << t | 0) }
                    disableAll() { this.mask = 0 }
                    test(t) { return 0 != (this.mask & t.mask) }
                }
                let tr = 0;
                const er = new ui,
                    nr = new hi,
                    ir = new Gi,
                    rr = new ui,
                    sr = new ui,
                    or = new ui,
                    ar = new hi,
                    lr = new ui(1, 0, 0),
                    cr = new ui(0, 1, 0),
                    hr = new ui(0, 0, 1),
                    ur = { type: "added" },
                    dr = { type: "removed" };
                class pr extends Hn {
                    constructor() {
                        super(), Object.defineProperty(this, "id", { value: tr++ }), this.uuid = jn(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = pr.DefaultUp.clone();
                        const t = new ui,
                            e = new Qi,
                            n = new hi,
                            i = new ui(1, 1, 1);
                        e._onChange((function() { n.setFromEuler(e, !1) })), n._onChange((function() { e.setFromQuaternion(n, void 0, !1) })), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: i }, modelViewMatrix: { value: new Gi }, normalMatrix: { value: new ti } }), this.matrix = new Gi, this.matrixWorld = new Gi, this.matrixAutoUpdate = pr.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new $i, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                    }
                    onBeforeRender() {}
                    onAfterRender() {}
                    applyMatrix4(t) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale) }
                    applyQuaternion(t) { return this.quaternion.premultiply(t), this }
                    setRotationFromAxisAngle(t, e) { this.quaternion.setFromAxisAngle(t, e) }
                    setRotationFromEuler(t) { this.quaternion.setFromEuler(t, !0) }
                    setRotationFromMatrix(t) { this.quaternion.setFromRotationMatrix(t) }
                    setRotationFromQuaternion(t) { this.quaternion.copy(t) }
                    rotateOnAxis(t, e) { return nr.setFromAxisAngle(t, e), this.quaternion.multiply(nr), this }
                    rotateOnWorldAxis(t, e) { return nr.setFromAxisAngle(t, e), this.quaternion.premultiply(nr), this }
                    rotateX(t) { return this.rotateOnAxis(lr, t) }
                    rotateY(t) { return this.rotateOnAxis(cr, t) }
                    rotateZ(t) { return this.rotateOnAxis(hr, t) }
                    translateOnAxis(t, e) { return er.copy(t).applyQuaternion(this.quaternion), this.position.add(er.multiplyScalar(e)), this }
                    translateX(t) { return this.translateOnAxis(lr, t) }
                    translateY(t) { return this.translateOnAxis(cr, t) }
                    translateZ(t) { return this.translateOnAxis(hr, t) }
                    localToWorld(t) { return t.applyMatrix4(this.matrixWorld) }
                    worldToLocal(t) { return t.applyMatrix4(ir.copy(this.matrixWorld).invert()) }
                    lookAt(t, e, n) {
                        t.isVector3 ? rr.copy(t) : rr.set(t, e, n);
                        const i = this.parent;
                        this.updateWorldMatrix(!0, !1), sr.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ir.lookAt(sr, rr, this.up) : ir.lookAt(rr, sr, this.up), this.quaternion.setFromRotationMatrix(ir), i && (ir.extractRotation(i.matrixWorld), nr.setFromRotationMatrix(ir), this.quaternion.premultiply(nr.invert()))
                    }
                    add(t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++) this.add(arguments[t]); return this } return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(ur)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this) }
                    remove(t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]); return this } const e = this.children.indexOf(t); return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(dr)), this }
                    removeFromParent() { const t = this.parent; return null !== t && t.remove(this), this }
                    clear() {
                        for (let t = 0; t < this.children.length; t++) {
                            const e = this.children[t];
                            e.parent = null, e.dispatchEvent(dr)
                        }
                        return this.children.length = 0, this
                    }
                    attach(t) { return this.updateWorldMatrix(!0, !1), ir.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), ir.multiply(t.parent.matrixWorld)), t.applyMatrix4(ir), this.add(t), t.updateWorldMatrix(!1, !0), this }
                    getObjectById(t) { return this.getObjectByProperty("id", t) }
                    getObjectByName(t) { return this.getObjectByProperty("name", t) }
                    getObjectByProperty(t, e) { if (this[t] === e) return this; for (let n = 0, i = this.children.length; n < i; n++) { const i = this.children[n].getObjectByProperty(t, e); if (void 0 !== i) return i } }
                    getWorldPosition(t) { return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld) }
                    getWorldQuaternion(t) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(sr, t, or), t }
                    getWorldScale(t) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(sr, ar, t), t }
                    getWorldDirection(t) { this.updateWorldMatrix(!0, !1); const e = this.matrixWorld.elements; return t.set(e[8], e[9], e[10]).normalize() }
                    raycast() {}
                    traverse(t) { t(this); const e = this.children; for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t) }
                    traverseVisible(t) {
                        if (!1 === this.visible) return;
                        t(this);
                        const e = this.children;
                        for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
                    }
                    traverseAncestors(t) {
                        const e = this.parent;
                        null !== e && (t(e), e.traverseAncestors(t))
                    }
                    updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 }
                    updateMatrixWorld(t) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0); const e = this.children; for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t) }
                    updateWorldMatrix(t, e) { const n = this.parent; if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) { const t = this.children; for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0) } }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t,
                            n = {};
                        e && (t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
                        const i = {};

                        function r(e, n) { return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid }
                        if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && (i.environment = this.environment.toJSON(t).uuid);
                        else if (this.isMesh || this.isLine || this.isPoints) {
                            i.geometry = r(t.geometries, this.geometry);
                            const e = this.geometry.parameters;
                            if (void 0 !== e && void 0 !== e.shapes) {
                                const n = e.shapes;
                                if (Array.isArray(n))
                                    for (let e = 0, i = n.length; e < i; e++) {
                                        const i = n[e];
                                        r(t.shapes, i)
                                    } else r(t.shapes, n)
                            }
                        }
                        if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                            if (Array.isArray(this.material)) {
                                const e = [];
                                for (let n = 0, i = this.material.length; n < i; n++) e.push(r(t.materials, this.material[n]));
                                i.material = e
                            } else i.material = r(t.materials, this.material);
                        if (this.children.length > 0) { i.children = []; for (let e = 0; e < this.children.length; e++) i.children.push(this.children[e].toJSON(t).object) }
                        if (this.animations.length > 0) {
                            i.animations = [];
                            for (let e = 0; e < this.animations.length; e++) {
                                const n = this.animations[e];
                                i.animations.push(r(t.animations, n))
                            }
                        }
                        if (e) {
                            const e = s(t.geometries),
                                i = s(t.materials),
                                r = s(t.textures),
                                o = s(t.images),
                                a = s(t.shapes),
                                l = s(t.skeletons),
                                c = s(t.animations);
                            e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o), a.length > 0 && (n.shapes = a), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c)
                        }
                        return n.object = i, n;

                        function s(t) {
                            const e = [];
                            for (const n in t) {
                                const i = t[n];
                                delete i.metadata, e.push(i)
                            }
                            return e
                        }
                    }
                    clone(t) { return (new this.constructor).copy(this, t) }
                    copy(t, e = !0) {
                        if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                            for (let e = 0; e < t.children.length; e++) {
                                const n = t.children[e];
                                this.add(n.clone())
                            }
                        return this
                    }
                }
                pr.DefaultUp = new ui(0, 1, 0), pr.DefaultMatrixAutoUpdate = !0, pr.prototype.isObject3D = !0;
                const mr = new ui,
                    fr = new ui,
                    gr = new ui,
                    vr = new ui,
                    yr = new ui,
                    xr = new ui,
                    _r = new ui,
                    br = new ui,
                    wr = new ui,
                    Mr = new ui;
                class Sr {
                    constructor(t = new ui, e = new ui, n = new ui) { this.a = t, this.b = e, this.c = n }
                    static getNormal(t, e, n, i) { i.subVectors(n, e), mr.subVectors(t, e), i.cross(mr); const r = i.lengthSq(); return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0) }
                    static getBarycoord(t, e, n, i, r) {
                        mr.subVectors(i, e), fr.subVectors(n, e), gr.subVectors(t, e);
                        const s = mr.dot(mr),
                            o = mr.dot(fr),
                            a = mr.dot(gr),
                            l = fr.dot(fr),
                            c = fr.dot(gr),
                            h = s * l - o * o;
                        if (0 === h) return r.set(-2, -1, -1);
                        const u = 1 / h,
                            d = (l * a - o * c) * u,
                            p = (s * c - o * a) * u;
                        return r.set(1 - d - p, p, d)
                    }
                    static containsPoint(t, e, n, i) { return this.getBarycoord(t, e, n, i, vr), vr.x >= 0 && vr.y >= 0 && vr.x + vr.y <= 1 }
                    static getUV(t, e, n, i, r, s, o, a) { return this.getBarycoord(t, e, n, i, vr), a.set(0, 0), a.addScaledVector(r, vr.x), a.addScaledVector(s, vr.y), a.addScaledVector(o, vr.z), a }
                    static isFrontFacing(t, e, n, i) { return mr.subVectors(n, e), fr.subVectors(t, e), mr.cross(fr).dot(i) < 0 }
                    set(t, e, n) { return this.a.copy(t), this.b.copy(e), this.c.copy(n), this }
                    setFromPointsAndIndices(t, e, n, i) { return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this }
                    getArea() { return mr.subVectors(this.c, this.b), fr.subVectors(this.a, this.b), .5 * mr.cross(fr).length() }
                    getMidpoint(t) { return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) }
                    getNormal(t) { return Sr.getNormal(this.a, this.b, this.c, t) }
                    getPlane(t) { return t.setFromCoplanarPoints(this.a, this.b, this.c) }
                    getBarycoord(t, e) { return Sr.getBarycoord(t, this.a, this.b, this.c, e) }
                    getUV(t, e, n, i, r) { return Sr.getUV(t, this.a, this.b, this.c, e, n, i, r) }
                    containsPoint(t) { return Sr.containsPoint(t, this.a, this.b, this.c) }
                    isFrontFacing(t) { return Sr.isFrontFacing(this.a, this.b, this.c, t) }
                    intersectsBox(t) { return t.intersectsTriangle(this) }
                    closestPointToPoint(t, e) {
                        const n = this.a,
                            i = this.b,
                            r = this.c;
                        let s, o;
                        yr.subVectors(i, n), xr.subVectors(r, n), br.subVectors(t, n);
                        const a = yr.dot(br),
                            l = xr.dot(br);
                        if (a <= 0 && l <= 0) return e.copy(n);
                        wr.subVectors(t, i);
                        const c = yr.dot(wr),
                            h = xr.dot(wr);
                        if (c >= 0 && h <= c) return e.copy(i);
                        const u = a * h - c * l;
                        if (u <= 0 && a >= 0 && c <= 0) return s = a / (a - c), e.copy(n).addScaledVector(yr, s);
                        Mr.subVectors(t, r);
                        const d = yr.dot(Mr),
                            p = xr.dot(Mr);
                        if (p >= 0 && d <= p) return e.copy(r);
                        const m = d * l - a * p;
                        if (m <= 0 && l >= 0 && p <= 0) return o = l / (l - p), e.copy(n).addScaledVector(xr, o);
                        const f = c * p - d * h;
                        if (f <= 0 && h - c >= 0 && d - p >= 0) return _r.subVectors(r, i), o = (h - c) / (h - c + (d - p)), e.copy(i).addScaledVector(_r, o);
                        const g = 1 / (f + m + u);
                        return s = m * g, o = u * g, e.copy(n).addScaledVector(yr, s).addScaledVector(xr, o)
                    }
                    equals(t) { return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c) }
                }
                let Tr = 0;
                class Er extends Hn {
                    constructor() { super(), Object.defineProperty(this, "id", { value: Tr++ }), this.uuid = jn(), this.name = "", this.type = "Material", this.fog = !0, this.blending = S, this.side = y, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = z, this.blendDst = U, this.blendEquation = R, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Y, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Ln, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = mn, this.stencilZFail = mn, this.stencilZPass = mn, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0 }
                    onBuild() {}
                    onBeforeCompile() {}
                    customProgramCacheKey() { return this.onBeforeCompile.toString() }
                    setValues(t) {
                        if (void 0 !== t)
                            for (const e in t) {
                                const n = t[e];
                                if (void 0 === n) { console.warn("THREE.Material: '" + e + "' parameter is undefined."); continue }
                                if ("shading" === e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === b; continue }
                                const i = this[e];
                                void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                            }
                    }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t;
                        e && (t = { textures: {}, images: {} });
                        const n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };

                        function i(t) {
                            const e = [];
                            for (const n in t) {
                                const i = t[n];
                                delete i.metadata, e.push(i)
                            }
                            return e
                        }
                        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== S && (n.blending = this.blending), this.side !== y && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                            const e = i(t.textures),
                                r = i(t.images);
                            e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
                        }
                        return n
                    }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) {
                        this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                        const e = t.clippingPlanes;
                        let n = null;
                        if (null !== e) {
                            const t = e.length;
                            n = new Array(t);
                            for (let i = 0; i !== t; ++i) n[i] = e[i].clone()
                        }
                        return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
                    }
                    dispose() { this.dispatchEvent({ type: "dispose" }) }
                    set needsUpdate(t) {!0 === t && this.version++ }
                }
                Er.prototype.isMaterial = !0;
                const Ar = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 },
                    Lr = { h: 0, s: 0, l: 0 },
                    Rr = { h: 0, s: 0, l: 0 };

                function Cr(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t }

                function Pr(t) { return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4) }

                function Ir(t) { return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055 }
                class Dr {
                    constructor(t, e, n) { return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n) }
                    set(t) { return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this }
                    setScalar(t) { return this.r = t, this.g = t, this.b = t, this }
                    setHex(t) { return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this }
                    setRGB(t, e, n) { return this.r = t, this.g = e, this.b = n, this }
                    setHSL(t, e, n) {
                        if (t = Xn(t, 1), e = qn(e, 0, 1), n = qn(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                        else {
                            const i = n <= .5 ? n * (1 + e) : n + e - n * e,
                                r = 2 * n - i;
                            this.r = Cr(r, i, t + 1 / 3), this.g = Cr(r, i, t), this.b = Cr(r, i, t - 1 / 3)
                        }
                        return this
                    }
                    setStyle(t) {
                        function e(e) { void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.") }
                        let n;
                        if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
                            let t;
                            const i = n[1],
                                r = n[2];
                            switch (i) {
                                case "rgb":
                                case "rgba":
                                    if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[4]), this;
                                    if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[4]), this;
                                    break;
                                case "hsl":
                                case "hsla":
                                    if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                                        const n = parseFloat(t[1]) / 360,
                                            i = parseInt(t[2], 10) / 100,
                                            r = parseInt(t[3], 10) / 100;
                                        return e(t[4]), this.setHSL(n, i, r)
                                    }
                            }
                        } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                            const t = n[1],
                                e = t.length;
                            if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
                            if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
                        }
                        return t && t.length > 0 ? this.setColorName(t) : this
                    }
                    setColorName(t) { const e = Ar[t.toLowerCase()]; return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this }
                    clone() { return new this.constructor(this.r, this.g, this.b) }
                    copy(t) { return this.r = t.r, this.g = t.g, this.b = t.b, this }
                    copyGammaToLinear(t, e = 2) { return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this }
                    copyLinearToGamma(t, e = 2) { const n = e > 0 ? 1 / e : 1; return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this }
                    convertGammaToLinear(t) { return this.copyGammaToLinear(this, t), this }
                    convertLinearToGamma(t) { return this.copyLinearToGamma(this, t), this }
                    copySRGBToLinear(t) { return this.r = Pr(t.r), this.g = Pr(t.g), this.b = Pr(t.b), this }
                    copyLinearToSRGB(t) { return this.r = Ir(t.r), this.g = Ir(t.g), this.b = Ir(t.b), this }
                    convertSRGBToLinear() { return this.copySRGBToLinear(this), this }
                    convertLinearToSRGB() { return this.copyLinearToSRGB(this), this }
                    getHex() { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 }
                    getHexString() { return ("000000" + this.getHex().toString(16)).slice(-6) }
                    getHSL(t) {
                        const e = this.r,
                            n = this.g,
                            i = this.b,
                            r = Math.max(e, n, i),
                            s = Math.min(e, n, i);
                        let o, a;
                        const l = (s + r) / 2;
                        if (s === r) o = 0, a = 0;
                        else {
                            const t = r - s;
                            switch (a = l <= .5 ? t / (r + s) : t / (2 - r - s), r) {
                                case e:
                                    o = (n - i) / t + (n < i ? 6 : 0);
                                    break;
                                case n:
                                    o = (i - e) / t + 2;
                                    break;
                                case i:
                                    o = (e - n) / t + 4
                            }
                            o /= 6
                        }
                        return t.h = o, t.s = a, t.l = l, t
                    }
                    getStyle() { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" }
                    offsetHSL(t, e, n) { return this.getHSL(Lr), Lr.h += t, Lr.s += e, Lr.l += n, this.setHSL(Lr.h, Lr.s, Lr.l), this }
                    add(t) { return this.r += t.r, this.g += t.g, this.b += t.b, this }
                    addColors(t, e) { return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this }
                    addScalar(t) { return this.r += t, this.g += t, this.b += t, this }
                    sub(t) { return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this }
                    multiply(t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this }
                    multiplyScalar(t) { return this.r *= t, this.g *= t, this.b *= t, this }
                    lerp(t, e) { return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this }
                    lerpColors(t, e, n) { return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this }
                    lerpHSL(t, e) {
                        this.getHSL(Lr), t.getHSL(Rr);
                        const n = Yn(Lr.h, Rr.h, e),
                            i = Yn(Lr.s, Rr.s, e),
                            r = Yn(Lr.l, Rr.l, e);
                        return this.setHSL(n, i, r), this
                    }
                    equals(t) { return t.r === this.r && t.g === this.g && t.b === this.b }
                    fromArray(t, e = 0) { return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this }
                    toArray(t = [], e = 0) { return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t }
                    fromBufferAttribute(t, e) { return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this }
                    toJSON() { return this.getHex() }
                }
                Dr.NAMES = Ar, Dr.prototype.isColor = !0, Dr.prototype.r = 1, Dr.prototype.g = 1, Dr.prototype.b = 1;
                class Nr extends Er {
                    constructor(t) { super(), this.type = "MeshBasicMaterial", this.color = new Dr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = $, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this }
                }
                Nr.prototype.isMeshBasicMaterial = !0;
                const Br = new ui,
                    Or = new $n;
                class Fr {
                    constructor(t, e, n) {
                        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = Rn, this.updateRange = { offset: 0, count: -1 }, this.version = 0
                    }
                    onUploadCallback() {}
                    set needsUpdate(t) {!0 === t && this.version++ }
                    setUsage(t) { return this.usage = t, this }
                    copy(t) { return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this }
                    copyAt(t, e, n) { t *= this.itemSize, n *= e.itemSize; for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i]; return this }
                    copyArray(t) { return this.array.set(t), this }
                    copyColorsArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let i = 0, r = t.length; i < r; i++) {
                            let r = t[i];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new Dr), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
                        }
                        return this
                    }
                    copyVector2sArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let i = 0, r = t.length; i < r; i++) {
                            let r = t[i];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new $n), e[n++] = r.x, e[n++] = r.y
                        }
                        return this
                    }
                    copyVector3sArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let i = 0, r = t.length; i < r; i++) {
                            let r = t[i];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new ui), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
                        }
                        return this
                    }
                    copyVector4sArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let i = 0, r = t.length; i < r; i++) {
                            let r = t[i];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new oi), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
                        }
                        return this
                    }
                    applyMatrix3(t) {
                        if (2 === this.itemSize)
                            for (let e = 0, n = this.count; e < n; e++) Or.fromBufferAttribute(this, e), Or.applyMatrix3(t), this.setXY(e, Or.x, Or.y);
                        else if (3 === this.itemSize)
                            for (let e = 0, n = this.count; e < n; e++) Br.fromBufferAttribute(this, e), Br.applyMatrix3(t), this.setXYZ(e, Br.x, Br.y, Br.z);
                        return this
                    }
                    applyMatrix4(t) { for (let e = 0, n = this.count; e < n; e++) Br.x = this.getX(e), Br.y = this.getY(e), Br.z = this.getZ(e), Br.applyMatrix4(t), this.setXYZ(e, Br.x, Br.y, Br.z); return this }
                    applyNormalMatrix(t) { for (let e = 0, n = this.count; e < n; e++) Br.x = this.getX(e), Br.y = this.getY(e), Br.z = this.getZ(e), Br.applyNormalMatrix(t), this.setXYZ(e, Br.x, Br.y, Br.z); return this }
                    transformDirection(t) { for (let e = 0, n = this.count; e < n; e++) Br.x = this.getX(e), Br.y = this.getY(e), Br.z = this.getZ(e), Br.transformDirection(t), this.setXYZ(e, Br.x, Br.y, Br.z); return this }
                    set(t, e = 0) { return this.array.set(t, e), this }
                    getX(t) { return this.array[t * this.itemSize] }
                    setX(t, e) { return this.array[t * this.itemSize] = e, this }
                    getY(t) { return this.array[t * this.itemSize + 1] }
                    setY(t, e) { return this.array[t * this.itemSize + 1] = e, this }
                    getZ(t) { return this.array[t * this.itemSize + 2] }
                    setZ(t, e) { return this.array[t * this.itemSize + 2] = e, this }
                    getW(t) { return this.array[t * this.itemSize + 3] }
                    setW(t, e) { return this.array[t * this.itemSize + 3] = e, this }
                    setXY(t, e, n) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this }
                    setXYZ(t, e, n, i) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this }
                    setXYZW(t, e, n, i, r) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this }
                    onUpload(t) { return this.onUploadCallback = t, this }
                    clone() { return new this.constructor(this.array, this.itemSize).copy(this) }
                    toJSON() { const t = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized }; return "" !== this.name && (t.name = this.name), this.usage !== Rn && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t }
                }
                Fr.prototype.isBufferAttribute = !0;
                class zr extends Fr { constructor(t, e, n) { super(new Int8Array(t), e, n) } }
                class Ur extends Fr { constructor(t, e, n) { super(new Uint8Array(t), e, n) } }
                class Hr extends Fr { constructor(t, e, n) { super(new Uint8ClampedArray(t), e, n) } }
                class kr extends Fr { constructor(t, e, n) { super(new Int16Array(t), e, n) } }
                class Gr extends Fr { constructor(t, e, n) { super(new Uint16Array(t), e, n) } }
                class Vr extends Fr { constructor(t, e, n) { super(new Int32Array(t), e, n) } }
                class Wr extends Fr { constructor(t, e, n) { super(new Uint32Array(t), e, n) } }
                class jr extends Fr { constructor(t, e, n) { super(new Uint16Array(t), e, n) } }
                jr.prototype.isFloat16BufferAttribute = !0;
                class qr extends Fr { constructor(t, e, n) { super(new Float32Array(t), e, n) } }
                class Xr extends Fr { constructor(t, e, n) { super(new Float64Array(t), e, n) } }

                function Yr(t) { if (0 === t.length) return -1 / 0; let e = t[0]; for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]); return e }
                const Zr = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };

                function Jr(t, e) { return new Zr[t](e) }
                let Kr = 0;
                const Qr = new Gi,
                    $r = new pr,
                    ts = new ui,
                    es = new mi,
                    ns = new mi,
                    is = new ui;
                class rs extends Hn {
                    constructor() { super(), Object.defineProperty(this, "id", { value: Kr++ }), this.uuid = jn(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} }
                    getIndex() { return this.index }
                    setIndex(t) { return Array.isArray(t) ? this.index = new(Yr(t) > 65535 ? Wr : Gr)(t, 1) : this.index = t, this }
                    getAttribute(t) { return this.attributes[t] }
                    setAttribute(t, e) { return this.attributes[t] = e, this }
                    deleteAttribute(t) { return delete this.attributes[t], this }
                    hasAttribute(t) { return void 0 !== this.attributes[t] }
                    addGroup(t, e, n = 0) { this.groups.push({ start: t, count: e, materialIndex: n }) }
                    clearGroups() { this.groups = [] }
                    setDrawRange(t, e) { this.drawRange.start = t, this.drawRange.count = e }
                    applyMatrix4(t) {
                        const e = this.attributes.position;
                        void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                        const n = this.attributes.normal;
                        if (void 0 !== n) {
                            const e = (new ti).getNormalMatrix(t);
                            n.applyNormalMatrix(e), n.needsUpdate = !0
                        }
                        const i = this.attributes.tangent;
                        return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                    }
                    applyQuaternion(t) { return Qr.makeRotationFromQuaternion(t), this.applyMatrix4(Qr), this }
                    rotateX(t) { return Qr.makeRotationX(t), this.applyMatrix4(Qr), this }
                    rotateY(t) { return Qr.makeRotationY(t), this.applyMatrix4(Qr), this }
                    rotateZ(t) { return Qr.makeRotationZ(t), this.applyMatrix4(Qr), this }
                    translate(t, e, n) { return Qr.makeTranslation(t, e, n), this.applyMatrix4(Qr), this }
                    scale(t, e, n) { return Qr.makeScale(t, e, n), this.applyMatrix4(Qr), this }
                    lookAt(t) { return $r.lookAt(t), $r.updateMatrix(), this.applyMatrix4($r.matrix), this }
                    center() { return this.computeBoundingBox(), this.boundingBox.getCenter(ts).negate(), this.translate(ts.x, ts.y, ts.z), this }
                    setFromPoints(t) {
                        const e = [];
                        for (let n = 0, i = t.length; n < i; n++) {
                            const i = t[n];
                            e.push(i.x, i.y, i.z || 0)
                        }
                        return this.setAttribute("position", new qr(e, 3)), this
                    }
                    computeBoundingBox() {
                        null === this.boundingBox && (this.boundingBox = new mi);
                        const t = this.attributes.position,
                            e = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new ui(-1 / 0, -1 / 0, -1 / 0), new ui(1 / 0, 1 / 0, 1 / 0));
                        if (void 0 !== t) {
                            if (this.boundingBox.setFromBufferAttribute(t), e)
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t];
                                    es.setFromBufferAttribute(n), this.morphTargetsRelative ? (is.addVectors(this.boundingBox.min, es.min), this.boundingBox.expandByPoint(is), is.addVectors(this.boundingBox.max, es.max), this.boundingBox.expandByPoint(is)) : (this.boundingBox.expandByPoint(es.min), this.boundingBox.expandByPoint(es.max))
                                }
                        } else this.boundingBox.makeEmpty();
                        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                    }
                    computeBoundingSphere() {
                        null === this.boundingSphere && (this.boundingSphere = new Di);
                        const t = this.attributes.position,
                            e = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new ui, 1 / 0);
                        if (t) {
                            const n = this.boundingSphere.center;
                            if (es.setFromBufferAttribute(t), e)
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t];
                                    ns.setFromBufferAttribute(n), this.morphTargetsRelative ? (is.addVectors(es.min, ns.min), es.expandByPoint(is), is.addVectors(es.max, ns.max), es.expandByPoint(is)) : (es.expandByPoint(ns.min), es.expandByPoint(ns.max))
                                }
                            es.getCenter(n);
                            let i = 0;
                            for (let e = 0, r = t.count; e < r; e++) is.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(is));
                            if (e)
                                for (let r = 0, s = e.length; r < s; r++) {
                                    const s = e[r],
                                        o = this.morphTargetsRelative;
                                    for (let e = 0, r = s.count; e < r; e++) is.fromBufferAttribute(s, e), o && (ts.fromBufferAttribute(t, e), is.add(ts)), i = Math.max(i, n.distanceToSquared(is))
                                }
                            this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                    computeFaceNormals() {}
                    computeTangents() {
                        const t = this.index,
                            e = this.attributes;
                        if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                        const n = t.array,
                            i = e.position.array,
                            r = e.normal.array,
                            s = e.uv.array,
                            o = i.length / 3;
                        void 0 === e.tangent && this.setAttribute("tangent", new Fr(new Float32Array(4 * o), 4));
                        const a = e.tangent.array,
                            l = [],
                            c = [];
                        for (let t = 0; t < o; t++) l[t] = new ui, c[t] = new ui;
                        const h = new ui,
                            u = new ui,
                            d = new ui,
                            p = new $n,
                            m = new $n,
                            f = new $n,
                            g = new ui,
                            v = new ui;

                        function y(t, e, n) {
                            h.fromArray(i, 3 * t), u.fromArray(i, 3 * e), d.fromArray(i, 3 * n), p.fromArray(s, 2 * t), m.fromArray(s, 2 * e), f.fromArray(s, 2 * n), u.sub(h), d.sub(h), m.sub(p), f.sub(p);
                            const r = 1 / (m.x * f.y - f.x * m.y);
                            isFinite(r) && (g.copy(u).multiplyScalar(f.y).addScaledVector(d, -m.y).multiplyScalar(r), v.copy(d).multiplyScalar(m.x).addScaledVector(u, -f.x).multiplyScalar(r), l[t].add(g), l[e].add(g), l[n].add(g), c[t].add(v), c[e].add(v), c[n].add(v))
                        }
                        let x = this.groups;
                        0 === x.length && (x = [{ start: 0, count: n.length }]);
                        for (let t = 0, e = x.length; t < e; ++t) {
                            const e = x[t],
                                i = e.start;
                            for (let t = i, r = i + e.count; t < r; t += 3) y(n[t + 0], n[t + 1], n[t + 2])
                        }
                        const _ = new ui,
                            b = new ui,
                            w = new ui,
                            M = new ui;

                        function S(t) {
                            w.fromArray(r, 3 * t), M.copy(w);
                            const e = l[t];
                            _.copy(e), _.sub(w.multiplyScalar(w.dot(e))).normalize(), b.crossVectors(M, e);
                            const n = b.dot(c[t]) < 0 ? -1 : 1;
                            a[4 * t] = _.x, a[4 * t + 1] = _.y, a[4 * t + 2] = _.z, a[4 * t + 3] = n
                        }
                        for (let t = 0, e = x.length; t < e; ++t) {
                            const e = x[t],
                                i = e.start;
                            for (let t = i, r = i + e.count; t < r; t += 3) S(n[t + 0]), S(n[t + 1]), S(n[t + 2])
                        }
                    }
                    computeVertexNormals() {
                        const t = this.index,
                            e = this.getAttribute("position");
                        if (void 0 !== e) {
                            let n = this.getAttribute("normal");
                            if (void 0 === n) n = new Fr(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                            else
                                for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                            const i = new ui,
                                r = new ui,
                                s = new ui,
                                o = new ui,
                                a = new ui,
                                l = new ui,
                                c = new ui,
                                h = new ui;
                            if (t)
                                for (let u = 0, d = t.count; u < d; u += 3) {
                                    const d = t.getX(u + 0),
                                        p = t.getX(u + 1),
                                        m = t.getX(u + 2);
                                    i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), s.fromBufferAttribute(e, m), c.subVectors(s, r), h.subVectors(i, r), c.cross(h), o.fromBufferAttribute(n, d), a.fromBufferAttribute(n, p), l.fromBufferAttribute(n, m), o.add(c), a.add(c), l.add(c), n.setXYZ(d, o.x, o.y, o.z), n.setXYZ(p, a.x, a.y, a.z), n.setXYZ(m, l.x, l.y, l.z)
                                } else
                                    for (let t = 0, o = e.count; t < o; t += 3) i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), s.fromBufferAttribute(e, t + 2), c.subVectors(s, r), h.subVectors(i, r), c.cross(h), n.setXYZ(t + 0, c.x, c.y, c.z), n.setXYZ(t + 1, c.x, c.y, c.z), n.setXYZ(t + 2, c.x, c.y, c.z);
                            this.normalizeNormals(), n.needsUpdate = !0
                        }
                    }
                    merge(t, e) {
                        if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                        void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                        const n = this.attributes;
                        for (const i in n) {
                            if (void 0 === t.attributes[i]) continue;
                            const r = n[i].array,
                                s = t.attributes[i],
                                o = s.array,
                                a = s.itemSize * e,
                                l = Math.min(o.length, r.length - a);
                            for (let t = 0, e = a; t < l; t++, e++) r[e] = o[t]
                        }
                        return this
                    }
                    normalizeNormals() { const t = this.attributes.normal; for (let e = 0, n = t.count; e < n; e++) is.fromBufferAttribute(t, e), is.normalize(), t.setXYZ(e, is.x, is.y, is.z) }
                    toNonIndexed() {
                        function t(t, e) {
                            const n = t.array,
                                i = t.itemSize,
                                r = t.normalized,
                                s = new n.constructor(e.length * i);
                            let o = 0,
                                a = 0;
                            for (let r = 0, l = e.length; r < l; r++) { o = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i; for (let t = 0; t < i; t++) s[a++] = n[o++] }
                            return new Fr(s, i, r)
                        }
                        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                        const e = new rs,
                            n = this.index.array,
                            i = this.attributes;
                        for (const r in i) {
                            const s = t(i[r], n);
                            e.setAttribute(r, s)
                        }
                        const r = this.morphAttributes;
                        for (const i in r) {
                            const s = [],
                                o = r[i];
                            for (let e = 0, i = o.length; e < i; e++) {
                                const i = t(o[e], n);
                                s.push(i)
                            }
                            e.morphAttributes[i] = s
                        }
                        e.morphTargetsRelative = this.morphTargetsRelative;
                        const s = this.groups;
                        for (let t = 0, n = s.length; t < n; t++) {
                            const n = s[t];
                            e.addGroup(n.start, n.count, n.materialIndex)
                        }
                        return e
                    }
                    toJSON() {
                        const t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
                        if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) { const e = this.parameters; for (const n in e) void 0 !== e[n] && (t[n] = e[n]); return t }
                        t.data = { attributes: {} };
                        const e = this.index;
                        null !== e && (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) });
                        const n = this.attributes;
                        for (const e in n) {
                            const i = n[e];
                            t.data.attributes[e] = i.toJSON(t.data)
                        }
                        const i = {};
                        let r = !1;
                        for (const e in this.morphAttributes) {
                            const n = this.morphAttributes[e],
                                s = [];
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = n[e];
                                s.push(i.toJSON(t.data))
                            }
                            s.length > 0 && (i[e] = s, r = !0)
                        }
                        r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
                        const s = this.groups;
                        s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                        const o = this.boundingSphere;
                        return null !== o && (t.data.boundingSphere = { center: o.center.toArray(), radius: o.radius }), t
                    }
                    clone() { return (new rs).copy(this) }
                    copy(t) {
                        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                        const e = {};
                        this.name = t.name;
                        const n = t.index;
                        null !== n && this.setIndex(n.clone(e));
                        const i = t.attributes;
                        for (const t in i) {
                            const n = i[t];
                            this.setAttribute(t, n.clone(e))
                        }
                        const r = t.morphAttributes;
                        for (const t in r) {
                            const n = [],
                                i = r[t];
                            for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
                            this.morphAttributes[t] = n
                        }
                        this.morphTargetsRelative = t.morphTargetsRelative;
                        const s = t.groups;
                        for (let t = 0, e = s.length; t < e; t++) {
                            const e = s[t];
                            this.addGroup(e.start, e.count, e.materialIndex)
                        }
                        const o = t.boundingBox;
                        null !== o && (this.boundingBox = o.clone());
                        const a = t.boundingSphere;
                        return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
                    }
                    dispose() { this.dispatchEvent({ type: "dispose" }) }
                }
                rs.prototype.isBufferGeometry = !0;
                const ss = new Gi,
                    os = new ki,
                    as = new Di,
                    ls = new ui,
                    cs = new ui,
                    hs = new ui,
                    us = new ui,
                    ds = new ui,
                    ps = new ui,
                    ms = new ui,
                    fs = new ui,
                    gs = new ui,
                    vs = new $n,
                    ys = new $n,
                    xs = new $n,
                    _s = new ui,
                    bs = new ui;
                class ws extends pr {
                    constructor(t = new rs, e = new Nr) { super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets() }
                    copy(t) { return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this }
                    updateMorphTargets() {
                        const t = this.geometry;
                        if (t.isBufferGeometry) {
                            const e = t.morphAttributes,
                                n = Object.keys(e);
                            if (n.length > 0) {
                                const t = e[n[0]];
                                if (void 0 !== t) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let e = 0, n = t.length; e < n; e++) {
                                        const n = t[e].name || String(e);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                    }
                                }
                            }
                        } else {
                            const e = t.morphTargets;
                            void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                        }
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            i = this.material,
                            r = this.matrixWorld;
                        if (void 0 === i) return;
                        if (null === n.boundingSphere && n.computeBoundingSphere(), as.copy(n.boundingSphere), as.applyMatrix4(r), !1 === t.ray.intersectsSphere(as)) return;
                        if (ss.copy(r).invert(), os.copy(t.ray).applyMatrix4(ss), null !== n.boundingBox && !1 === os.intersectsBox(n.boundingBox)) return;
                        let s;
                        if (n.isBufferGeometry) {
                            const r = n.index,
                                o = n.attributes.position,
                                a = n.morphAttributes.position,
                                l = n.morphTargetsRelative,
                                c = n.attributes.uv,
                                h = n.attributes.uv2,
                                u = n.groups,
                                d = n.drawRange;
                            if (null !== r)
                                if (Array.isArray(i))
                                    for (let n = 0, p = u.length; n < p; n++) {
                                        const p = u[n],
                                            m = i[p.materialIndex];
                                        for (let n = Math.max(p.start, d.start), i = Math.min(p.start + p.count, d.start + d.count); n < i; n += 3) {
                                            const i = r.getX(n),
                                                u = r.getX(n + 1),
                                                d = r.getX(n + 2);
                                            s = Ms(this, m, t, os, o, a, l, c, h, i, u, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, e.push(s))
                                        }
                                    } else
                                        for (let n = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); n < u; n += 3) {
                                            const u = r.getX(n),
                                                d = r.getX(n + 1),
                                                p = r.getX(n + 2);
                                            s = Ms(this, i, t, os, o, a, l, c, h, u, d, p), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                                        } else if (void 0 !== o)
                                            if (Array.isArray(i))
                                                for (let n = 0, r = u.length; n < r; n++) {
                                                    const r = u[n],
                                                        p = i[r.materialIndex];
                                                    for (let n = Math.max(r.start, d.start), i = Math.min(r.start + r.count, d.start + d.count); n < i; n += 3) s = Ms(this, p, t, os, o, a, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, e.push(s))
                                                } else
                                                    for (let n = Math.max(0, d.start), r = Math.min(o.count, d.start + d.count); n < r; n += 3) s = Ms(this, i, t, os, o, a, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                        } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }

                function Ms(t, e, n, i, r, s, o, a, l, c, h, u) {
                    ls.fromBufferAttribute(r, c), cs.fromBufferAttribute(r, h), hs.fromBufferAttribute(r, u);
                    const d = t.morphTargetInfluences;
                    if (e.morphTargets && s && d) {
                        ms.set(0, 0, 0), fs.set(0, 0, 0), gs.set(0, 0, 0);
                        for (let t = 0, e = s.length; t < e; t++) {
                            const e = d[t],
                                n = s[t];
                            0 !== e && (us.fromBufferAttribute(n, c), ds.fromBufferAttribute(n, h), ps.fromBufferAttribute(n, u), o ? (ms.addScaledVector(us, e), fs.addScaledVector(ds, e), gs.addScaledVector(ps, e)) : (ms.addScaledVector(us.sub(ls), e), fs.addScaledVector(ds.sub(cs), e), gs.addScaledVector(ps.sub(hs), e)))
                        }
                        ls.add(ms), cs.add(fs), hs.add(gs)
                    }
                    t.isSkinnedMesh && (t.boneTransform(c, ls), t.boneTransform(h, cs), t.boneTransform(u, hs));
                    const p = function(t, e, n, i, r, s, o, a) {
                        let l;
                        if (l = e.side === x ? i.intersectTriangle(o, s, r, !0, a) : i.intersectTriangle(r, s, o, e.side !== _, a), null === l) return null;
                        bs.copy(a), bs.applyMatrix4(t.matrixWorld);
                        const c = n.ray.origin.distanceTo(bs);
                        return c < n.near || c > n.far ? null : { distance: c, point: bs.clone(), object: t }
                    }(t, e, n, i, ls, cs, hs, _s);
                    if (p) {
                        a && (vs.fromBufferAttribute(a, c), ys.fromBufferAttribute(a, h), xs.fromBufferAttribute(a, u), p.uv = Sr.getUV(_s, ls, cs, hs, vs, ys, xs, new $n)), l && (vs.fromBufferAttribute(l, c), ys.fromBufferAttribute(l, h), xs.fromBufferAttribute(l, u), p.uv2 = Sr.getUV(_s, ls, cs, hs, vs, ys, xs, new $n));
                        const t = { a: c, b: h, c: u, normal: new ui, materialIndex: 0 };
                        Sr.getNormal(ls, cs, hs, t.normal), p.face = t
                    }
                    return p
                }
                ws.prototype.isMesh = !0;
                class Ss extends rs {
                    constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
                        super(), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: n, widthSegments: i, heightSegments: r, depthSegments: s };
                        const o = this;
                        i = Math.floor(i), r = Math.floor(r), s = Math.floor(s);
                        const a = [],
                            l = [],
                            c = [],
                            h = [];
                        let u = 0,
                            d = 0;

                        function p(t, e, n, i, r, s, p, m, f, g, v) {
                            const y = s / f,
                                x = p / g,
                                _ = s / 2,
                                b = p / 2,
                                w = m / 2,
                                M = f + 1,
                                S = g + 1;
                            let T = 0,
                                E = 0;
                            const A = new ui;
                            for (let s = 0; s < S; s++) {
                                const o = s * x - b;
                                for (let a = 0; a < M; a++) {
                                    const u = a * y - _;
                                    A[t] = u * i, A[e] = o * r, A[n] = w, l.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = m > 0 ? 1 : -1, c.push(A.x, A.y, A.z), h.push(a / f), h.push(1 - s / g), T += 1
                                }
                            }
                            for (let t = 0; t < g; t++)
                                for (let e = 0; e < f; e++) {
                                    const n = u + e + M * t,
                                        i = u + e + M * (t + 1),
                                        r = u + (e + 1) + M * (t + 1),
                                        s = u + (e + 1) + M * t;
                                    a.push(n, i, s), a.push(i, r, s), E += 6
                                }
                            o.addGroup(d, E, v), d += E, u += T
                        }
                        p("z", "y", "x", -1, -1, n, e, t, s, r, 0), p("z", "y", "x", 1, -1, n, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, s, 2), p("x", "z", "y", 1, -1, t, n, -e, i, s, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new qr(l, 3)), this.setAttribute("normal", new qr(c, 3)), this.setAttribute("uv", new qr(h, 2))
                    }
                    static fromJSON(t) { return new Ss(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments) }
                }

                function Ts(t) {
                    const e = {};
                    for (const n in t) {
                        e[n] = {};
                        for (const i in t[n]) {
                            const r = t[n][i];
                            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                        }
                    }
                    return e
                }

                function Es(t) { const e = {}; for (let n = 0; n < t.length; n++) { const i = Ts(t[n]); for (const t in i) e[t] = i[t] } return e }
                const As = { clone: Ts, merge: Es };
                class Ls extends Er {
                    constructor(t) { super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t)) }
                    copy(t) { return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Ts(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        e.glslVersion = this.glslVersion, e.uniforms = {};
                        for (const n in this.uniforms) {
                            const i = this.uniforms[n].value;
                            i && i.isTexture ? e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid } : i && i.isColor ? e.uniforms[n] = { type: "c", value: i.getHex() } : i && i.isVector2 ? e.uniforms[n] = { type: "v2", value: i.toArray() } : i && i.isVector3 ? e.uniforms[n] = { type: "v3", value: i.toArray() } : i && i.isVector4 ? e.uniforms[n] = { type: "v4", value: i.toArray() } : i && i.isMatrix3 ? e.uniforms[n] = { type: "m3", value: i.toArray() } : i && i.isMatrix4 ? e.uniforms[n] = { type: "m4", value: i.toArray() } : e.uniforms[n] = { value: i }
                        }
                        Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                        const n = {};
                        for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
                        return Object.keys(n).length > 0 && (e.extensions = n), e
                    }
                }
                Ls.prototype.isShaderMaterial = !0;
                class Rs extends pr {
                    constructor() { super(), this.type = "Camera", this.matrixWorldInverse = new Gi, this.projectionMatrix = new Gi, this.projectionMatrixInverse = new Gi }
                    copy(t, e) { return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this }
                    getWorldDirection(t) { this.updateWorldMatrix(!0, !1); const e = this.matrixWorld.elements; return t.set(-e[8], -e[9], -e[10]).normalize() }
                    updateMatrixWorld(t) { super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert() }
                    updateWorldMatrix(t, e) { super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert() }
                    clone() { return (new this.constructor).copy(this) }
                }
                Rs.prototype.isCamera = !0;
                class Cs extends Rs {
                    constructor(t = 50, e = 1, n = .1, i = 2e3) { super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() }
                    copy(t, e) { return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this }
                    setFocalLength(t) {
                        const e = .5 * this.getFilmHeight() / t;
                        this.fov = 2 * Wn * Math.atan(e), this.updateProjectionMatrix()
                    }
                    getFocalLength() { const t = Math.tan(.5 * Vn * this.fov); return .5 * this.getFilmHeight() / t }
                    getEffectiveFOV() { return 2 * Wn * Math.atan(Math.tan(.5 * Vn * this.fov) / this.zoom) }
                    getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) }
                    getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) }
                    setViewOffset(t, e, n, i, r, s) { this.aspect = t / e, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix() }
                    clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }
                    updateProjectionMatrix() {
                        const t = this.near;
                        let e = t * Math.tan(.5 * Vn * this.fov) / this.zoom,
                            n = 2 * e,
                            i = this.aspect * n,
                            r = -.5 * i;
                        const s = this.view;
                        if (null !== this.view && this.view.enabled) {
                            const t = s.fullWidth,
                                o = s.fullHeight;
                            r += s.offsetX * i / t, e -= s.offsetY * n / o, i *= s.width / t, n *= s.height / o
                        }
                        const o = this.filmOffset;
                        0 !== o && (r += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(t) { const e = super.toJSON(t); return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e }
                }
                Cs.prototype.isPerspectiveCamera = !0;
                const Ps = 90;
                class Is extends pr {
                    constructor(t, e, n) {
                        if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                        this.renderTarget = n;
                        const i = new Cs(Ps, 1, t, e);
                        i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new ui(1, 0, 0)), this.add(i);
                        const r = new Cs(Ps, 1, t, e);
                        r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new ui(-1, 0, 0)), this.add(r);
                        const s = new Cs(Ps, 1, t, e);
                        s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new ui(0, 1, 0)), this.add(s);
                        const o = new Cs(Ps, 1, t, e);
                        o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new ui(0, -1, 0)), this.add(o);
                        const a = new Cs(Ps, 1, t, e);
                        a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new ui(0, 0, 1)), this.add(a);
                        const l = new Cs(Ps, 1, t, e);
                        l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new ui(0, 0, -1)), this.add(l)
                    }
                    update(t, e) {
                        null === this.parent && this.updateMatrixWorld();
                        const n = this.renderTarget,
                            [i, r, s, o, a, l] = this.children,
                            c = t.xr.enabled,
                            h = t.getRenderTarget();
                        t.xr.enabled = !1;
                        const u = n.texture.generateMipmaps;
                        n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, o), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = u, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(h), t.xr.enabled = c
                    }
                }
                class Ds extends ri {
                    constructor(t, e, n, i, r, s, o, a, l, c) { super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : ct, n, i, r, s, o = void 0 !== o ? o : kt, a, l, c), this._needsFlipEnvMap = !0, this.flipY = !1 }
                    get images() { return this.image }
                    set images(t) { this.image = t }
                }
                Ds.prototype.isCubeTexture = !0;
                class Ns extends ai {
                    constructor(t, e, n) { Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new Ds(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : Mt, this.texture._needsFlipEnvMap = !1 }
                    fromEquirectangularTexture(t, e) {
                        this.texture.type = e.type, this.texture.format = Gt, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                        const n = { tEquirect: { value: null } },
                            i = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                            r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                            s = new Ss(5, 5, 5),
                            o = new Ls({ name: "CubemapFromEquirect", uniforms: Ts(n), vertexShader: i, fragmentShader: r, side: x, blending: M });
                        o.uniforms.tEquirect.value = e;
                        const a = new ws(s, o),
                            l = e.minFilter;
                        return e.minFilter === Et && (e.minFilter = Mt), new Is(1, 10, this).update(t, a), e.minFilter = l, a.geometry.dispose(), a.material.dispose(), this
                    }
                    clear(t, e, n, i) {
                        const r = t.getRenderTarget();
                        for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
                        t.setRenderTarget(r)
                    }
                }
                Ns.prototype.isWebGLCubeRenderTarget = !0;
                const Bs = new ui,
                    Os = new ui,
                    Fs = new ti;
                class zs {
                    constructor(t = new ui(1, 0, 0), e = 0) { this.normal = t, this.constant = e }
                    set(t, e) { return this.normal.copy(t), this.constant = e, this }
                    setComponents(t, e, n, i) { return this.normal.set(t, e, n), this.constant = i, this }
                    setFromNormalAndCoplanarPoint(t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this }
                    setFromCoplanarPoints(t, e, n) { const i = Bs.subVectors(n, e).cross(Os.subVectors(t, e)).normalize(); return this.setFromNormalAndCoplanarPoint(i, t), this }
                    copy(t) { return this.normal.copy(t.normal), this.constant = t.constant, this }
                    normalize() { const t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this }
                    negate() { return this.constant *= -1, this.normal.negate(), this }
                    distanceToPoint(t) { return this.normal.dot(t) + this.constant }
                    distanceToSphere(t) { return this.distanceToPoint(t.center) - t.radius }
                    projectPoint(t, e) { return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t) }
                    intersectLine(t, e) {
                        const n = t.delta(Bs),
                            i = this.normal.dot(n);
                        if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                        const r = -(t.start.dot(this.normal) + this.constant) / i;
                        return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start)
                    }
                    intersectsLine(t) {
                        const e = this.distanceToPoint(t.start),
                            n = this.distanceToPoint(t.end);
                        return e < 0 && n > 0 || n < 0 && e > 0
                    }
                    intersectsBox(t) { return t.intersectsPlane(this) }
                    intersectsSphere(t) { return t.intersectsPlane(this) }
                    coplanarPoint(t) { return t.copy(this.normal).multiplyScalar(-this.constant) }
                    applyMatrix4(t, e) {
                        const n = e || Fs.getNormalMatrix(t),
                            i = this.coplanarPoint(Bs).applyMatrix4(t),
                            r = this.normal.applyMatrix3(n).normalize();
                        return this.constant = -i.dot(r), this
                    }
                    translate(t) { return this.constant -= t.dot(this.normal), this }
                    equals(t) { return t.normal.equals(this.normal) && t.constant === this.constant }
                    clone() { return (new this.constructor).copy(this) }
                }
                zs.prototype.isPlane = !0;
                const Us = new Di,
                    Hs = new ui;
                class ks {
                    constructor(t = new zs, e = new zs, n = new zs, i = new zs, r = new zs, s = new zs) { this.planes = [t, e, n, i, r, s] }
                    set(t, e, n, i, r, s) { const o = this.planes; return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(s), this }
                    copy(t) { const e = this.planes; for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]); return this }
                    setFromProjectionMatrix(t) {
                        const e = this.planes,
                            n = t.elements,
                            i = n[0],
                            r = n[1],
                            s = n[2],
                            o = n[3],
                            a = n[4],
                            l = n[5],
                            c = n[6],
                            h = n[7],
                            u = n[8],
                            d = n[9],
                            p = n[10],
                            m = n[11],
                            f = n[12],
                            g = n[13],
                            v = n[14],
                            y = n[15];
                        return e[0].setComponents(o - i, h - a, m - u, y - f).normalize(), e[1].setComponents(o + i, h + a, m + u, y + f).normalize(), e[2].setComponents(o + r, h + l, m + d, y + g).normalize(), e[3].setComponents(o - r, h - l, m - d, y - g).normalize(), e[4].setComponents(o - s, h - c, m - p, y - v).normalize(), e[5].setComponents(o + s, h + c, m + p, y + v).normalize(), this
                    }
                    intersectsObject(t) { const e = t.geometry; return null === e.boundingSphere && e.computeBoundingSphere(), Us.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Us) }
                    intersectsSprite(t) { return Us.center.set(0, 0, 0), Us.radius = .7071067811865476, Us.applyMatrix4(t.matrixWorld), this.intersectsSphere(Us) }
                    intersectsSphere(t) {
                        const e = this.planes,
                            n = t.center,
                            i = -t.radius;
                        for (let t = 0; t < 6; t++)
                            if (e[t].distanceToPoint(n) < i) return !1;
                        return !0
                    }
                    intersectsBox(t) { const e = this.planes; for (let n = 0; n < 6; n++) { const i = e[n]; if (Hs.x = i.normal.x > 0 ? t.max.x : t.min.x, Hs.y = i.normal.y > 0 ? t.max.y : t.min.y, Hs.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(Hs) < 0) return !1 } return !0 }
                    containsPoint(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++)
                            if (e[n].distanceToPoint(t) < 0) return !1;
                        return !0
                    }
                    clone() { return (new this.constructor).copy(this) }
                }

                function Gs() {
                    let t = null,
                        e = !1,
                        n = null,
                        i = null;

                    function r(e, s) { n(e, s), i = t.requestAnimationFrame(r) }
                    return { start: function() {!0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0) }, stop: function() { t.cancelAnimationFrame(i), e = !1 }, setAnimationLoop: function(t) { n = t }, setContext: function(e) { t = e } }
                }

                function Vs(t, e) {
                    const n = e.isWebGL2,
                        i = new WeakMap;
                    return {
                        get: function(t) { return t.isInterleavedBufferAttribute && (t = t.data), i.get(t) },
                        remove: function(e) {
                            e.isInterleavedBufferAttribute && (e = e.data);
                            const n = i.get(e);
                            n && (t.deleteBuffer(n.buffer), i.delete(e))
                        },
                        update: function(e, r) {
                            if (e.isGLBufferAttribute) { const t = i.get(e); return void((!t || t.version < e.version) && i.set(e, { buffer: e.buffer, type: e.type, bytesPerElement: e.elementSize, version: e.version })) }
                            e.isInterleavedBufferAttribute && (e = e.data);
                            const s = i.get(e);
                            void 0 === s ? i.set(e, function(e, i) {
                                const r = e.array,
                                    s = e.usage,
                                    o = t.createBuffer();
                                t.bindBuffer(i, o), t.bufferData(i, r, s), e.onUploadCallback();
                                let a = 5126;
                                return r instanceof Float32Array ? a = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : (r instanceof Uint8Array || r instanceof Uint8ClampedArray) && (a = 5121), { buffer: o, type: a, bytesPerElement: r.BYTES_PER_ELEMENT, version: e.version }
                            }(e, r)) : s.version < e.version && (function(e, i, r) {
                                const s = i.array,
                                    o = i.updateRange;
                                t.bindBuffer(r, e), -1 === o.count ? t.bufferSubData(r, 0, s) : (n ? t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)), o.count = -1)
                            }(s.buffer, e, r), s.version = e.version)
                        }
                    }
                }
                class Ws extends rs {
                    constructor(t = 1, e = 1, n = 1, i = 1) {
                        super(), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i };
                        const r = t / 2,
                            s = e / 2,
                            o = Math.floor(n),
                            a = Math.floor(i),
                            l = o + 1,
                            c = a + 1,
                            h = t / o,
                            u = e / a,
                            d = [],
                            p = [],
                            m = [],
                            f = [];
                        for (let t = 0; t < c; t++) {
                            const e = t * u - s;
                            for (let n = 0; n < l; n++) {
                                const i = n * h - r;
                                p.push(i, -e, 0), m.push(0, 0, 1), f.push(n / o), f.push(1 - t / a)
                            }
                        }
                        for (let t = 0; t < a; t++)
                            for (let e = 0; e < o; e++) {
                                const n = e + l * t,
                                    i = e + l * (t + 1),
                                    r = e + 1 + l * (t + 1),
                                    s = e + 1 + l * t;
                                d.push(n, i, s), d.push(i, r, s)
                            }
                        this.setIndex(d), this.setAttribute("position", new qr(p, 3)), this.setAttribute("normal", new qr(m, 3)), this.setAttribute("uv", new qr(f, 2))
                    }
                    static fromJSON(t) { return new Ws(t.width, t.height, t.widthSegments, t.heightSegments) }
                }
                const js = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotVH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSNMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n\t\tnormal, v, roughnessFactor, material.diffuseColor, totalSpecular,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform vec3 attenuationColor;\n\tuniform float attenuationDistance;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" },
                    qs = { common: { diffuse: { value: new Dr(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new ti }, uv2Transform: { value: new ti }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new $n(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Dr(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Dr(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new ti } }, sprite: { diffuse: { value: new Dr(16777215) }, opacity: { value: 1 }, center: { value: new $n(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new ti } } },
                    Xs = { basic: { uniforms: Es([qs.common, qs.specularmap, qs.envmap, qs.aomap, qs.lightmap, qs.fog]), vertexShader: js.meshbasic_vert, fragmentShader: js.meshbasic_frag }, lambert: { uniforms: Es([qs.common, qs.specularmap, qs.envmap, qs.aomap, qs.lightmap, qs.emissivemap, qs.fog, qs.lights, { emissive: { value: new Dr(0) } }]), vertexShader: js.meshlambert_vert, fragmentShader: js.meshlambert_frag }, phong: { uniforms: Es([qs.common, qs.specularmap, qs.envmap, qs.aomap, qs.lightmap, qs.emissivemap, qs.bumpmap, qs.normalmap, qs.displacementmap, qs.fog, qs.lights, { emissive: { value: new Dr(0) }, specular: { value: new Dr(1118481) }, shininess: { value: 30 } }]), vertexShader: js.meshphong_vert, fragmentShader: js.meshphong_frag }, standard: { uniforms: Es([qs.common, qs.envmap, qs.aomap, qs.lightmap, qs.emissivemap, qs.bumpmap, qs.normalmap, qs.displacementmap, qs.roughnessmap, qs.metalnessmap, qs.fog, qs.lights, { emissive: { value: new Dr(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: js.meshphysical_vert, fragmentShader: js.meshphysical_frag }, toon: { uniforms: Es([qs.common, qs.aomap, qs.lightmap, qs.emissivemap, qs.bumpmap, qs.normalmap, qs.displacementmap, qs.gradientmap, qs.fog, qs.lights, { emissive: { value: new Dr(0) } }]), vertexShader: js.meshtoon_vert, fragmentShader: js.meshtoon_frag }, matcap: { uniforms: Es([qs.common, qs.bumpmap, qs.normalmap, qs.displacementmap, qs.fog, { matcap: { value: null } }]), vertexShader: js.meshmatcap_vert, fragmentShader: js.meshmatcap_frag }, points: { uniforms: Es([qs.points, qs.fog]), vertexShader: js.points_vert, fragmentShader: js.points_frag }, dashed: { uniforms: Es([qs.common, qs.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: js.linedashed_vert, fragmentShader: js.linedashed_frag }, depth: { uniforms: Es([qs.common, qs.displacementmap]), vertexShader: js.depth_vert, fragmentShader: js.depth_frag }, normal: { uniforms: Es([qs.common, qs.bumpmap, qs.normalmap, qs.displacementmap, { opacity: { value: 1 } }]), vertexShader: js.normal_vert, fragmentShader: js.normal_frag }, sprite: { uniforms: Es([qs.sprite, qs.fog]), vertexShader: js.sprite_vert, fragmentShader: js.sprite_frag }, background: { uniforms: { uvTransform: { value: new ti }, t2D: { value: null } }, vertexShader: js.background_vert, fragmentShader: js.background_frag }, cube: { uniforms: Es([qs.envmap, { opacity: { value: 1 } }]), vertexShader: js.cube_vert, fragmentShader: js.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: js.equirect_vert, fragmentShader: js.equirect_frag }, distanceRGBA: { uniforms: Es([qs.common, qs.displacementmap, { referencePosition: { value: new ui }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: js.distanceRGBA_vert, fragmentShader: js.distanceRGBA_frag }, shadow: { uniforms: Es([qs.lights, qs.fog, { color: { value: new Dr(0) }, opacity: { value: 1 } }]), vertexShader: js.shadow_vert, fragmentShader: js.shadow_frag } };

                function Ys(t, e, n, i, r) {
                    const s = new Dr(0);
                    let o, a, l = 0,
                        c = null,
                        h = 0,
                        u = null;

                    function d(t, e) { n.buffers.color.setClear(t.r, t.g, t.b, e, r) }
                    return {
                        getClearColor: function() { return s },
                        setClearColor: function(t, e = 1) { s.set(t), l = e, d(s, l) },
                        getClearAlpha: function() { return l },
                        setClearAlpha: function(t) { l = t, d(s, l) },
                        render: function(n, r) {
                            let p = !1,
                                m = !0 === r.isScene ? r.background : null;
                            m && m.isTexture && (m = e.get(m));
                            const f = t.xr,
                                g = f.getSession && f.getSession();
                            g && "additive" === g.environmentBlendMode && (m = null), null === m ? d(s, l) : m && m.isColor && (d(m, 1), p = !0), (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), m && (m.isCubeTexture || m.mapping === pt) ? (void 0 === a && (a = new ws(new Ss(1, 1, 1), new Ls({ name: "BackgroundCubeMaterial", uniforms: Ts(Xs.cube.uniforms), vertexShader: Xs.cube.vertexShader, fragmentShader: Xs.cube.fragmentShader, side: x, depthTest: !1, depthWrite: !1, fog: !1 })), a.geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function(t, e, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(a.material, "envMap", { get: function() { return this.uniforms.envMap.value } }), i.update(a)), a.material.uniforms.envMap.value = m, a.material.uniforms.flipEnvMap.value = m.isCubeTexture && m._needsFlipEnvMap ? -1 : 1, c === m && h === m.version && u === t.toneMapping || (a.material.needsUpdate = !0, c = m, h = m.version, u = t.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null)) : m && m.isTexture && (void 0 === o && (o = new ws(new Ws(2, 2), new Ls({ name: "BackgroundMaterial", uniforms: Ts(Xs.background.uniforms), vertexShader: Xs.background.vertexShader, fragmentShader: Xs.background.fragmentShader, side: y, depthTest: !1, depthWrite: !1, fog: !1 })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", { get: function() { return this.uniforms.t2D.value } }), i.update(o)), o.material.uniforms.t2D.value = m, !0 === m.matrixAutoUpdate && m.updateMatrix(), o.material.uniforms.uvTransform.value.copy(m.matrix), c === m && h === m.version && u === t.toneMapping || (o.material.needsUpdate = !0, c = m, h = m.version, u = t.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null))
                        }
                    }
                }

                function Zs(t, e, n, i) {
                    const r = t.getParameter(34921),
                        s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                        o = i.isWebGL2 || null !== s,
                        a = {},
                        l = d(null);
                    let c = l;

                    function h(e) { return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e) }

                    function u(e) { return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e) }

                    function d(t) {
                        const e = [],
                            n = [],
                            i = [];
                        for (let t = 0; t < r; t++) e[t] = 0, n[t] = 0, i[t] = 0;
                        return { geometry: null, program: null, wireframe: !1, newAttributes: e, enabledAttributes: n, attributeDivisors: i, object: t, attributes: {}, index: null }
                    }

                    function p() { const t = c.newAttributes; for (let e = 0, n = t.length; e < n; e++) t[e] = 0 }

                    function m(t) { f(t, 0) }

                    function f(n, r) {
                        const s = c.newAttributes,
                            o = c.enabledAttributes,
                            a = c.attributeDivisors;
                        s[n] = 1, 0 === o[n] && (t.enableVertexAttribArray(n), o[n] = 1), a[n] !== r && ((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), a[n] = r)
                    }

                    function g() {
                        const e = c.newAttributes,
                            n = c.enabledAttributes;
                        for (let i = 0, r = n.length; i < r; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0)
                    }

                    function v(e, n, r, s, o, a) {!0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, s, o, a) : t.vertexAttribIPointer(e, n, r, o, a) }

                    function y() { x(), c !== l && (c = l, h(c.object)) }

                    function x() { l.geometry = null, l.program = null, l.wireframe = !1 }
                    return {
                        setup: function(r, l, u, y, x) {
                            let _ = !1;
                            if (o) {
                                const e = function(e, n, r) {
                                    const o = !0 === r.wireframe;
                                    let l = a[e.id];
                                    void 0 === l && (l = {}, a[e.id] = l);
                                    let c = l[n.id];
                                    void 0 === c && (c = {}, l[n.id] = c);
                                    let h = c[o];
                                    return void 0 === h && (h = d(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()), c[o] = h), h
                                }(y, u, l);
                                c !== e && (c = e, h(c.object)), _ = function(t, e) {
                                    const n = c.attributes,
                                        i = t.attributes;
                                    let r = 0;
                                    for (const t in i) {
                                        const e = n[t],
                                            s = i[t];
                                        if (void 0 === e) return !0;
                                        if (e.attribute !== s) return !0;
                                        if (e.data !== s.data) return !0;
                                        r++
                                    }
                                    return c.attributesNum !== r || c.index !== e
                                }(y, x), _ && function(t, e) {
                                    const n = {},
                                        i = t.attributes;
                                    let r = 0;
                                    for (const t in i) {
                                        const e = i[t],
                                            s = {};
                                        s.attribute = e, e.data && (s.data = e.data), n[t] = s, r++
                                    }
                                    c.attributes = n, c.attributesNum = r, c.index = e
                                }(y, x)
                            } else {
                                const t = !0 === l.wireframe;
                                c.geometry === y.id && c.program === u.id && c.wireframe === t || (c.geometry = y.id, c.program = u.id, c.wireframe = t, _ = !0)
                            }!0 === r.isInstancedMesh && (_ = !0), null !== x && n.update(x, 34963), _ && (function(r, s, o, a) {
                                if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                                p();
                                const l = a.attributes,
                                    c = o.getAttributes(),
                                    h = s.defaultAttributeValues;
                                for (const e in c) {
                                    const i = c[e];
                                    if (i >= 0) {
                                        const s = l[e];
                                        if (void 0 !== s) {
                                            const e = s.normalized,
                                                r = s.itemSize,
                                                o = n.get(s);
                                            if (void 0 === o) continue;
                                            const l = o.buffer,
                                                c = o.type,
                                                h = o.bytesPerElement;
                                            if (s.isInterleavedBufferAttribute) {
                                                const n = s.data,
                                                    o = n.stride,
                                                    u = s.offset;
                                                n && n.isInstancedInterleavedBuffer ? (f(i, n.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)) : m(i), t.bindBuffer(34962, l), v(i, r, c, e, o * h, u * h)
                                            } else s.isInstancedBufferAttribute ? (f(i, s.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count)) : m(i), t.bindBuffer(34962, l), v(i, r, c, e, 0, 0)
                                        } else if ("instanceMatrix" === e) {
                                            const e = n.get(r.instanceMatrix);
                                            if (void 0 === e) continue;
                                            const s = e.buffer,
                                                o = e.type;
                                            f(i + 0, 1), f(i + 1, 1), f(i + 2, 1), f(i + 3, 1), t.bindBuffer(34962, s), t.vertexAttribPointer(i + 0, 4, o, !1, 64, 0), t.vertexAttribPointer(i + 1, 4, o, !1, 64, 16), t.vertexAttribPointer(i + 2, 4, o, !1, 64, 32), t.vertexAttribPointer(i + 3, 4, o, !1, 64, 48)
                                        } else if ("instanceColor" === e) {
                                            const e = n.get(r.instanceColor);
                                            if (void 0 === e) continue;
                                            const s = e.buffer,
                                                o = e.type;
                                            f(i, 1), t.bindBuffer(34962, s), t.vertexAttribPointer(i, 3, o, !1, 12, 0)
                                        } else if (void 0 !== h) {
                                            const n = h[e];
                                            if (void 0 !== n) switch (n.length) {
                                                case 2:
                                                    t.vertexAttrib2fv(i, n);
                                                    break;
                                                case 3:
                                                    t.vertexAttrib3fv(i, n);
                                                    break;
                                                case 4:
                                                    t.vertexAttrib4fv(i, n);
                                                    break;
                                                default:
                                                    t.vertexAttrib1fv(i, n)
                                            }
                                        }
                                    }
                                }
                                g()
                            }(r, l, u, y), null !== x && t.bindBuffer(34963, n.get(x).buffer))
                        },
                        reset: y,
                        resetDefaultState: x,
                        dispose: function() {
                            y();
                            for (const t in a) {
                                const e = a[t];
                                for (const t in e) {
                                    const n = e[t];
                                    for (const t in n) u(n[t].object), delete n[t];
                                    delete e[t]
                                }
                                delete a[t]
                            }
                        },
                        releaseStatesOfGeometry: function(t) {
                            if (void 0 === a[t.id]) return;
                            const e = a[t.id];
                            for (const t in e) {
                                const n = e[t];
                                for (const t in n) u(n[t].object), delete n[t];
                                delete e[t]
                            }
                            delete a[t.id]
                        },
                        releaseStatesOfProgram: function(t) {
                            for (const e in a) {
                                const n = a[e];
                                if (void 0 === n[t.id]) continue;
                                const i = n[t.id];
                                for (const t in i) u(i[t].object), delete i[t];
                                delete n[t.id]
                            }
                        },
                        initAttributes: p,
                        enableAttribute: m,
                        disableUnusedAttributes: g
                    }
                }

                function Js(t, e, n, i) {
                    const r = i.isWebGL2;
                    let s;
                    this.setMode = function(t) { s = t }, this.render = function(e, i) { t.drawArrays(s, e, i), n.update(i, s, 1) }, this.renderInstances = function(i, o, a) {
                        if (0 === a) return;
                        let l, c;
                        if (r) l = t, c = "drawArraysInstanced";
                        else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        l[c](s, i, o, a), n.update(o, s, a)
                    }
                }

                function Ks(t, e, n) {
                    let i;

                    function r(e) {
                        if ("highp" === e) {
                            if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                            e = "mediump"
                        }
                        return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                    }
                    const s = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
                    let o = void 0 !== n.precision ? n.precision : "highp";
                    const a = r(o);
                    a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a);
                    const l = s || e.has("WEBGL_draw_buffers"),
                        c = !0 === n.logarithmicDepthBuffer,
                        h = t.getParameter(34930),
                        u = t.getParameter(35660),
                        d = t.getParameter(3379),
                        p = t.getParameter(34076),
                        m = t.getParameter(34921),
                        f = t.getParameter(36347),
                        g = t.getParameter(36348),
                        v = t.getParameter(36349),
                        y = u > 0,
                        x = s || e.has("OES_texture_float");
                    return {
                        isWebGL2: s,
                        drawBuffers: l,
                        getMaxAnisotropy: function() {
                            if (void 0 !== i) return i;
                            if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                                const n = e.get("EXT_texture_filter_anisotropic");
                                i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                            } else i = 0;
                            return i
                        },
                        getMaxPrecision: r,
                        precision: o,
                        logarithmicDepthBuffer: c,
                        maxTextures: h,
                        maxVertexTextures: u,
                        maxTextureSize: d,
                        maxCubemapSize: p,
                        maxAttributes: m,
                        maxVertexUniforms: f,
                        maxVaryings: g,
                        maxFragmentUniforms: v,
                        vertexTextures: y,
                        floatFragmentTextures: x,
                        floatVertexTextures: y && x,
                        maxSamples: s ? t.getParameter(36183) : 0
                    }
                }

                function Qs(t) {
                    const e = this;
                    let n = null,
                        i = 0,
                        r = !1,
                        s = !1;
                    const o = new zs,
                        a = new ti,
                        l = { value: null, needsUpdate: !1 };

                    function c() { l.value !== n && (l.value = n, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0 }

                    function h(t, n, i, r) {
                        const s = null !== t ? t.length : 0;
                        let c = null;
                        if (0 !== s) {
                            if (c = l.value, !0 !== r || null === c) {
                                const e = i + 4 * s,
                                    r = n.matrixWorldInverse;
                                a.getNormalMatrix(r), (null === c || c.length < e) && (c = new Float32Array(e));
                                for (let e = 0, n = i; e !== s; ++e, n += 4) o.copy(t[e]).applyMatrix4(r, a), o.normal.toArray(c, n), c[n + 3] = o.constant
                            }
                            l.value = c, l.needsUpdate = !0
                        }
                        return e.numPlanes = s, e.numIntersection = 0, c
                    }
                    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e, s) { const o = 0 !== t.length || e || 0 !== i || r; return r = e, n = h(t, s, 0), i = t.length, o }, this.beginShadows = function() { s = !0, h(null) }, this.endShadows = function() { s = !1, c() }, this.setState = function(e, o, a) {
                        const u = e.clippingPlanes,
                            d = e.clipIntersection,
                            p = e.clipShadows,
                            m = t.get(e);
                        if (!r || null === u || 0 === u.length || s && !p) s ? h(null) : c();
                        else {
                            const t = s ? 0 : i,
                                e = 4 * t;
                            let r = m.clippingState || null;
                            l.value = r, r = h(u, o, e, a);
                            for (let t = 0; t !== e; ++t) r[t] = n[t];
                            m.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                        }
                    }
                }

                function $s(t) {
                    let e = new WeakMap;

                    function n(t, e) { return e === ut ? t.mapping = ct : e === dt && (t.mapping = ht), t }

                    function i(t) {
                        const n = t.target;
                        n.removeEventListener("dispose", i);
                        const r = e.get(n);
                        void 0 !== r && (e.delete(n), r.dispose())
                    }
                    return {
                        get: function(r) {
                            if (r && r.isTexture) {
                                const s = r.mapping;
                                if (s === ut || s === dt) {
                                    if (e.has(r)) return n(e.get(r).texture, r.mapping); {
                                        const s = r.image;
                                        if (s && s.height > 0) {
                                            const o = t.getRenderTarget(),
                                                a = new Ns(s.height / 2);
                                            return a.fromEquirectangularTexture(t, r), e.set(r, a), t.setRenderTarget(o), r.addEventListener("dispose", i), n(a.texture, r.mapping)
                                        }
                                        return null
                                    }
                                }
                            }
                            return r
                        },
                        dispose: function() { e = new WeakMap }
                    }
                }

                function to(t) {
                    const e = {};

                    function n(n) {
                        if (void 0 !== e[n]) return e[n];
                        let i;
                        switch (n) {
                            case "WEBGL_depth_texture":
                                i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            default:
                                i = t.getExtension(n)
                        }
                        return e[n] = i, i
                    }
                    return { has: function(t) { return null !== n(t) }, init: function(t) { t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float") }, get: function(t) { const e = n(t); return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e } }
                }

                function eo(t, e, n, i) {
                    const r = {},
                        s = new WeakMap;

                    function o(t) {
                        const a = t.target;
                        null !== a.index && e.remove(a.index);
                        for (const t in a.attributes) e.remove(a.attributes[t]);
                        a.removeEventListener("dispose", o), delete r[a.id];
                        const l = s.get(a);
                        l && (e.remove(l), s.delete(a)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
                    }

                    function a(t) {
                        const n = [],
                            i = t.index,
                            r = t.attributes.position;
                        let o = 0;
                        if (null !== i) {
                            const t = i.array;
                            o = i.version;
                            for (let e = 0, i = t.length; e < i; e += 3) {
                                const i = t[e + 0],
                                    r = t[e + 1],
                                    s = t[e + 2];
                                n.push(i, r, r, s, s, i)
                            }
                        } else {
                            const t = r.array;
                            o = r.version;
                            for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                                const t = e + 0,
                                    i = e + 1,
                                    r = e + 2;
                                n.push(t, i, i, r, r, t)
                            }
                        }
                        const a = new(Yr(n) > 65535 ? Wr : Gr)(n, 1);
                        a.version = o;
                        const l = s.get(t);
                        l && e.remove(l), s.set(t, a)
                    }
                    return {
                        get: function(t, e) { return !0 === r[e.id] || (e.addEventListener("dispose", o), r[e.id] = !0, n.memory.geometries++), e },
                        update: function(t) { const n = t.attributes; for (const t in n) e.update(n[t], 34962); const i = t.morphAttributes; for (const t in i) { const n = i[t]; for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962) } },
                        getWireframeAttribute: function(t) {
                            const e = s.get(t);
                            if (e) {
                                const n = t.index;
                                null !== n && e.version < n.version && a(t)
                            } else a(t);
                            return s.get(t)
                        }
                    }
                }

                function no(t, e, n, i) {
                    const r = i.isWebGL2;
                    let s, o, a;
                    this.setMode = function(t) { s = t }, this.setIndex = function(t) { o = t.type, a = t.bytesPerElement }, this.render = function(e, i) { t.drawElements(s, i, o, e * a), n.update(i, s, 1) }, this.renderInstances = function(i, l, c) {
                        if (0 === c) return;
                        let h, u;
                        if (r) h = t, u = "drawElementsInstanced";
                        else if (h = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        h[u](s, l, o, i * a, c), n.update(l, s, c)
                    }
                }

                function io(t) {
                    const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
                    return {
                        memory: { geometries: 0, textures: 0 },
                        render: e,
                        programs: null,
                        autoReset: !0,
                        reset: function() { e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0 },
                        update: function(t, n, i) {
                            switch (e.calls++, n) {
                                case 4:
                                    e.triangles += i * (t / 3);
                                    break;
                                case 1:
                                    e.lines += i * (t / 2);
                                    break;
                                case 3:
                                    e.lines += i * (t - 1);
                                    break;
                                case 2:
                                    e.lines += i * t;
                                    break;
                                case 0:
                                    e.points += i * t;
                                    break;
                                default:
                                    console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                            }
                        }
                    }
                }

                function ro(t, e) { return t[0] - e[0] }

                function so(t, e) { return Math.abs(e[1]) - Math.abs(t[1]) }

                function oo(t) {
                    const e = {},
                        n = new Float32Array(8),
                        i = [];
                    for (let t = 0; t < 8; t++) i[t] = [t, 0];
                    return {
                        update: function(r, s, o, a) {
                            const l = r.morphTargetInfluences,
                                c = void 0 === l ? 0 : l.length;
                            let h = e[s.id];
                            if (void 0 === h || h.length !== c) {
                                h = [];
                                for (let t = 0; t < c; t++) h[t] = [t, 0];
                                e[s.id] = h
                            }
                            for (let t = 0; t < c; t++) {
                                const e = h[t];
                                e[0] = t, e[1] = l[t]
                            }
                            h.sort(so);
                            for (let t = 0; t < 8; t++) t < c && h[t][1] ? (i[t][0] = h[t][0], i[t][1] = h[t][1]) : (i[t][0] = Number.MAX_SAFE_INTEGER, i[t][1] = 0);
                            i.sort(ro);
                            const u = o.morphTargets && s.morphAttributes.position,
                                d = o.morphNormals && s.morphAttributes.normal;
                            let p = 0;
                            for (let t = 0; t < 8; t++) {
                                const e = i[t],
                                    r = e[0],
                                    o = e[1];
                                r !== Number.MAX_SAFE_INTEGER && o ? (u && s.getAttribute("morphTarget" + t) !== u[r] && s.setAttribute("morphTarget" + t, u[r]), d && s.getAttribute("morphNormal" + t) !== d[r] && s.setAttribute("morphNormal" + t, d[r]), n[t] = o, p += o) : (u && !0 === s.hasAttribute("morphTarget" + t) && s.deleteAttribute("morphTarget" + t), d && !0 === s.hasAttribute("morphNormal" + t) && s.deleteAttribute("morphNormal" + t), n[t] = 0)
                            }
                            const m = s.morphTargetsRelative ? 1 : 1 - p;
                            a.getUniforms().setValue(t, "morphTargetBaseInfluence", m), a.getUniforms().setValue(t, "morphTargetInfluences", n)
                        }
                    }
                }

                function ao(t, e, n, i) {
                    let r = new WeakMap;

                    function s(t) {
                        const e = t.target;
                        e.removeEventListener("dispose", s), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
                    }
                    return {
                        update: function(t) {
                            const o = i.render.frame,
                                a = t.geometry,
                                l = e.get(t, a);
                            return r.get(l) !== o && (e.update(l), r.set(l, o)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s) && t.addEventListener("dispose", s), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), l
                        },
                        dispose: function() { r = new WeakMap }
                    }
                }
                Xs.physical = { uniforms: Es([Xs.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new $n(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new Dr(0) }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new $n }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Dr(0) } }]), vertexShader: js.meshphysical_vert, fragmentShader: js.meshphysical_frag };
                class lo extends ri { constructor(t = null, e = 1, n = 1, i = 1) { super(null), this.image = { data: t, width: e, height: n, depth: i }, this.magFilter = yt, this.minFilter = yt, this.wrapR = gt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } }
                lo.prototype.isDataTexture2DArray = !0;
                class co extends ri { constructor(t = null, e = 1, n = 1, i = 1) { super(null), this.image = { data: t, width: e, height: n, depth: i }, this.magFilter = yt, this.minFilter = yt, this.wrapR = gt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } }
                co.prototype.isDataTexture3D = !0;
                const ho = new ri,
                    uo = new lo,
                    po = new co,
                    mo = new Ds,
                    fo = [],
                    go = [],
                    vo = new Float32Array(16),
                    yo = new Float32Array(9),
                    xo = new Float32Array(4);

                function _o(t, e, n) { const i = t[0]; if (i <= 0 || i > 0) return t; const r = e * n; let s = fo[r]; if (void 0 === s && (s = new Float32Array(r), fo[r] = s), 0 !== e) { i.toArray(s, 0); for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(s, r) } return s }

                function bo(t, e) {
                    if (t.length !== e.length) return !1;
                    for (let n = 0, i = t.length; n < i; n++)
                        if (t[n] !== e[n]) return !1;
                    return !0
                }

                function wo(t, e) { for (let n = 0, i = e.length; n < i; n++) t[n] = e[n] }

                function Mo(t, e) {
                    let n = go[e];
                    void 0 === n && (n = new Int32Array(e), go[e] = n);
                    for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
                    return n
                }

                function So(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
                }

                function To(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                    else {
                        if (bo(n, e)) return;
                        t.uniform2fv(this.addr, e), wo(n, e)
                    }
                }

                function Eo(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                    else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
                    else {
                        if (bo(n, e)) return;
                        t.uniform3fv(this.addr, e), wo(n, e)
                    }
                }

                function Ao(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                    else {
                        if (bo(n, e)) return;
                        t.uniform4fv(this.addr, e), wo(n, e)
                    }
                }

                function Lo(t, e) {
                    const n = this.cache,
                        i = e.elements;
                    if (void 0 === i) {
                        if (bo(n, e)) return;
                        t.uniformMatrix2fv(this.addr, !1, e), wo(n, e)
                    } else {
                        if (bo(n, i)) return;
                        xo.set(i), t.uniformMatrix2fv(this.addr, !1, xo), wo(n, i)
                    }
                }

                function Ro(t, e) {
                    const n = this.cache,
                        i = e.elements;
                    if (void 0 === i) {
                        if (bo(n, e)) return;
                        t.uniformMatrix3fv(this.addr, !1, e), wo(n, e)
                    } else {
                        if (bo(n, i)) return;
                        yo.set(i), t.uniformMatrix3fv(this.addr, !1, yo), wo(n, i)
                    }
                }

                function Co(t, e) {
                    const n = this.cache,
                        i = e.elements;
                    if (void 0 === i) {
                        if (bo(n, e)) return;
                        t.uniformMatrix4fv(this.addr, !1, e), wo(n, e)
                    } else {
                        if (bo(n, i)) return;
                        vo.set(i), t.uniformMatrix4fv(this.addr, !1, vo), wo(n, i)
                    }
                }

                function Po(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
                }

                function Io(t, e) {
                    const n = this.cache;
                    bo(n, e) || (t.uniform2iv(this.addr, e), wo(n, e))
                }

                function Do(t, e) {
                    const n = this.cache;
                    bo(n, e) || (t.uniform3iv(this.addr, e), wo(n, e))
                }

                function No(t, e) {
                    const n = this.cache;
                    bo(n, e) || (t.uniform4iv(this.addr, e), wo(n, e))
                }

                function Bo(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
                }

                function Oo(t, e) {
                    const n = this.cache;
                    bo(n, e) || (t.uniform2uiv(this.addr, e), wo(n, e))
                }

                function Fo(t, e) {
                    const n = this.cache;
                    bo(n, e) || (t.uniform3uiv(this.addr, e), wo(n, e))
                }

                function zo(t, e) {
                    const n = this.cache;
                    bo(n, e) || (t.uniform4uiv(this.addr, e), wo(n, e))
                }

                function Uo(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || ho, r)
                }

                function Ho(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || po, r)
                }

                function ko(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || mo, r)
                }

                function Go(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || uo, r)
                }

                function Vo(t, e) { t.uniform1fv(this.addr, e) }

                function Wo(t, e) {
                    const n = _o(e, this.size, 2);
                    t.uniform2fv(this.addr, n)
                }

                function jo(t, e) {
                    const n = _o(e, this.size, 3);
                    t.uniform3fv(this.addr, n)
                }

                function qo(t, e) {
                    const n = _o(e, this.size, 4);
                    t.uniform4fv(this.addr, n)
                }

                function Xo(t, e) {
                    const n = _o(e, this.size, 4);
                    t.uniformMatrix2fv(this.addr, !1, n)
                }

                function Yo(t, e) {
                    const n = _o(e, this.size, 9);
                    t.uniformMatrix3fv(this.addr, !1, n)
                }

                function Zo(t, e) {
                    const n = _o(e, this.size, 16);
                    t.uniformMatrix4fv(this.addr, !1, n)
                }

                function Jo(t, e) { t.uniform1iv(this.addr, e) }

                function Ko(t, e) { t.uniform2iv(this.addr, e) }

                function Qo(t, e) { t.uniform3iv(this.addr, e) }

                function $o(t, e) { t.uniform4iv(this.addr, e) }

                function ta(t, e) { t.uniform1uiv(this.addr, e) }

                function ea(t, e) { t.uniform2uiv(this.addr, e) }

                function na(t, e) { t.uniform3uiv(this.addr, e) }

                function ia(t, e) { t.uniform4uiv(this.addr, e) }

                function ra(t, e, n) {
                    const i = e.length,
                        r = Mo(n, i);
                    t.uniform1iv(this.addr, r);
                    for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || ho, r[t])
                }

                function sa(t, e, n) {
                    const i = e.length,
                        r = Mo(n, i);
                    t.uniform1iv(this.addr, r);
                    for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || mo, r[t])
                }

                function oa(t, e, n) {
                    this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                        switch (t) {
                            case 5126:
                                return So;
                            case 35664:
                                return To;
                            case 35665:
                                return Eo;
                            case 35666:
                                return Ao;
                            case 35674:
                                return Lo;
                            case 35675:
                                return Ro;
                            case 35676:
                                return Co;
                            case 5124:
                            case 35670:
                                return Po;
                            case 35667:
                            case 35671:
                                return Io;
                            case 35668:
                            case 35672:
                                return Do;
                            case 35669:
                            case 35673:
                                return No;
                            case 5125:
                                return Bo;
                            case 36294:
                                return Oo;
                            case 36295:
                                return Fo;
                            case 36296:
                                return zo;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return Uo;
                            case 35679:
                            case 36299:
                            case 36307:
                                return Ho;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return ko;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return Go
                        }
                    }(e.type)
                }

                function aa(t, e, n) {
                    this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                        switch (t) {
                            case 5126:
                                return Vo;
                            case 35664:
                                return Wo;
                            case 35665:
                                return jo;
                            case 35666:
                                return qo;
                            case 35674:
                                return Xo;
                            case 35675:
                                return Yo;
                            case 35676:
                                return Zo;
                            case 5124:
                            case 35670:
                                return Jo;
                            case 35667:
                            case 35671:
                                return Ko;
                            case 35668:
                            case 35672:
                                return Qo;
                            case 35669:
                            case 35673:
                                return $o;
                            case 5125:
                                return ta;
                            case 36294:
                                return ea;
                            case 36295:
                                return na;
                            case 36296:
                                return ia;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return ra;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return sa
                        }
                    }(e.type)
                }

                function la(t) { this.id = t, this.seq = [], this.map = {} }
                aa.prototype.updateCache = function(t) {
                    const e = this.cache;
                    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), wo(e, t)
                }, la.prototype.setValue = function(t, e, n) {
                    const i = this.seq;
                    for (let r = 0, s = i.length; r !== s; ++r) {
                        const s = i[r];
                        s.setValue(t, e[s.id], n)
                    }
                };
                const ca = /(\w+)(\])?(\[|\.)?/g;

                function ha(t, e) { t.seq.push(e), t.map[e.id] = e }

                function ua(t, e, n) {
                    const i = t.name,
                        r = i.length;
                    for (ca.lastIndex = 0;;) {
                        const s = ca.exec(i),
                            o = ca.lastIndex;
                        let a = s[1];
                        const l = "]" === s[2],
                            c = s[3];
                        if (l && (a |= 0), void 0 === c || "[" === c && o + 2 === r) { ha(n, void 0 === c ? new oa(a, t, e) : new aa(a, t, e)); break } {
                            let t = n.map[a];
                            void 0 === t && (t = new la(a), ha(n, t)), n = t
                        }
                    }
                }

                function da(t, e) {
                    this.seq = [], this.map = {};
                    const n = t.getProgramParameter(e, 35718);
                    for (let i = 0; i < n; ++i) {
                        const n = t.getActiveUniform(e, i);
                        ua(n, t.getUniformLocation(e, n.name), this)
                    }
                }

                function pa(t, e, n) { const i = t.createShader(e); return t.shaderSource(i, n), t.compileShader(i), i }
                da.prototype.setValue = function(t, e, n, i) {
                    const r = this.map[e];
                    void 0 !== r && r.setValue(t, n, i)
                }, da.prototype.setOptional = function(t, e, n) {
                    const i = e[n];
                    void 0 !== i && this.setValue(t, n, i)
                }, da.upload = function(t, e, n, i) {
                    for (let r = 0, s = e.length; r !== s; ++r) {
                        const s = e[r],
                            o = n[s.id];
                        !1 !== o.needsUpdate && s.setValue(t, o.value, i)
                    }
                }, da.seqWithValue = function(t, e) {
                    const n = [];
                    for (let i = 0, r = t.length; i !== r; ++i) {
                        const r = t[i];
                        r.id in e && n.push(r)
                    }
                    return n
                };
                let ma = 0;

                function fa(t) {
                    switch (t) {
                        case tn:
                            return ["Linear", "( value )"];
                        case en:
                            return ["sRGB", "( value )"];
                        case rn:
                            return ["RGBE", "( value )"];
                        case on:
                            return ["RGBM", "( value, 7.0 )"];
                        case an:
                            return ["RGBM", "( value, 16.0 )"];
                        case ln:
                            return ["RGBD", "( value, 256.0 )"];
                        case nn:
                            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                        case sn:
                            return ["LogLuv", "( value )"];
                        default:
                            return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
                    }
                }

                function ga(t, e, n) {
                    const i = t.getShaderParameter(e, 35713),
                        r = t.getShaderInfoLog(e).trim();
                    return i && "" === r ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function(t) { const e = t.split("\n"); for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t]; return e.join("\n") }(t.getShaderSource(e))
                }

                function va(t, e) { const n = fa(e); return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }" }

                function ya(t, e) { const n = fa(e); return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }" }

                function xa(t, e) {
                    let n;
                    switch (e) {
                        case it:
                            n = "Linear";
                            break;
                        case rt:
                            n = "Reinhard";
                            break;
                        case st:
                            n = "OptimizedCineon";
                            break;
                        case ot:
                            n = "ACESFilmic";
                            break;
                        case at:
                            n = "Custom";
                            break;
                        default:
                            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
                    }
                    return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                }

                function _a(t) { return "" !== t }

                function ba(t, e) { return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) }

                function wa(t, e) { return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) }
                const Ma = /^[ \t]*#include +<([\w\d./]+)>/gm;

                function Sa(t) { return t.replace(Ma, Ta) }

                function Ta(t, e) { const n = js[e]; if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">"); return Sa(n) }
                const Ea = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                    Aa = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

                function La(t) { return t.replace(Aa, Ca).replace(Ea, Ra) }

                function Ra(t, e, n, i) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Ca(0, e, n, i) }

                function Ca(t, e, n, i) { let r = ""; for (let t = parseInt(e); t < parseInt(n); t++) r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t); return r }

                function Pa(t) { let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;"; return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e }

                function Ia(t, e, n, i) {
                    const r = t.getContext(),
                        s = n.defines;
                    let o = n.vertexShader,
                        a = n.fragmentShader;
                    const l = function(t) { let e = "SHADOWMAP_TYPE_BASIC"; return t.shadowMapType === f ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === g ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === v && (e = "SHADOWMAP_TYPE_VSM"), e }(n),
                        c = function(t) {
                            let e = "ENVMAP_TYPE_CUBE";
                            if (t.envMap) switch (t.envMapMode) {
                                case ct:
                                case ht:
                                    e = "ENVMAP_TYPE_CUBE";
                                    break;
                                case pt:
                                case mt:
                                    e = "ENVMAP_TYPE_CUBE_UV"
                            }
                            return e
                        }(n),
                        h = function(t) {
                            let e = "ENVMAP_MODE_REFLECTION";
                            if (t.envMap) switch (t.envMapMode) {
                                case ht:
                                case mt:
                                    e = "ENVMAP_MODE_REFRACTION"
                            }
                            return e
                        }(n),
                        u = function(t) {
                            let e = "ENVMAP_BLENDING_NONE";
                            if (t.envMap) switch (t.combine) {
                                case $:
                                    e = "ENVMAP_BLENDING_MULTIPLY";
                                    break;
                                case tt:
                                    e = "ENVMAP_BLENDING_MIX";
                                    break;
                                case et:
                                    e = "ENVMAP_BLENDING_ADD"
                            }
                            return e
                        }(n),
                        d = t.gammaFactor > 0 ? t.gammaFactor : 1,
                        p = n.isWebGL2 ? "" : function(t) { return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission > 0) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(_a).join("\n") }(n),
                        m = function(t) { const e = []; for (const n in t) { const i = t[n];!1 !== i && e.push("#define " + n + " " + i) } return e.join("\n") }(s),
                        y = r.createProgram();
                    let x, _, b = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                    n.isRawShaderMaterial ? (x = [m].filter(_a).join("\n"), x.length > 0 && (x += "\n"), _ = [p, m].filter(_a).join("\n"), _.length > 0 && (_ += "\n")) : (x = [Pa(n), "#define SHADER_NAME " + n.shaderName, m, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(_a).join("\n"), _ = [p, Pa(n), "#define SHADER_NAME " + n.shaderName, m, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== nt ? "#define TONE_MAPPING" : "", n.toneMapping !== nt ? js.tonemapping_pars_fragment : "", n.toneMapping !== nt ? xa("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", js.encodings_pars_fragment, n.map ? va("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? va("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? va("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? va("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? va("lightMapTexelToLinear", n.lightMapEncoding) : "", ya("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(_a).join("\n")), o = Sa(o), o = ba(o, n), o = wa(o, n), a = Sa(a), a = ba(a, n), a = wa(a, n), o = La(o), a = La(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (b = "#version 300 es\n", x = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + x, _ = ["#define varying in", n.glslVersion === Un ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === Un ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + _);
                    const w = b + _ + a,
                        M = pa(r, 35633, b + x + o),
                        S = pa(r, 35632, w);
                    if (r.attachShader(y, M), r.attachShader(y, S), void 0 !== n.index0AttributeName ? r.bindAttribLocation(y, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(y, 0, "position"), r.linkProgram(y), t.debug.checkShaderErrors) {
                        const t = r.getProgramInfoLog(y).trim(),
                            e = r.getShaderInfoLog(M).trim(),
                            n = r.getShaderInfoLog(S).trim();
                        let i = !0,
                            s = !0;
                        if (!1 === r.getProgramParameter(y, 35714)) {
                            i = !1;
                            const e = ga(r, M, "vertex"),
                                n = ga(r, S, "fragment");
                            console.error("THREE.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(y, 35715), "gl.getProgramInfoLog", t, e, n)
                        } else "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== n || (s = !1);
                        s && (this.diagnostics = { runnable: i, programLog: t, vertexShader: { log: e, prefix: x }, fragmentShader: { log: n, prefix: _ } })
                    }
                    let T, E;
                    return r.deleteShader(M), r.deleteShader(S), this.getUniforms = function() { return void 0 === T && (T = new da(r, y)), T }, this.getAttributes = function() {
                        return void 0 === E && (E = function(t, e) {
                            const n = {},
                                i = t.getProgramParameter(e, 35721);
                            for (let r = 0; r < i; r++) {
                                const i = t.getActiveAttrib(e, r).name;
                                n[i] = t.getAttribLocation(e, i)
                            }
                            return n
                        }(r, y)), E
                    }, this.destroy = function() { i.releaseStatesOfProgram(this), r.deleteProgram(y), this.program = void 0 }, this.name = n.shaderName, this.id = ma++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = M, this.fragmentShader = S, this
                }

                function Da(t, e, n, i, r, s) {
                    const o = [],
                        a = i.isWebGL2,
                        l = i.logarithmicDepthBuffer,
                        c = i.floatVertexTextures,
                        h = i.maxVertexUniforms,
                        u = i.vertexTextures;
                    let d = i.precision;
                    const p = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" },
                        m = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmission", "transmissionMap", "thicknessMap"];

                    function f(t) { let e; return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = tn, e }
                    return {
                        getParameters: function(r, o, m, g, v) {
                            const y = g.fog,
                                b = r.isMeshStandardMaterial ? g.environment : null,
                                w = e.get(r.envMap || b),
                                M = p[r.type],
                                S = v.isSkinnedMesh ? function(t) {
                                    const e = t.skeleton.bones;
                                    if (c) return 1024; {
                                        const t = h,
                                            n = Math.floor((t - 20) / 4),
                                            i = Math.min(n, e.length);
                                        return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i
                                    }
                                }(v) : 0;
                            let T, E;
                            if (null !== r.precision && (d = i.getMaxPrecision(r.precision), d !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", d, "instead.")), M) {
                                const t = Xs[M];
                                T = t.vertexShader, E = t.fragmentShader
                            } else T = r.vertexShader, E = r.fragmentShader;
                            const A = t.getRenderTarget();
                            return { isWebGL2: a, shaderID: M, shaderName: r.type, vertexShader: T, fragmentShader: E, defines: r.defines, isRawShaderMaterial: !0 === r.isRawShaderMaterial, glslVersion: r.glslVersion, precision: d, instancing: !0 === v.isInstancedMesh, instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor, supportsVertexTextures: u, outputEncoding: null !== A ? f(A.texture) : t.outputEncoding, map: !!r.map, mapEncoding: f(r.map), matcap: !!r.matcap, matcapEncoding: f(r.matcap), envMap: !!w, envMapMode: w && w.mapping, envMapEncoding: f(w), envMapCubeUV: !!w && (w.mapping === pt || w.mapping === mt), lightMap: !!r.lightMap, lightMapEncoding: f(r.lightMap), aoMap: !!r.aoMap, emissiveMap: !!r.emissiveMap, emissiveMapEncoding: f(r.emissiveMap), bumpMap: !!r.bumpMap, normalMap: !!r.normalMap, objectSpaceNormalMap: r.normalMapType === dn, tangentSpaceNormalMap: r.normalMapType === un, clearcoatMap: !!r.clearcoatMap, clearcoatRoughnessMap: !!r.clearcoatRoughnessMap, clearcoatNormalMap: !!r.clearcoatNormalMap, displacementMap: !!r.displacementMap, roughnessMap: !!r.roughnessMap, metalnessMap: !!r.metalnessMap, specularMap: !!r.specularMap, alphaMap: !!r.alphaMap, gradientMap: !!r.gradientMap, sheen: !!r.sheen, transmission: !!r.transmission, transmissionMap: !!r.transmissionMap, thicknessMap: !!r.thicknessMap, combine: r.combine, vertexTangents: r.normalMap && r.vertexTangents, vertexColors: r.vertexColors, vertexAlphas: !0 === r.vertexColors && v.geometry && v.geometry.attributes.color && 4 === v.geometry.attributes.color.itemSize, vertexUvs: !!(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatMap || r.clearcoatRoughnessMap || r.clearcoatNormalMap || r.displacementMap || r.transmissionMap || r.thicknessMap), uvsVertexOnly: !(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatNormalMap || r.transmission || r.transmissionMap || r.thicknessMap || !r.displacementMap), fog: !!y, useFog: r.fog, fogExp2: y && y.isFogExp2, flatShading: !!r.flatShading, sizeAttenuation: r.sizeAttenuation, logarithmicDepthBuffer: l, skinning: !0 === v.isSkinnedMesh && S > 0, maxBones: S, useVertexTexture: c, morphTargets: r.morphTargets, morphNormals: r.morphNormals, numDirLights: o.directional.length, numPointLights: o.point.length, numSpotLights: o.spot.length, numRectAreaLights: o.rectArea.length, numHemiLights: o.hemi.length, numDirLightShadows: o.directionalShadowMap.length, numPointLightShadows: o.pointShadowMap.length, numSpotLightShadows: o.spotShadowMap.length, numClippingPlanes: s.numPlanes, numClipIntersection: s.numIntersection, dithering: r.dithering, shadowMapEnabled: t.shadowMap.enabled && m.length > 0, shadowMapType: t.shadowMap.type, toneMapping: r.toneMapped ? t.toneMapping : nt, physicallyCorrectLights: t.physicallyCorrectLights, premultipliedAlpha: r.premultipliedAlpha, alphaTest: r.alphaTest, doubleSided: r.side === _, flipSided: r.side === x, depthPacking: void 0 !== r.depthPacking && r.depthPacking, index0AttributeName: r.index0AttributeName, extensionDerivatives: r.extensions && r.extensions.derivatives, extensionFragDepth: r.extensions && r.extensions.fragDepth, extensionDrawBuffers: r.extensions && r.extensions.drawBuffers, extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD, rendererExtensionFragDepth: a || n.has("EXT_frag_depth"), rendererExtensionDrawBuffers: a || n.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: a || n.has("EXT_shader_texture_lod"), customProgramCacheKey: r.customProgramCacheKey() }
                        },
                        getProgramCacheKey: function(e) {
                            const n = [];
                            if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                                for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                            if (!1 === e.isRawShaderMaterial) {
                                for (let t = 0; t < m.length; t++) n.push(e[m[t]]);
                                n.push(t.outputEncoding), n.push(t.gammaFactor)
                            }
                            return n.push(e.customProgramCacheKey), n.join()
                        },
                        getUniforms: function(t) {
                            const e = p[t.type];
                            let n;
                            if (e) {
                                const t = Xs[e];
                                n = As.clone(t.uniforms)
                            } else n = t.uniforms;
                            return n
                        },
                        acquireProgram: function(e, n) { let i; for (let t = 0, e = o.length; t < e; t++) { const e = o[t]; if (e.cacheKey === n) { i = e, ++i.usedTimes; break } } return void 0 === i && (i = new Ia(t, n, e, r), o.push(i)), i },
                        releaseProgram: function(t) {
                            if (0 == --t.usedTimes) {
                                const e = o.indexOf(t);
                                o[e] = o[o.length - 1], o.pop(), t.destroy()
                            }
                        },
                        programs: o
                    }
                }

                function Na() { let t = new WeakMap; return { get: function(e) { let n = t.get(e); return void 0 === n && (n = {}, t.set(e, n)), n }, remove: function(e) { t.delete(e) }, update: function(e, n, i) { t.get(e)[n] = i }, dispose: function() { t = new WeakMap } } }

                function Ba(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id }

                function Oa(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id }

                function Fa(t) {
                    const e = [];
                    let n = 0;
                    const i = [],
                        r = [],
                        s = [],
                        o = { id: -1 };

                    function a(i, r, s, a, l, c) { let h = e[n]; const u = t.get(s); return void 0 === h ? (h = { id: i.id, object: i, geometry: r, material: s, program: u.program || o, groupOrder: a, renderOrder: i.renderOrder, z: l, group: c }, e[n] = h) : (h.id = i.id, h.object = i, h.geometry = r, h.material = s, h.program = u.program || o, h.groupOrder = a, h.renderOrder = i.renderOrder, h.z = l, h.group = c), n++, h }
                    return {
                        opaque: i,
                        transmissive: r,
                        transparent: s,
                        init: function() { n = 0, i.length = 0, r.length = 0, s.length = 0 },
                        push: function(t, e, n, o, l, c) {
                            const h = a(t, e, n, o, l, c);
                            n.transmission > 0 ? r.push(h) : !0 === n.transparent ? s.push(h) : i.push(h)
                        },
                        unshift: function(t, e, n, o, l, c) {
                            const h = a(t, e, n, o, l, c);
                            n.transmission > 0 ? r.unshift(h) : !0 === n.transparent ? s.unshift(h) : i.unshift(h)
                        },
                        finish: function() {
                            for (let t = n, i = e.length; t < i; t++) {
                                const n = e[t];
                                if (null === n.id) break;
                                n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
                            }
                        },
                        sort: function(t, e) { i.length > 1 && i.sort(t || Ba), r.length > 1 && r.sort(e || Oa), s.length > 1 && s.sort(e || Oa) }
                    }
                }

                function za(t) { let e = new WeakMap; return { get: function(n, i) { let r; return !1 === e.has(n) ? (r = new Fa(t), e.set(n, [r])) : i >= e.get(n).length ? (r = new Fa(t), e.get(n).push(r)) : r = e.get(n)[i], r }, dispose: function() { e = new WeakMap } } }

                function Ua() {
                    const t = {};
                    return {
                        get: function(e) {
                            if (void 0 !== t[e.id]) return t[e.id];
                            let n;
                            switch (e.type) {
                                case "DirectionalLight":
                                    n = { direction: new ui, color: new Dr };
                                    break;
                                case "SpotLight":
                                    n = { position: new ui, direction: new ui, color: new Dr, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
                                    break;
                                case "PointLight":
                                    n = { position: new ui, color: new Dr, distance: 0, decay: 0 };
                                    break;
                                case "HemisphereLight":
                                    n = { direction: new ui, skyColor: new Dr, groundColor: new Dr };
                                    break;
                                case "RectAreaLight":
                                    n = { color: new Dr, position: new ui, halfWidth: new ui, halfHeight: new ui }
                            }
                            return t[e.id] = n, n
                        }
                    }
                }
                let Ha = 0;

                function ka(t, e) { return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0) }

                function Ga(t, e) {
                    const n = new Ua,
                        i = function() {
                            const t = {};
                            return {
                                get: function(e) {
                                    if (void 0 !== t[e.id]) return t[e.id];
                                    let n;
                                    switch (e.type) {
                                        case "DirectionalLight":
                                        case "SpotLight":
                                            n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new $n };
                                            break;
                                        case "PointLight":
                                            n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new $n, shadowCameraNear: 1, shadowCameraFar: 1e3 }
                                    }
                                    return t[e.id] = n, n
                                }
                            }
                        }(),
                        r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] };
                    for (let t = 0; t < 9; t++) r.probe.push(new ui);
                    const s = new ui,
                        o = new Gi,
                        a = new Gi;
                    return {
                        setup: function(s) {
                            let o = 0,
                                a = 0,
                                l = 0;
                            for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                            let c = 0,
                                h = 0,
                                u = 0,
                                d = 0,
                                p = 0,
                                m = 0,
                                f = 0,
                                g = 0;
                            s.sort(ka);
                            for (let t = 0, e = s.length; t < e; t++) {
                                const e = s[t],
                                    v = e.color,
                                    y = e.intensity,
                                    x = e.distance,
                                    _ = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                                if (e.isAmbientLight) o += v.r * y, a += v.g * y, l += v.b * y;
                                else if (e.isLightProbe)
                                    for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], y);
                                else if (e.isDirectionalLight) {
                                    const t = n.get(e);
                                    if (t.color.copy(e.color).multiplyScalar(e.intensity), e.castShadow) {
                                        const t = e.shadow,
                                            n = i.get(e);
                                        n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.directionalShadow[c] = n, r.directionalShadowMap[c] = _, r.directionalShadowMatrix[c] = e.shadow.matrix, m++
                                    }
                                    r.directional[c] = t, c++
                                } else if (e.isSpotLight) {
                                    const t = n.get(e);
                                    if (t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(v).multiplyScalar(y), t.distance = x, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) {
                                        const t = e.shadow,
                                            n = i.get(e);
                                        n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.spotShadow[u] = n, r.spotShadowMap[u] = _, r.spotShadowMatrix[u] = e.shadow.matrix, g++
                                    }
                                    r.spot[u] = t, u++
                                } else if (e.isRectAreaLight) {
                                    const t = n.get(e);
                                    t.color.copy(v).multiplyScalar(y), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), r.rectArea[d] = t, d++
                                } else if (e.isPointLight) {
                                    const t = n.get(e);
                                    if (t.color.copy(e.color).multiplyScalar(e.intensity), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                                        const t = e.shadow,
                                            n = i.get(e);
                                        n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, r.pointShadow[h] = n, r.pointShadowMap[h] = _, r.pointShadowMatrix[h] = e.shadow.matrix, f++
                                    }
                                    r.point[h] = t, h++
                                } else if (e.isHemisphereLight) {
                                    const t = n.get(e);
                                    t.skyColor.copy(e.color).multiplyScalar(y), t.groundColor.copy(e.groundColor).multiplyScalar(y), r.hemi[p] = t, p++
                                }
                            }
                            d > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = qs.LTC_FLOAT_1, r.rectAreaLTC2 = qs.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = qs.LTC_HALF_1, r.rectAreaLTC2 = qs.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = a, r.ambient[2] = l;
                            const v = r.hash;
                            v.directionalLength === c && v.pointLength === h && v.spotLength === u && v.rectAreaLength === d && v.hemiLength === p && v.numDirectionalShadows === m && v.numPointShadows === f && v.numSpotShadows === g || (r.directional.length = c, r.spot.length = u, r.rectArea.length = d, r.point.length = h, r.hemi.length = p, r.directionalShadow.length = m, r.directionalShadowMap.length = m, r.pointShadow.length = f, r.pointShadowMap.length = f, r.spotShadow.length = g, r.spotShadowMap.length = g, r.directionalShadowMatrix.length = m, r.pointShadowMatrix.length = f, r.spotShadowMatrix.length = g, v.directionalLength = c, v.pointLength = h, v.spotLength = u, v.rectAreaLength = d, v.hemiLength = p, v.numDirectionalShadows = m, v.numPointShadows = f, v.numSpotShadows = g, r.version = Ha++)
                        },
                        setupView: function(t, e) {
                            let n = 0,
                                i = 0,
                                l = 0,
                                c = 0,
                                h = 0;
                            const u = e.matrixWorldInverse;
                            for (let e = 0, d = t.length; e < d; e++) {
                                const d = t[e];
                                if (d.isDirectionalLight) {
                                    const t = r.directional[n];
                                    t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(u), n++
                                } else if (d.isSpotLight) {
                                    const t = r.spot[l];
                                    t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(u), l++
                                } else if (d.isRectAreaLight) {
                                    const t = r.rectArea[c];
                                    t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), a.identity(), o.copy(d.matrixWorld), o.premultiply(u), a.extractRotation(o), t.halfWidth.set(.5 * d.width, 0, 0), t.halfHeight.set(0, .5 * d.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), c++
                                } else if (d.isPointLight) {
                                    const t = r.point[i];
                                    t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), i++
                                } else if (d.isHemisphereLight) {
                                    const t = r.hemi[h];
                                    t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(u), t.direction.normalize(), h++
                                }
                            }
                        },
                        state: r
                    }
                }

                function Va(t, e) {
                    const n = new Ga(t, e),
                        i = [],
                        r = [];
                    return { init: function() { i.length = 0, r.length = 0 }, state: { lightsArray: i, shadowsArray: r, lights: n }, setupLights: function() { n.setup(i) }, setupLightsView: function(t) { n.setupView(i, t) }, pushLight: function(t) { i.push(t) }, pushShadow: function(t) { r.push(t) } }
                }

                function Wa(t, e) { let n = new WeakMap; return { get: function(i, r = 0) { let s; return !1 === n.has(i) ? (s = new Va(t, e), n.set(i, [s])) : r >= n.get(i).length ? (s = new Va(t, e), n.get(i).push(s)) : s = n.get(i)[r], s }, dispose: function() { n = new WeakMap } } }
                class ja extends Er {
                    constructor(t) { super(), this.type = "MeshDepthMaterial", this.depthPacking = cn, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.depthPacking = t.depthPacking, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this }
                }
                ja.prototype.isMeshDepthMaterial = !0;
                class qa extends Er {
                    constructor(t) { super(), this.type = "MeshDistanceMaterial", this.referencePosition = new ui, this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this }
                }

                function Xa(t, e, n) {
                    let i = new ks;
                    const r = new $n,
                        s = new $n,
                        o = new oi,
                        a = [],
                        l = [],
                        c = {},
                        h = n.maxTextureSize,
                        u = { 0: x, 1: y, 2: _ },
                        d = new Ls({ defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new $n }, radius: { value: 4 } }, vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }),
                        p = d.clone();
                    p.defines.HORIZONTAL_PASS = 1;
                    const m = new rs;
                    m.setAttribute("position", new Fr(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                    const g = new ws(m, d),
                        b = this;

                    function w(n, i) {
                        const r = e.update(g);
                        d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, d, g, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, p, g, null)
                    }

                    function S(t) { const e = t << 0; let n = a[e]; return void 0 === n && (n = new ja({ depthPacking: hn, morphTargets: t }), a[e] = n), n }

                    function T(t) { const e = t << 0; let n = l[e]; return void 0 === n && (n = new qa({ morphTargets: t }), l[e] = n), n }

                    function E(e, n, i, r, s, o, a) {
                        let l = null,
                            h = S,
                            d = e.customDepthMaterial;
                        if (!0 === r.isPointLight && (h = T, d = e.customDistanceMaterial), void 0 === d) { let t = !1;!0 === i.morphTargets && (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0), l = h(t) } else l = d;
                        if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                            const t = l.uuid,
                                e = i.uuid;
                            let n = c[t];
                            void 0 === n && (n = {}, c[t] = n);
                            let r = n[e];
                            void 0 === r && (r = l.clone(), n[e] = r), l = r
                        }
                        return l.visible = i.visible, l.wireframe = i.wireframe, l.side = a === v ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : u[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, !0 === r.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(r.matrixWorld), l.nearDistance = s, l.farDistance = o), l
                    }

                    function A(n, r, s, o, a) {
                        if (!1 === n.visible) return;
                        if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && a === v) && (!n.frustumCulled || i.intersectsObject(n))) {
                            n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                            const i = e.update(n),
                                r = n.material;
                            if (Array.isArray(r)) {
                                const e = i.groups;
                                for (let l = 0, c = e.length; l < c; l++) {
                                    const c = e[l],
                                        h = r[c.materialIndex];
                                    if (h && h.visible) {
                                        const e = E(n, i, h, o, s.near, s.far, a);
                                        t.renderBufferDirect(s, null, i, e, n, c)
                                    }
                                }
                            } else if (r.visible) {
                                const e = E(n, i, r, o, s.near, s.far, a);
                                t.renderBufferDirect(s, null, i, e, n, null)
                            }
                        }
                        const l = n.children;
                        for (let t = 0, e = l.length; t < e; t++) A(l[t], r, s, o, a)
                    }
                    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = f, this.render = function(e, n, a) {
                        if (!1 === b.enabled) return;
                        if (!1 === b.autoUpdate && !1 === b.needsUpdate) return;
                        if (0 === e.length) return;
                        const l = t.getRenderTarget(),
                            c = t.getActiveCubeFace(),
                            u = t.getActiveMipmapLevel(),
                            d = t.state;
                        d.setBlending(M), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                        for (let l = 0, c = e.length; l < c; l++) {
                            const c = e[l],
                                u = c.shadow;
                            if (void 0 === u) { console.warn("THREE.WebGLShadowMap:", c, "has no shadow."); continue }
                            if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
                            r.copy(u.mapSize);
                            const p = u.getFrameExtents();
                            if (r.multiply(p), s.copy(u.mapSize), (r.x > h || r.y > h) && (r.x > h && (s.x = Math.floor(h / p.x), r.x = s.x * p.x, u.mapSize.x = s.x), r.y > h && (s.y = Math.floor(h / p.y), r.y = s.y * p.y, u.mapSize.y = s.y)), null === u.map && !u.isPointLightShadow && this.type === v) {
                                const t = { minFilter: Mt, magFilter: Mt, format: Gt };
                                u.map = new ai(r.x, r.y, t), u.map.texture.name = c.name + ".shadowMap", u.mapPass = new ai(r.x, r.y, t), u.camera.updateProjectionMatrix()
                            }
                            if (null === u.map) {
                                const t = { minFilter: yt, magFilter: yt, format: Gt };
                                u.map = new ai(r.x, r.y, t), u.map.texture.name = c.name + ".shadowMap", u.camera.updateProjectionMatrix()
                            }
                            t.setRenderTarget(u.map), t.clear();
                            const m = u.getViewportCount();
                            for (let t = 0; t < m; t++) {
                                const e = u.getViewport(t);
                                o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), d.viewport(o), u.updateMatrices(c, t), i = u.getFrustum(), A(n, a, u.camera, c, this.type)
                            }
                            u.isPointLightShadow || this.type !== v || w(u, a), u.needsUpdate = !1
                        }
                        b.needsUpdate = !1, t.setRenderTarget(l, c, u)
                    }
                }

                function Ya(t, e, n) {
                    const i = n.isWebGL2,
                        r = new function() { let e = !1; const n = new oi; let i = null; const r = new oi(0, 0, 0, 0); return { setMask: function(n) { i === n || e || (t.colorMask(n, n, n, n), i = n) }, setLocked: function(t) { e = t }, setClear: function(e, i, s, o, a) {!0 === a && (e *= o, i *= o, s *= o), n.set(e, i, s, o), !1 === r.equals(n) && (t.clearColor(e, i, s, o), r.copy(n)) }, reset: function() { e = !1, i = null, r.set(-1, 0, 0, 0) } } },
                        s = new function() {
                            let e = !1,
                                n = null,
                                i = null,
                                r = null;
                            return {
                                setTest: function(t) { t ? yt(2929) : xt(2929) },
                                setMask: function(i) { n === i || e || (t.depthMask(i), n = i) },
                                setFunc: function(e) {
                                    if (i !== e) {
                                        if (e) switch (e) {
                                            case j:
                                                t.depthFunc(512);
                                                break;
                                            case q:
                                                t.depthFunc(519);
                                                break;
                                            case X:
                                                t.depthFunc(513);
                                                break;
                                            case Y:
                                                t.depthFunc(515);
                                                break;
                                            case Z:
                                                t.depthFunc(514);
                                                break;
                                            case J:
                                                t.depthFunc(518);
                                                break;
                                            case K:
                                                t.depthFunc(516);
                                                break;
                                            case Q:
                                                t.depthFunc(517);
                                                break;
                                            default:
                                                t.depthFunc(515)
                                        } else t.depthFunc(515);
                                        i = e
                                    }
                                },
                                setLocked: function(t) { e = t },
                                setClear: function(e) { r !== e && (t.clearDepth(e), r = e) },
                                reset: function() { e = !1, n = null, i = null, r = null }
                            }
                        },
                        o = new function() {
                            let e = !1,
                                n = null,
                                i = null,
                                r = null,
                                s = null,
                                o = null,
                                a = null,
                                l = null,
                                c = null;
                            return { setTest: function(t) { e || (t ? yt(2960) : xt(2960)) }, setMask: function(i) { n === i || e || (t.stencilMask(i), n = i) }, setFunc: function(e, n, o) { i === e && r === n && s === o || (t.stencilFunc(e, n, o), i = e, r = n, s = o) }, setOp: function(e, n, i) { o === e && a === n && l === i || (t.stencilOp(e, n, i), o = e, a = n, l = i) }, setLocked: function(t) { e = t }, setClear: function(e) { c !== e && (t.clearStencil(e), c = e) }, reset: function() { e = !1, n = null, i = null, r = null, s = null, o = null, a = null, l = null, c = null } }
                        };
                    let a = {},
                        l = null,
                        c = {},
                        p = null,
                        m = !1,
                        f = null,
                        g = null,
                        v = null,
                        y = null,
                        b = null,
                        w = null,
                        $ = null,
                        tt = !1,
                        et = null,
                        nt = null,
                        it = null,
                        rt = null,
                        st = null;
                    const ot = t.getParameter(35661);
                    let at = !1,
                        lt = 0;
                    const ct = t.getParameter(7938); - 1 !== ct.indexOf("WebGL") ? (lt = parseFloat(/^WebGL (\d)/.exec(ct)[1]), at = lt >= 1) : -1 !== ct.indexOf("OpenGL ES") && (lt = parseFloat(/^OpenGL ES (\d)/.exec(ct)[1]), at = lt >= 2);
                    let ht = null,
                        ut = {};
                    const dt = t.getParameter(3088),
                        pt = t.getParameter(2978),
                        mt = (new oi).fromArray(dt),
                        ft = (new oi).fromArray(pt);

                    function gt(e, n, i) {
                        const r = new Uint8Array(4),
                            s = t.createTexture();
                        t.bindTexture(e, s), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                        for (let e = 0; e < i; e++) t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
                        return s
                    }
                    const vt = {};

                    function yt(e) {!0 !== a[e] && (t.enable(e), a[e] = !0) }

                    function xt(e) {!1 !== a[e] && (t.disable(e), a[e] = !1) }
                    vt[3553] = gt(3553, 3553, 1), vt[34067] = gt(34067, 34069, 6), r.setClear(0, 0, 0, 1), s.setClear(1), o.setClear(0), yt(2929), s.setFunc(Y), Mt(!1), St(u), yt(2884), wt(M);
                    const _t = {
                        [R]: 32774,
                        [C]: 32778,
                        [P]: 32779
                    };
                    if (i) _t[I] = 32775, _t[D] = 32776;
                    else {
                        const t = e.get("EXT_blend_minmax");
                        null !== t && (_t[I] = t.MIN_EXT, _t[D] = t.MAX_EXT)
                    }
                    const bt = {
                        [N]: 0,
                        [B]: 1,
                        [O]: 768,
                        [z]: 770,
                        [W]: 776,
                        [G]: 774,
                        [H]: 772,
                        [F]: 769,
                        [U]: 771,
                        [V]: 775,
                        [k]: 773
                    };

                    function wt(e, n, i, r, s, o, a, l) {
                        if (e !== M) {
                            if (!1 === m && (yt(3042), m = !0), e === L) s = s || n, o = o || i, a = a || r, n === g && s === b || (t.blendEquationSeparate(_t[n], _t[s]), g = n, b = s), i === v && r === y && o === w && a === $ || (t.blendFuncSeparate(bt[i], bt[r], bt[o], bt[a]), v = i, y = r, w = o, $ = a), f = e, tt = null;
                            else if (e !== f || l !== tt) {
                                if (g === R && b === R || (t.blendEquation(32774), g = R, b = R), l) switch (e) {
                                    case S:
                                        t.blendFuncSeparate(1, 771, 1, 771);
                                        break;
                                    case T:
                                        t.blendFunc(1, 1);
                                        break;
                                    case E:
                                        t.blendFuncSeparate(0, 0, 769, 771);
                                        break;
                                    case A:
                                        t.blendFuncSeparate(0, 768, 0, 770);
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", e)
                                } else switch (e) {
                                    case S:
                                        t.blendFuncSeparate(770, 771, 1, 771);
                                        break;
                                    case T:
                                        t.blendFunc(770, 1);
                                        break;
                                    case E:
                                        t.blendFunc(0, 769);
                                        break;
                                    case A:
                                        t.blendFunc(0, 768);
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", e)
                                }
                                v = null, y = null, w = null, $ = null, f = e, tt = l
                            }
                        } else !0 === m && (xt(3042), m = !1)
                    }

                    function Mt(e) { et !== e && (e ? t.frontFace(2304) : t.frontFace(2305), et = e) }

                    function St(e) { e !== h ? (yt(2884), e !== nt && (e === u ? t.cullFace(1029) : e === d ? t.cullFace(1028) : t.cullFace(1032))) : xt(2884), nt = e }

                    function Tt(e, n, i) { e ? (yt(32823), rt === n && st === i || (t.polygonOffset(n, i), rt = n, st = i)) : xt(32823) }

                    function Et(e) { void 0 === e && (e = 33984 + ot - 1), ht !== e && (t.activeTexture(e), ht = e) }
                    return {
                        buffers: { color: r, depth: s, stencil: o },
                        enable: yt,
                        disable: xt,
                        bindFramebuffer: function(e, n) { return null === n && null !== l && (n = l), c[e] !== n && (t.bindFramebuffer(e, n), c[e] = n, i && (36009 === e && (c[36160] = n), 36160 === e && (c[36009] = n)), !0) },
                        bindXRFramebuffer: function(e) { e !== l && (t.bindFramebuffer(36160, e), l = e) },
                        useProgram: function(e) { return p !== e && (t.useProgram(e), p = e, !0) },
                        setBlending: wt,
                        setMaterial: function(t, e) {
                            t.side === _ ? xt(2884) : yt(2884);
                            let n = t.side === x;
                            e && (n = !n), Mt(n), t.blending === S && !1 === t.transparent ? wt(M) : wt(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), r.setMask(t.colorWrite);
                            const i = t.stencilWrite;
                            o.setTest(i), i && (o.setMask(t.stencilWriteMask), o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), Tt(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? yt(32926) : xt(32926)
                        },
                        setFlipSided: Mt,
                        setCullFace: St,
                        setLineWidth: function(e) { e !== it && (at && t.lineWidth(e), it = e) },
                        setPolygonOffset: Tt,
                        setScissorTest: function(t) { t ? yt(3089) : xt(3089) },
                        activeTexture: Et,
                        bindTexture: function(e, n) {
                            null === ht && Et();
                            let i = ut[ht];
                            void 0 === i && (i = { type: void 0, texture: void 0 }, ut[ht] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || vt[e]), i.type = e, i.texture = n)
                        },
                        unbindTexture: function() {
                            const e = ut[ht];
                            void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                        },
                        compressedTexImage2D: function() { try { t.compressedTexImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } },
                        texImage2D: function() { try { t.texImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } },
                        texImage3D: function() { try { t.texImage3D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } },
                        scissor: function(e) {!1 === mt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), mt.copy(e)) },
                        viewport: function(e) {!1 === ft.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), ft.copy(e)) },
                        reset: function() { t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === i && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), a = {}, ht = null, ut = {}, l = null, c = {}, p = null, m = !1, f = null, g = null, v = null, y = null, b = null, w = null, $ = null, tt = !1, et = null, nt = null, it = null, rt = null, st = null, mt.set(0, 0, t.canvas.width, t.canvas.height), ft.set(0, 0, t.canvas.width, t.canvas.height), r.reset(), s.reset(), o.reset() }
                    }
                }

                function Za(t, e, n, i, r, s, o) {
                    const a = r.isWebGL2,
                        l = r.maxTextures,
                        c = r.maxCubemapSize,
                        h = r.maxTextureSize,
                        u = r.maxSamples,
                        d = new WeakMap;
                    let p, m = !1;
                    try { m = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (t) {}

                    function f(t, e) { return m ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") }

                    function g(t, e, n, i) {
                        let r = 1;
                        if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                            if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                                const i = e ? Kn : Math.floor,
                                    s = i(r * t.width),
                                    o = i(r * t.height);
                                void 0 === p && (p = f(s, o));
                                const a = n ? f(s, o) : p;
                                return a.width = s, a.height = o, a.getContext("2d").drawImage(t, 0, 0, s, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + o + ")."), a
                            }
                            return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                        }
                        return t
                    }

                    function v(t) { return Zn(t.width) && Zn(t.height) }

                    function y(t, e) { return t.generateMipmaps && e && t.minFilter !== yt && t.minFilter !== Mt }

                    function x(e, n, r, s, o = 1) { t.generateMipmap(e), i.get(n).__maxMipLevel = Math.log2(Math.max(r, s, o)) }

                    function _(n, i, r) {
                        if (!1 === a) return i;
                        if (null !== n) {
                            if (void 0 !== t[n]) return t[n];
                            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                        }
                        let s = i;
                        return 6403 === i && (5126 === r && (s = 33326), 5131 === r && (s = 33325), 5121 === r && (s = 33321)), 6407 === i && (5126 === r && (s = 34837), 5131 === r && (s = 34843), 5121 === r && (s = 32849)), 6408 === i && (5126 === r && (s = 34836), 5131 === r && (s = 34842), 5121 === r && (s = 32856)), 33325 !== s && 33326 !== s && 34842 !== s && 34836 !== s || e.get("EXT_color_buffer_float"), s
                    }

                    function b(t) { return t === yt || t === xt || t === bt ? 9728 : 9729 }

                    function w(e) {
                        const n = e.target;
                        n.removeEventListener("dispose", w),
                            function(e) {
                                const n = i.get(e);
                                void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture), i.remove(e))
                            }(n), n.isVideoTexture && d.delete(n), o.memory.textures--
                    }

                    function M(e) {
                        const n = e.target;
                        n.removeEventListener("dispose", M),
                            function(e) {
                                const n = e.texture,
                                    r = i.get(e),
                                    s = i.get(n);
                                if (e) {
                                    if (void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture), o.memory.textures--), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)
                                        for (let e = 0; e < 6; e++) t.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                                    else t.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                                    if (e.isWebGLMultipleRenderTargets)
                                        for (let e = 0, r = n.length; e < r; e++) {
                                            const r = i.get(n[e]);
                                            r.__webglTexture && (t.deleteTexture(r.__webglTexture), o.memory.textures--), i.remove(n[e])
                                        }
                                    i.remove(n), i.remove(e)
                                }
                            }(n)
                    }
                    let S = 0;

                    function T(t, e) {
                        const r = i.get(t);
                        if (t.isVideoTexture && function(t) {
                                const e = o.render.frame;
                                d.get(t) !== e && (d.set(t, e), t.update())
                            }(t), t.version > 0 && r.__version !== t.version) {
                            const n = t.image;
                            if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                            else {
                                if (!1 !== n.complete) return void P(r, t, e);
                                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                            }
                        }
                        n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture)
                    }

                    function E(e, r) {
                        const o = i.get(e);
                        e.version > 0 && o.__version !== e.version ? function(e, i, r) {
                            if (6 !== i.image.length) return;
                            C(e, i), n.activeTexture(33984 + r), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
                            const o = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
                                l = i.image[0] && i.image[0].isDataTexture,
                                h = [];
                            for (let t = 0; t < 6; t++) h[t] = o || l ? l ? i.image[t].image : i.image[t] : g(i.image[t], !1, !0, c);
                            const u = h[0],
                                d = v(u) || a,
                                p = s.convert(i.format),
                                m = s.convert(i.type),
                                f = _(i.internalFormat, p, m);
                            let b;
                            if (R(34067, i, d), o) {
                                for (let t = 0; t < 6; t++) {
                                    b = h[t].mipmaps;
                                    for (let e = 0; e < b.length; e++) {
                                        const r = b[e];
                                        i.format !== Gt && i.format !== kt ? null !== p ? n.compressedTexImage2D(34069 + t, e, f, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, e, f, r.width, r.height, 0, p, m, r.data)
                                    }
                                }
                                e.__maxMipLevel = b.length - 1
                            } else {
                                b = i.mipmaps;
                                for (let t = 0; t < 6; t++)
                                    if (l) {
                                        n.texImage2D(34069 + t, 0, f, h[t].width, h[t].height, 0, p, m, h[t].data);
                                        for (let e = 0; e < b.length; e++) {
                                            const i = b[e].image[t].image;
                                            n.texImage2D(34069 + t, e + 1, f, i.width, i.height, 0, p, m, i.data)
                                        }
                                    } else {
                                        n.texImage2D(34069 + t, 0, f, p, m, h[t]);
                                        for (let e = 0; e < b.length; e++) {
                                            const i = b[e];
                                            n.texImage2D(34069 + t, e + 1, f, p, m, i.image[t])
                                        }
                                    }
                                e.__maxMipLevel = b.length
                            }
                            y(i, d) && x(34067, i, u.width, u.height), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                        }(o, e, r) : (n.activeTexture(33984 + r), n.bindTexture(34067, o.__webglTexture))
                    }
                    const A = {
                            [ft]: 10497,
                            [gt]: 33071,
                            [vt]: 33648
                        },
                        L = {
                            [yt]: 9728,
                            [xt]: 9984,
                            [bt]: 9986,
                            [Mt]: 9729,
                            [St]: 9985,
                            [Et]: 9987
                        };

                    function R(n, s, o) {
                        if (o ? (t.texParameteri(n, 10242, A[s.wrapS]), t.texParameteri(n, 10243, A[s.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, A[s.wrapR]), t.texParameteri(n, 10240, L[s.magFilter]), t.texParameteri(n, 10241, L[s.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), s.wrapS === gt && s.wrapT === gt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, b(s.magFilter)), t.texParameteri(n, 10241, b(s.minFilter)), s.minFilter !== yt && s.minFilter !== Mt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
                            const o = e.get("EXT_texture_filter_anisotropic");
                            if (s.type === Nt && !1 === e.has("OES_texture_float_linear")) return;
                            if (!1 === a && s.type === Bt && !1 === e.has("OES_texture_half_float_linear")) return;
                            (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy)
                        }
                    }

                    function C(e, n) { void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", w), e.__webglTexture = t.createTexture(), o.memory.textures++) }

                    function P(e, i, r) {
                        let o = 3553;
                        i.isDataTexture2DArray && (o = 35866), i.isDataTexture3D && (o = 32879), C(e, i), n.activeTexture(33984 + r), n.bindTexture(o, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
                        const l = function(t) { return !a && (t.wrapS !== gt || t.wrapT !== gt || t.minFilter !== yt && t.minFilter !== Mt) }(i) && !1 === v(i.image),
                            c = g(i.image, l, !1, h),
                            u = v(c) || a,
                            d = s.convert(i.format);
                        let p, m = s.convert(i.type),
                            f = _(i.internalFormat, d, m);
                        R(o, i, u);
                        const b = i.mipmaps;
                        if (i.isDepthTexture) f = 6402, a ? f = i.type === Nt ? 36012 : i.type === Dt ? 33190 : i.type === Ut ? 35056 : 33189 : i.type === Nt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === qt && 6402 === f && i.type !== Pt && i.type !== Dt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = Pt, m = s.convert(i.type)), i.format === Xt && 6402 === f && (f = 34041, i.type !== Ut && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = Ut, m = s.convert(i.type))), n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, null);
                        else if (i.isDataTexture)
                            if (b.length > 0 && u) {
                                for (let t = 0, e = b.length; t < e; t++) p = b[t], n.texImage2D(3553, t, f, p.width, p.height, 0, d, m, p.data);
                                i.generateMipmaps = !1, e.__maxMipLevel = b.length - 1
                            } else n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, c.data), e.__maxMipLevel = 0;
                        else if (i.isCompressedTexture) {
                            for (let t = 0, e = b.length; t < e; t++) p = b[t], i.format !== Gt && i.format !== kt ? null !== d ? n.compressedTexImage2D(3553, t, f, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, f, p.width, p.height, 0, d, m, p.data);
                            e.__maxMipLevel = b.length - 1
                        } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, f, c.width, c.height, c.depth, 0, d, m, c.data), e.__maxMipLevel = 0;
                        else if (i.isDataTexture3D) n.texImage3D(32879, 0, f, c.width, c.height, c.depth, 0, d, m, c.data), e.__maxMipLevel = 0;
                        else if (b.length > 0 && u) {
                            for (let t = 0, e = b.length; t < e; t++) p = b[t], n.texImage2D(3553, t, f, d, m, p);
                            i.generateMipmaps = !1, e.__maxMipLevel = b.length - 1
                        } else n.texImage2D(3553, 0, f, d, m, c), e.__maxMipLevel = 0;
                        y(i, u) && x(o, i, c.width, c.height), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                    }

                    function I(e, r, o, a, l) {
                        const c = s.convert(o.format),
                            h = s.convert(o.type),
                            u = _(o.internalFormat, c, h);
                        32879 === l || 35866 === l ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null), n.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, a, l, i.get(o).__webglTexture, 0), n.bindFramebuffer(36160, null)
                    }

                    function D(e, n, i) {
                        if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                            let r = 33189;
                            if (i) {
                                const e = n.depthTexture;
                                e && e.isDepthTexture && (e.type === Nt ? r = 36012 : e.type === Dt && (r = 33190));
                                const i = N(n);
                                t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                            } else t.renderbufferStorage(36161, r, n.width, n.height);
                            t.framebufferRenderbuffer(36160, 36096, 36161, e)
                        } else if (n.depthBuffer && n.stencilBuffer) {
                            if (i) {
                                const e = N(n);
                                t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height)
                            } else t.renderbufferStorage(36161, 34041, n.width, n.height);
                            t.framebufferRenderbuffer(36160, 33306, 36161, e)
                        } else {
                            const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
                                r = s.convert(e.format),
                                o = s.convert(e.type),
                                a = _(e.internalFormat, r, o);
                            if (i) {
                                const e = N(n);
                                t.renderbufferStorageMultisample(36161, e, a, n.width, n.height)
                            } else t.renderbufferStorage(36161, a, n.width, n.height)
                        }
                        t.bindRenderbuffer(36161, null)
                    }

                    function N(t) { return a && t.isWebGLMultisampleRenderTarget ? Math.min(u, t.samples) : 0 }
                    let B = !1,
                        O = !1;
                    this.allocateTextureUnit = function() { const t = S; return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), S += 1, t }, this.resetTextureUnits = function() { S = 0 }, this.setTexture2D = T, this.setTexture2DArray = function(t, e) {
                        const r = i.get(t);
                        t.version > 0 && r.__version !== t.version ? P(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture))
                    }, this.setTexture3D = function(t, e) {
                        const r = i.get(t);
                        t.version > 0 && r.__version !== t.version ? P(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture))
                    }, this.setTextureCube = E, this.setupRenderTarget = function(e) {
                        const l = e.texture,
                            c = i.get(e),
                            h = i.get(l);
                        e.addEventListener("dispose", M), !0 !== e.isWebGLMultipleRenderTargets && (h.__webglTexture = t.createTexture(), h.__version = l.version, o.memory.textures++);
                        const u = !0 === e.isWebGLCubeRenderTarget,
                            d = !0 === e.isWebGLMultipleRenderTargets,
                            p = !0 === e.isWebGLMultisampleRenderTarget,
                            m = l.isDataTexture3D || l.isDataTexture2DArray,
                            f = v(e) || a;
                        if (!a || l.format !== kt || l.type !== Nt && l.type !== Bt || (l.format = Gt, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), u) { c.__webglFramebuffer = []; for (let e = 0; e < 6; e++) c.__webglFramebuffer[e] = t.createFramebuffer() } else if (c.__webglFramebuffer = t.createFramebuffer(), d)
                            if (r.drawBuffers) {
                                const n = e.texture;
                                for (let e = 0, r = n.length; e < r; e++) {
                                    const r = i.get(n[e]);
                                    void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(), o.memory.textures++)
                                }
                            } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                        else if (p)
                            if (a) {
                                c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
                                const i = s.convert(l.format),
                                    r = s.convert(l.type),
                                    o = _(l.internalFormat, i, r),
                                    a = N(e);
                                t.renderbufferStorageMultisample(36161, a, o, e.width, e.height), n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), D(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null)
                            } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                        if (u) {
                            n.bindTexture(34067, h.__webglTexture), R(34067, l, f);
                            for (let t = 0; t < 6; t++) I(c.__webglFramebuffer[t], e, l, 36064, 34069 + t);
                            y(l, f) && x(34067, l, e.width, e.height), n.bindTexture(34067, null)
                        } else if (d) {
                            const t = e.texture;
                            for (let r = 0, s = t.length; r < s; r++) {
                                const s = t[r],
                                    o = i.get(s);
                                n.bindTexture(3553, o.__webglTexture), R(3553, s, f), I(c.__webglFramebuffer, e, s, 36064 + r, 3553), y(s, f) && x(3553, s, e.width, e.height)
                            }
                            n.bindTexture(3553, null)
                        } else {
                            let t = 3553;
                            m && (a ? t = l.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), n.bindTexture(t, h.__webglTexture), R(t, l, f), I(c.__webglFramebuffer, e, l, 36064, t), y(l, f) && x(t, l, e.width, e.height, e.depth), n.bindTexture(t, null)
                        }
                        e.depthBuffer && function(e) {
                            const r = i.get(e),
                                s = !0 === e.isWebGLCubeRenderTarget;
                            if (e.depthTexture) {
                                if (s) throw new Error("target.depthTexture not supported in Cube render targets");
                                ! function(e, r) {
                                    if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                                    if (n.bindFramebuffer(36160, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                                    i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), T(r.depthTexture, 0);
                                    const s = i.get(r.depthTexture).__webglTexture;
                                    if (r.depthTexture.format === qt) t.framebufferTexture2D(36160, 36096, 3553, s, 0);
                                    else {
                                        if (r.depthTexture.format !== Xt) throw new Error("Unknown depthTexture format");
                                        t.framebufferTexture2D(36160, 33306, 3553, s, 0)
                                    }
                                }(r.__webglFramebuffer, e)
                            } else if (s) { r.__webglDepthbuffer = []; for (let i = 0; i < 6; i++) n.bindFramebuffer(36160, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = t.createRenderbuffer(), D(r.__webglDepthbuffer[i], e, !1) } else n.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), D(r.__webglDepthbuffer, e, !1);
                            n.bindFramebuffer(36160, null)
                        }(e)
                    }, this.updateRenderTargetMipmap = function(t) {
                        const e = v(t) || a,
                            r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                        for (let s = 0, o = r.length; s < o; s++) {
                            const o = r[s];
                            if (y(o, e)) {
                                const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                                    r = i.get(o).__webglTexture;
                                n.bindTexture(e, r), x(e, o, t.width, t.height), n.bindTexture(e, null)
                            }
                        }
                    }, this.updateMultisampleRenderTarget = function(e) {
                        if (e.isWebGLMultisampleRenderTarget)
                            if (a) {
                                const r = e.width,
                                    s = e.height;
                                let o = 16384;
                                e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024);
                                const a = i.get(e);
                                n.bindFramebuffer(36008, a.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, a.__webglFramebuffer), t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, o, 9728), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, a.__webglMultisampledFramebuffer)
                            } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                    }, this.safeSetTexture2D = function(t, e) { t && t.isWebGLRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), B = !0), t = t.texture), T(t, e) }, this.safeSetTextureCube = function(t, e) { t && t.isWebGLCubeRenderTarget && (!1 === O && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), O = !0), t = t.texture), E(t, e) }
                }

                function Ja(t, e, n) { const i = n.isWebGL2; return { convert: function(t) { let n; if (t === Lt) return 5121; if (t === Ot) return 32819; if (t === Ft) return 32820; if (t === zt) return 33635; if (t === Rt) return 5120; if (t === Ct) return 5122; if (t === Pt) return 5123; if (t === It) return 5124; if (t === Dt) return 5125; if (t === Nt) return 5126; if (t === Bt) return i ? 5131 : (n = e.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null); if (t === Ht) return 6406; if (t === kt) return 6407; if (t === Gt) return 6408; if (t === Vt) return 6409; if (t === Wt) return 6410; if (t === qt) return 6402; if (t === Xt) return 34041; if (t === Yt) return 6403; if (t === Zt) return 36244; if (t === Jt) return 33319; if (t === Kt) return 33320; if (t === Qt) return 36248; if (t === $t) return 36249; if (t === te || t === ee || t === ne || t === ie) { if (n = e.get("WEBGL_compressed_texture_s3tc"), null === n) return null; if (t === te) return n.COMPRESSED_RGB_S3TC_DXT1_EXT; if (t === ee) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (t === ne) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (t === ie) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (t === re || t === se || t === oe || t === ae) { if (n = e.get("WEBGL_compressed_texture_pvrtc"), null === n) return null; if (t === re) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (t === se) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (t === oe) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (t === ae) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (t === le) return n = e.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null; if ((t === ce || t === he) && (n = e.get("WEBGL_compressed_texture_etc"), null !== n)) { if (t === ce) return n.COMPRESSED_RGB8_ETC2; if (t === he) return n.COMPRESSED_RGBA8_ETC2_EAC } return t === ue || t === de || t === pe || t === me || t === fe || t === ge || t === ve || t === ye || t === xe || t === _e || t === be || t === we || t === Me || t === Se || t === Ee || t === Ae || t === Le || t === Re || t === Ce || t === Pe || t === Ie || t === De || t === Ne || t === Be || t === Oe || t === Fe || t === ze || t === Ue ? (n = e.get("WEBGL_compressed_texture_astc"), null !== n ? t : null) : t === Te ? (n = e.get("EXT_texture_compression_bptc"), null !== n ? t : null) : t === Ut ? i ? 34042 : (n = e.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0 } } }
                qa.prototype.isMeshDistanceMaterial = !0;
                class Ka extends Cs { constructor(t = []) { super(), this.cameras = t } }
                Ka.prototype.isArrayCamera = !0;
                class Qa extends pr { constructor() { super(), this.type = "Group" } }
                Qa.prototype.isGroup = !0;
                const $a = { type: "move" };
                class tl {
                    constructor() { this._targetRay = null, this._grip = null, this._hand = null }
                    getHandSpace() { return null === this._hand && (this._hand = new Qa, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand }
                    getTargetRaySpace() { return null === this._targetRay && (this._targetRay = new Qa, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new ui, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new ui), this._targetRay }
                    getGripSpace() { return null === this._grip && (this._grip = new Qa, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new ui, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new ui), this._grip }
                    dispatchEvent(t) { return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this }
                    disconnect(t) { return this.dispatchEvent({ type: "disconnected", data: t }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this }
                    update(t, e, n) {
                        let i = null,
                            r = null,
                            s = null;
                        const o = this._targetRay,
                            a = this._grip,
                            l = this._hand;
                        if (t && "visible-blurred" !== e.session.visibilityState)
                            if (null !== o && (i = e.getPose(t.targetRaySpace, n), null !== i && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent($a))), l && t.hand) {
                                s = !0;
                                for (const i of t.hand.values()) {
                                    const t = e.getJointPose(i, n);
                                    if (void 0 === l.joints[i.jointName]) {
                                        const t = new Qa;
                                        t.matrixAutoUpdate = !1, t.visible = !1, l.joints[i.jointName] = t, l.add(t)
                                    }
                                    const r = l.joints[i.jointName];
                                    null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = t.radius), r.visible = null !== t
                                }
                                const i = l.joints["index-finger-tip"],
                                    r = l.joints["thumb-tip"],
                                    o = i.position.distanceTo(r.position),
                                    a = .02,
                                    c = .005;
                                l.inputState.pinching && o > a + c ? (l.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this })) : !l.inputState.pinching && o <= a - c && (l.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this }))
                            } else null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1));
                        return null !== o && (o.visible = null !== i), null !== a && (a.visible = null !== r), null !== l && (l.visible = null !== s), this
                    }
                }
                class el extends Hn {
                    constructor(t, e) {
                        super();
                        const n = this,
                            i = t.state;
                        let r = null,
                            s = 1,
                            o = null,
                            a = "local-floor",
                            l = null,
                            c = null,
                            h = null,
                            u = null;
                        const d = [],
                            p = new Map,
                            m = new Cs;
                        m.layers.enable(1), m.viewport = new oi;
                        const f = new Cs;
                        f.layers.enable(2), f.viewport = new oi;
                        const g = [m, f],
                            v = new Ka;
                        v.layers.enable(1), v.layers.enable(2);
                        let y = null,
                            x = null;

                        function _(t) {
                            const e = p.get(t.inputSource);
                            e && e.dispatchEvent({ type: t.type, data: t.inputSource })
                        }

                        function b() { p.forEach((function(t, e) { t.disconnect(e) })), p.clear(), y = null, x = null, i.bindXRFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), A.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" }) }

                        function w(t) {
                            const e = r.inputSources;
                            for (let t = 0; t < d.length; t++) p.set(e[t], d[t]);
                            for (let e = 0; e < t.removed.length; e++) {
                                const n = t.removed[e],
                                    i = p.get(n);
                                i && (i.dispatchEvent({ type: "disconnected", data: n }), p.delete(n))
                            }
                            for (let e = 0; e < t.added.length; e++) {
                                const n = t.added[e],
                                    i = p.get(n);
                                i && i.dispatchEvent({ type: "connected", data: n })
                            }
                        }
                        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(t) { let e = d[t]; return void 0 === e && (e = new tl, d[t] = e), e.getTargetRaySpace() }, this.getControllerGrip = function(t) { let e = d[t]; return void 0 === e && (e = new tl, d[t] = e), e.getGripSpace() }, this.getHand = function(t) { let e = d[t]; return void 0 === e && (e = new tl, d[t] = e), e.getHandSpace() }, this.setFramebufferScaleFactor = function(t) { s = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function(t) { a = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function() { return o }, this.getSession = function() { return r }, this.setSession = async function(t) {
                            if (r = t, null !== r) {
                                r.addEventListener("select", _), r.addEventListener("selectstart", _), r.addEventListener("selectend", _), r.addEventListener("squeeze", _), r.addEventListener("squeezestart", _), r.addEventListener("squeezeend", _), r.addEventListener("end", b), r.addEventListener("inputsourceschange", w);
                                const t = e.getContextAttributes();
                                if (!0 !== t.xrCompatible && await e.makeXRCompatible(), void 0 === r.renderState.layers) {
                                    const n = { antialias: t.antialias, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: s },
                                        i = new XRWebGLLayer(r, e, n);
                                    r.updateRenderState({ baseLayer: i })
                                } else {
                                    let n = 0;
                                    t.depth && (n = t.stencil ? 34041 : 6402);
                                    const i = { colorFormat: t.alpha ? 6408 : 6407, depthFormat: n, scaleFactor: s };
                                    c = new XRWebGLBinding(r, e), u = c.createProjectionLayer(i), h = e.createFramebuffer(), r.updateRenderState({ layers: [u] })
                                }
                                o = await r.requestReferenceSpace(a), A.setContext(r), A.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" })
                            }
                        };
                        const M = new ui,
                            S = new ui;

                        function T(t, e) { null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert() }
                        this.updateCamera = function(t) {
                            if (null === r) return;
                            v.near = f.near = m.near = t.near, v.far = f.far = m.far = t.far, y === v.near && x === v.far || (r.updateRenderState({ depthNear: v.near, depthFar: v.far }), y = v.near, x = v.far);
                            const e = t.parent,
                                n = v.cameras;
                            T(v, e);
                            for (let t = 0; t < n.length; t++) T(n[t], e);
                            v.matrixWorld.decompose(v.position, v.quaternion, v.scale), t.position.copy(v.position), t.quaternion.copy(v.quaternion), t.scale.copy(v.scale), t.matrix.copy(v.matrix), t.matrixWorld.copy(v.matrixWorld);
                            const i = t.children;
                            for (let t = 0, e = i.length; t < e; t++) i[t].updateMatrixWorld(!0);
                            2 === n.length ? function(t, e, n) {
                                M.setFromMatrixPosition(e.matrixWorld), S.setFromMatrixPosition(n.matrixWorld);
                                const i = M.distanceTo(S),
                                    r = e.projectionMatrix.elements,
                                    s = n.projectionMatrix.elements,
                                    o = r[14] / (r[10] - 1),
                                    a = r[14] / (r[10] + 1),
                                    l = (r[9] + 1) / r[5],
                                    c = (r[9] - 1) / r[5],
                                    h = (r[8] - 1) / r[0],
                                    u = (s[8] + 1) / s[0],
                                    d = o * h,
                                    p = o * u,
                                    m = i / (-h + u),
                                    f = m * -h;
                                e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(f), t.translateZ(m), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                                const g = o + m,
                                    v = a + m,
                                    y = d - f,
                                    x = p + (i - f),
                                    _ = l * a / v * g,
                                    b = c * a / v * g;
                                t.projectionMatrix.makePerspective(y, x, _, b, g, v)
                            }(v, m, f) : v.projectionMatrix.copy(m.projectionMatrix)
                        }, this.getCamera = function() { return v };
                        let E = null;
                        const A = new Gs;
                        A.setAnimationLoop((function(t, n) {
                            if (l = n.getViewerPose(o), null !== l) {
                                const t = l.views,
                                    n = r.renderState.baseLayer;
                                void 0 === r.renderState.layers && i.bindXRFramebuffer(n.framebuffer);
                                let s = !1;
                                t.length !== v.cameras.length && (v.cameras.length = 0, s = !0);
                                for (let o = 0; o < t.length; o++) {
                                    const a = t[o];
                                    let l = null;
                                    if (void 0 === r.renderState.layers) l = n.getViewport(a);
                                    else {
                                        const t = c.getViewSubImage(u, a);
                                        i.bindXRFramebuffer(h), e.framebufferTexture2D(36160, 36064, 3553, t.colorTexture, 0), void 0 !== t.depthStencilTexture && e.framebufferTexture2D(36160, 36096, 3553, t.depthStencilTexture, 0), l = t.viewport
                                    }
                                    const d = g[o];
                                    d.matrix.fromArray(a.transform.matrix), d.projectionMatrix.fromArray(a.projectionMatrix), d.viewport.set(l.x, l.y, l.width, l.height), 0 === o && v.matrix.copy(d.matrix), !0 === s && v.cameras.push(d)
                                }
                            }
                            const s = r.inputSources;
                            for (let t = 0; t < d.length; t++) {
                                const e = d[t],
                                    i = s[t];
                                e.update(i, n, o)
                            }
                            E && E(t, n)
                        })), this.setAnimationLoop = function(t) { E = t }, this.dispose = function() {}
                    }
                }

                function nl(t) {
                    function e(e, n) {
                        e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap);
                        const i = t.get(n).envMap;
                        if (i) {
                            e.envMap.value = i, e.flipEnvMap.value = i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio;
                            const r = t.get(i).__maxMipLevel;
                            void 0 !== r && (e.maxMipLevel.value = r)
                        }
                        let r, s;
                        n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uv2Transform.value.copy(s.matrix))
                    }

                    function n(e, n) { e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, n.side === x && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), n.side === x && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity) }
                    return {
                        refreshFogUniforms: function(t, e) { t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density) },
                        refreshMaterialUniforms: function(t, i, r, s, o) {
                            i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i), function(t, e) { e.emissiveMap && (t.emissiveMap.value = e.emissiveMap) }(t, i)) : i.isMeshToonMaterial ? (e(t, i), function(t, e) { e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === x && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === x && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshPhongMaterial ? (e(t, i), function(t, e) { t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === x && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === x && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshStandardMaterial ? (e(t, i), i.isMeshPhysicalMaterial ? function(t, e, i) { n(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen), e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === x && t.clearcoatNormalScale.value.negate()), t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), e.transmission > 0 && (t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height)), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor) }(t, i, o) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i), function(t, e) { e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === x && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === x && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshDepthMaterial ? (e(t, i), function(t, e) { e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i), function(t, e) { e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance }(t, i)) : i.isMeshNormalMaterial ? (e(t, i), function(t, e) { e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === x && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === x && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isLineBasicMaterial ? (function(t, e) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity }(t, i), i.isLineDashedMaterial && function(t, e) { t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale }(t, i)) : i.isPointsMaterial ? function(t, e, n, i) {
                                let r;
                                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.map ? r = e.map : e.alphaMap && (r = e.alphaMap), void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
                            }(t, i, r, s) : i.isSpriteMaterial ? function(t, e) {
                                let n;
                                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.map ? n = e.map : e.alphaMap && (n = e.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                            }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                        }
                    }
                }

                function il(t = {}) {
                    const e = void 0 !== t.canvas ? t.canvas : function() { const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); return t.style.display = "block", t }(),
                        n = void 0 !== t.context ? t.context : null,
                        i = void 0 !== t.alpha && t.alpha,
                        r = void 0 === t.depth || t.depth,
                        s = void 0 === t.stencil || t.stencil,
                        o = void 0 !== t.antialias && t.antialias,
                        a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                        l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                        c = void 0 !== t.powerPreference ? t.powerPreference : "default",
                        h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
                    let u = null,
                        d = null;
                    const p = [],
                        m = [];
                    this.domElement = e, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = tn, this.physicallyCorrectLights = !1, this.toneMapping = nt, this.toneMappingExposure = 1;
                    const f = this;
                    let g = !1,
                        v = 0,
                        b = 0,
                        w = null,
                        M = -1,
                        S = null;
                    const T = new oi,
                        E = new oi;
                    let A = null,
                        L = e.width,
                        R = e.height,
                        C = 1,
                        P = null,
                        I = null;
                    const D = new oi(0, 0, L, R),
                        N = new oi(0, 0, L, R);
                    let B = !1;
                    const O = [],
                        F = new ks;
                    let z = !1,
                        U = !1,
                        H = null;
                    const k = new Gi,
                        G = new ui,
                        V = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };

                    function W() { return null === w ? C : 1 }
                    let j, q, X, Y, Z, J, K, Q, $, tt, et, it, rt, st, ot, at, lt, ct, ht, ut, dt, pt, mt = n;

                    function ft(t, n) {
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i],
                                s = e.getContext(r, n);
                            if (null !== s) return s
                        }
                        return null
                    }
                    try {
                        const t = { alpha: i, depth: r, stencil: s, antialias: o, premultipliedAlpha: a, preserveDrawingBuffer: l, powerPreference: c, failIfMajorPerformanceCaveat: h };
                        if (e.addEventListener("webglcontextlost", _t, !1), e.addEventListener("webglcontextrestored", bt, !1), null === mt) { const e = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === f.isWebGL1Renderer && e.shift(), mt = ft(e, t), null === mt) throw ft(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") }
                        void 0 === mt.getShaderPrecisionFormat && (mt.getShaderPrecisionFormat = function() { return { rangeMin: 1, rangeMax: 1, precision: 1 } })
                    } catch (t) { throw console.error("THREE.WebGLRenderer: " + t.message), t }

                    function vt() { j = new to(mt), q = new Ks(mt, j, t), j.init(q), dt = new Ja(mt, j, q), X = new Ya(mt, j, q), O[0] = 1029, Y = new io(mt), Z = new Na, J = new Za(mt, j, X, Z, q, dt, Y), K = new $s(f), Q = new Vs(mt, q), pt = new Zs(mt, j, Q, q), $ = new eo(mt, Q, Y, pt), tt = new ao(mt, $, Q, Y), ct = new oo(mt), ot = new Qs(Z), et = new Da(f, K, j, q, pt, ot), it = new nl(Z), rt = new za(Z), st = new Wa(j, q), lt = new Ys(f, K, X, tt, a), at = new Xa(f, tt, q), ht = new Js(mt, j, Y, q), ut = new no(mt, j, Y, q), Y.programs = et.programs, f.capabilities = q, f.extensions = j, f.properties = Z, f.renderLists = rt, f.shadowMap = at, f.state = X, f.info = Y }
                    vt();
                    const xt = new el(f, mt);

                    function _t(t) { t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0 }

                    function bt() {
                        console.log("THREE.WebGLRenderer: Context Restored."), g = !1;
                        const t = Y.autoReset,
                            e = at.enabled,
                            n = at.autoUpdate,
                            i = at.needsUpdate,
                            r = at.type;
                        vt(), Y.autoReset = t, at.enabled = e, at.autoUpdate = n, at.needsUpdate = i, at.type = r
                    }

                    function wt(t) {
                        const e = t.target;
                        e.removeEventListener("dispose", wt),
                            function(t) {
                                (function(t) {
                                    const e = Z.get(t).programs;
                                    void 0 !== e && e.forEach((function(t) { et.releaseProgram(t) }))
                                })(t), Z.remove(t)
                            }(e)
                    }
                    this.xr = xt, this.getContext = function() { return mt }, this.getContextAttributes = function() { return mt.getContextAttributes() }, this.forceContextLoss = function() {
                        const t = j.get("WEBGL_lose_context");
                        t && t.loseContext()
                    }, this.forceContextRestore = function() {
                        const t = j.get("WEBGL_lose_context");
                        t && t.restoreContext()
                    }, this.getPixelRatio = function() { return C }, this.setPixelRatio = function(t) { void 0 !== t && (C = t, this.setSize(L, R, !1)) }, this.getSize = function(t) { return t.set(L, R) }, this.setSize = function(t, n, i) { xt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (L = t, R = n, e.width = Math.floor(t * C), e.height = Math.floor(n * C), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n)) }, this.getDrawingBufferSize = function(t) { return t.set(L * C, R * C).floor() }, this.setDrawingBufferSize = function(t, n, i) { L = t, R = n, C = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n) }, this.getCurrentViewport = function(t) { return t.copy(T) }, this.getViewport = function(t) { return t.copy(D) }, this.setViewport = function(t, e, n, i) { t.isVector4 ? D.set(t.x, t.y, t.z, t.w) : D.set(t, e, n, i), X.viewport(T.copy(D).multiplyScalar(C).floor()) }, this.getScissor = function(t) { return t.copy(N) }, this.setScissor = function(t, e, n, i) { t.isVector4 ? N.set(t.x, t.y, t.z, t.w) : N.set(t, e, n, i), X.scissor(E.copy(N).multiplyScalar(C).floor()) }, this.getScissorTest = function() { return B }, this.setScissorTest = function(t) { X.setScissorTest(B = t) }, this.setOpaqueSort = function(t) { P = t }, this.setTransparentSort = function(t) { I = t }, this.getClearColor = function(t) { return t.copy(lt.getClearColor()) }, this.setClearColor = function() { lt.setClearColor.apply(lt, arguments) }, this.getClearAlpha = function() { return lt.getClearAlpha() }, this.setClearAlpha = function() { lt.setClearAlpha.apply(lt, arguments) }, this.clear = function(t, e, n) {
                        let i = 0;
                        (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), mt.clear(i)
                    }, this.clearColor = function() { this.clear(!0, !1, !1) }, this.clearDepth = function() { this.clear(!1, !0, !1) }, this.clearStencil = function() { this.clear(!1, !1, !0) }, this.dispose = function() { e.removeEventListener("webglcontextlost", _t, !1), e.removeEventListener("webglcontextrestored", bt, !1), rt.dispose(), st.dispose(), Z.dispose(), K.dispose(), tt.dispose(), pt.dispose(), xt.dispose(), xt.removeEventListener("sessionstart", St), xt.removeEventListener("sessionend", Tt), H && (H.dispose(), H = null), At.stop() }, this.renderBufferImmediate = function(t, e) {
                        pt.initAttributes();
                        const n = Z.get(t);
                        t.hasPositions && !n.position && (n.position = mt.createBuffer()), t.hasNormals && !n.normal && (n.normal = mt.createBuffer()), t.hasUvs && !n.uv && (n.uv = mt.createBuffer()), t.hasColors && !n.color && (n.color = mt.createBuffer());
                        const i = e.getAttributes();
                        t.hasPositions && (mt.bindBuffer(34962, n.position), mt.bufferData(34962, t.positionArray, 35048), pt.enableAttribute(i.position), mt.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), t.hasNormals && (mt.bindBuffer(34962, n.normal), mt.bufferData(34962, t.normalArray, 35048), pt.enableAttribute(i.normal), mt.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (mt.bindBuffer(34962, n.uv), mt.bufferData(34962, t.uvArray, 35048), pt.enableAttribute(i.uv), mt.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), t.hasColors && (mt.bindBuffer(34962, n.color), mt.bufferData(34962, t.colorArray, 35048), pt.enableAttribute(i.color), mt.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), pt.disableUnusedAttributes(), mt.drawArrays(4, 0, t.count), t.count = 0
                    }, this.renderBufferDirect = function(t, e, n, i, r, s) {
                        null === e && (e = V);
                        const o = r.isMesh && r.matrixWorld.determinant() < 0,
                            a = Ot(t, e, i, r);
                        X.setMaterial(i, o);
                        let l = n.index;
                        const c = n.attributes.position;
                        if (null === l) { if (void 0 === c || 0 === c.count) return } else if (0 === l.count) return;
                        let h, u = 1;
                        !0 === i.wireframe && (l = $.getWireframeAttribute(n), u = 2), (i.morphTargets || i.morphNormals) && ct.update(r, n, i, a), pt.setup(r, i, a, n, l);
                        let d = ht;
                        null !== l && (h = Q.get(l), d = ut, d.setIndex(h));
                        const p = null !== l ? l.count : c.count,
                            m = n.drawRange.start * u,
                            f = n.drawRange.count * u,
                            g = null !== s ? s.start * u : 0,
                            v = null !== s ? s.count * u : 1 / 0,
                            y = Math.max(m, g),
                            x = Math.min(p, m + f, g + v) - 1,
                            _ = Math.max(0, x - y + 1);
                        if (0 !== _) {
                            if (r.isMesh) !0 === i.wireframe ? (X.setLineWidth(i.wireframeLinewidth * W()), d.setMode(1)) : d.setMode(4);
                            else if (r.isLine) {
                                let t = i.linewidth;
                                void 0 === t && (t = 1), X.setLineWidth(t * W()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                            } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                            if (r.isInstancedMesh) d.renderInstances(y, _, r.count);
                            else if (n.isInstancedBufferGeometry) {
                                const t = Math.min(n.instanceCount, n._maxInstanceCount);
                                d.renderInstances(y, _, t)
                            } else d.render(y, _)
                        }
                    }, this.compile = function(t, e) {
                        d = st.get(t), d.init(), t.traverseVisible((function(t) { t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t)) })), d.setupLights(), t.traverse((function(e) {
                            const n = e.material;
                            if (n)
                                if (Array.isArray(n))
                                    for (let i = 0; i < n.length; i++) It(n[i], t, e);
                                else It(n, t, e)
                        }))
                    };
                    let Mt = null;

                    function St() { At.stop() }

                    function Tt() { At.start() }
                    const At = new Gs;

                    function Rt(t, e, n, i) {
                        if (!1 === t.visible) return;
                        if (t.layers.test(e.layers))
                            if (t.isGroup) n = t.renderOrder;
                            else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                        else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
                        else if (t.isSprite) {
                            if (!t.frustumCulled || F.intersectsSprite(t)) {
                                i && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(k);
                                const e = tt.update(t),
                                    r = t.material;
                                r.visible && u.push(t, e, r, n, G.z, null)
                            }
                        } else if (t.isImmediateRenderObject) i && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(k), u.push(t, null, t.material, n, G.z, null);
                        else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== Y.render.frame && (t.skeleton.update(), t.skeleton.frame = Y.render.frame), !t.frustumCulled || F.intersectsObject(t))) {
                            i && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(k);
                            const e = tt.update(t),
                                r = t.material;
                            if (Array.isArray(r)) {
                                const i = e.groups;
                                for (let s = 0, o = i.length; s < o; s++) {
                                    const o = i[s],
                                        a = r[o.materialIndex];
                                    a && a.visible && u.push(t, e, a, n, G.z, o)
                                }
                            } else r.visible && u.push(t, e, r, n, G.z, null)
                        }
                        const r = t.children;
                        for (let t = 0, s = r.length; t < s; t++) Rt(r[t], e, n, i)
                    }

                    function Ct(t, e, n) {
                        const i = !0 === e.isScene ? e.overrideMaterial : null;
                        for (let r = 0, s = t.length; r < s; r++) {
                            const s = t[r],
                                o = s.object,
                                a = s.geometry,
                                l = null === i ? s.material : i,
                                c = s.group;
                            if (n.isArrayCamera) {
                                const t = n.cameras;
                                for (let n = 0, i = t.length; n < i; n++) {
                                    const i = t[n];
                                    o.layers.test(i.layers) && (X.viewport(T.copy(i.viewport)), d.setupLightsView(i), Pt(o, e, i, a, l, c))
                                }
                            } else Pt(o, e, n, a, l, c)
                        }
                    }

                    function Pt(t, e, n, i, r, s) {
                        if (t.onBeforeRender(f, e, n, i, r, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                            const i = Ot(n, e, r, t);
                            X.setMaterial(r), pt.reset(),
                                function(t, e) { t.render((function(t) { f.renderBufferImmediate(t, e) })) }(t, i)
                        } else !0 === r.transparent && r.side === _ ? (r.side = x, r.needsUpdate = !0, f.renderBufferDirect(n, e, i, r, t, s), r.side = y, r.needsUpdate = !0, f.renderBufferDirect(n, e, i, r, t, s), r.side = _) : f.renderBufferDirect(n, e, i, r, t, s);
                        t.onAfterRender(f, e, n, i, r, s)
                    }

                    function It(t, e, n) {
                        !0 !== e.isScene && (e = V);
                        const i = Z.get(t),
                            r = d.state.lights,
                            s = d.state.shadowsArray,
                            o = r.state.version,
                            a = et.getParameters(t, r.state, s, e, n),
                            l = et.getProgramCacheKey(a);
                        let c = i.programs;
                        i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = K.get(t.envMap || i.environment), void 0 === c && (t.addEventListener("dispose", wt), c = new Map, i.programs = c);
                        let h = c.get(l);
                        if (void 0 !== h) { if (i.currentProgram === h && i.lightsStateVersion === o) return Dt(t, a), h } else a.uniforms = et.getUniforms(t), t.onBuild(a, f), t.onBeforeCompile(a, f), h = et.acquireProgram(a, l), c.set(l, h), i.uniforms = a.uniforms;
                        const u = i.uniforms;
                        (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = ot.uniform), Dt(t, a), i.needsLights = function(t) { return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights }(t), i.lightsStateVersion = o, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
                        const p = h.getUniforms(),
                            m = da.seqWithValue(p.seq, u);
                        return i.currentProgram = h, i.uniformsList = m, h
                    }

                    function Dt(t, e) {
                        const n = Z.get(t);
                        n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.skinning = e.skinning, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas
                    }

                    function Ot(t, e, n, i) {
                        !0 !== e.isScene && (e = V), J.resetTextureUnits();
                        const r = e.fog,
                            s = n.isMeshStandardMaterial ? e.environment : null,
                            o = null === w ? f.outputEncoding : w.texture.encoding,
                            a = K.get(n.envMap || s),
                            l = !0 === n.vertexColors && i.geometry && i.geometry.attributes.color && 4 === i.geometry.attributes.color.itemSize,
                            c = Z.get(n),
                            h = d.state.lights;
                        if (!0 === z && (!0 === U || t !== S)) {
                            const e = t === S && n.id === M;
                            ot.setState(n, t, e)
                        }
                        let u = !1;
                        n.version === c.__version ? c.needsLights && c.lightsStateVersion !== h.state.version || c.outputEncoding !== o || i.isInstancedMesh && !1 === c.instancing ? u = !0 : i.isInstancedMesh || !0 !== c.instancing ? i.isSkinnedMesh && !1 === c.skinning ? u = !0 : i.isSkinnedMesh || !0 !== c.skinning ? c.envMap !== a || n.fog && c.fog !== r ? u = !0 : void 0 === c.numClippingPlanes || c.numClippingPlanes === ot.numPlanes && c.numIntersection === ot.numIntersection ? c.vertexAlphas !== l && (u = !0) : u = !0 : u = !0 : u = !0 : (u = !0, c.__version = n.version);
                        let p = c.currentProgram;
                        !0 === u && (p = It(n, e, i));
                        let m = !1,
                            g = !1,
                            v = !1;
                        const y = p.getUniforms(),
                            x = c.uniforms;
                        if (X.useProgram(p.program) && (m = !0, g = !0, v = !0), n.id !== M && (M = n.id, g = !0), m || S !== t) {
                            if (y.setValue(mt, "projectionMatrix", t.projectionMatrix), q.logarithmicDepthBuffer && y.setValue(mt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), S !== t && (S = t, g = !0, v = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                                const e = y.map.cameraPosition;
                                void 0 !== e && e.setValue(mt, G.setFromMatrixPosition(t.matrixWorld))
                            }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && y.setValue(mt, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || i.isSkinnedMesh) && y.setValue(mt, "viewMatrix", t.matrixWorldInverse)
                        }
                        if (i.isSkinnedMesh) {
                            y.setOptional(mt, i, "bindMatrix"), y.setOptional(mt, i, "bindMatrixInverse");
                            const t = i.skeleton;
                            t && (q.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), y.setValue(mt, "boneTexture", t.boneTexture, J), y.setValue(mt, "boneTextureSize", t.boneTextureSize)) : y.setOptional(mt, t, "boneMatrices"))
                        }
                        var _, b;
                        return (g || c.receiveShadow !== i.receiveShadow) && (c.receiveShadow = i.receiveShadow, y.setValue(mt, "receiveShadow", i.receiveShadow)), g && (y.setValue(mt, "toneMappingExposure", f.toneMappingExposure), c.needsLights && (b = v, (_ = x).ambientLightColor.needsUpdate = b, _.lightProbe.needsUpdate = b, _.directionalLights.needsUpdate = b, _.directionalLightShadows.needsUpdate = b, _.pointLights.needsUpdate = b, _.pointLightShadows.needsUpdate = b, _.spotLights.needsUpdate = b, _.spotLightShadows.needsUpdate = b, _.rectAreaLights.needsUpdate = b, _.hemisphereLights.needsUpdate = b), r && n.fog && it.refreshFogUniforms(x, r), it.refreshMaterialUniforms(x, n, C, R, H), da.upload(mt, c.uniformsList, x, J)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (da.upload(mt, c.uniformsList, x, J), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && y.setValue(mt, "center", i.center), y.setValue(mt, "modelViewMatrix", i.modelViewMatrix), y.setValue(mt, "normalMatrix", i.normalMatrix), y.setValue(mt, "modelMatrix", i.matrixWorld), p
                    }
                    At.setAnimationLoop((function(t) { Mt && Mt(t) })), "undefined" != typeof window && At.setContext(window), this.setAnimationLoop = function(t) { Mt = t, xt.setAnimationLoop(t), null === t ? At.stop() : At.start() }, xt.addEventListener("sessionstart", St), xt.addEventListener("sessionend", Tt), this.render = function(t, e) {
                        if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                        if (!0 === g) return;
                        !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === xt.enabled && !0 === xt.isPresenting && (!0 === xt.cameraAutoUpdate && xt.updateCamera(e), e = xt.getCamera()), !0 === t.isScene && t.onBeforeRender(f, t, e, w), d = st.get(t, m.length), d.init(), m.push(d), k.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), F.setFromProjectionMatrix(k), U = this.localClippingEnabled, z = ot.init(this.clippingPlanes, U, e), u = rt.get(t, p.length), u.init(), p.push(u), Rt(t, e, 0, f.sortObjects), u.finish(), !0 === f.sortObjects && u.sort(P, I), !0 === z && ot.beginShadows();
                        const n = d.state.shadowsArray;
                        at.render(n, t, e), d.setupLights(), d.setupLightsView(e), !0 === z && ot.endShadows(), !0 === this.info.autoReset && this.info.reset(), lt.render(u, t);
                        const i = u.opaque,
                            r = u.transmissive,
                            s = u.transparent;
                        i.length > 0 && Ct(i, t, e), r.length > 0 && function(t, e, n, i) {
                            if (null === H) {
                                const t = !0 === o && !0 === q.isWebGL2;
                                H = new(t ? ci : ai)(1024, 1024, { generateMipmaps: !0, type: null !== dt.convert(Bt) ? Bt : Lt, minFilter: Et, magFilter: yt, wrapS: gt, wrapT: gt })
                            }
                            const r = f.getRenderTarget();
                            f.setRenderTarget(H), f.clear();
                            const s = f.toneMapping;
                            f.toneMapping = nt, Ct(t, n, i), f.toneMapping = s, J.updateMultisampleRenderTarget(H), J.updateRenderTargetMipmap(H), f.setRenderTarget(r), Ct(e, n, i)
                        }(i, r, t, e), s.length > 0 && Ct(s, t, e), null !== w && (J.updateMultisampleRenderTarget(w), J.updateRenderTargetMipmap(w)), !0 === t.isScene && t.onAfterRender(f, t, e), X.buffers.depth.setTest(!0), X.buffers.depth.setMask(!0), X.buffers.color.setMask(!0), X.setPolygonOffset(!1), pt.resetDefaultState(), M = -1, S = null, m.pop(), d = m.length > 0 ? m[m.length - 1] : null, p.pop(), u = p.length > 0 ? p[p.length - 1] : null
                    }, this.getActiveCubeFace = function() { return v }, this.getActiveMipmapLevel = function() { return b }, this.getRenderTarget = function() { return w }, this.setRenderTarget = function(t, e = 0, n = 0) {
                        w = t, v = e, b = n, t && void 0 === Z.get(t).__webglFramebuffer && J.setupRenderTarget(t);
                        let i = null,
                            r = !1,
                            s = !1;
                        if (t) {
                            const n = t.texture;
                            (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);
                            const o = Z.get(t).__webglFramebuffer;
                            t.isWebGLCubeRenderTarget ? (i = o[e], r = !0) : i = t.isWebGLMultisampleRenderTarget ? Z.get(t).__webglMultisampledFramebuffer : o, T.copy(t.viewport), E.copy(t.scissor), A = t.scissorTest
                        } else T.copy(D).multiplyScalar(C).floor(), E.copy(N).multiplyScalar(C).floor(), A = B;
                        if (X.bindFramebuffer(36160, i) && q.drawBuffers) {
                            let e = !1;
                            if (t)
                                if (t.isWebGLMultipleRenderTargets) {
                                    const n = t.texture;
                                    if (O.length !== n.length || 36064 !== O[0]) {
                                        for (let t = 0, e = n.length; t < e; t++) O[t] = 36064 + t;
                                        O.length = n.length, e = !0
                                    }
                                } else 1 === O.length && 36064 === O[0] || (O[0] = 36064, O.length = 1, e = !0);
                            else 1 === O.length && 1029 === O[0] || (O[0] = 1029, O.length = 1, e = !0);
                            e && (q.isWebGL2 ? mt.drawBuffers(O) : j.get("WEBGL_draw_buffers").drawBuffersWEBGL(O))
                        }
                        if (X.viewport(T), X.scissor(E), X.setScissorTest(A), r) {
                            const i = Z.get(t.texture);
                            mt.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
                        } else if (s) {
                            const i = Z.get(t.texture),
                                r = e || 0;
                            mt.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
                        }
                    }, this.readRenderTargetPixels = function(t, e, n, i, r, s, o) {
                        if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                        let a = Z.get(t).__webglFramebuffer;
                        if (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) {
                            X.bindFramebuffer(36160, a);
                            try {
                                const o = t.texture,
                                    a = o.format,
                                    l = o.type;
                                if (a !== Gt && dt.convert(a) !== mt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                const c = l === Bt && (j.has("EXT_color_buffer_half_float") || q.isWebGL2 && j.has("EXT_color_buffer_float"));
                                if (!(l === Lt || dt.convert(l) === mt.getParameter(35738) || l === Nt && (q.isWebGL2 || j.has("OES_texture_float") || j.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                36053 === mt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && mt.readPixels(e, n, i, r, dt.convert(a), dt.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            } finally {
                                const t = null !== w ? Z.get(w).__webglFramebuffer : null;
                                X.bindFramebuffer(36160, t)
                            }
                        }
                    }, this.copyFramebufferToTexture = function(t, e, n = 0) {
                        const i = Math.pow(2, -n),
                            r = Math.floor(e.image.width * i),
                            s = Math.floor(e.image.height * i);
                        let o = dt.convert(e.format);
                        q.isWebGL2 && (6407 === o && (o = 32849), 6408 === o && (o = 32856)), J.setTexture2D(e, 0), mt.copyTexImage2D(3553, n, o, t.x, t.y, r, s, 0), X.unbindTexture()
                    }, this.copyTextureToTexture = function(t, e, n, i = 0) {
                        const r = e.image.width,
                            s = e.image.height,
                            o = dt.convert(n.format),
                            a = dt.convert(n.type);
                        J.setTexture2D(n, 0), mt.pixelStorei(37440, n.flipY), mt.pixelStorei(37441, n.premultiplyAlpha), mt.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? mt.texSubImage2D(3553, i, t.x, t.y, r, s, o, a, e.image.data) : e.isCompressedTexture ? mt.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : mt.texSubImage2D(3553, i, t.x, t.y, o, a, e.image), 0 === i && n.generateMipmaps && mt.generateMipmap(3553), X.unbindTexture()
                    }, this.copyTextureToTexture3D = function(t, e, n, i, r = 0) {
                        if (f.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                        const s = t.max.x - t.min.x + 1,
                            o = t.max.y - t.min.y + 1,
                            a = t.max.z - t.min.z + 1,
                            l = dt.convert(i.format),
                            c = dt.convert(i.type);
                        let h;
                        if (i.isDataTexture3D) J.setTexture3D(i, 0), h = 32879;
                        else {
                            if (!i.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                            J.setTexture2DArray(i, 0), h = 35866
                        }
                        mt.pixelStorei(37440, i.flipY), mt.pixelStorei(37441, i.premultiplyAlpha), mt.pixelStorei(3317, i.unpackAlignment);
                        const u = mt.getParameter(3314),
                            d = mt.getParameter(32878),
                            p = mt.getParameter(3316),
                            m = mt.getParameter(3315),
                            g = mt.getParameter(32877),
                            v = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                        mt.pixelStorei(3314, v.width), mt.pixelStorei(32878, v.height), mt.pixelStorei(3316, t.min.x), mt.pixelStorei(3315, t.min.y), mt.pixelStorei(32877, t.min.z), n.isDataTexture || n.isDataTexture3D ? mt.texSubImage3D(h, r, e.x, e.y, e.z, s, o, a, l, c, v.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), mt.compressedTexSubImage3D(h, r, e.x, e.y, e.z, s, o, a, l, v.data)) : mt.texSubImage3D(h, r, e.x, e.y, e.z, s, o, a, l, c, v), mt.pixelStorei(3314, u), mt.pixelStorei(32878, d), mt.pixelStorei(3316, p), mt.pixelStorei(3315, m), mt.pixelStorei(32877, g), 0 === r && i.generateMipmaps && mt.generateMipmap(h), X.unbindTexture()
                    }, this.initTexture = function(t) { J.setTexture2D(t, 0), X.unbindTexture() }, this.resetState = function() { v = 0, b = 0, w = null, X.reset(), pt.reset() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }))
                }
                class rl extends il {}
                rl.prototype.isWebGL1Renderer = !0;
                class sl {
                    constructor(t, e = 25e-5) { this.name = "", this.color = new Dr(t), this.density = e }
                    clone() { return new sl(this.color, this.density) }
                    toJSON() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } }
                }
                sl.prototype.isFogExp2 = !0;
                class ol {
                    constructor(t, e = 1, n = 1e3) { this.name = "", this.color = new Dr(t), this.near = e, this.far = n }
                    clone() { return new ol(this.color, this.near, this.far) }
                    toJSON() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } }
                }
                ol.prototype.isFog = !0;
                class al extends pr {
                    constructor() { super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) }
                    copy(t, e) { return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this }
                    toJSON(t) { const e = super.toJSON(t); return null !== this.fog && (e.object.fog = this.fog.toJSON()), e }
                }
                al.prototype.isScene = !0;
                class ll {
                    constructor(t, e) { this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = Rn, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = jn() }
                    onUploadCallback() {}
                    set needsUpdate(t) {!0 === t && this.version++ }
                    setUsage(t) { return this.usage = t, this }
                    copy(t) { return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this }
                    copyAt(t, e, n) { t *= this.stride, n *= e.stride; for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i]; return this }
                    set(t, e = 0) { return this.array.set(t, e), this }
                    clone(t) {
                        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = jn()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                        const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                            n = new this.constructor(e, this.stride);
                        return n.setUsage(this.usage), n
                    }
                    onUpload(t) { return this.onUploadCallback = t, this }
                    toJSON(t) { return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = jn()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } }
                }
                ll.prototype.isInterleavedBuffer = !0;
                const cl = new ui;
                class hl {
                    constructor(t, e, n, i = !1) { this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i }
                    get count() { return this.data.count }
                    get array() { return this.data.array }
                    set needsUpdate(t) { this.data.needsUpdate = t }
                    applyMatrix4(t) { for (let e = 0, n = this.data.count; e < n; e++) cl.x = this.getX(e), cl.y = this.getY(e), cl.z = this.getZ(e), cl.applyMatrix4(t), this.setXYZ(e, cl.x, cl.y, cl.z); return this }
                    applyNormalMatrix(t) { for (let e = 0, n = this.count; e < n; e++) cl.x = this.getX(e), cl.y = this.getY(e), cl.z = this.getZ(e), cl.applyNormalMatrix(t), this.setXYZ(e, cl.x, cl.y, cl.z); return this }
                    transformDirection(t) { for (let e = 0, n = this.count; e < n; e++) cl.x = this.getX(e), cl.y = this.getY(e), cl.z = this.getZ(e), cl.transformDirection(t), this.setXYZ(e, cl.x, cl.y, cl.z); return this }
                    setX(t, e) { return this.data.array[t * this.data.stride + this.offset] = e, this }
                    setY(t, e) { return this.data.array[t * this.data.stride + this.offset + 1] = e, this }
                    setZ(t, e) { return this.data.array[t * this.data.stride + this.offset + 2] = e, this }
                    setW(t, e) { return this.data.array[t * this.data.stride + this.offset + 3] = e, this }
                    getX(t) { return this.data.array[t * this.data.stride + this.offset] }
                    getY(t) { return this.data.array[t * this.data.stride + this.offset + 1] }
                    getZ(t) { return this.data.array[t * this.data.stride + this.offset + 2] }
                    getW(t) { return this.data.array[t * this.data.stride + this.offset + 3] }
                    setXY(t, e, n) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this }
                    setXYZ(t, e, n, i) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this }
                    setXYZW(t, e, n, i, r) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this }
                    clone(t) { if (void 0 === t) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { const n = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e]) } return new Fr(new this.array.constructor(t), this.itemSize, this.normalized) } return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new hl(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) }
                    toJSON(t) { if (void 0 === t) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { const n = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized } } return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } }
                }
                hl.prototype.isInterleavedBufferAttribute = !0;
                class ul extends Er {
                    constructor(t) { super(), this.type = "SpriteMaterial", this.color = new Dr(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this }
                }
                let dl;
                ul.prototype.isSpriteMaterial = !0;
                const pl = new ui,
                    ml = new ui,
                    fl = new ui,
                    gl = new $n,
                    vl = new $n,
                    yl = new Gi,
                    xl = new ui,
                    _l = new ui,
                    bl = new ui,
                    wl = new $n,
                    Ml = new $n,
                    Sl = new $n;
                class Tl extends pr {
                    constructor(t) {
                        if (super(), this.type = "Sprite", void 0 === dl) {
                            dl = new rs;
                            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                                e = new ll(t, 5);
                            dl.setIndex([0, 1, 2, 0, 2, 3]), dl.setAttribute("position", new hl(e, 3, 0, !1)), dl.setAttribute("uv", new hl(e, 2, 3, !1))
                        }
                        this.geometry = dl, this.material = void 0 !== t ? t : new ul, this.center = new $n(.5, .5)
                    }
                    raycast(t, e) {
                        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), ml.setFromMatrixScale(this.matrixWorld), yl.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), fl.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && ml.multiplyScalar(-fl.z);
                        const n = this.material.rotation;
                        let i, r;
                        0 !== n && (r = Math.cos(n), i = Math.sin(n));
                        const s = this.center;
                        El(xl.set(-.5, -.5, 0), fl, s, ml, i, r), El(_l.set(.5, -.5, 0), fl, s, ml, i, r), El(bl.set(.5, .5, 0), fl, s, ml, i, r), wl.set(0, 0), Ml.set(1, 0), Sl.set(1, 1);
                        let o = t.ray.intersectTriangle(xl, _l, bl, !1, pl);
                        if (null === o && (El(_l.set(-.5, .5, 0), fl, s, ml, i, r), Ml.set(0, 1), o = t.ray.intersectTriangle(xl, bl, _l, !1, pl), null === o)) return;
                        const a = t.ray.origin.distanceTo(pl);
                        a < t.near || a > t.far || e.push({ distance: a, point: pl.clone(), uv: Sr.getUV(pl, xl, _l, bl, wl, Ml, Sl, new $n), face: null, object: this })
                    }
                    copy(t) { return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this }
                }

                function El(t, e, n, i, r, s) { gl.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (vl.x = s * gl.x - r * gl.y, vl.y = r * gl.x + s * gl.y) : vl.copy(gl), t.copy(e), t.x += vl.x, t.y += vl.y, t.applyMatrix4(yl) }
                Tl.prototype.isSprite = !0;
                const Al = new ui,
                    Ll = new ui;
                class Rl extends pr {
                    constructor() { super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }), this.autoUpdate = !0 }
                    copy(t) {
                        super.copy(t, !1);
                        const e = t.levels;
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            this.addLevel(n.object.clone(), n.distance)
                        }
                        return this.autoUpdate = t.autoUpdate, this
                    }
                    addLevel(t, e = 0) { e = Math.abs(e); const n = this.levels; let i; for (i = 0; i < n.length && !(e < n[i].distance); i++); return n.splice(i, 0, { distance: e, object: t }), this.add(t), this }
                    getCurrentLevel() { return this._currentLevel }
                    getObjectForDistance(t) { const e = this.levels; if (e.length > 0) { let n, i; for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++); return e[n - 1].object } return null }
                    raycast(t, e) {
                        if (this.levels.length > 0) {
                            Al.setFromMatrixPosition(this.matrixWorld);
                            const n = t.ray.origin.distanceTo(Al);
                            this.getObjectForDistance(n).raycast(t, e)
                        }
                    }
                    update(t) { const e = this.levels; if (e.length > 1) { Al.setFromMatrixPosition(t.matrixWorld), Ll.setFromMatrixPosition(this.matrixWorld); const n = Al.distanceTo(Ll) / t.zoom; let i, r; for (e[0].object.visible = !0, i = 1, r = e.length; i < r && n >= e[i].distance; i++) e[i - 1].object.visible = !1, e[i].object.visible = !0; for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1 } }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = [];
                        const n = this.levels;
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            e.object.levels.push({ object: i.object.uuid, distance: i.distance })
                        }
                        return e
                    }
                }
                const Cl = new ui,
                    Pl = new oi,
                    Il = new oi,
                    Dl = new ui,
                    Nl = new Gi;
                class Bl extends ws {
                    constructor(t, e) { super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Gi, this.bindMatrixInverse = new Gi }
                    copy(t) { return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this }
                    bind(t, e) { this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert() }
                    pose() { this.skeleton.pose() }
                    normalizeSkinWeights() {
                        const t = new oi,
                            e = this.geometry.attributes.skinWeight;
                        for (let n = 0, i = e.count; n < i; n++) {
                            t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                            const i = 1 / t.manhattanLength();
                            i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                        }
                    }
                    updateMatrixWorld(t) { super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) }
                    boneTransform(t, e) {
                        const n = this.skeleton,
                            i = this.geometry;
                        Pl.fromBufferAttribute(i.attributes.skinIndex, t), Il.fromBufferAttribute(i.attributes.skinWeight, t), Cl.fromBufferAttribute(i.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                        for (let t = 0; t < 4; t++) {
                            const i = Il.getComponent(t);
                            if (0 !== i) {
                                const r = Pl.getComponent(t);
                                Nl.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(Dl.copy(Cl).applyMatrix4(Nl), i)
                            }
                        }
                        return e.applyMatrix4(this.bindMatrixInverse)
                    }
                }
                Bl.prototype.isSkinnedMesh = !0;
                class Ol extends pr { constructor() { super(), this.type = "Bone" } }
                Ol.prototype.isBone = !0;
                class Fl extends ri { constructor(t = null, e = 1, n = 1, i, r, s, o, a, l = yt, c = yt, h, u) { super(null, s, o, a, l, c, i, r, h, u), this.image = { data: t, width: e, height: n }, this.magFilter = l, this.minFilter = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } }
                Fl.prototype.isDataTexture = !0;
                const zl = new Gi,
                    Ul = new Gi;
                class Hl {
                    constructor(t = [], e = []) { this.uuid = jn(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init() }
                    init() {
                        const t = this.bones,
                            e = this.boneInverses;
                        if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();
                        else if (t.length !== e.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Gi) }
                    }
                    calculateInverses() {
                        this.boneInverses.length = 0;
                        for (let t = 0, e = this.bones.length; t < e; t++) {
                            const e = new Gi;
                            this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
                        }
                    }
                    pose() {
                        for (let t = 0, e = this.bones.length; t < e; t++) {
                            const e = this.bones[t];
                            e && e.matrixWorld.copy(this.boneInverses[t]).invert()
                        }
                        for (let t = 0, e = this.bones.length; t < e; t++) {
                            const e = this.bones[t];
                            e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                        }
                    }
                    update() {
                        const t = this.bones,
                            e = this.boneInverses,
                            n = this.boneMatrices,
                            i = this.boneTexture;
                        for (let i = 0, r = t.length; i < r; i++) {
                            const r = t[i] ? t[i].matrixWorld : Ul;
                            zl.multiplyMatrices(r, e[i]), zl.toArray(n, 16 * i)
                        }
                        null !== i && (i.needsUpdate = !0)
                    }
                    clone() { return new Hl(this.bones, this.boneInverses) }
                    computeBoneTexture() {
                        let t = Math.sqrt(4 * this.bones.length);
                        t = Jn(t), t = Math.max(t, 4);
                        const e = new Float32Array(t * t * 4);
                        e.set(this.boneMatrices);
                        const n = new Fl(e, t, t, Gt, Nt);
                        return this.boneMatrices = e, this.boneTexture = n, this.boneTextureSize = t, this
                    }
                    getBoneByName(t) { for (let e = 0, n = this.bones.length; e < n; e++) { const n = this.bones[e]; if (n.name === t) return n } }
                    dispose() { null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null) }
                    fromJSON(t, e) {
                        this.uuid = t.uuid;
                        for (let n = 0, i = t.bones.length; n < i; n++) {
                            const i = t.bones[n];
                            let r = e[i];
                            void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i), r = new Ol), this.bones.push(r), this.boneInverses.push((new Gi).fromArray(t.boneInverses[n]))
                        }
                        return this.init(), this
                    }
                    toJSON() {
                        const t = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
                        t.uuid = this.uuid;
                        const e = this.bones,
                            n = this.boneInverses;
                        for (let i = 0, r = e.length; i < r; i++) {
                            const r = e[i];
                            t.bones.push(r.uuid);
                            const s = n[i];
                            t.boneInverses.push(s.toArray())
                        }
                        return t
                    }
                }
                const kl = new Gi,
                    Gl = new Gi,
                    Vl = [],
                    Wl = new ws;
                class jl extends ws {
                    constructor(t, e, n) { super(t, e), this.instanceMatrix = new Fr(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1 }
                    copy(t) { return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this }
                    getColorAt(t, e) { e.fromArray(this.instanceColor.array, 3 * t) }
                    getMatrixAt(t, e) { e.fromArray(this.instanceMatrix.array, 16 * t) }
                    raycast(t, e) {
                        const n = this.matrixWorld,
                            i = this.count;
                        if (Wl.geometry = this.geometry, Wl.material = this.material, void 0 !== Wl.material)
                            for (let r = 0; r < i; r++) {
                                this.getMatrixAt(r, kl), Gl.multiplyMatrices(n, kl), Wl.matrixWorld = Gl, Wl.raycast(t, Vl);
                                for (let t = 0, n = Vl.length; t < n; t++) {
                                    const n = Vl[t];
                                    n.instanceId = r, n.object = this, e.push(n)
                                }
                                Vl.length = 0
                            }
                    }
                    setColorAt(t, e) { null === this.instanceColor && (this.instanceColor = new Fr(new Float32Array(3 * this.count), 3)), e.toArray(this.instanceColor.array, 3 * t) }
                    setMatrixAt(t, e) { e.toArray(this.instanceMatrix.array, 16 * t) }
                    updateMorphTargets() {}
                    dispose() { this.dispatchEvent({ type: "dispose" }) }
                }
                jl.prototype.isInstancedMesh = !0;
                class ql extends Er {
                    constructor(t) { super(), this.type = "LineBasicMaterial", this.color = new Dr(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this }
                }
                ql.prototype.isLineBasicMaterial = !0;
                const Xl = new ui,
                    Yl = new ui,
                    Zl = new Gi,
                    Jl = new ki,
                    Kl = new Di;
                class Ql extends pr {
                    constructor(t = new rs, e = new ql) { super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets() }
                    copy(t) { return super.copy(t), this.material = t.material, this.geometry = t.geometry, this }
                    computeLineDistances() {
                        const t = this.geometry;
                        if (t.isBufferGeometry)
                            if (null === t.index) {
                                const e = t.attributes.position,
                                    n = [0];
                                for (let t = 1, i = e.count; t < i; t++) Xl.fromBufferAttribute(e, t - 1), Yl.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += Xl.distanceTo(Yl);
                                t.setAttribute("lineDistance", new qr(n, 1))
                            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                        return this
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            i = this.matrixWorld,
                            r = t.params.Line.threshold,
                            s = n.drawRange;
                        if (null === n.boundingSphere && n.computeBoundingSphere(), Kl.copy(n.boundingSphere), Kl.applyMatrix4(i), Kl.radius += r, !1 === t.ray.intersectsSphere(Kl)) return;
                        Zl.copy(i).invert(), Jl.copy(t.ray).applyMatrix4(Zl);
                        const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            a = o * o,
                            l = new ui,
                            c = new ui,
                            h = new ui,
                            u = new ui,
                            d = this.isLineSegments ? 2 : 1;
                        if (n.isBufferGeometry) {
                            const i = n.index,
                                r = n.attributes.position;
                            if (null !== i)
                                for (let n = Math.max(0, s.start), o = Math.min(i.count, s.start + s.count) - 1; n < o; n += d) {
                                    const s = i.getX(n),
                                        o = i.getX(n + 1);
                                    if (l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, o), Jl.distanceSqToSegment(l, c, u, h) > a) continue;
                                    u.applyMatrix4(this.matrixWorld);
                                    const d = t.ray.origin.distanceTo(u);
                                    d < t.near || d > t.far || e.push({ distance: d, point: h.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this })
                                } else
                                    for (let n = Math.max(0, s.start), i = Math.min(r.count, s.start + s.count) - 1; n < i; n += d) {
                                        if (l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1), Jl.distanceSqToSegment(l, c, u, h) > a) continue;
                                        u.applyMatrix4(this.matrixWorld);
                                        const i = t.ray.origin.distanceTo(u);
                                        i < t.near || i > t.far || e.push({ distance: i, point: h.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this })
                                    }
                        } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                    updateMorphTargets() {
                        const t = this.geometry;
                        if (t.isBufferGeometry) {
                            const e = t.morphAttributes,
                                n = Object.keys(e);
                            if (n.length > 0) {
                                const t = e[n[0]];
                                if (void 0 !== t) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let e = 0, n = t.length; e < n; e++) {
                                        const n = t[e].name || String(e);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                    }
                                }
                            }
                        } else {
                            const e = t.morphTargets;
                            void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                        }
                    }
                }
                Ql.prototype.isLine = !0;
                const $l = new ui,
                    tc = new ui;
                class ec extends Ql {
                    constructor(t, e) { super(t, e), this.type = "LineSegments" }
                    computeLineDistances() {
                        const t = this.geometry;
                        if (t.isBufferGeometry)
                            if (null === t.index) {
                                const e = t.attributes.position,
                                    n = [];
                                for (let t = 0, i = e.count; t < i; t += 2) $l.fromBufferAttribute(e, t), tc.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + $l.distanceTo(tc);
                                t.setAttribute("lineDistance", new qr(n, 1))
                            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                        return this
                    }
                }
                ec.prototype.isLineSegments = !0;
                class nc extends Ql { constructor(t, e) { super(t, e), this.type = "LineLoop" } }
                nc.prototype.isLineLoop = !0;
                class ic extends Er {
                    constructor(t) { super(), this.type = "PointsMaterial", this.color = new Dr(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this }
                }
                ic.prototype.isPointsMaterial = !0;
                const rc = new Gi,
                    sc = new ki,
                    oc = new Di,
                    ac = new ui;
                class lc extends pr {
                    constructor(t = new rs, e = new ic) { super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets() }
                    copy(t) { return super.copy(t), this.material = t.material, this.geometry = t.geometry, this }
                    raycast(t, e) {
                        const n = this.geometry,
                            i = this.matrixWorld,
                            r = t.params.Points.threshold,
                            s = n.drawRange;
                        if (null === n.boundingSphere && n.computeBoundingSphere(), oc.copy(n.boundingSphere), oc.applyMatrix4(i), oc.radius += r, !1 === t.ray.intersectsSphere(oc)) return;
                        rc.copy(i).invert(), sc.copy(t.ray).applyMatrix4(rc);
                        const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            a = o * o;
                        if (n.isBufferGeometry) {
                            const r = n.index,
                                o = n.attributes.position;
                            if (null !== r)
                                for (let n = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); n < l; n++) {
                                    const s = r.getX(n);
                                    ac.fromBufferAttribute(o, s), cc(ac, s, a, i, t, e, this)
                                } else
                                    for (let n = Math.max(0, s.start), r = Math.min(o.count, s.start + s.count); n < r; n++) ac.fromBufferAttribute(o, n), cc(ac, n, a, i, t, e, this)
                        } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                    updateMorphTargets() {
                        const t = this.geometry;
                        if (t.isBufferGeometry) {
                            const e = t.morphAttributes,
                                n = Object.keys(e);
                            if (n.length > 0) {
                                const t = e[n[0]];
                                if (void 0 !== t) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let e = 0, n = t.length; e < n; e++) {
                                        const n = t[e].name || String(e);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                    }
                                }
                            }
                        } else {
                            const e = t.morphTargets;
                            void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                        }
                    }
                }

                function cc(t, e, n, i, r, s, o) {
                    const a = sc.distanceSqToPoint(t);
                    if (a < n) {
                        const n = new ui;
                        sc.closestPointToPoint(t, n), n.applyMatrix4(i);
                        const l = r.ray.origin.distanceTo(n);
                        if (l < r.near || l > r.far) return;
                        s.push({ distance: l, distanceToRay: Math.sqrt(a), point: n, index: e, face: null, object: o })
                    }
                }
                lc.prototype.isPoints = !0;
                class hc extends ri {
                    constructor(t, e, n, i, r, s, o, a, l) { super(t, e, n, i, r, s, o, a, l), this.format = void 0 !== o ? o : kt, this.minFilter = void 0 !== s ? s : Mt, this.magFilter = void 0 !== r ? r : Mt, this.generateMipmaps = !1; const c = this; "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() { c.needsUpdate = !0, t.requestVideoFrameCallback(e) })) }
                    clone() { return new this.constructor(this.image).copy(this) }
                    update() { const t = this.image;!1 == "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0) }
                }
                hc.prototype.isVideoTexture = !0;
                class uc extends ri { constructor(t, e, n, i, r, s, o, a, l, c, h, u) { super(null, s, o, a, l, c, i, r, h, u), this.image = { width: e, height: n }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1 } }
                uc.prototype.isCompressedTexture = !0;
                class dc extends ri { constructor(t, e, n, i, r, s, o, a, l) { super(t, e, n, i, r, s, o, a, l), this.needsUpdate = !0 } }
                dc.prototype.isCanvasTexture = !0;
                class pc extends ri {
                    constructor(t, e, n, i, r, s, o, a, l, c) {
                        if ((c = void 0 !== c ? c : qt) !== qt && c !== Xt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                        void 0 === n && c === qt && (n = Pt), void 0 === n && c === Xt && (n = Ut), super(null, i, r, s, o, a, c, n, l), this.image = { width: t, height: e }, this.magFilter = void 0 !== o ? o : yt, this.minFilter = void 0 !== a ? a : yt, this.flipY = !1, this.generateMipmaps = !1
                    }
                }
                pc.prototype.isDepthTexture = !0;
                class mc extends rs {
                    constructor(t = 1, e = 8, n = 0, i = 2 * Math.PI) {
                        super(), this.type = "CircleGeometry", this.parameters = { radius: t, segments: e, thetaStart: n, thetaLength: i }, e = Math.max(3, e);
                        const r = [],
                            s = [],
                            o = [],
                            a = [],
                            l = new ui,
                            c = new $n;
                        s.push(0, 0, 0), o.push(0, 0, 1), a.push(.5, .5);
                        for (let r = 0, h = 3; r <= e; r++, h += 3) {
                            const u = n + r / e * i;
                            l.x = t * Math.cos(u), l.y = t * Math.sin(u), s.push(l.x, l.y, l.z), o.push(0, 0, 1), c.x = (s[h] / t + 1) / 2, c.y = (s[h + 1] / t + 1) / 2, a.push(c.x, c.y)
                        }
                        for (let t = 1; t <= e; t++) r.push(t, t + 1, 0);
                        this.setIndex(r), this.setAttribute("position", new qr(s, 3)), this.setAttribute("normal", new qr(o, 3)), this.setAttribute("uv", new qr(a, 2))
                    }
                    static fromJSON(t) { return new mc(t.radius, t.segments, t.thetaStart, t.thetaLength) }
                }
                class fc extends rs {
                    constructor(t = 1, e = 1, n = 1, i = 8, r = 1, s = !1, o = 0, a = 2 * Math.PI) {
                        super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: n, radialSegments: i, heightSegments: r, openEnded: s, thetaStart: o, thetaLength: a };
                        const l = this;
                        i = Math.floor(i), r = Math.floor(r);
                        const c = [],
                            h = [],
                            u = [],
                            d = [];
                        let p = 0;
                        const m = [],
                            f = n / 2;
                        let g = 0;

                        function v(n) {
                            const r = p,
                                s = new $n,
                                m = new ui;
                            let v = 0;
                            const y = !0 === n ? t : e,
                                x = !0 === n ? 1 : -1;
                            for (let t = 1; t <= i; t++) h.push(0, f * x, 0), u.push(0, x, 0), d.push(.5, .5), p++;
                            const _ = p;
                            for (let t = 0; t <= i; t++) {
                                const e = t / i * a + o,
                                    n = Math.cos(e),
                                    r = Math.sin(e);
                                m.x = y * r, m.y = f * x, m.z = y * n, h.push(m.x, m.y, m.z), u.push(0, x, 0), s.x = .5 * n + .5, s.y = .5 * r * x + .5, d.push(s.x, s.y), p++
                            }
                            for (let t = 0; t < i; t++) {
                                const e = r + t,
                                    i = _ + t;
                                !0 === n ? c.push(i, i + 1, e) : c.push(i + 1, i, e), v += 3
                            }
                            l.addGroup(g, v, !0 === n ? 1 : 2), g += v
                        }! function() {
                            const s = new ui,
                                v = new ui;
                            let y = 0;
                            const x = (e - t) / n;
                            for (let l = 0; l <= r; l++) {
                                const c = [],
                                    g = l / r,
                                    y = g * (e - t) + t;
                                for (let t = 0; t <= i; t++) {
                                    const e = t / i,
                                        r = e * a + o,
                                        l = Math.sin(r),
                                        m = Math.cos(r);
                                    v.x = y * l, v.y = -g * n + f, v.z = y * m, h.push(v.x, v.y, v.z), s.set(l, x, m).normalize(), u.push(s.x, s.y, s.z), d.push(e, 1 - g), c.push(p++)
                                }
                                m.push(c)
                            }
                            for (let t = 0; t < i; t++)
                                for (let e = 0; e < r; e++) {
                                    const n = m[e][t],
                                        i = m[e + 1][t],
                                        r = m[e + 1][t + 1],
                                        s = m[e][t + 1];
                                    c.push(n, i, s), c.push(i, r, s), y += 6
                                }
                            l.addGroup(g, y, 0), g += y
                        }(), !1 === s && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(c), this.setAttribute("position", new qr(h, 3)), this.setAttribute("normal", new qr(u, 3)), this.setAttribute("uv", new qr(d, 2))
                    }
                    static fromJSON(t) { return new fc(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength) }
                }
                class gc extends fc {
                    constructor(t = 1, e = 1, n = 8, i = 1, r = !1, s = 0, o = 2 * Math.PI) { super(0, t, e, n, i, r, s, o), this.type = "ConeGeometry", this.parameters = { radius: t, height: e, radialSegments: n, heightSegments: i, openEnded: r, thetaStart: s, thetaLength: o } }
                    static fromJSON(t) { return new gc(t.radius, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength) }
                }
                class vc extends rs {
                    constructor(t, e, n = 1, i = 0) {
                        super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: t, indices: e, radius: n, detail: i };
                        const r = [],
                            s = [];

                        function o(t, e, n, i) {
                            const r = i + 1,
                                s = [];
                            for (let i = 0; i <= r; i++) {
                                s[i] = [];
                                const o = t.clone().lerp(n, i / r),
                                    a = e.clone().lerp(n, i / r),
                                    l = r - i;
                                for (let t = 0; t <= l; t++) s[i][t] = 0 === t && i === r ? o : o.clone().lerp(a, t / l)
                            }
                            for (let t = 0; t < r; t++)
                                for (let e = 0; e < 2 * (r - t) - 1; e++) {
                                    const n = Math.floor(e / 2);
                                    e % 2 == 0 ? (a(s[t][n + 1]), a(s[t + 1][n]), a(s[t][n])) : (a(s[t][n + 1]), a(s[t + 1][n + 1]), a(s[t + 1][n]))
                                }
                        }

                        function a(t) { r.push(t.x, t.y, t.z) }

                        function l(e, n) {
                            const i = 3 * e;
                            n.x = t[i + 0], n.y = t[i + 1], n.z = t[i + 2]
                        }

                        function c(t, e, n, i) { i < 0 && 1 === t.x && (s[e] = t.x - 1), 0 === n.x && 0 === n.z && (s[e] = i / 2 / Math.PI + .5) }

                        function h(t) { return Math.atan2(t.z, -t.x) }! function(t) {
                            const n = new ui,
                                i = new ui,
                                r = new ui;
                            for (let s = 0; s < e.length; s += 3) l(e[s + 0], n), l(e[s + 1], i), l(e[s + 2], r), o(n, i, r, t)
                        }(i),
                        function(t) { const e = new ui; for (let n = 0; n < r.length; n += 3) e.x = r[n + 0], e.y = r[n + 1], e.z = r[n + 2], e.normalize().multiplyScalar(t), r[n + 0] = e.x, r[n + 1] = e.y, r[n + 2] = e.z }(n),
                        function() {
                            const t = new ui;
                            for (let n = 0; n < r.length; n += 3) {
                                t.x = r[n + 0], t.y = r[n + 1], t.z = r[n + 2];
                                const i = h(t) / 2 / Math.PI + .5,
                                    o = (e = t, Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5);
                                s.push(i, 1 - o)
                            }
                            var e;
                            (function() {
                                const t = new ui,
                                    e = new ui,
                                    n = new ui,
                                    i = new ui,
                                    o = new $n,
                                    a = new $n,
                                    l = new $n;
                                for (let u = 0, d = 0; u < r.length; u += 9, d += 6) {
                                    t.set(r[u + 0], r[u + 1], r[u + 2]), e.set(r[u + 3], r[u + 4], r[u + 5]), n.set(r[u + 6], r[u + 7], r[u + 8]), o.set(s[d + 0], s[d + 1]), a.set(s[d + 2], s[d + 3]), l.set(s[d + 4], s[d + 5]), i.copy(t).add(e).add(n).divideScalar(3);
                                    const p = h(i);
                                    c(o, d + 0, t, p), c(a, d + 2, e, p), c(l, d + 4, n, p)
                                }
                            })(),
                            function() {
                                for (let t = 0; t < s.length; t += 6) {
                                    const e = s[t + 0],
                                        n = s[t + 2],
                                        i = s[t + 4],
                                        r = Math.max(e, n, i),
                                        o = Math.min(e, n, i);
                                    r > .9 && o < .1 && (e < .2 && (s[t + 0] += 1), n < .2 && (s[t + 2] += 1), i < .2 && (s[t + 4] += 1))
                                }
                            }()
                        }(), this.setAttribute("position", new qr(r, 3)), this.setAttribute("normal", new qr(r.slice(), 3)), this.setAttribute("uv", new qr(s, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals()
                    }
                    static fromJSON(t) { return new vc(t.vertices, t.indices, t.radius, t.details) }
                }
                class yc extends vc {
                    constructor(t = 1, e = 0) {
                        const n = (1 + Math.sqrt(5)) / 2,
                            i = 1 / n;
                        super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronGeometry", this.parameters = { radius: t, detail: e }
                    }
                    static fromJSON(t) { return new yc(t.radius, t.detail) }
                }
                const xc = new ui,
                    _c = new ui,
                    bc = new ui,
                    wc = new Sr;
                class Mc extends rs {
                    constructor(t, e) {
                        if (super(), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: e }, e = void 0 !== e ? e : 1, !0 === t.isGeometry) return void console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                        const n = Math.pow(10, 4),
                            i = Math.cos(Vn * e),
                            r = t.getIndex(),
                            s = t.getAttribute("position"),
                            o = r ? r.count : s.count,
                            a = [0, 0, 0],
                            l = ["a", "b", "c"],
                            c = new Array(3),
                            h = {},
                            u = [];
                        for (let t = 0; t < o; t += 3) {
                            r ? (a[0] = r.getX(t), a[1] = r.getX(t + 1), a[2] = r.getX(t + 2)) : (a[0] = t, a[1] = t + 1, a[2] = t + 2);
                            const { a: e, b: o, c: d } = wc;
                            if (e.fromBufferAttribute(s, a[0]), o.fromBufferAttribute(s, a[1]), d.fromBufferAttribute(s, a[2]), wc.getNormal(bc), c[0] = `${Math.round(e.x*n)},${Math.round(e.y*n)},${Math.round(e.z*n)}`, c[1] = `${Math.round(o.x*n)},${Math.round(o.y*n)},${Math.round(o.z*n)}`, c[2] = `${Math.round(d.x*n)},${Math.round(d.y*n)},${Math.round(d.z*n)}`, c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0])
                                for (let t = 0; t < 3; t++) {
                                    const e = (t + 1) % 3,
                                        n = c[t],
                                        r = c[e],
                                        s = wc[l[t]],
                                        o = wc[l[e]],
                                        d = `${n}_${r}`,
                                        p = `${r}_${n}`;
                                    p in h && h[p] ? (bc.dot(h[p].normal) <= i && (u.push(s.x, s.y, s.z), u.push(o.x, o.y, o.z)), h[p] = null) : d in h || (h[d] = { index0: a[t], index1: a[e], normal: bc.clone() })
                                }
                        }
                        for (const t in h)
                            if (h[t]) {
                                const { index0: e, index1: n } = h[t];
                                xc.fromBufferAttribute(s, e), _c.fromBufferAttribute(s, n), u.push(xc.x, xc.y, xc.z), u.push(_c.x, _c.y, _c.z)
                            }
                        this.setAttribute("position", new qr(u, 3))
                    }
                }
                class Sc {
                    constructor() { this.type = "Curve", this.arcLengthDivisions = 200 }
                    getPoint() { return console.warn("THREE.Curve: .getPoint() not implemented."), null }
                    getPointAt(t, e) { const n = this.getUtoTmapping(t); return this.getPoint(n, e) }
                    getPoints(t = 5) { const e = []; for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t)); return e }
                    getSpacedPoints(t = 5) { const e = []; for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t)); return e }
                    getLength() { const t = this.getLengths(); return t[t.length - 1] }
                    getLengths(t = this.arcLengthDivisions) {
                        if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                        this.needsUpdate = !1;
                        const e = [];
                        let n, i = this.getPoint(0),
                            r = 0;
                        e.push(0);
                        for (let s = 1; s <= t; s++) n = this.getPoint(s / t), r += n.distanceTo(i), e.push(r), i = n;
                        return this.cacheArcLengths = e, e
                    }
                    updateArcLengths() { this.needsUpdate = !0, this.getLengths() }
                    getUtoTmapping(t, e) {
                        const n = this.getLengths();
                        let i = 0;
                        const r = n.length;
                        let s;
                        s = e || t * n[r - 1];
                        let o, a = 0,
                            l = r - 1;
                        for (; a <= l;)
                            if (i = Math.floor(a + (l - a) / 2), o = n[i] - s, o < 0) a = i + 1;
                            else {
                                if (!(o > 0)) { l = i; break }
                                l = i - 1
                            }
                        if (i = l, n[i] === s) return i / (r - 1);
                        const c = n[i];
                        return (i + (s - c) / (n[i + 1] - c)) / (r - 1)
                    }
                    getTangent(t, e) {
                        const n = 1e-4;
                        let i = t - n,
                            r = t + n;
                        i < 0 && (i = 0), r > 1 && (r = 1);
                        const s = this.getPoint(i),
                            o = this.getPoint(r),
                            a = e || (s.isVector2 ? new $n : new ui);
                        return a.copy(o).sub(s).normalize(), a
                    }
                    getTangentAt(t, e) { const n = this.getUtoTmapping(t); return this.getTangent(n, e) }
                    computeFrenetFrames(t, e) {
                        const n = new ui,
                            i = [],
                            r = [],
                            s = [],
                            o = new ui,
                            a = new Gi;
                        for (let e = 0; e <= t; e++) {
                            const n = e / t;
                            i[e] = this.getTangentAt(n, new ui), i[e].normalize()
                        }
                        r[0] = new ui, s[0] = new ui;
                        let l = Number.MAX_VALUE;
                        const c = Math.abs(i[0].x),
                            h = Math.abs(i[0].y),
                            u = Math.abs(i[0].z);
                        c <= l && (l = c, n.set(1, 0, 0)), h <= l && (l = h, n.set(0, 1, 0)), u <= l && n.set(0, 0, 1), o.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], o), s[0].crossVectors(i[0], r[0]);
                        for (let e = 1; e <= t; e++) {
                            if (r[e] = r[e - 1].clone(), s[e] = s[e - 1].clone(), o.crossVectors(i[e - 1], i[e]), o.length() > Number.EPSILON) {
                                o.normalize();
                                const t = Math.acos(qn(i[e - 1].dot(i[e]), -1, 1));
                                r[e].applyMatrix4(a.makeRotationAxis(o, t))
                            }
                            s[e].crossVectors(i[e], r[e])
                        }
                        if (!0 === e) {
                            let e = Math.acos(qn(r[0].dot(r[t]), -1, 1));
                            e /= t, i[0].dot(o.crossVectors(r[0], r[t])) > 0 && (e = -e);
                            for (let n = 1; n <= t; n++) r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)), s[n].crossVectors(i[n], r[n])
                        }
                        return { tangents: i, normals: r, binormals: s }
                    }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { return this.arcLengthDivisions = t.arcLengthDivisions, this }
                    toJSON() { const t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t }
                    fromJSON(t) { return this.arcLengthDivisions = t.arcLengthDivisions, this }
                }
                class Tc extends Sc {
                    constructor(t = 0, e = 0, n = 1, i = 1, r = 0, s = 2 * Math.PI, o = !1, a = 0) { super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = o, this.aRotation = a }
                    getPoint(t, e) {
                        const n = e || new $n,
                            i = 2 * Math.PI;
                        let r = this.aEndAngle - this.aStartAngle;
                        const s = Math.abs(r) < Number.EPSILON;
                        for (; r < 0;) r += i;
                        for (; r > i;) r -= i;
                        r < Number.EPSILON && (r = s ? 0 : i), !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i);
                        const o = this.aStartAngle + t * r;
                        let a = this.aX + this.xRadius * Math.cos(o),
                            l = this.aY + this.yRadius * Math.sin(o);
                        if (0 !== this.aRotation) {
                            const t = Math.cos(this.aRotation),
                                e = Math.sin(this.aRotation),
                                n = a - this.aX,
                                i = l - this.aY;
                            a = n * t - i * e + this.aX, l = n * e + i * t + this.aY
                        }
                        return n.set(a, l)
                    }
                    copy(t) { return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }
                    toJSON() { const t = super.toJSON(); return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t }
                    fromJSON(t) { return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }
                }
                Tc.prototype.isEllipseCurve = !0;
                class Ec extends Tc { constructor(t, e, n, i, r, s) { super(t, e, n, n, i, r, s), this.type = "ArcCurve" } }

                function Ac() {
                    let t = 0,
                        e = 0,
                        n = 0,
                        i = 0;

                    function r(r, s, o, a) { t = r, e = o, n = -3 * r + 3 * s - 2 * o - a, i = 2 * r - 2 * s + o + a }
                    return {
                        initCatmullRom: function(t, e, n, i, s) { r(e, n, s * (n - t), s * (i - e)) },
                        initNonuniformCatmullRom: function(t, e, n, i, s, o, a) {
                            let l = (e - t) / s - (n - t) / (s + o) + (n - e) / o,
                                c = (n - e) / o - (i - e) / (o + a) + (i - n) / a;
                            l *= o, c *= o, r(e, n, l, c)
                        },
                        calc: function(r) { const s = r * r; return t + e * r + n * s + i * (s * r) }
                    }
                }
                Ec.prototype.isArcCurve = !0;
                const Lc = new ui,
                    Rc = new Ac,
                    Cc = new Ac,
                    Pc = new Ac;
                class Ic extends Sc {
                    constructor(t = [], e = !1, n = "centripetal", i = .5) { super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = i }
                    getPoint(t, e = new ui) {
                        const n = e,
                            i = this.points,
                            r = i.length,
                            s = (r - (this.closed ? 0 : 1)) * t;
                        let o, a, l = Math.floor(s),
                            c = s - l;
                        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? o = i[(l - 1) % r] : (Lc.subVectors(i[0], i[1]).add(i[0]), o = Lc);
                        const h = i[l % r],
                            u = i[(l + 1) % r];
                        if (this.closed || l + 2 < r ? a = i[(l + 2) % r] : (Lc.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), a = Lc), "centripetal" === this.curveType || "chordal" === this.curveType) {
                            const t = "chordal" === this.curveType ? .5 : .25;
                            let e = Math.pow(o.distanceToSquared(h), t),
                                n = Math.pow(h.distanceToSquared(u), t),
                                i = Math.pow(u.distanceToSquared(a), t);
                            n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), Rc.initNonuniformCatmullRom(o.x, h.x, u.x, a.x, e, n, i), Cc.initNonuniformCatmullRom(o.y, h.y, u.y, a.y, e, n, i), Pc.initNonuniformCatmullRom(o.z, h.z, u.z, a.z, e, n, i)
                        } else "catmullrom" === this.curveType && (Rc.initCatmullRom(o.x, h.x, u.x, a.x, this.tension), Cc.initCatmullRom(o.y, h.y, u.y, a.y, this.tension), Pc.initCatmullRom(o.z, h.z, u.z, a.z, this.tension));
                        return n.set(Rc.calc(c), Cc.calc(c), Pc.calc(c)), n
                    }
                    copy(t) {
                        super.copy(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push(n.clone())
                        }
                        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.points = [];
                        for (let e = 0, n = this.points.length; e < n; e++) {
                            const n = this.points[e];
                            t.points.push(n.toArray())
                        }
                        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push((new ui).fromArray(n))
                        }
                        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                    }
                }

                function Dc(t, e, n, i, r) {
                    const s = .5 * (i - e),
                        o = .5 * (r - n),
                        a = t * t;
                    return (2 * n - 2 * i + s + o) * (t * a) + (-3 * n + 3 * i - 2 * s - o) * a + s * t + n
                }

                function Nc(t, e, n, i) { return function(t, e) { const n = 1 - t; return n * n * e }(t, e) + function(t, e) { return 2 * (1 - t) * t * e }(t, n) + function(t, e) { return t * t * e }(t, i) }

                function Bc(t, e, n, i, r) { return function(t, e) { const n = 1 - t; return n * n * n * e }(t, e) + function(t, e) { const n = 1 - t; return 3 * n * n * t * e }(t, n) + function(t, e) { return 3 * (1 - t) * t * t * e }(t, i) + function(t, e) { return t * t * t * e }(t, r) }
                Ic.prototype.isCatmullRomCurve3 = !0;
                class Oc extends Sc {
                    constructor(t = new $n, e = new $n, n = new $n, i = new $n) { super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i }
                    getPoint(t, e = new $n) {
                        const n = e,
                            i = this.v0,
                            r = this.v1,
                            s = this.v2,
                            o = this.v3;
                        return n.set(Bc(t, i.x, r.x, s.x, o.x), Bc(t, i.y, r.y, s.y, o.y)), n
                    }
                    copy(t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }
                    toJSON() { const t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }
                }
                Oc.prototype.isCubicBezierCurve = !0;
                class Fc extends Sc {
                    constructor(t = new ui, e = new ui, n = new ui, i = new ui) { super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i }
                    getPoint(t, e = new ui) {
                        const n = e,
                            i = this.v0,
                            r = this.v1,
                            s = this.v2,
                            o = this.v3;
                        return n.set(Bc(t, i.x, r.x, s.x, o.x), Bc(t, i.y, r.y, s.y, o.y), Bc(t, i.z, r.z, s.z, o.z)), n
                    }
                    copy(t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }
                    toJSON() { const t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }
                }
                Fc.prototype.isCubicBezierCurve3 = !0;
                class zc extends Sc {
                    constructor(t = new $n, e = new $n) { super(), this.type = "LineCurve", this.v1 = t, this.v2 = e }
                    getPoint(t, e = new $n) { const n = e; return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n }
                    getPointAt(t, e) { return this.getPoint(t, e) }
                    getTangent(t, e) { const n = e || new $n; return n.copy(this.v2).sub(this.v1).normalize(), n }
                    copy(t) { return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }
                    toJSON() { const t = super.toJSON(); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }
                }
                zc.prototype.isLineCurve = !0;
                class Uc extends Sc {
                    constructor(t = new ui, e = new ui) { super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e }
                    getPoint(t, e = new ui) { const n = e; return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n }
                    getPointAt(t, e) { return this.getPoint(t, e) }
                    copy(t) { return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }
                    toJSON() { const t = super.toJSON(); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }
                }
                class Hc extends Sc {
                    constructor(t = new $n, e = new $n, n = new $n) { super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n }
                    getPoint(t, e = new $n) {
                        const n = e,
                            i = this.v0,
                            r = this.v1,
                            s = this.v2;
                        return n.set(Nc(t, i.x, r.x, s.x), Nc(t, i.y, r.y, s.y)), n
                    }
                    copy(t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }
                    toJSON() { const t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }
                }
                Hc.prototype.isQuadraticBezierCurve = !0;
                class kc extends Sc {
                    constructor(t = new ui, e = new ui, n = new ui) { super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n }
                    getPoint(t, e = new ui) {
                        const n = e,
                            i = this.v0,
                            r = this.v1,
                            s = this.v2;
                        return n.set(Nc(t, i.x, r.x, s.x), Nc(t, i.y, r.y, s.y), Nc(t, i.z, r.z, s.z)), n
                    }
                    copy(t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }
                    toJSON() { const t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }
                }
                kc.prototype.isQuadraticBezierCurve3 = !0;
                class Gc extends Sc {
                    constructor(t = []) { super(), this.type = "SplineCurve", this.points = t }
                    getPoint(t, e = new $n) {
                        const n = e,
                            i = this.points,
                            r = (i.length - 1) * t,
                            s = Math.floor(r),
                            o = r - s,
                            a = i[0 === s ? s : s - 1],
                            l = i[s],
                            c = i[s > i.length - 2 ? i.length - 1 : s + 1],
                            h = i[s > i.length - 3 ? i.length - 1 : s + 2];
                        return n.set(Dc(o, a.x, l.x, c.x, h.x), Dc(o, a.y, l.y, c.y, h.y)), n
                    }
                    copy(t) {
                        super.copy(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push(n.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.points = [];
                        for (let e = 0, n = this.points.length; e < n; e++) {
                            const n = this.points[e];
                            t.points.push(n.toArray())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push((new $n).fromArray(n))
                        }
                        return this
                    }
                }
                Gc.prototype.isSplineCurve = !0;
                var Vc = Object.freeze({ __proto__: null, ArcCurve: Ec, CatmullRomCurve3: Ic, CubicBezierCurve: Oc, CubicBezierCurve3: Fc, EllipseCurve: Tc, LineCurve: zc, LineCurve3: Uc, QuadraticBezierCurve: Hc, QuadraticBezierCurve3: kc, SplineCurve: Gc });

                function Wc(t, e, n, i, r) {
                    let s, o;
                    if (r === function(t, e, n, i) { let r = 0; for (let s = e, o = n - i; s < n; s += i) r += (t[o] - t[s]) * (t[s + 1] + t[o + 1]), o = s; return r }(t, e, n, i) > 0)
                        for (s = e; s < n; s += i) o = uh(s, t[s], t[s + 1], o);
                    else
                        for (s = n - i; s >= e; s -= i) o = uh(s, t[s], t[s + 1], o);
                    return o && sh(o, o.next) && (dh(o), o = o.next), o
                }

                function jc(t, e) {
                    if (!t) return t;
                    e || (e = t);
                    let n, i = t;
                    do {
                        if (n = !1, i.steiner || !sh(i, i.next) && 0 !== rh(i.prev, i, i.next)) i = i.next;
                        else {
                            if (dh(i), i = e = i.prev, i === i.next) break;
                            n = !0
                        }
                    } while (n || i !== e);
                    return e
                }

                function qc(t, e, n, i, r, s, o) {
                    if (!t) return;
                    !o && s && function(t, e, n, i) {
                        let r = t;
                        do { null === r.z && (r.z = th(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next } while (r !== t);
                        r.prevZ.nextZ = null, r.prevZ = null,
                            function(t) {
                                let e, n, i, r, s, o, a, l, c = 1;
                                do {
                                    for (n = t, t = null, s = null, o = 0; n;) {
                                        for (o++, i = n, a = 0, e = 0; e < c && (a++, i = i.nextZ, i); e++);
                                        for (l = c; a > 0 || l > 0 && i;) 0 !== a && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, a--) : (r = i, i = i.nextZ, l--), s ? s.nextZ = r : t = r, r.prevZ = s, s = r;
                                        n = i
                                    }
                                    s.nextZ = null, c *= 2
                                } while (o > 1)
                            }(r)
                    }(t, i, r, s);
                    let a, l, c = t;
                    for (; t.prev !== t.next;)
                        if (a = t.prev, l = t.next, s ? Yc(t, i, r, s) : Xc(t)) e.push(a.i / n), e.push(t.i / n), e.push(l.i / n), dh(t), t = l.next, c = l.next;
                        else if ((t = l) === c) { o ? 1 === o ? qc(t = Zc(jc(t), e, n), e, n, i, r, s, 2) : 2 === o && Jc(t, e, n, i, r, s) : qc(jc(t), e, n, i, r, s, 1); break }
                }

                function Xc(t) {
                    const e = t.prev,
                        n = t,
                        i = t.next;
                    if (rh(e, n, i) >= 0) return !1;
                    let r = t.next.next;
                    for (; r !== t.prev;) {
                        if (nh(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && rh(r.prev, r, r.next) >= 0) return !1;
                        r = r.next
                    }
                    return !0
                }

                function Yc(t, e, n, i) {
                    const r = t.prev,
                        s = t,
                        o = t.next;
                    if (rh(r, s, o) >= 0) return !1;
                    const a = r.x < s.x ? r.x < o.x ? r.x : o.x : s.x < o.x ? s.x : o.x,
                        l = r.y < s.y ? r.y < o.y ? r.y : o.y : s.y < o.y ? s.y : o.y,
                        c = r.x > s.x ? r.x > o.x ? r.x : o.x : s.x > o.x ? s.x : o.x,
                        h = r.y > s.y ? r.y > o.y ? r.y : o.y : s.y > o.y ? s.y : o.y,
                        u = th(a, l, e, n, i),
                        d = th(c, h, e, n, i);
                    let p = t.prevZ,
                        m = t.nextZ;
                    for (; p && p.z >= u && m && m.z <= d;) {
                        if (p !== t.prev && p !== t.next && nh(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) && rh(p.prev, p, p.next) >= 0) return !1;
                        if (p = p.prevZ, m !== t.prev && m !== t.next && nh(r.x, r.y, s.x, s.y, o.x, o.y, m.x, m.y) && rh(m.prev, m, m.next) >= 0) return !1;
                        m = m.nextZ
                    }
                    for (; p && p.z >= u;) {
                        if (p !== t.prev && p !== t.next && nh(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) && rh(p.prev, p, p.next) >= 0) return !1;
                        p = p.prevZ
                    }
                    for (; m && m.z <= d;) {
                        if (m !== t.prev && m !== t.next && nh(r.x, r.y, s.x, s.y, o.x, o.y, m.x, m.y) && rh(m.prev, m, m.next) >= 0) return !1;
                        m = m.nextZ
                    }
                    return !0
                }

                function Zc(t, e, n) {
                    let i = t;
                    do {
                        const r = i.prev,
                            s = i.next.next;
                        !sh(r, s) && oh(r, i, i.next, s) && ch(r, s) && ch(s, r) && (e.push(r.i / n), e.push(i.i / n), e.push(s.i / n), dh(i), dh(i.next), i = t = s), i = i.next
                    } while (i !== t);
                    return jc(i)
                }

                function Jc(t, e, n, i, r, s) {
                    let o = t;
                    do {
                        let t = o.next.next;
                        for (; t !== o.prev;) {
                            if (o.i !== t.i && ih(o, t)) { let a = hh(o, t); return o = jc(o, o.next), a = jc(a, a.next), qc(o, e, n, i, r, s), void qc(a, e, n, i, r, s) }
                            t = t.next
                        }
                        o = o.next
                    } while (o !== t)
                }

                function Kc(t, e) { return t.x - e.x }

                function Qc(t, e) {
                    if (e = function(t, e) {
                            let n = e;
                            const i = t.x,
                                r = t.y;
                            let s, o = -1 / 0;
                            do {
                                if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                                    const t = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                    if (t <= i && t > o) {
                                        if (o = t, t === i) { if (r === n.y) return n; if (r === n.next.y) return n.next }
                                        s = n.x < n.next.x ? n : n.next
                                    }
                                }
                                n = n.next
                            } while (n !== e);
                            if (!s) return null;
                            if (i === o) return s;
                            const a = s,
                                l = s.x,
                                c = s.y;
                            let h, u = 1 / 0;
                            n = s;
                            do { i >= n.x && n.x >= l && i !== n.x && nh(r < c ? i : o, r, l, c, r < c ? o : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x), ch(n, t) && (h < u || h === u && (n.x > s.x || n.x === s.x && $c(s, n))) && (s = n, u = h)), n = n.next } while (n !== a);
                            return s
                        }(t, e), e) {
                        const n = hh(e, t);
                        jc(e, e.next), jc(n, n.next)
                    }
                }

                function $c(t, e) { return rh(t.prev, t, e.prev) < 0 && rh(e.next, t, t.next) < 0 }

                function th(t, e, n, i, r) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 }

                function eh(t) {
                    let e = t,
                        n = t;
                    do {
                        (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
                    } while (e !== t);
                    return n
                }

                function nh(t, e, n, i, r, s, o, a) { return (r - o) * (e - a) - (t - o) * (s - a) >= 0 && (t - o) * (i - a) - (n - o) * (e - a) >= 0 && (n - o) * (s - a) - (r - o) * (i - a) >= 0 }

                function ih(t, e) {
                    return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                        let n = t;
                        do {
                            if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && oh(n, n.next, t, e)) return !0;
                            n = n.next
                        } while (n !== t);
                        return !1
                    }(t, e) && (ch(t, e) && ch(e, t) && function(t, e) {
                        let n = t,
                            i = !1;
                        const r = (t.x + e.x) / 2,
                            s = (t.y + e.y) / 2;
                        do { n.y > s != n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next } while (n !== t);
                        return i
                    }(t, e) && (rh(t.prev, t, e.prev) || rh(t, e.prev, e)) || sh(t, e) && rh(t.prev, t, t.next) > 0 && rh(e.prev, e, e.next) > 0)
                }

                function rh(t, e, n) { return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y) }

                function sh(t, e) { return t.x === e.x && t.y === e.y }

                function oh(t, e, n, i) {
                    const r = lh(rh(t, e, n)),
                        s = lh(rh(t, e, i)),
                        o = lh(rh(n, i, t)),
                        a = lh(rh(n, i, e));
                    return r !== s && o !== a || !(0 !== r || !ah(t, n, e)) || !(0 !== s || !ah(t, i, e)) || !(0 !== o || !ah(n, t, i)) || !(0 !== a || !ah(n, e, i))
                }

                function ah(t, e, n) { return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y) }

                function lh(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 }

                function ch(t, e) { return rh(t.prev, t, t.next) < 0 ? rh(t, e, t.next) >= 0 && rh(t, t.prev, e) >= 0 : rh(t, e, t.prev) < 0 || rh(t, t.next, e) < 0 }

                function hh(t, e) {
                    const n = new ph(t.i, t.x, t.y),
                        i = new ph(e.i, e.x, e.y),
                        r = t.next,
                        s = e.prev;
                    return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, s.next = i, i.prev = s, i
                }

                function uh(t, e, n, i) { const r = new ph(t, e, n); return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r }

                function dh(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) }

                function ph(t, e, n) { this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 }
                class mh {
                    static area(t) { const e = t.length; let n = 0; for (let i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y; return .5 * n }
                    static isClockWise(t) { return mh.area(t) < 0 }
                    static triangulateShape(t, e) {
                        const n = [],
                            i = [],
                            r = [];
                        fh(t), gh(n, t);
                        let s = t.length;
                        e.forEach(fh);
                        for (let t = 0; t < e.length; t++) i.push(s), s += e[t].length, gh(n, e[t]);
                        const o = function(t, e, n = 2) {
                            const i = e && e.length,
                                r = i ? e[0] * n : t.length;
                            let s = Wc(t, 0, r, n, !0);
                            const o = [];
                            if (!s || s.next === s.prev) return o;
                            let a, l, c, h, u, d, p;
                            if (i && (s = function(t, e, n, i) { const r = []; let s, o, a, l, c; for (s = 0, o = e.length; s < o; s++) a = e[s] * i, l = s < o - 1 ? e[s + 1] * i : t.length, c = Wc(t, a, l, i, !1), c === c.next && (c.steiner = !0), r.push(eh(c)); for (r.sort(Kc), s = 0; s < r.length; s++) Qc(r[s], n), n = jc(n, n.next); return n }(t, e, s, n)), t.length > 80 * n) {
                                a = c = t[0], l = h = t[1];
                                for (let e = n; e < r; e += n) u = t[e], d = t[e + 1], u < a && (a = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
                                p = Math.max(c - a, h - l), p = 0 !== p ? 1 / p : 0
                            }
                            return qc(s, o, n, a, l, p), o
                        }(n, i);
                        for (let t = 0; t < o.length; t += 3) r.push(o.slice(t, t + 3));
                        return r
                    }
                }

                function fh(t) {
                    const e = t.length;
                    e > 2 && t[e - 1].equals(t[0]) && t.pop()
                }

                function gh(t, e) { for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y) }
                class vh extends rs {
                    constructor(t, e) {
                        super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: t, options: e }, t = Array.isArray(t) ? t : [t];
                        const n = this,
                            i = [],
                            r = [];
                        for (let e = 0, n = t.length; e < n; e++) s(t[e]);

                        function s(t) {
                            const s = [],
                                o = void 0 !== e.curveSegments ? e.curveSegments : 12,
                                a = void 0 !== e.steps ? e.steps : 1;
                            let l = void 0 !== e.depth ? e.depth : 100,
                                c = void 0 === e.bevelEnabled || e.bevelEnabled,
                                h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                                u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
                                d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                                p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                            const m = e.extrudePath,
                                f = void 0 !== e.UVGenerator ? e.UVGenerator : yh;
                            void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);
                            let g, v, y, x, _, b = !1;
                            m && (g = m.getSpacedPoints(a), b = !0, c = !1, v = m.computeFrenetFrames(a, !1), y = new ui, x = new ui, _ = new ui), c || (p = 0, h = 0, u = 0, d = 0);
                            const w = t.extractPoints(o);
                            let M = w.shape;
                            const S = w.holes;
                            if (!mh.isClockWise(M)) {
                                M = M.reverse();
                                for (let t = 0, e = S.length; t < e; t++) {
                                    const e = S[t];
                                    mh.isClockWise(e) && (S[t] = e.reverse())
                                }
                            }
                            const T = mh.triangulateShape(M, S),
                                E = M;
                            for (let t = 0, e = S.length; t < e; t++) {
                                const e = S[t];
                                M = M.concat(e)
                            }

                            function A(t, e, n) { return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t) }
                            const L = M.length,
                                R = T.length;

                            function C(t, e, n) {
                                let i, r, s;
                                const o = t.x - e.x,
                                    a = t.y - e.y,
                                    l = n.x - t.x,
                                    c = n.y - t.y,
                                    h = o * o + a * a,
                                    u = o * c - a * l;
                                if (Math.abs(u) > Number.EPSILON) {
                                    const u = Math.sqrt(h),
                                        d = Math.sqrt(l * l + c * c),
                                        p = e.x - a / u,
                                        m = e.y + o / u,
                                        f = ((n.x - c / d - p) * c - (n.y + l / d - m) * l) / (o * c - a * l);
                                    i = p + o * f - t.x, r = m + a * f - t.y;
                                    const g = i * i + r * r;
                                    if (g <= 2) return new $n(i, r);
                                    s = Math.sqrt(g / 2)
                                } else {
                                    let t = !1;
                                    o > Number.EPSILON ? l > Number.EPSILON && (t = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(c) && (t = !0), t ? (i = -a, r = o, s = Math.sqrt(h)) : (i = o, r = a, s = Math.sqrt(h / 2))
                                }
                                return new $n(i / s, r / s)
                            }
                            const P = [];
                            for (let t = 0, e = E.length, n = e - 1, i = t + 1; t < e; t++, n++, i++) n === e && (n = 0), i === e && (i = 0), P[t] = C(E[t], E[n], E[i]);
                            const I = [];
                            let D, N = P.concat();
                            for (let t = 0, e = S.length; t < e; t++) {
                                const e = S[t];
                                D = [];
                                for (let t = 0, n = e.length, i = n - 1, r = t + 1; t < n; t++, i++, r++) i === n && (i = 0), r === n && (r = 0), D[t] = C(e[t], e[i], e[r]);
                                I.push(D), N = N.concat(D)
                            }
                            for (let t = 0; t < p; t++) {
                                const e = t / p,
                                    n = h * Math.cos(e * Math.PI / 2),
                                    i = u * Math.sin(e * Math.PI / 2) + d;
                                for (let t = 0, e = E.length; t < e; t++) {
                                    const e = A(E[t], P[t], i);
                                    F(e.x, e.y, -n)
                                }
                                for (let t = 0, e = S.length; t < e; t++) {
                                    const e = S[t];
                                    D = I[t];
                                    for (let t = 0, r = e.length; t < r; t++) {
                                        const r = A(e[t], D[t], i);
                                        F(r.x, r.y, -n)
                                    }
                                }
                            }
                            const B = u + d;
                            for (let t = 0; t < L; t++) {
                                const e = c ? A(M[t], N[t], B) : M[t];
                                b ? (x.copy(v.normals[0]).multiplyScalar(e.x), y.copy(v.binormals[0]).multiplyScalar(e.y), _.copy(g[0]).add(x).add(y), F(_.x, _.y, _.z)) : F(e.x, e.y, 0)
                            }
                            for (let t = 1; t <= a; t++)
                                for (let e = 0; e < L; e++) {
                                    const n = c ? A(M[e], N[e], B) : M[e];
                                    b ? (x.copy(v.normals[t]).multiplyScalar(n.x), y.copy(v.binormals[t]).multiplyScalar(n.y), _.copy(g[t]).add(x).add(y), F(_.x, _.y, _.z)) : F(n.x, n.y, l / a * t)
                                }
                            for (let t = p - 1; t >= 0; t--) {
                                const e = t / p,
                                    n = h * Math.cos(e * Math.PI / 2),
                                    i = u * Math.sin(e * Math.PI / 2) + d;
                                for (let t = 0, e = E.length; t < e; t++) {
                                    const e = A(E[t], P[t], i);
                                    F(e.x, e.y, l + n)
                                }
                                for (let t = 0, e = S.length; t < e; t++) {
                                    const e = S[t];
                                    D = I[t];
                                    for (let t = 0, r = e.length; t < r; t++) {
                                        const r = A(e[t], D[t], i);
                                        b ? F(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : F(r.x, r.y, l + n)
                                    }
                                }
                            }

                            function O(t, e) {
                                let n = t.length;
                                for (; --n >= 0;) {
                                    const i = n;
                                    let r = n - 1;
                                    r < 0 && (r = t.length - 1);
                                    for (let t = 0, n = a + 2 * p; t < n; t++) {
                                        const n = L * t,
                                            s = L * (t + 1);
                                        U(e + i + n, e + r + n, e + r + s, e + i + s)
                                    }
                                }
                            }

                            function F(t, e, n) { s.push(t), s.push(e), s.push(n) }

                            function z(t, e, r) {
                                H(t), H(e), H(r);
                                const s = i.length / 3,
                                    o = f.generateTopUV(n, i, s - 3, s - 2, s - 1);
                                k(o[0]), k(o[1]), k(o[2])
                            }

                            function U(t, e, r, s) {
                                H(t), H(e), H(s), H(e), H(r), H(s);
                                const o = i.length / 3,
                                    a = f.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1);
                                k(a[0]), k(a[1]), k(a[3]), k(a[1]), k(a[2]), k(a[3])
                            }

                            function H(t) { i.push(s[3 * t + 0]), i.push(s[3 * t + 1]), i.push(s[3 * t + 2]) }

                            function k(t) { r.push(t.x), r.push(t.y) }! function() {
                                const t = i.length / 3;
                                if (c) {
                                    let t = 0,
                                        e = L * t;
                                    for (let t = 0; t < R; t++) {
                                        const n = T[t];
                                        z(n[2] + e, n[1] + e, n[0] + e)
                                    }
                                    t = a + 2 * p, e = L * t;
                                    for (let t = 0; t < R; t++) {
                                        const n = T[t];
                                        z(n[0] + e, n[1] + e, n[2] + e)
                                    }
                                } else {
                                    for (let t = 0; t < R; t++) {
                                        const e = T[t];
                                        z(e[2], e[1], e[0])
                                    }
                                    for (let t = 0; t < R; t++) {
                                        const e = T[t];
                                        z(e[0] + L * a, e[1] + L * a, e[2] + L * a)
                                    }
                                }
                                n.addGroup(t, i.length / 3 - t, 0)
                            }(),
                            function() {
                                const t = i.length / 3;
                                let e = 0;
                                O(E, e), e += E.length;
                                for (let t = 0, n = S.length; t < n; t++) {
                                    const n = S[t];
                                    O(n, e), e += n.length
                                }
                                n.addGroup(t, i.length / 3 - t, 1)
                            }()
                        }
                        this.setAttribute("position", new qr(i, 3)), this.setAttribute("uv", new qr(r, 2)), this.computeVertexNormals()
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return function(t, e, n) {
                            if (n.shapes = [], Array.isArray(t))
                                for (let e = 0, i = t.length; e < i; e++) {
                                    const i = t[e];
                                    n.shapes.push(i.uuid)
                                } else n.shapes.push(t.uuid);
                            return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
                        }(this.parameters.shapes, this.parameters.options, t)
                    }
                    static fromJSON(t, e) {
                        const n = [];
                        for (let i = 0, r = t.shapes.length; i < r; i++) {
                            const r = e[t.shapes[i]];
                            n.push(r)
                        }
                        const i = t.options.extrudePath;
                        return void 0 !== i && (t.options.extrudePath = (new Vc[i.type]).fromJSON(i)), new vh(n, t.options)
                    }
                }
                const yh = {
                    generateTopUV: function(t, e, n, i, r) {
                        const s = e[3 * n],
                            o = e[3 * n + 1],
                            a = e[3 * i],
                            l = e[3 * i + 1],
                            c = e[3 * r],
                            h = e[3 * r + 1];
                        return [new $n(s, o), new $n(a, l), new $n(c, h)]
                    },
                    generateSideWallUV: function(t, e, n, i, r, s) {
                        const o = e[3 * n],
                            a = e[3 * n + 1],
                            l = e[3 * n + 2],
                            c = e[3 * i],
                            h = e[3 * i + 1],
                            u = e[3 * i + 2],
                            d = e[3 * r],
                            p = e[3 * r + 1],
                            m = e[3 * r + 2],
                            f = e[3 * s],
                            g = e[3 * s + 1],
                            v = e[3 * s + 2];
                        return Math.abs(a - h) < Math.abs(o - c) ? [new $n(o, 1 - l), new $n(c, 1 - u), new $n(d, 1 - m), new $n(f, 1 - v)] : [new $n(a, 1 - l), new $n(h, 1 - u), new $n(p, 1 - m), new $n(g, 1 - v)]
                    }
                };
                class xh extends vc {
                    constructor(t = 1, e = 0) {
                        const n = (1 + Math.sqrt(5)) / 2;
                        super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronGeometry", this.parameters = { radius: t, detail: e }
                    }
                    static fromJSON(t) { return new xh(t.radius, t.detail) }
                }
                class _h extends rs {
                    constructor(t, e = 12, n = 0, i = 2 * Math.PI) {
                        super(), this.type = "LatheGeometry", this.parameters = { points: t, segments: e, phiStart: n, phiLength: i }, e = Math.floor(e), i = qn(i, 0, 2 * Math.PI);
                        const r = [],
                            s = [],
                            o = [],
                            a = 1 / e,
                            l = new ui,
                            c = new $n;
                        for (let r = 0; r <= e; r++) {
                            const h = n + r * a * i,
                                u = Math.sin(h),
                                d = Math.cos(h);
                            for (let n = 0; n <= t.length - 1; n++) l.x = t[n].x * u, l.y = t[n].y, l.z = t[n].x * d, s.push(l.x, l.y, l.z), c.x = r / e, c.y = n / (t.length - 1), o.push(c.x, c.y)
                        }
                        for (let n = 0; n < e; n++)
                            for (let e = 0; e < t.length - 1; e++) {
                                const i = e + n * t.length,
                                    s = i,
                                    o = i + t.length,
                                    a = i + t.length + 1,
                                    l = i + 1;
                                r.push(s, o, l), r.push(o, a, l)
                            }
                        if (this.setIndex(r), this.setAttribute("position", new qr(s, 3)), this.setAttribute("uv", new qr(o, 2)), this.computeVertexNormals(), i === 2 * Math.PI) {
                            const n = this.attributes.normal.array,
                                i = new ui,
                                r = new ui,
                                s = new ui,
                                o = e * t.length * 3;
                            for (let e = 0, a = 0; e < t.length; e++, a += 3) i.x = n[a + 0], i.y = n[a + 1], i.z = n[a + 2], r.x = n[o + a + 0], r.y = n[o + a + 1], r.z = n[o + a + 2], s.addVectors(i, r).normalize(), n[a + 0] = n[o + a + 0] = s.x, n[a + 1] = n[o + a + 1] = s.y, n[a + 2] = n[o + a + 2] = s.z
                        }
                    }
                    static fromJSON(t) { return new _h(t.points, t.segments, t.phiStart, t.phiLength) }
                }
                class bh extends vc {
                    constructor(t = 1, e = 0) { super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronGeometry", this.parameters = { radius: t, detail: e } }
                    static fromJSON(t) { return new bh(t.radius, t.detail) }
                }
                class wh extends rs {
                    constructor(t, e, n) {
                        super(), this.type = "ParametricGeometry", this.parameters = { func: t, slices: e, stacks: n };
                        const i = [],
                            r = [],
                            s = [],
                            o = [],
                            a = 1e-5,
                            l = new ui,
                            c = new ui,
                            h = new ui,
                            u = new ui,
                            d = new ui;
                        t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
                        const p = e + 1;
                        for (let i = 0; i <= n; i++) {
                            const p = i / n;
                            for (let n = 0; n <= e; n++) {
                                const i = n / e;
                                t(i, p, c), r.push(c.x, c.y, c.z), i - a >= 0 ? (t(i - a, p, h), u.subVectors(c, h)) : (t(i + a, p, h), u.subVectors(h, c)), p - a >= 0 ? (t(i, p - a, h), d.subVectors(c, h)) : (t(i, p + a, h), d.subVectors(h, c)), l.crossVectors(u, d).normalize(), s.push(l.x, l.y, l.z), o.push(i, p)
                            }
                        }
                        for (let t = 0; t < n; t++)
                            for (let n = 0; n < e; n++) {
                                const e = t * p + n,
                                    r = t * p + n + 1,
                                    s = (t + 1) * p + n + 1,
                                    o = (t + 1) * p + n;
                                i.push(e, r, o), i.push(r, s, o)
                            }
                        this.setIndex(i), this.setAttribute("position", new qr(r, 3)), this.setAttribute("normal", new qr(s, 3)), this.setAttribute("uv", new qr(o, 2))
                    }
                }
                class Mh extends rs {
                    constructor(t = .5, e = 1, n = 8, i = 1, r = 0, s = 2 * Math.PI) {
                        super(), this.type = "RingGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: n, phiSegments: i, thetaStart: r, thetaLength: s }, n = Math.max(3, n);
                        const o = [],
                            a = [],
                            l = [],
                            c = [];
                        let h = t;
                        const u = (e - t) / (i = Math.max(1, i)),
                            d = new ui,
                            p = new $n;
                        for (let t = 0; t <= i; t++) {
                            for (let t = 0; t <= n; t++) {
                                const i = r + t / n * s;
                                d.x = h * Math.cos(i), d.y = h * Math.sin(i), a.push(d.x, d.y, d.z), l.push(0, 0, 1), p.x = (d.x / e + 1) / 2, p.y = (d.y / e + 1) / 2, c.push(p.x, p.y)
                            }
                            h += u
                        }
                        for (let t = 0; t < i; t++) {
                            const e = t * (n + 1);
                            for (let t = 0; t < n; t++) {
                                const i = t + e,
                                    r = i,
                                    s = i + n + 1,
                                    a = i + n + 2,
                                    l = i + 1;
                                o.push(r, s, l), o.push(s, a, l)
                            }
                        }
                        this.setIndex(o), this.setAttribute("position", new qr(a, 3)), this.setAttribute("normal", new qr(l, 3)), this.setAttribute("uv", new qr(c, 2))
                    }
                    static fromJSON(t) { return new Mh(t.innerRadius, t.outerRadius, t.thetaSegments, t.phiSegments, t.thetaStart, t.thetaLength) }
                }
                class Sh extends rs {
                    constructor(t, e = 12) {
                        super(), this.type = "ShapeGeometry", this.parameters = { shapes: t, curveSegments: e };
                        const n = [],
                            i = [],
                            r = [],
                            s = [];
                        let o = 0,
                            a = 0;
                        if (!1 === Array.isArray(t)) l(t);
                        else
                            for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(o, a, e), o += a, a = 0;

                        function l(t) {
                            const o = i.length / 3,
                                l = t.extractPoints(e);
                            let c = l.shape;
                            const h = l.holes;
                            !1 === mh.isClockWise(c) && (c = c.reverse());
                            for (let t = 0, e = h.length; t < e; t++) { const e = h[t];!0 === mh.isClockWise(e) && (h[t] = e.reverse()) }
                            const u = mh.triangulateShape(c, h);
                            for (let t = 0, e = h.length; t < e; t++) {
                                const e = h[t];
                                c = c.concat(e)
                            }
                            for (let t = 0, e = c.length; t < e; t++) {
                                const e = c[t];
                                i.push(e.x, e.y, 0), r.push(0, 0, 1), s.push(e.x, e.y)
                            }
                            for (let t = 0, e = u.length; t < e; t++) {
                                const e = u[t],
                                    i = e[0] + o,
                                    r = e[1] + o,
                                    s = e[2] + o;
                                n.push(i, r, s), a += 3
                            }
                        }
                        this.setIndex(n), this.setAttribute("position", new qr(i, 3)), this.setAttribute("normal", new qr(r, 3)), this.setAttribute("uv", new qr(s, 2))
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return function(t, e) {
                            if (e.shapes = [], Array.isArray(t))
                                for (let n = 0, i = t.length; n < i; n++) {
                                    const i = t[n];
                                    e.shapes.push(i.uuid)
                                } else e.shapes.push(t.uuid);
                            return e
                        }(this.parameters.shapes, t)
                    }
                    static fromJSON(t, e) {
                        const n = [];
                        for (let i = 0, r = t.shapes.length; i < r; i++) {
                            const r = e[t.shapes[i]];
                            n.push(r)
                        }
                        return new Sh(n, t.curveSegments)
                    }
                }
                class Th extends rs {
                    constructor(t = 1, e = 8, n = 6, i = 0, r = 2 * Math.PI, s = 0, o = Math.PI) {
                        super(), this.type = "SphereGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: i, phiLength: r, thetaStart: s, thetaLength: o }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n));
                        const a = Math.min(s + o, Math.PI);
                        let l = 0;
                        const c = [],
                            h = new ui,
                            u = new ui,
                            d = [],
                            p = [],
                            m = [],
                            f = [];
                        for (let d = 0; d <= n; d++) {
                            const g = [],
                                v = d / n;
                            let y = 0;
                            0 == d && 0 == s ? y = .5 / e : d == n && a == Math.PI && (y = -.5 / e);
                            for (let n = 0; n <= e; n++) {
                                const a = n / e;
                                h.x = -t * Math.cos(i + a * r) * Math.sin(s + v * o), h.y = t * Math.cos(s + v * o), h.z = t * Math.sin(i + a * r) * Math.sin(s + v * o), p.push(h.x, h.y, h.z), u.copy(h).normalize(), m.push(u.x, u.y, u.z), f.push(a + y, 1 - v), g.push(l++)
                            }
                            c.push(g)
                        }
                        for (let t = 0; t < n; t++)
                            for (let i = 0; i < e; i++) {
                                const e = c[t][i + 1],
                                    r = c[t][i],
                                    o = c[t + 1][i],
                                    l = c[t + 1][i + 1];
                                (0 !== t || s > 0) && d.push(e, r, l), (t !== n - 1 || a < Math.PI) && d.push(r, o, l)
                            }
                        this.setIndex(d), this.setAttribute("position", new qr(p, 3)), this.setAttribute("normal", new qr(m, 3)), this.setAttribute("uv", new qr(f, 2))
                    }
                    static fromJSON(t) { return new Th(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength) }
                }
                class Eh extends vc {
                    constructor(t = 1, e = 0) { super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronGeometry", this.parameters = { radius: t, detail: e } }
                    static fromJSON(t) { return new Eh(t.radius, t.detail) }
                }
                class Ah extends vh {
                    constructor(t, e = {}) {
                        const n = e.font;
                        if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new rs;
                        const i = n.generateShapes(t, e.size);
                        e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), super(i, e), this.type = "TextGeometry"
                    }
                }
                class Lh extends rs {
                    constructor(t = 1, e = .4, n = 8, i = 6, r = 2 * Math.PI) {
                        super(), this.type = "TorusGeometry", this.parameters = { radius: t, tube: e, radialSegments: n, tubularSegments: i, arc: r }, n = Math.floor(n), i = Math.floor(i);
                        const s = [],
                            o = [],
                            a = [],
                            l = [],
                            c = new ui,
                            h = new ui,
                            u = new ui;
                        for (let s = 0; s <= n; s++)
                            for (let d = 0; d <= i; d++) {
                                const p = d / i * r,
                                    m = s / n * Math.PI * 2;
                                h.x = (t + e * Math.cos(m)) * Math.cos(p), h.y = (t + e * Math.cos(m)) * Math.sin(p), h.z = e * Math.sin(m), o.push(h.x, h.y, h.z), c.x = t * Math.cos(p), c.y = t * Math.sin(p), u.subVectors(h, c).normalize(), a.push(u.x, u.y, u.z), l.push(d / i), l.push(s / n)
                            }
                        for (let t = 1; t <= n; t++)
                            for (let e = 1; e <= i; e++) {
                                const n = (i + 1) * t + e - 1,
                                    r = (i + 1) * (t - 1) + e - 1,
                                    o = (i + 1) * (t - 1) + e,
                                    a = (i + 1) * t + e;
                                s.push(n, r, a), s.push(r, o, a)
                            }
                        this.setIndex(s), this.setAttribute("position", new qr(o, 3)), this.setAttribute("normal", new qr(a, 3)), this.setAttribute("uv", new qr(l, 2))
                    }
                    static fromJSON(t) { return new Lh(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc) }
                }
                class Rh extends rs {
                    constructor(t = 1, e = .4, n = 64, i = 8, r = 2, s = 3) {
                        super(), this.type = "TorusKnotGeometry", this.parameters = { radius: t, tube: e, tubularSegments: n, radialSegments: i, p: r, q: s }, n = Math.floor(n), i = Math.floor(i);
                        const o = [],
                            a = [],
                            l = [],
                            c = [],
                            h = new ui,
                            u = new ui,
                            d = new ui,
                            p = new ui,
                            m = new ui,
                            f = new ui,
                            g = new ui;
                        for (let o = 0; o <= n; ++o) {
                            const y = o / n * r * Math.PI * 2;
                            v(y, r, s, t, d), v(y + .01, r, s, t, p), f.subVectors(p, d), g.addVectors(p, d), m.crossVectors(f, g), g.crossVectors(m, f), m.normalize(), g.normalize();
                            for (let t = 0; t <= i; ++t) {
                                const r = t / i * Math.PI * 2,
                                    s = -e * Math.cos(r),
                                    p = e * Math.sin(r);
                                h.x = d.x + (s * g.x + p * m.x), h.y = d.y + (s * g.y + p * m.y), h.z = d.z + (s * g.z + p * m.z), a.push(h.x, h.y, h.z), u.subVectors(h, d).normalize(), l.push(u.x, u.y, u.z), c.push(o / n), c.push(t / i)
                            }
                        }
                        for (let t = 1; t <= n; t++)
                            for (let e = 1; e <= i; e++) {
                                const n = (i + 1) * (t - 1) + (e - 1),
                                    r = (i + 1) * t + (e - 1),
                                    s = (i + 1) * t + e,
                                    a = (i + 1) * (t - 1) + e;
                                o.push(n, r, a), o.push(r, s, a)
                            }

                        function v(t, e, n, i, r) {
                            const s = Math.cos(t),
                                o = Math.sin(t),
                                a = n / e * t,
                                l = Math.cos(a);
                            r.x = i * (2 + l) * .5 * s, r.y = i * (2 + l) * o * .5, r.z = i * Math.sin(a) * .5
                        }
                        this.setIndex(o), this.setAttribute("position", new qr(a, 3)), this.setAttribute("normal", new qr(l, 3)), this.setAttribute("uv", new qr(c, 2))
                    }
                    static fromJSON(t) { return new Rh(t.radius, t.tube, t.tubularSegments, t.radialSegments, t.p, t.q) }
                }
                class Ch extends rs {
                    constructor(t, e = 64, n = 1, i = 8, r = !1) {
                        super(), this.type = "TubeGeometry", this.parameters = { path: t, tubularSegments: e, radius: n, radialSegments: i, closed: r };
                        const s = t.computeFrenetFrames(e, r);
                        this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals;
                        const o = new ui,
                            a = new ui,
                            l = new $n;
                        let c = new ui;
                        const h = [],
                            u = [],
                            d = [],
                            p = [];

                        function m(r) {
                            c = t.getPointAt(r / e, c);
                            const l = s.normals[r],
                                d = s.binormals[r];
                            for (let t = 0; t <= i; t++) {
                                const e = t / i * Math.PI * 2,
                                    r = Math.sin(e),
                                    s = -Math.cos(e);
                                a.x = s * l.x + r * d.x, a.y = s * l.y + r * d.y, a.z = s * l.z + r * d.z, a.normalize(), u.push(a.x, a.y, a.z), o.x = c.x + n * a.x, o.y = c.y + n * a.y, o.z = c.z + n * a.z, h.push(o.x, o.y, o.z)
                            }
                        }! function() {
                            for (let t = 0; t < e; t++) m(t);
                            m(!1 === r ? e : 0),
                                function() {
                                    for (let t = 0; t <= e; t++)
                                        for (let n = 0; n <= i; n++) l.x = t / e, l.y = n / i, d.push(l.x, l.y)
                                }(),
                                function() {
                                    for (let t = 1; t <= e; t++)
                                        for (let e = 1; e <= i; e++) {
                                            const n = (i + 1) * (t - 1) + (e - 1),
                                                r = (i + 1) * t + (e - 1),
                                                s = (i + 1) * t + e,
                                                o = (i + 1) * (t - 1) + e;
                                            p.push(n, r, o), p.push(r, s, o)
                                        }
                                }()
                        }(), this.setIndex(p), this.setAttribute("position", new qr(h, 3)), this.setAttribute("normal", new qr(u, 3)), this.setAttribute("uv", new qr(d, 2))
                    }
                    toJSON() { const t = super.toJSON(); return t.path = this.parameters.path.toJSON(), t }
                    static fromJSON(t) { return new Ch((new Vc[t.path.type]).fromJSON(t.path), t.tubularSegments, t.radius, t.radialSegments, t.closed) }
                }
                class Ph extends rs {
                    constructor(t) {
                        if (super(), this.type = "WireframeGeometry", !0 === t.isGeometry) return void console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                        const e = [],
                            n = [0, 0],
                            i = {},
                            r = new ui;
                        if (null !== t.index) {
                            const s = t.attributes.position,
                                o = t.index;
                            let a = t.groups;
                            0 === a.length && (a = [{ start: 0, count: o.count, materialIndex: 0 }]);
                            for (let t = 0, e = a.length; t < e; ++t) {
                                const e = a[t],
                                    r = e.start;
                                for (let t = r, s = r + e.count; t < s; t += 3)
                                    for (let e = 0; e < 3; e++) {
                                        const r = o.getX(t + e),
                                            s = o.getX(t + (e + 1) % 3);
                                        n[0] = Math.min(r, s), n[1] = Math.max(r, s);
                                        const a = n[0] + "," + n[1];
                                        void 0 === i[a] && (i[a] = { index1: n[0], index2: n[1] })
                                    }
                            }
                            for (const t in i) {
                                const n = i[t];
                                r.fromBufferAttribute(s, n.index1), e.push(r.x, r.y, r.z), r.fromBufferAttribute(s, n.index2), e.push(r.x, r.y, r.z)
                            }
                        } else {
                            const n = t.attributes.position;
                            for (let t = 0, i = n.count / 3; t < i; t++)
                                for (let i = 0; i < 3; i++) {
                                    const s = 3 * t + i;
                                    r.fromBufferAttribute(n, s), e.push(r.x, r.y, r.z);
                                    const o = 3 * t + (i + 1) % 3;
                                    r.fromBufferAttribute(n, o), e.push(r.x, r.y, r.z)
                                }
                        }
                        this.setAttribute("position", new qr(e, 3))
                    }
                }
                var Ih = Object.freeze({ __proto__: null, BoxGeometry: Ss, BoxBufferGeometry: Ss, CircleGeometry: mc, CircleBufferGeometry: mc, ConeGeometry: gc, ConeBufferGeometry: gc, CylinderGeometry: fc, CylinderBufferGeometry: fc, DodecahedronGeometry: yc, DodecahedronBufferGeometry: yc, EdgesGeometry: Mc, ExtrudeGeometry: vh, ExtrudeBufferGeometry: vh, IcosahedronGeometry: xh, IcosahedronBufferGeometry: xh, LatheGeometry: _h, LatheBufferGeometry: _h, OctahedronGeometry: bh, OctahedronBufferGeometry: bh, ParametricGeometry: wh, ParametricBufferGeometry: wh, PlaneGeometry: Ws, PlaneBufferGeometry: Ws, PolyhedronGeometry: vc, PolyhedronBufferGeometry: vc, RingGeometry: Mh, RingBufferGeometry: Mh, ShapeGeometry: Sh, ShapeBufferGeometry: Sh, SphereGeometry: Th, SphereBufferGeometry: Th, TetrahedronGeometry: Eh, TetrahedronBufferGeometry: Eh, TextGeometry: Ah, TextBufferGeometry: Ah, TorusGeometry: Lh, TorusBufferGeometry: Lh, TorusKnotGeometry: Rh, TorusKnotBufferGeometry: Rh, TubeGeometry: Ch, TubeBufferGeometry: Ch, WireframeGeometry: Ph });
                class Dh extends Er {
                    constructor(t) { super(), this.type = "ShadowMaterial", this.color = new Dr(0), this.transparent = !0, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this }
                }
                Dh.prototype.isShadowMaterial = !0;
                class Nh extends Ls { constructor(t) { super(t), this.type = "RawShaderMaterial" } }
                Nh.prototype.isRawShaderMaterial = !0;
                class Bh extends Er {
                    constructor(t) { super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Dr(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Dr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = un, this.normalScale = new $n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.vertexTangents = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this.vertexTangents = t.vertexTangents, this }
                }
                Bh.prototype.isMeshStandardMaterial = !0;
                class Oh extends Bh {
                    constructor(t) { super(), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new $n(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", { get: function() { return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity) }, set: function(t) { this.reflectivity = qn(2.5 * (t - 1) / (t + 1), 0, 1) } }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.thickness = .01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Dr(1, 1, 1), this.setValues(t) }
                    copy(t) { return super.copy(t), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new Dr).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this }
                }
                Oh.prototype.isMeshPhysicalMaterial = !0;
                class Fh extends Er {
                    constructor(t) { super(), this.type = "MeshPhongMaterial", this.color = new Dr(16777215), this.specular = new Dr(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Dr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = un, this.normalScale = new $n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = $, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this }
                }
                Fh.prototype.isMeshPhongMaterial = !0;
                class zh extends Er {
                    constructor(t) { super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Dr(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Dr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = un, this.normalScale = new $n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }
                }
                zh.prototype.isMeshToonMaterial = !0;
                class Uh extends Er {
                    constructor(t) { super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = un, this.normalScale = new $n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this }
                }
                Uh.prototype.isMeshNormalMaterial = !0;
                class Hh extends Er {
                    constructor(t) { super(), this.type = "MeshLambertMaterial", this.color = new Dr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Dr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = $, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }
                }
                Hh.prototype.isMeshLambertMaterial = !0;
                class kh extends Er {
                    constructor(t) { super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Dr(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = un, this.normalScale = new $n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this }
                }
                kh.prototype.isMeshMatcapMaterial = !0;
                class Gh extends ql {
                    constructor(t) { super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this }
                }
                Gh.prototype.isLineDashedMaterial = !0;
                var Vh = Object.freeze({ __proto__: null, ShadowMaterial: Dh, SpriteMaterial: ul, RawShaderMaterial: Nh, ShaderMaterial: Ls, PointsMaterial: ic, MeshPhysicalMaterial: Oh, MeshStandardMaterial: Bh, MeshPhongMaterial: Fh, MeshToonMaterial: zh, MeshNormalMaterial: Uh, MeshLambertMaterial: Hh, MeshDepthMaterial: ja, MeshDistanceMaterial: qa, MeshBasicMaterial: Nr, MeshMatcapMaterial: kh, LineDashedMaterial: Gh, LineBasicMaterial: ql, Material: Er });
                const Wh = {
                    arraySlice: function(t, e, n) { return Wh.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n) },
                    convertArray: function(t, e, n) { return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t) },
                    isTypedArray: function(t) { return ArrayBuffer.isView(t) && !(t instanceof DataView) },
                    getKeyframeOrder: function(t) {
                        const e = t.length,
                            n = new Array(e);
                        for (let t = 0; t !== e; ++t) n[t] = t;
                        return n.sort((function(e, n) { return t[e] - t[n] })), n
                    },
                    sortedArray: function(t, e, n) {
                        const i = t.length,
                            r = new t.constructor(i);
                        for (let s = 0, o = 0; o !== i; ++s) { const i = n[s] * e; for (let n = 0; n !== e; ++n) r[o++] = t[i + n] }
                        return r
                    },
                    flattenJSON: function(t, e, n, i) {
                        let r = 1,
                            s = t[0];
                        for (; void 0 !== s && void 0 === s[i];) s = t[r++];
                        if (void 0 === s) return;
                        let o = s[i];
                        if (void 0 !== o)
                            if (Array.isArray(o))
                                do { o = s[i], void 0 !== o && (e.push(s.time), n.push.apply(n, o)), s = t[r++] } while (void 0 !== s);
                            else if (void 0 !== o.toArray)
                            do { o = s[i], void 0 !== o && (e.push(s.time), o.toArray(n, n.length)), s = t[r++] } while (void 0 !== s);
                        else
                            do { o = s[i], void 0 !== o && (e.push(s.time), n.push(o)), s = t[r++] } while (void 0 !== s)
                    },
                    subclip: function(t, e, n, i, r = 30) {
                        const s = t.clone();
                        s.name = e;
                        const o = [];
                        for (let t = 0; t < s.tracks.length; ++t) {
                            const e = s.tracks[t],
                                a = e.getValueSize(),
                                l = [],
                                c = [];
                            for (let t = 0; t < e.times.length; ++t) { const s = e.times[t] * r; if (!(s < n || s >= i)) { l.push(e.times[t]); for (let n = 0; n < a; ++n) c.push(e.values[t * a + n]) } }
                            0 !== l.length && (e.times = Wh.convertArray(l, e.times.constructor), e.values = Wh.convertArray(c, e.values.constructor), o.push(e))
                        }
                        s.tracks = o;
                        let a = 1 / 0;
                        for (let t = 0; t < s.tracks.length; ++t) a > s.tracks[t].times[0] && (a = s.tracks[t].times[0]);
                        for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * a);
                        return s.resetDuration(), s
                    },
                    makeClipAdditive: function(t, e = 0, n = t, i = 30) {
                        i <= 0 && (i = 30);
                        const r = n.tracks.length,
                            s = e / i;
                        for (let e = 0; e < r; ++e) {
                            const i = n.tracks[e],
                                r = i.ValueTypeName;
                            if ("bool" === r || "string" === r) continue;
                            const o = t.tracks.find((function(t) { return t.name === i.name && t.ValueTypeName === r }));
                            if (void 0 === o) continue;
                            let a = 0;
                            const l = i.getValueSize();
                            i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
                            let c = 0;
                            const h = o.getValueSize();
                            o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
                            const u = i.times.length - 1;
                            let d;
                            if (s <= i.times[0]) {
                                const t = a,
                                    e = l - a;
                                d = Wh.arraySlice(i.values, t, e)
                            } else if (s >= i.times[u]) {
                                const t = u * l + a,
                                    e = t + l - a;
                                d = Wh.arraySlice(i.values, t, e)
                            } else {
                                const t = i.createInterpolant(),
                                    e = a,
                                    n = l - a;
                                t.evaluate(s), d = Wh.arraySlice(t.resultBuffer, e, n)
                            }
                            "quaternion" === r && (new hi).fromArray(d).normalize().conjugate().toArray(d);
                            const p = o.times.length;
                            for (let t = 0; t < p; ++t) {
                                const e = t * h + c;
                                if ("quaternion" === r) hi.multiplyQuaternionsFlat(o.values, e, d, 0, o.values, e);
                                else { const t = h - 2 * c; for (let n = 0; n < t; ++n) o.values[e + n] -= d[n] }
                            }
                        }
                        return t.blendMode = Je, t
                    }
                };
                class jh {
                    constructor(t, e, n, i) { this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {} }
                    evaluate(t) {
                        const e = this.parameterPositions;
                        let n = this._cachedIndex,
                            i = e[n],
                            r = e[n - 1];
                        t: {
                            e: {
                                let s;n: {
                                    i: if (!(t < i)) {
                                        for (let s = n + 2;;) { if (void 0 === i) { if (t < r) break i; return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r) } if (n === s) break; if (r = i, i = e[++n], t < i) break e }
                                        s = e.length;
                                        break n
                                    }if (t >= r) break t; {
                                        const o = e[1];
                                        t < o && (n = 2, r = o);
                                        for (let s = n - 2;;) { if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i); if (n === s) break; if (i = r, r = e[--n - 1], t >= r) break e }
                                        s = n, n = 0
                                    }
                                }
                                for (; n < s;) {
                                    const i = n + s >>> 1;
                                    t < e[i] ? s = i : n = i + 1
                                }
                                if (i = e[n], r = e[n - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                                if (void 0 === i) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, t)
                            }
                            this._cachedIndex = n,
                            this.intervalChanged_(n, r, i)
                        }
                        return this.interpolate_(n, r, t, i)
                    }
                    getSettings_() { return this.settings || this.DefaultSettings_ }
                    copySampleValue_(t) {
                        const e = this.resultBuffer,
                            n = this.sampleValues,
                            i = this.valueSize,
                            r = t * i;
                        for (let t = 0; t !== i; ++t) e[t] = n[r + t];
                        return e
                    }
                    interpolate_() { throw new Error("call to abstract method") }
                    intervalChanged_() {}
                }
                jh.prototype.beforeStart_ = jh.prototype.copySampleValue_, jh.prototype.afterEnd_ = jh.prototype.copySampleValue_;
                class qh extends jh {
                    constructor(t, e, n, i) { super(t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: qe, endingEnd: qe } }
                    intervalChanged_(t, e, n) {
                        const i = this.parameterPositions;
                        let r = t - 2,
                            s = t + 1,
                            o = i[r],
                            a = i[s];
                        if (void 0 === o) switch (this.getSettings_().endingStart) {
                            case Xe:
                                r = t, o = 2 * e - n;
                                break;
                            case Ye:
                                r = i.length - 2, o = e + i[r] - i[r + 1];
                                break;
                            default:
                                r = t, o = n
                        }
                        if (void 0 === a) switch (this.getSettings_().endingEnd) {
                            case Xe:
                                s = t, a = 2 * n - e;
                                break;
                            case Ye:
                                s = 1, a = n + i[1] - i[0];
                                break;
                            default:
                                s = t - 1, a = e
                        }
                        const l = .5 * (n - e),
                            c = this.valueSize;
                        this._weightPrev = l / (e - o), this._weightNext = l / (a - n), this._offsetPrev = r * c, this._offsetNext = s * c
                    }
                    interpolate_(t, e, n, i) {
                        const r = this.resultBuffer,
                            s = this.sampleValues,
                            o = this.valueSize,
                            a = t * o,
                            l = a - o,
                            c = this._offsetPrev,
                            h = this._offsetNext,
                            u = this._weightPrev,
                            d = this._weightNext,
                            p = (n - e) / (i - e),
                            m = p * p,
                            f = m * p,
                            g = -u * f + 2 * u * m - u * p,
                            v = (1 + u) * f + (-1.5 - 2 * u) * m + (-.5 + u) * p + 1,
                            y = (-1 - d) * f + (1.5 + d) * m + .5 * p,
                            x = d * f - d * m;
                        for (let t = 0; t !== o; ++t) r[t] = g * s[c + t] + v * s[l + t] + y * s[a + t] + x * s[h + t];
                        return r
                    }
                }
                class Xh extends jh {
                    constructor(t, e, n, i) { super(t, e, n, i) }
                    interpolate_(t, e, n, i) {
                        const r = this.resultBuffer,
                            s = this.sampleValues,
                            o = this.valueSize,
                            a = t * o,
                            l = a - o,
                            c = (n - e) / (i - e),
                            h = 1 - c;
                        for (let t = 0; t !== o; ++t) r[t] = s[l + t] * h + s[a + t] * c;
                        return r
                    }
                }
                class Yh extends jh {
                    constructor(t, e, n, i) { super(t, e, n, i) }
                    interpolate_(t) { return this.copySampleValue_(t - 1) }
                }
                class Zh {
                    constructor(t, e, n, i) {
                        if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                        if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                        this.name = t, this.times = Wh.convertArray(e, this.TimeBufferType), this.values = Wh.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
                    }
                    static toJSON(t) {
                        const e = t.constructor;
                        let n;
                        if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                        else {
                            n = { name: t.name, times: Wh.convertArray(t.times, Array), values: Wh.convertArray(t.values, Array) };
                            const e = t.getInterpolation();
                            e !== t.DefaultInterpolation && (n.interpolation = e)
                        }
                        return n.type = t.ValueTypeName, n
                    }
                    InterpolantFactoryMethodDiscrete(t) { return new Yh(this.times, this.values, this.getValueSize(), t) }
                    InterpolantFactoryMethodLinear(t) { return new Xh(this.times, this.values, this.getValueSize(), t) }
                    InterpolantFactoryMethodSmooth(t) { return new qh(this.times, this.values, this.getValueSize(), t) }
                    setInterpolation(t) {
                        let e;
                        switch (t) {
                            case Ve:
                                e = this.InterpolantFactoryMethodDiscrete;
                                break;
                            case We:
                                e = this.InterpolantFactoryMethodLinear;
                                break;
                            case je:
                                e = this.InterpolantFactoryMethodSmooth
                        }
                        if (void 0 === e) {
                            const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                            if (void 0 === this.createInterpolant) {
                                if (t === this.DefaultInterpolation) throw new Error(e);
                                this.setInterpolation(this.DefaultInterpolation)
                            }
                            return console.warn("THREE.KeyframeTrack:", e), this
                        }
                        return this.createInterpolant = e, this
                    }
                    getInterpolation() {
                        switch (this.createInterpolant) {
                            case this.InterpolantFactoryMethodDiscrete:
                                return Ve;
                            case this.InterpolantFactoryMethodLinear:
                                return We;
                            case this.InterpolantFactoryMethodSmooth:
                                return je
                        }
                    }
                    getValueSize() { return this.values.length / this.times.length }
                    shift(t) { if (0 !== t) { const e = this.times; for (let n = 0, i = e.length; n !== i; ++n) e[n] += t } return this }
                    scale(t) { if (1 !== t) { const e = this.times; for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t } return this }
                    trim(t, e) {
                        const n = this.times,
                            i = n.length;
                        let r = 0,
                            s = i - 1;
                        for (; r !== i && n[r] < t;) ++r;
                        for (; - 1 !== s && n[s] > e;) --s;
                        if (++s, 0 !== r || s !== i) {
                            r >= s && (s = Math.max(s, 1), r = s - 1);
                            const t = this.getValueSize();
                            this.times = Wh.arraySlice(n, r, s), this.values = Wh.arraySlice(this.values, r * t, s * t)
                        }
                        return this
                    }
                    validate() {
                        let t = !0;
                        const e = this.getValueSize();
                        e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                        const n = this.times,
                            i = this.values,
                            r = n.length;
                        0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                        let s = null;
                        for (let e = 0; e !== r; e++) {
                            const i = n[e];
                            if ("number" == typeof i && isNaN(i)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i), t = !1; break }
                            if (null !== s && s > i) { console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, s), t = !1; break }
                            s = i
                        }
                        if (void 0 !== i && Wh.isTypedArray(i))
                            for (let e = 0, n = i.length; e !== n; ++e) { const n = i[e]; if (isNaN(n)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1; break } }
                        return t
                    }
                    optimize() {
                        const t = Wh.arraySlice(this.times),
                            e = Wh.arraySlice(this.values),
                            n = this.getValueSize(),
                            i = this.getInterpolation() === je,
                            r = t.length - 1;
                        let s = 1;
                        for (let o = 1; o < r; ++o) {
                            let r = !1;
                            const a = t[o];
                            if (a !== t[o + 1] && (1 !== o || a !== t[0]))
                                if (i) r = !0;
                                else {
                                    const t = o * n,
                                        i = t - n,
                                        s = t + n;
                                    for (let o = 0; o !== n; ++o) { const n = e[t + o]; if (n !== e[i + o] || n !== e[s + o]) { r = !0; break } }
                                }
                            if (r) {
                                if (o !== s) {
                                    t[s] = t[o];
                                    const i = o * n,
                                        r = s * n;
                                    for (let t = 0; t !== n; ++t) e[r + t] = e[i + t]
                                }++s
                            }
                        }
                        if (r > 0) { t[s] = t[r]; for (let t = r * n, i = s * n, o = 0; o !== n; ++o) e[i + o] = e[t + o];++s }
                        return s !== t.length ? (this.times = Wh.arraySlice(t, 0, s), this.values = Wh.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this
                    }
                    clone() {
                        const t = Wh.arraySlice(this.times, 0),
                            e = Wh.arraySlice(this.values, 0),
                            n = new(0, this.constructor)(this.name, t, e);
                        return n.createInterpolant = this.createInterpolant, n
                    }
                }
                Zh.prototype.TimeBufferType = Float32Array, Zh.prototype.ValueBufferType = Float32Array, Zh.prototype.DefaultInterpolation = We;
                class Jh extends Zh {}
                Jh.prototype.ValueTypeName = "bool", Jh.prototype.ValueBufferType = Array, Jh.prototype.DefaultInterpolation = Ve, Jh.prototype.InterpolantFactoryMethodLinear = void 0, Jh.prototype.InterpolantFactoryMethodSmooth = void 0;
                class Kh extends Zh {}
                Kh.prototype.ValueTypeName = "color";
                class Qh extends Zh {}
                Qh.prototype.ValueTypeName = "number";
                class $h extends jh {
                    constructor(t, e, n, i) { super(t, e, n, i) }
                    interpolate_(t, e, n, i) {
                        const r = this.resultBuffer,
                            s = this.sampleValues,
                            o = this.valueSize,
                            a = (n - e) / (i - e);
                        let l = t * o;
                        for (let t = l + o; l !== t; l += 4) hi.slerpFlat(r, 0, s, l - o, s, l, a);
                        return r
                    }
                }
                class tu extends Zh { InterpolantFactoryMethodLinear(t) { return new $h(this.times, this.values, this.getValueSize(), t) } }
                tu.prototype.ValueTypeName = "quaternion", tu.prototype.DefaultInterpolation = We, tu.prototype.InterpolantFactoryMethodSmooth = void 0;
                class eu extends Zh {}
                eu.prototype.ValueTypeName = "string", eu.prototype.ValueBufferType = Array, eu.prototype.DefaultInterpolation = Ve, eu.prototype.InterpolantFactoryMethodLinear = void 0, eu.prototype.InterpolantFactoryMethodSmooth = void 0;
                class nu extends Zh {}
                nu.prototype.ValueTypeName = "vector";
                class iu {
                    constructor(t, e = -1, n, i = Ze) { this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = jn(), this.duration < 0 && this.resetDuration() }
                    static parse(t) {
                        const e = [],
                            n = t.tracks,
                            i = 1 / (t.fps || 1);
                        for (let t = 0, r = n.length; t !== r; ++t) e.push(ru(n[t]).scale(i));
                        const r = new this(t.name, t.duration, e, t.blendMode);
                        return r.uuid = t.uuid, r
                    }
                    static toJSON(t) {
                        const e = [],
                            n = t.tracks,
                            i = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode };
                        for (let t = 0, i = n.length; t !== i; ++t) e.push(Zh.toJSON(n[t]));
                        return i
                    }
                    static CreateFromMorphTargetSequence(t, e, n, i) {
                        const r = e.length,
                            s = [];
                        for (let t = 0; t < r; t++) {
                            let o = [],
                                a = [];
                            o.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0);
                            const l = Wh.getKeyframeOrder(o);
                            o = Wh.sortedArray(o, 1, l), a = Wh.sortedArray(a, 1, l), i || 0 !== o[0] || (o.push(r), a.push(a[0])), s.push(new Qh(".morphTargetInfluences[" + e[t].name + "]", o, a).scale(1 / n))
                        }
                        return new this(t, -1, s)
                    }
                    static findByName(t, e) {
                        let n = t;
                        if (!Array.isArray(t)) {
                            const e = t;
                            n = e.geometry && e.geometry.animations || e.animations
                        }
                        for (let t = 0; t < n.length; t++)
                            if (n[t].name === e) return n[t];
                        return null
                    }
                    static CreateClipsFromMorphTargetSequences(t, e, n) {
                        const i = {},
                            r = /^([\w-]*?)([\d]+)$/;
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e],
                                s = n.name.match(r);
                            if (s && s.length > 1) {
                                const t = s[1];
                                let e = i[t];
                                e || (i[t] = e = []), e.push(n)
                            }
                        }
                        const s = [];
                        for (const t in i) s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
                        return s
                    }
                    static parseAnimation(t, e) {
                        if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                        const n = function(t, e, n, i, r) {
                                if (0 !== n.length) {
                                    const s = [],
                                        o = [];
                                    Wh.flattenJSON(n, s, o, i), 0 !== s.length && r.push(new t(e, s, o))
                                }
                            },
                            i = [],
                            r = t.name || "default",
                            s = t.fps || 30,
                            o = t.blendMode;
                        let a = t.length || -1;
                        const l = t.hierarchy || [];
                        for (let t = 0; t < l.length; t++) {
                            const r = l[t].keys;
                            if (r && 0 !== r.length)
                                if (r[0].morphTargets) {
                                    const t = {};
                                    let e;
                                    for (e = 0; e < r.length; e++)
                                        if (r[e].morphTargets)
                                            for (let n = 0; n < r[e].morphTargets.length; n++) t[r[e].morphTargets[n]] = -1;
                                    for (const n in t) {
                                        const t = [],
                                            s = [];
                                        for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                            const i = r[e];
                                            t.push(i.time), s.push(i.morphTarget === n ? 1 : 0)
                                        }
                                        i.push(new Qh(".morphTargetInfluence[" + n + "]", t, s))
                                    }
                                    a = t.length * (s || 1)
                                } else {
                                    const s = ".bones[" + e[t].name + "]";
                                    n(nu, s + ".position", r, "pos", i), n(tu, s + ".quaternion", r, "rot", i), n(nu, s + ".scale", r, "scl", i)
                                }
                        }
                        return 0 === i.length ? null : new this(r, a, i, o)
                    }
                    resetDuration() {
                        let t = 0;
                        for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                            const n = this.tracks[e];
                            t = Math.max(t, n.times[n.times.length - 1])
                        }
                        return this.duration = t, this
                    }
                    trim() { for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration); return this }
                    validate() { let t = !0; for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate(); return t }
                    optimize() { for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize(); return this }
                    clone() { const t = []; for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone()); return new this.constructor(this.name, this.duration, t, this.blendMode) }
                    toJSON() { return this.constructor.toJSON(this) }
                }

                function ru(t) {
                    if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                    const e = function(t) {
                        switch (t.toLowerCase()) {
                            case "scalar":
                            case "double":
                            case "float":
                            case "number":
                            case "integer":
                                return Qh;
                            case "vector":
                            case "vector2":
                            case "vector3":
                            case "vector4":
                                return nu;
                            case "color":
                                return Kh;
                            case "quaternion":
                                return tu;
                            case "bool":
                            case "boolean":
                                return Jh;
                            case "string":
                                return eu
                        }
                        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                    }(t.type);
                    if (void 0 === t.times) {
                        const e = [],
                            n = [];
                        Wh.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
                    }
                    return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
                }
                const su = { enabled: !1, files: {}, add: function(t, e) {!1 !== this.enabled && (this.files[t] = e) }, get: function(t) { if (!1 !== this.enabled) return this.files[t] }, remove: function(t) { delete this.files[t] }, clear: function() { this.files = {} } };
                class ou {
                    constructor(t, e, n) {
                        const i = this;
                        let r, s = !1,
                            o = 0,
                            a = 0;
                        const l = [];
                        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) { a++, !1 === s && void 0 !== i.onStart && i.onStart(t, o, a), s = !0 }, this.itemEnd = function(t) { o++, void 0 !== i.onProgress && i.onProgress(t, o, a), o === a && (s = !1, void 0 !== i.onLoad && i.onLoad()) }, this.itemError = function(t) { void 0 !== i.onError && i.onError(t) }, this.resolveURL = function(t) { return r ? r(t) : t }, this.setURLModifier = function(t) { return r = t, this }, this.addHandler = function(t, e) { return l.push(t, e), this }, this.removeHandler = function(t) { const e = l.indexOf(t); return -1 !== e && l.splice(e, 2), this }, this.getHandler = function(t) {
                            for (let e = 0, n = l.length; e < n; e += 2) {
                                const n = l[e],
                                    i = l[e + 1];
                                if (n.global && (n.lastIndex = 0), n.test(t)) return i
                            }
                            return null
                        }
                    }
                }
                const au = new ou;
                class lu {
                    constructor(t) { this.manager = void 0 !== t ? t : au, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} }
                    load() {}
                    loadAsync(t, e) { const n = this; return new Promise((function(i, r) { n.load(t, i, e, r) })) }
                    parse() {}
                    setCrossOrigin(t) { return this.crossOrigin = t, this }
                    setWithCredentials(t) { return this.withCredentials = t, this }
                    setPath(t) { return this.path = t, this }
                    setResourcePath(t) { return this.resourcePath = t, this }
                    setRequestHeader(t) { return this.requestHeader = t, this }
                }
                const cu = {};
                class hu extends lu {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                        const r = this,
                            s = su.get(t);
                        if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() { e && e(s), r.manager.itemEnd(t) }), 0), s;
                        if (void 0 !== cu[t]) return void cu[t].push({ onLoad: e, onProgress: n, onError: i });
                        const o = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                        let a;
                        if (o) {
                            const n = o[1],
                                s = !!o[2];
                            let a = o[3];
                            a = decodeURIComponent(a), s && (a = atob(a));
                            try {
                                let i;
                                const s = (this.responseType || "").toLowerCase();
                                switch (s) {
                                    case "arraybuffer":
                                    case "blob":
                                        const t = new Uint8Array(a.length);
                                        for (let e = 0; e < a.length; e++) t[e] = a.charCodeAt(e);
                                        i = "blob" === s ? new Blob([t.buffer], { type: n }) : t.buffer;
                                        break;
                                    case "document":
                                        const e = new DOMParser;
                                        i = e.parseFromString(a, n);
                                        break;
                                    case "json":
                                        i = JSON.parse(a);
                                        break;
                                    default:
                                        i = a
                                }
                                setTimeout((function() { e && e(i), r.manager.itemEnd(t) }), 0)
                            } catch (e) { setTimeout((function() { i && i(e), r.manager.itemError(t), r.manager.itemEnd(t) }), 0) }
                        } else {
                            cu[t] = [], cu[t].push({ onLoad: e, onProgress: n, onError: i }), a = new XMLHttpRequest, a.open("GET", t, !0), a.addEventListener("load", (function(e) {
                                const n = this.response,
                                    i = cu[t];
                                if (delete cu[t], 200 === this.status || 0 === this.status) {
                                    0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), su.add(t, n);
                                    for (let t = 0, e = i.length; t < e; t++) {
                                        const e = i[t];
                                        e.onLoad && e.onLoad(n)
                                    }
                                    r.manager.itemEnd(t)
                                } else {
                                    for (let t = 0, n = i.length; t < n; t++) {
                                        const n = i[t];
                                        n.onError && n.onError(e)
                                    }
                                    r.manager.itemError(t), r.manager.itemEnd(t)
                                }
                            }), !1), a.addEventListener("progress", (function(e) {
                                const n = cu[t];
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    i.onProgress && i.onProgress(e)
                                }
                            }), !1), a.addEventListener("error", (function(e) {
                                const n = cu[t];
                                delete cu[t];
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    i.onError && i.onError(e)
                                }
                                r.manager.itemError(t), r.manager.itemEnd(t)
                            }), !1), a.addEventListener("abort", (function(e) {
                                const n = cu[t];
                                delete cu[t];
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    i.onError && i.onError(e)
                                }
                                r.manager.itemError(t), r.manager.itemEnd(t)
                            }), !1), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                            for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t]);
                            a.send(null)
                        }
                        return r.manager.itemStart(t), a
                    }
                    setResponseType(t) { return this.responseType = t, this }
                    setMimeType(t) { return this.mimeType = t, this }
                }
                class uu extends lu {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = this,
                            s = new hu(this.manager);
                        s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, (function(n) { try { e(r.parse(JSON.parse(n))) } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) } }), n, i)
                    }
                    parse(t) {
                        const e = [];
                        for (let n = 0; n < t.length; n++) {
                            const i = iu.parse(t[n]);
                            e.push(i)
                        }
                        return e
                    }
                }
                class du extends lu {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = this,
                            s = [],
                            o = new uc,
                            a = new hu(this.manager);
                        a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(r.withCredentials);
                        let l = 0;

                        function c(c) {
                            a.load(t[c], (function(t) {
                                const n = r.parse(t, !0);
                                s[c] = { width: n.width, height: n.height, format: n.format, mipmaps: n.mipmaps }, l += 1, 6 === l && (1 === n.mipmapCount && (o.minFilter = Mt), o.image = s, o.format = n.format, o.needsUpdate = !0, e && e(o))
                            }), n, i)
                        }
                        if (Array.isArray(t))
                            for (let e = 0, n = t.length; e < n; ++e) c(e);
                        else a.load(t, (function(t) {
                            const n = r.parse(t, !0);
                            if (n.isCubemap) {
                                const t = n.mipmaps.length / n.mipmapCount;
                                for (let e = 0; e < t; e++) { s[e] = { mipmaps: [] }; for (let t = 0; t < n.mipmapCount; t++) s[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]), s[e].format = n.format, s[e].width = n.width, s[e].height = n.height }
                                o.image = s
                            } else o.image.width = n.width, o.image.height = n.height, o.mipmaps = n.mipmaps;
                            1 === n.mipmapCount && (o.minFilter = Mt), o.format = n.format, o.needsUpdate = !0, e && e(o)
                        }), n, i);
                        return o
                    }
                }
                class pu extends lu {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                        const r = this,
                            s = su.get(t);
                        if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() { e && e(s), r.manager.itemEnd(t) }), 0), s;
                        const o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                        function a() { o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1), su.add(t, this), e && e(this), r.manager.itemEnd(t) }

                        function l(e) { o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t) }
                        return o.addEventListener("load", a, !1), o.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(t), o.src = t, o
                    }
                }
                class mu extends lu {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = new Ds,
                            s = new pu(this.manager);
                        s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                        let o = 0;

                        function a(n) { s.load(t[n], (function(t) { r.images[n] = t, o++, 6 === o && (r.needsUpdate = !0, e && e(r)) }), void 0, i) }
                        for (let e = 0; e < t.length; ++e) a(e);
                        return r
                    }
                }
                class fu extends lu {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = this,
                            s = new Fl,
                            o = new hu(this.manager);
                        return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(r.withCredentials), o.load(t, (function(t) {
                            const n = r.parse(t);
                            n && (void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data), s.wrapS = void 0 !== n.wrapS ? n.wrapS : gt, s.wrapT = void 0 !== n.wrapT ? n.wrapT : gt, s.magFilter = void 0 !== n.magFilter ? n.magFilter : Mt, s.minFilter = void 0 !== n.minFilter ? n.minFilter : Mt, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (s.encoding = n.encoding), void 0 !== n.flipY && (s.flipY = n.flipY), void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = Et), 1 === n.mipmapCount && (s.minFilter = Mt), void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps), s.needsUpdate = !0, e && e(s, n))
                        }), n, i), s
                    }
                }
                class gu extends lu {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = new ri,
                            s = new pu(this.manager);
                        return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function(n) {
                            r.image = n;
                            const i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                            r.format = i ? kt : Gt, r.needsUpdate = !0, void 0 !== e && e(r)
                        }), n, i), r
                    }
                }
                class vu extends Sc {
                    constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 }
                    add(t) { this.curves.push(t) }
                    closePath() {
                        const t = this.curves[0].getPoint(0),
                            e = this.curves[this.curves.length - 1].getPoint(1);
                        t.equals(e) || this.curves.push(new zc(e, t))
                    }
                    getPoint(t) {
                        const e = t * this.getLength(),
                            n = this.getCurveLengths();
                        let i = 0;
                        for (; i < n.length;) {
                            if (n[i] >= e) {
                                const t = n[i] - e,
                                    r = this.curves[i],
                                    s = r.getLength(),
                                    o = 0 === s ? 0 : 1 - t / s;
                                return r.getPointAt(o)
                            }
                            i++
                        }
                        return null
                    }
                    getLength() { const t = this.getCurveLengths(); return t[t.length - 1] }
                    updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() }
                    getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const t = []; let e = 0; for (let n = 0, i = this.curves.length; n < i; n++) e += this.curves[n].getLength(), t.push(e); return this.cacheLengths = t, t }
                    getSpacedPoints(t = 40) { const e = []; for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t)); return this.autoClose && e.push(e[0]), e }
                    getPoints(t = 12) {
                        const e = [];
                        let n;
                        for (let i = 0, r = this.curves; i < r.length; i++) {
                            const s = r[i],
                                o = s && s.isEllipseCurve ? 2 * t : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t,
                                a = s.getPoints(o);
                            for (let t = 0; t < a.length; t++) {
                                const i = a[t];
                                n && n.equals(i) || (e.push(i), n = i)
                            }
                        }
                        return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
                    }
                    copy(t) {
                        super.copy(t), this.curves = [];
                        for (let e = 0, n = t.curves.length; e < n; e++) {
                            const n = t.curves[e];
                            this.curves.push(n.clone())
                        }
                        return this.autoClose = t.autoClose, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.autoClose = this.autoClose, t.curves = [];
                        for (let e = 0, n = this.curves.length; e < n; e++) {
                            const n = this.curves[e];
                            t.curves.push(n.toJSON())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                        for (let e = 0, n = t.curves.length; e < n; e++) {
                            const n = t.curves[e];
                            this.curves.push((new Vc[n.type]).fromJSON(n))
                        }
                        return this
                    }
                }
                class yu extends vu {
                    constructor(t) { super(), this.type = "Path", this.currentPoint = new $n, t && this.setFromPoints(t) }
                    setFromPoints(t) { this.moveTo(t[0].x, t[0].y); for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y); return this }
                    moveTo(t, e) { return this.currentPoint.set(t, e), this }
                    lineTo(t, e) { const n = new zc(this.currentPoint.clone(), new $n(t, e)); return this.curves.push(n), this.currentPoint.set(t, e), this }
                    quadraticCurveTo(t, e, n, i) { const r = new Hc(this.currentPoint.clone(), new $n(t, e), new $n(n, i)); return this.curves.push(r), this.currentPoint.set(n, i), this }
                    bezierCurveTo(t, e, n, i, r, s) { const o = new Oc(this.currentPoint.clone(), new $n(t, e), new $n(n, i), new $n(r, s)); return this.curves.push(o), this.currentPoint.set(r, s), this }
                    splineThru(t) {
                        const e = [this.currentPoint.clone()].concat(t),
                            n = new Gc(e);
                        return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
                    }
                    arc(t, e, n, i, r, s) {
                        const o = this.currentPoint.x,
                            a = this.currentPoint.y;
                        return this.absarc(t + o, e + a, n, i, r, s), this
                    }
                    absarc(t, e, n, i, r, s) { return this.absellipse(t, e, n, n, i, r, s), this }
                    ellipse(t, e, n, i, r, s, o, a) {
                        const l = this.currentPoint.x,
                            c = this.currentPoint.y;
                        return this.absellipse(t + l, e + c, n, i, r, s, o, a), this
                    }
                    absellipse(t, e, n, i, r, s, o, a) {
                        const l = new Tc(t, e, n, i, r, s, o, a);
                        if (this.curves.length > 0) {
                            const t = l.getPoint(0);
                            t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                        }
                        this.curves.push(l);
                        const c = l.getPoint(1);
                        return this.currentPoint.copy(c), this
                    }
                    copy(t) { return super.copy(t), this.currentPoint.copy(t.currentPoint), this }
                    toJSON() { const t = super.toJSON(); return t.currentPoint = this.currentPoint.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this }
                }
                class xu extends yu {
                    constructor(t) { super(t), this.uuid = jn(), this.type = "Shape", this.holes = [] }
                    getPointsHoles(t) { const e = []; for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t); return e }
                    extractPoints(t) { return { shape: this.getPoints(t), holes: this.getPointsHoles(t) } }
                    copy(t) {
                        super.copy(t), this.holes = [];
                        for (let e = 0, n = t.holes.length; e < n; e++) {
                            const n = t.holes[e];
                            this.holes.push(n.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.uuid = this.uuid, t.holes = [];
                        for (let e = 0, n = this.holes.length; e < n; e++) {
                            const n = this.holes[e];
                            t.holes.push(n.toJSON())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
                        for (let e = 0, n = t.holes.length; e < n; e++) {
                            const n = t.holes[e];
                            this.holes.push((new yu).fromJSON(n))
                        }
                        return this
                    }
                }
                class _u extends pr {
                    constructor(t, e = 1) { super(), this.type = "Light", this.color = new Dr(t), this.intensity = e }
                    dispose() {}
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this }
                    toJSON(t) { const e = super.toJSON(t); return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e }
                }
                _u.prototype.isLight = !0;
                class bu extends _u {
                    constructor(t, e, n) { super(t, n), this.type = "HemisphereLight", this.position.copy(pr.DefaultUp), this.updateMatrix(), this.groundColor = new Dr(e) }
                    copy(t) { return _u.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this }
                }
                bu.prototype.isHemisphereLight = !0;
                const wu = new Gi,
                    Mu = new ui,
                    Su = new ui;
                class Tu {
                    constructor(t) { this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new $n(512, 512), this.map = null, this.mapPass = null, this.matrix = new Gi, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new ks, this._frameExtents = new $n(1, 1), this._viewportCount = 1, this._viewports = [new oi(0, 0, 1, 1)] }
                    getViewportCount() { return this._viewportCount }
                    getFrustum() { return this._frustum }
                    updateMatrices(t) {
                        const e = this.camera,
                            n = this.matrix;
                        Mu.setFromMatrixPosition(t.matrixWorld), e.position.copy(Mu), Su.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Su), e.updateMatrixWorld(), wu.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(wu), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
                    }
                    getViewport(t) { return this._viewports[t] }
                    getFrameExtents() { return this._frameExtents }
                    dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() }
                    copy(t) { return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this }
                    clone() { return (new this.constructor).copy(this) }
                    toJSON() { const t = {}; return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t }
                }
                class Eu extends Tu {
                    constructor() { super(new Cs(50, 1, .5, 500)), this.focus = 1 }
                    updateMatrices(t) {
                        const e = this.camera,
                            n = 2 * Wn * t.angle * this.focus,
                            i = this.mapSize.width / this.mapSize.height,
                            r = t.distance || e.far;
                        n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t)
                    }
                    copy(t) { return super.copy(t), this.focus = t.focus, this }
                }
                Eu.prototype.isSpotLightShadow = !0;
                class Au extends _u {
                    constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 1) { super(t, e), this.type = "SpotLight", this.position.copy(pr.DefaultUp), this.updateMatrix(), this.target = new pr, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.shadow = new Eu }
                    get power() { return this.intensity * Math.PI }
                    set power(t) { this.intensity = t / Math.PI }
                    dispose() { this.shadow.dispose() }
                    copy(t) { return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this }
                }
                Au.prototype.isSpotLight = !0;
                const Lu = new Gi,
                    Ru = new ui,
                    Cu = new ui;
                class Pu extends Tu {
                    constructor() { super(new Cs(90, 1, .5, 500)), this._frameExtents = new $n(4, 2), this._viewportCount = 6, this._viewports = [new oi(2, 1, 1, 1), new oi(0, 1, 1, 1), new oi(3, 1, 1, 1), new oi(1, 1, 1, 1), new oi(3, 0, 1, 1), new oi(1, 0, 1, 1)], this._cubeDirections = [new ui(1, 0, 0), new ui(-1, 0, 0), new ui(0, 0, 1), new ui(0, 0, -1), new ui(0, 1, 0), new ui(0, -1, 0)], this._cubeUps = [new ui(0, 1, 0), new ui(0, 1, 0), new ui(0, 1, 0), new ui(0, 1, 0), new ui(0, 0, 1), new ui(0, 0, -1)] }
                    updateMatrices(t, e = 0) {
                        const n = this.camera,
                            i = this.matrix,
                            r = t.distance || n.far;
                        r !== n.far && (n.far = r, n.updateProjectionMatrix()), Ru.setFromMatrixPosition(t.matrixWorld), n.position.copy(Ru), Cu.copy(n.position), Cu.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Cu), n.updateMatrixWorld(), i.makeTranslation(-Ru.x, -Ru.y, -Ru.z), Lu.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Lu)
                    }
                }
                Pu.prototype.isPointLightShadow = !0;
                class Iu extends _u {
                    constructor(t, e, n = 0, i = 1) { super(t, e), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new Pu }
                    get power() { return 4 * this.intensity * Math.PI }
                    set power(t) { this.intensity = t / (4 * Math.PI) }
                    dispose() { this.shadow.dispose() }
                    copy(t) { return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this }
                }
                Iu.prototype.isPointLight = !0;
                class Du extends Rs {
                    constructor(t = -1, e = 1, n = 1, i = -1, r = .1, s = 2e3) { super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix() }
                    copy(t, e) { return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this }
                    setViewOffset(t, e, n, i, r, s) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix() }
                    clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }
                    updateProjectionMatrix() {
                        const t = (this.right - this.left) / (2 * this.zoom),
                            e = (this.top - this.bottom) / (2 * this.zoom),
                            n = (this.right + this.left) / 2,
                            i = (this.top + this.bottom) / 2;
                        let r = n - t,
                            s = n + t,
                            o = i + e,
                            a = i - e;
                        if (null !== this.view && this.view.enabled) {
                            const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                                e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                            r += t * this.view.offsetX, s = r + t * this.view.width, o -= e * this.view.offsetY, a = o - e * this.view.height
                        }
                        this.projectionMatrix.makeOrthographic(r, s, o, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(t) { const e = super.toJSON(t); return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e }
                }
                Du.prototype.isOrthographicCamera = !0;
                class Nu extends Tu { constructor() { super(new Du(-5, 5, 5, -5, .5, 500)) } }
                Nu.prototype.isDirectionalLightShadow = !0;
                class Bu extends _u {
                    constructor(t, e) { super(t, e), this.type = "DirectionalLight", this.position.copy(pr.DefaultUp), this.updateMatrix(), this.target = new pr, this.shadow = new Nu }
                    dispose() { this.shadow.dispose() }
                    copy(t) { return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this }
                }
                Bu.prototype.isDirectionalLight = !0;
                class Ou extends _u { constructor(t, e) { super(t, e), this.type = "AmbientLight" } }
                Ou.prototype.isAmbientLight = !0;
                class Fu extends _u {
                    constructor(t, e, n = 10, i = 10) { super(t, e), this.type = "RectAreaLight", this.width = n, this.height = i }
                    copy(t) { return super.copy(t), this.width = t.width, this.height = t.height, this }
                    toJSON(t) { const e = super.toJSON(t); return e.object.width = this.width, e.object.height = this.height, e }
                }
                Fu.prototype.isRectAreaLight = !0;
                class zu {
                    constructor() { this.coefficients = []; for (let t = 0; t < 9; t++) this.coefficients.push(new ui) }
                    set(t) { for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]); return this }
                    zero() { for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0); return this }
                    getAt(t, e) {
                        const n = t.x,
                            i = t.y,
                            r = t.z,
                            s = this.coefficients;
                        return e.copy(s[0]).multiplyScalar(.282095), e.addScaledVector(s[1], .488603 * i), e.addScaledVector(s[2], .488603 * r), e.addScaledVector(s[3], .488603 * n), e.addScaledVector(s[4], n * i * 1.092548), e.addScaledVector(s[5], i * r * 1.092548), e.addScaledVector(s[6], .315392 * (3 * r * r - 1)), e.addScaledVector(s[7], n * r * 1.092548), e.addScaledVector(s[8], .546274 * (n * n - i * i)), e
                    }
                    getIrradianceAt(t, e) {
                        const n = t.x,
                            i = t.y,
                            r = t.z,
                            s = this.coefficients;
                        return e.copy(s[0]).multiplyScalar(.886227), e.addScaledVector(s[1], 1.023328 * i), e.addScaledVector(s[2], 1.023328 * r), e.addScaledVector(s[3], 1.023328 * n), e.addScaledVector(s[4], .858086 * n * i), e.addScaledVector(s[5], .858086 * i * r), e.addScaledVector(s[6], .743125 * r * r - .247708), e.addScaledVector(s[7], .858086 * n * r), e.addScaledVector(s[8], .429043 * (n * n - i * i)), e
                    }
                    add(t) { for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]); return this }
                    addScaledSH(t, e) { for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e); return this }
                    scale(t) { for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t); return this }
                    lerp(t, e) { for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e); return this }
                    equals(t) {
                        for (let e = 0; e < 9; e++)
                            if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                        return !0
                    }
                    copy(t) { return this.set(t.coefficients) }
                    clone() { return (new this.constructor).copy(this) }
                    fromArray(t, e = 0) { const n = this.coefficients; for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i); return this }
                    toArray(t = [], e = 0) { const n = this.coefficients; for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i); return t }
                    static getBasisAt(t, e) {
                        const n = t.x,
                            i = t.y,
                            r = t.z;
                        e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i)
                    }
                }
                zu.prototype.isSphericalHarmonics3 = !0;
                class Uu extends _u {
                    constructor(t = new zu, e = 1) { super(void 0, e), this.sh = t }
                    copy(t) { return super.copy(t), this.sh.copy(t.sh), this }
                    fromJSON(t) { return this.intensity = t.intensity, this.sh.fromArray(t.sh), this }
                    toJSON(t) { const e = super.toJSON(t); return e.object.sh = this.sh.toArray(), e }
                }
                Uu.prototype.isLightProbe = !0;
                class Hu extends lu {
                    constructor(t) { super(t), this.textures = {} }
                    load(t, e, n, i) {
                        const r = this,
                            s = new hu(r.manager);
                        s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function(n) { try { e(r.parse(JSON.parse(n))) } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) } }), n, i)
                    }
                    parse(t) {
                        const e = this.textures;

                        function n(t) { return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t] }
                        const i = new Vh[t.type];
                        if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && void 0 !== i.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.sheen && (i.sheen = (new Dr).setHex(t.sheen)), void 0 !== t.emissive && void 0 !== i.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && void 0 !== i.specular && i.specular.setHex(t.specular), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.transmission && (i.transmission = t.transmission), void 0 !== t.thickness && (i.thickness = t.thickness), void 0 !== t.attenuationDistance && (i.attenuationDistance = t.attenuationDistance), void 0 !== t.attenuationColor && void 0 !== i.attenuationColor && i.attenuationColor.setHex(t.attenuationColor), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.alphaToCoverage && (i.alphaToCoverage = t.alphaToCoverage), void 0 !== t.premultipliedAlpha && (i.premultipliedAlpha = t.premultipliedAlpha), void 0 !== t.vertexTangents && (i.vertexTangents = t.vertexTangents), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? i.vertexColors = t.vertexColors > 0 : i.vertexColors = t.vertexColors), void 0 !== t.uniforms)
                            for (const e in t.uniforms) {
                                const r = t.uniforms[e];
                                switch (i.uniforms[e] = {}, r.type) {
                                    case "t":
                                        i.uniforms[e].value = n(r.value);
                                        break;
                                    case "c":
                                        i.uniforms[e].value = (new Dr).setHex(r.value);
                                        break;
                                    case "v2":
                                        i.uniforms[e].value = (new $n).fromArray(r.value);
                                        break;
                                    case "v3":
                                        i.uniforms[e].value = (new ui).fromArray(r.value);
                                        break;
                                    case "v4":
                                        i.uniforms[e].value = (new oi).fromArray(r.value);
                                        break;
                                    case "m3":
                                        i.uniforms[e].value = (new ti).fromArray(r.value);
                                        break;
                                    case "m4":
                                        i.uniforms[e].value = (new Gi).fromArray(r.value);
                                        break;
                                    default:
                                        i.uniforms[e].value = r.value
                                }
                            }
                        if (void 0 !== t.defines && (i.defines = t.defines), void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
                            for (const e in t.extensions) i.extensions[e] = t.extensions[e];
                        if (void 0 !== t.shading && (i.flatShading = 1 === t.shading), void 0 !== t.size && (i.size = t.size), void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (i.map = n(t.map)), void 0 !== t.matcap && (i.matcap = n(t.matcap)), void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale), void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType), void 0 !== t.normalScale) { let e = t.normalScale;!1 === Array.isArray(e) && (e = [e, e]), i.normalScale = (new $n).fromArray(e) }
                        return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = (new $n).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmissionMap && (i.transmissionMap = n(t.transmissionMap)), void 0 !== t.thicknessMap && (i.thicknessMap = n(t.thicknessMap)), i
                    }
                    setTextures(t) { return this.textures = t, this }
                }
                class ku {
                    static decodeText(t) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t); let e = ""; for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]); try { return decodeURIComponent(escape(e)) } catch (t) { return e } }
                    static extractUrlBase(t) { const e = t.lastIndexOf("/"); return -1 === e ? "./" : t.substr(0, e + 1) }
                }
                class Gu extends rs {
                    constructor() { super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 }
                    copy(t) { return super.copy(t), this.instanceCount = t.instanceCount, this }
                    clone() { return (new this.constructor).copy(this) }
                    toJSON() { const t = super.toJSON(this); return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t }
                }
                Gu.prototype.isInstancedBufferGeometry = !0;
                class Vu extends Fr {
                    constructor(t, e, n, i = 1) { "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, n), this.meshPerAttribute = i }
                    copy(t) { return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this }
                    toJSON() { const t = super.toJSON(); return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t }
                }
                Vu.prototype.isInstancedBufferAttribute = !0;
                class Wu extends lu {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = this,
                            s = new hu(r.manager);
                        s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function(n) { try { e(r.parse(JSON.parse(n))) } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) } }), n, i)
                    }
                    parse(t) {
                        const e = {},
                            n = {};

                        function i(t, i) {
                            if (void 0 !== e[i]) return e[i];
                            const r = t.interleavedBuffers[i],
                                s = function(t, e) {
                                    if (void 0 !== n[e]) return n[e];
                                    const i = t.arrayBuffers[e],
                                        r = new Uint32Array(i).buffer;
                                    return n[e] = r, r
                                }(t, r.buffer),
                                o = Jr(r.type, s),
                                a = new ll(o, r.stride);
                            return a.uuid = r.uuid, e[i] = a, a
                        }
                        const r = t.isInstancedBufferGeometry ? new Gu : new rs,
                            s = t.data.index;
                        if (void 0 !== s) {
                            const t = Jr(s.type, s.array);
                            r.setIndex(new Fr(t, 1))
                        }
                        const o = t.data.attributes;
                        for (const e in o) {
                            const n = o[e];
                            let s;
                            if (n.isInterleavedBufferAttribute) {
                                const e = i(t.data, n.data);
                                s = new hl(e, n.itemSize, n.offset, n.normalized)
                            } else {
                                const t = Jr(n.type, n.array);
                                s = new(n.isInstancedBufferAttribute ? Vu : Fr)(t, n.itemSize, n.normalized)
                            }
                            void 0 !== n.name && (s.name = n.name), void 0 !== n.usage && s.setUsage(n.usage), void 0 !== n.updateRange && (s.updateRange.offset = n.updateRange.offset, s.updateRange.count = n.updateRange.count), r.setAttribute(e, s)
                        }
                        const a = t.data.morphAttributes;
                        if (a)
                            for (const e in a) {
                                const n = a[e],
                                    s = [];
                                for (let e = 0, r = n.length; e < r; e++) {
                                    const r = n[e];
                                    let o;
                                    if (r.isInterleavedBufferAttribute) {
                                        const e = i(t.data, r.data);
                                        o = new hl(e, r.itemSize, r.offset, r.normalized)
                                    } else {
                                        const t = Jr(r.type, r.array);
                                        o = new Fr(t, r.itemSize, r.normalized)
                                    }
                                    void 0 !== r.name && (o.name = r.name), s.push(o)
                                }
                                r.morphAttributes[e] = s
                            }
                        t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
                        const l = t.data.groups || t.data.drawcalls || t.data.offsets;
                        if (void 0 !== l)
                            for (let t = 0, e = l.length; t !== e; ++t) {
                                const e = l[t];
                                r.addGroup(e.start, e.count, e.materialIndex)
                            }
                        const c = t.data.boundingSphere;
                        if (void 0 !== c) {
                            const t = new ui;
                            void 0 !== c.center && t.fromArray(c.center), r.boundingSphere = new Di(t, c.radius)
                        }
                        return t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r
                    }
                }
                class ju extends lu {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = this,
                            s = "" === this.path ? ku.extractUrlBase(t) : this.path;
                        this.resourcePath = this.resourcePath || s;
                        const o = new hu(this.manager);
                        o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, (function(n) {
                            let s = null;
                            try { s = JSON.parse(n) } catch (e) { return void 0 !== i && i(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message) }
                            const o = s.metadata;
                            void 0 !== o && void 0 !== o.type && "geometry" !== o.type.toLowerCase() ? r.parse(s, e) : console.error("THREE.ObjectLoader: Can't load " + t)
                        }), n, i)
                    }
                    async loadAsync(t, e) {
                        const n = "" === this.path ? ku.extractUrlBase(t) : this.path;
                        this.resourcePath = this.resourcePath || n;
                        const i = new hu(this.manager);
                        i.setPath(this.path), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials);
                        const r = await i.loadAsync(t, e),
                            s = JSON.parse(r),
                            o = s.metadata;
                        if (void 0 === o || void 0 === o.type || "geometry" === o.type.toLowerCase()) throw new Error("THREE.ObjectLoader: Can't load " + t);
                        return await this.parseAsync(s)
                    }
                    parse(t, e) {
                        const n = this.parseAnimations(t.animations),
                            i = this.parseShapes(t.shapes),
                            r = this.parseGeometries(t.geometries, i),
                            s = this.parseImages(t.images, (function() { void 0 !== e && e(l) })),
                            o = this.parseTextures(t.textures, s),
                            a = this.parseMaterials(t.materials, o),
                            l = this.parseObject(t.object, r, a, o, n),
                            c = this.parseSkeletons(t.skeletons, l);
                        if (this.bindSkeletons(l, c), void 0 !== e) {
                            let t = !1;
                            for (const e in s)
                                if (s[e] instanceof HTMLImageElement) { t = !0; break }!1 === t && e(l)
                        }
                        return l
                    }
                    async parseAsync(t) {
                        const e = this.parseAnimations(t.animations),
                            n = this.parseShapes(t.shapes),
                            i = this.parseGeometries(t.geometries, n),
                            r = await this.parseImagesAsync(t.images),
                            s = this.parseTextures(t.textures, r),
                            o = this.parseMaterials(t.materials, s),
                            a = this.parseObject(t.object, i, o, s, e),
                            l = this.parseSkeletons(t.skeletons, a);
                        return this.bindSkeletons(a, l), a
                    }
                    parseShapes(t) {
                        const e = {};
                        if (void 0 !== t)
                            for (let n = 0, i = t.length; n < i; n++) {
                                const i = (new xu).fromJSON(t[n]);
                                e[i.uuid] = i
                            }
                        return e
                    }
                    parseSkeletons(t, e) {
                        const n = {},
                            i = {};
                        if (e.traverse((function(t) { t.isBone && (i[t.uuid] = t) })), void 0 !== t)
                            for (let e = 0, r = t.length; e < r; e++) {
                                const r = (new Hl).fromJSON(t[e], i);
                                n[r.uuid] = r
                            }
                        return n
                    }
                    parseGeometries(t, e) {
                        const n = {};
                        if (void 0 !== t) {
                            const i = new Wu;
                            for (let r = 0, s = t.length; r < s; r++) {
                                let s;
                                const o = t[r];
                                switch (o.type) {
                                    case "BufferGeometry":
                                    case "InstancedBufferGeometry":
                                        s = i.parse(o);
                                        break;
                                    case "Geometry":
                                        console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
                                        break;
                                    default:
                                        o.type in Ih ? s = Ih[o.type].fromJSON(o, e) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${o.type}"`)
                                }
                                s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), !0 === s.isBufferGeometry && void 0 !== o.userData && (s.userData = o.userData), n[o.uuid] = s
                            }
                        }
                        return n
                    }
                    parseMaterials(t, e) {
                        const n = {},
                            i = {};
                        if (void 0 !== t) {
                            const r = new Hu;
                            r.setTextures(e);
                            for (let e = 0, s = t.length; e < s; e++) {
                                const s = t[e];
                                if ("MultiMaterial" === s.type) {
                                    const t = [];
                                    for (let e = 0; e < s.materials.length; e++) {
                                        const i = s.materials[e];
                                        void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)), t.push(n[i.uuid])
                                    }
                                    i[s.uuid] = t
                                } else void 0 === n[s.uuid] && (n[s.uuid] = r.parse(s)), i[s.uuid] = n[s.uuid]
                            }
                        }
                        return i
                    }
                    parseAnimations(t) {
                        const e = {};
                        if (void 0 !== t)
                            for (let n = 0; n < t.length; n++) {
                                const i = t[n],
                                    r = iu.parse(i);
                                e[r.uuid] = r
                            }
                        return e
                    }
                    parseImages(t, e) {
                        const n = this,
                            i = {};
                        let r;

                        function s(t) { if ("string" == typeof t) { const e = t; return function(t) { return n.manager.itemStart(t), r.load(t, (function() { n.manager.itemEnd(t) }), void 0, (function() { n.manager.itemError(t), n.manager.itemEnd(t) })) }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e) } return t.data ? { data: Jr(t.type, t.data), width: t.width, height: t.height } : null }
                        if (void 0 !== t && t.length > 0) {
                            const n = new ou(e);
                            r = new pu(n), r.setCrossOrigin(this.crossOrigin);
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e],
                                    r = n.url;
                                if (Array.isArray(r)) {
                                    i[n.uuid] = [];
                                    for (let t = 0, e = r.length; t < e; t++) {
                                        const e = s(r[t]);
                                        null !== e && (e instanceof HTMLImageElement ? i[n.uuid].push(e) : i[n.uuid].push(new Fl(e.data, e.width, e.height)))
                                    }
                                } else {
                                    const t = s(n.url);
                                    null !== t && (i[n.uuid] = t)
                                }
                            }
                        }
                        return i
                    }
                    async parseImagesAsync(t) {
                        const e = this,
                            n = {};
                        let i;
                        async function r(t) {
                            if ("string" == typeof t) {
                                const n = t,
                                    r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n) ? n : e.resourcePath + n;
                                return await i.loadAsync(r)
                            }
                            return t.data ? { data: Jr(t.type, t.data), width: t.width, height: t.height } : null
                        }
                        if (void 0 !== t && t.length > 0) {
                            i = new pu(this.manager), i.setCrossOrigin(this.crossOrigin);
                            for (let e = 0, i = t.length; e < i; e++) {
                                const i = t[e],
                                    s = i.url;
                                if (Array.isArray(s)) {
                                    n[i.uuid] = [];
                                    for (let t = 0, e = s.length; t < e; t++) {
                                        const e = s[t],
                                            o = await r(e);
                                        null !== o && (o instanceof HTMLImageElement ? n[i.uuid].push(o) : n[i.uuid].push(new Fl(o.data, o.width, o.height)))
                                    }
                                } else {
                                    const t = await r(i.url);
                                    null !== t && (n[i.uuid] = t)
                                }
                            }
                        }
                        return n
                    }
                    parseTextures(t, e) {
                        function n(t, e) { return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t]) }
                        const i = {};
                        if (void 0 !== t)
                            for (let r = 0, s = t.length; r < s; r++) {
                                const s = t[r];
                                let o;
                                void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
                                const a = e[s.image];
                                Array.isArray(a) ? (o = new Ds(a), 6 === a.length && (o.needsUpdate = !0)) : (o = a && a.data ? new Fl(a.data, a.width, a.height) : new ri(a), a && (o.needsUpdate = !0)), o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), void 0 !== s.mapping && (o.mapping = n(s.mapping, qu)), void 0 !== s.offset && o.offset.fromArray(s.offset), void 0 !== s.repeat && o.repeat.fromArray(s.repeat), void 0 !== s.center && o.center.fromArray(s.center), void 0 !== s.rotation && (o.rotation = s.rotation), void 0 !== s.wrap && (o.wrapS = n(s.wrap[0], Xu), o.wrapT = n(s.wrap[1], Xu)), void 0 !== s.format && (o.format = s.format), void 0 !== s.type && (o.type = s.type), void 0 !== s.encoding && (o.encoding = s.encoding), void 0 !== s.minFilter && (o.minFilter = n(s.minFilter, Yu)), void 0 !== s.magFilter && (o.magFilter = n(s.magFilter, Yu)), void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy), void 0 !== s.flipY && (o.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (o.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (o.unpackAlignment = s.unpackAlignment), i[s.uuid] = o
                            }
                        return i
                    }
                    parseObject(t, e, n, i, r) {
                        let s, o, a;

                        function l(t) { return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t] }

                        function c(t) {
                            if (void 0 !== t) {
                                if (Array.isArray(t)) {
                                    const e = [];
                                    for (let i = 0, r = t.length; i < r; i++) {
                                        const r = t[i];
                                        void 0 === n[r] && console.warn("THREE.ObjectLoader: Undefined material", r), e.push(n[r])
                                    }
                                    return e
                                }
                                return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t]
                            }
                        }

                        function h(t) { return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined texture", t), i[t] }
                        switch (t.type) {
                            case "Scene":
                                s = new al, void 0 !== t.background && (Number.isInteger(t.background) ? s.background = new Dr(t.background) : s.background = h(t.background)), void 0 !== t.environment && (s.environment = h(t.environment)), void 0 !== t.fog && ("Fog" === t.fog.type ? s.fog = new ol(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (s.fog = new sl(t.fog.color, t.fog.density)));
                                break;
                            case "PerspectiveCamera":
                                s = new Cs(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (s.focus = t.focus), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.filmGauge && (s.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (s.filmOffset = t.filmOffset), void 0 !== t.view && (s.view = Object.assign({}, t.view));
                                break;
                            case "OrthographicCamera":
                                s = new Du(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.view && (s.view = Object.assign({}, t.view));
                                break;
                            case "AmbientLight":
                                s = new Ou(t.color, t.intensity);
                                break;
                            case "DirectionalLight":
                                s = new Bu(t.color, t.intensity);
                                break;
                            case "PointLight":
                                s = new Iu(t.color, t.intensity, t.distance, t.decay);
                                break;
                            case "RectAreaLight":
                                s = new Fu(t.color, t.intensity, t.width, t.height);
                                break;
                            case "SpotLight":
                                s = new Au(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                                break;
                            case "HemisphereLight":
                                s = new bu(t.color, t.groundColor, t.intensity);
                                break;
                            case "LightProbe":
                                s = (new Uu).fromJSON(t);
                                break;
                            case "SkinnedMesh":
                                o = l(t.geometry), a = c(t.material), s = new Bl(o, a), void 0 !== t.bindMode && (s.bindMode = t.bindMode), void 0 !== t.bindMatrix && s.bindMatrix.fromArray(t.bindMatrix), void 0 !== t.skeleton && (s.skeleton = t.skeleton);
                                break;
                            case "Mesh":
                                o = l(t.geometry), a = c(t.material), s = new ws(o, a);
                                break;
                            case "InstancedMesh":
                                o = l(t.geometry), a = c(t.material);
                                const e = t.count,
                                    n = t.instanceMatrix,
                                    i = t.instanceColor;
                                s = new jl(o, a, e), s.instanceMatrix = new Fr(new Float32Array(n.array), 16), void 0 !== i && (s.instanceColor = new Fr(new Float32Array(i.array), i.itemSize));
                                break;
                            case "LOD":
                                s = new Rl;
                                break;
                            case "Line":
                                s = new Ql(l(t.geometry), c(t.material));
                                break;
                            case "LineLoop":
                                s = new nc(l(t.geometry), c(t.material));
                                break;
                            case "LineSegments":
                                s = new ec(l(t.geometry), c(t.material));
                                break;
                            case "PointCloud":
                            case "Points":
                                s = new lc(l(t.geometry), c(t.material));
                                break;
                            case "Sprite":
                                s = new Tl(c(t.material));
                                break;
                            case "Group":
                                s = new Qa;
                                break;
                            case "Bone":
                                s = new Ol;
                                break;
                            default:
                                s = new pr
                        }
                        if (s.uuid = t.uuid, void 0 !== t.name && (s.name = t.name), void 0 !== t.matrix ? (s.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (s.matrixAutoUpdate = t.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== t.position && s.position.fromArray(t.position), void 0 !== t.rotation && s.rotation.fromArray(t.rotation), void 0 !== t.quaternion && s.quaternion.fromArray(t.quaternion), void 0 !== t.scale && s.scale.fromArray(t.scale)), void 0 !== t.castShadow && (s.castShadow = t.castShadow), void 0 !== t.receiveShadow && (s.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (s.shadow.bias = t.shadow.bias), void 0 !== t.shadow.normalBias && (s.shadow.normalBias = t.shadow.normalBias), void 0 !== t.shadow.radius && (s.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && s.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (s.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (s.visible = t.visible), void 0 !== t.frustumCulled && (s.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (s.renderOrder = t.renderOrder), void 0 !== t.userData && (s.userData = t.userData), void 0 !== t.layers && (s.layers.mask = t.layers), void 0 !== t.children) { const o = t.children; for (let t = 0; t < o.length; t++) s.add(this.parseObject(o[t], e, n, i, r)) }
                        if (void 0 !== t.animations) {
                            const e = t.animations;
                            for (let t = 0; t < e.length; t++) {
                                const n = e[t];
                                s.animations.push(r[n])
                            }
                        }
                        if ("LOD" === t.type) {
                            void 0 !== t.autoUpdate && (s.autoUpdate = t.autoUpdate);
                            const e = t.levels;
                            for (let t = 0; t < e.length; t++) {
                                const n = e[t],
                                    i = s.getObjectByProperty("uuid", n.object);
                                void 0 !== i && s.addLevel(i, n.distance)
                            }
                        }
                        return s
                    }
                    bindSkeletons(t, e) {
                        0 !== Object.keys(e).length && t.traverse((function(t) {
                            if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
                                const n = e[t.skeleton];
                                void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", t.skeleton) : t.bind(n, t.bindMatrix)
                            }
                        }))
                    }
                    setTexturePath(t) { return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t) }
                }
                const qu = { UVMapping: lt, CubeReflectionMapping: ct, CubeRefractionMapping: ht, EquirectangularReflectionMapping: ut, EquirectangularRefractionMapping: dt, CubeUVReflectionMapping: pt, CubeUVRefractionMapping: mt },
                    Xu = { RepeatWrapping: ft, ClampToEdgeWrapping: gt, MirroredRepeatWrapping: vt },
                    Yu = { NearestFilter: yt, NearestMipmapNearestFilter: xt, NearestMipmapLinearFilter: bt, LinearFilter: Mt, LinearMipmapNearestFilter: St, LinearMipmapLinearFilter: Et };
                class Zu extends lu {
                    constructor(t) { super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } }
                    setOptions(t) { return this.options = t, this }
                    load(t, e, n, i) {
                        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                        const r = this,
                            s = su.get(t);
                        if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() { e && e(s), r.manager.itemEnd(t) }), 0), s;
                        const o = {};
                        o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader, fetch(t, o).then((function(t) { return t.blob() })).then((function(t) { return createImageBitmap(t, Object.assign(r.options, { colorSpaceConversion: "none" })) })).then((function(n) { su.add(t, n), e && e(n), r.manager.itemEnd(t) })).catch((function(e) { i && i(e), r.manager.itemError(t), r.manager.itemEnd(t) })), r.manager.itemStart(t)
                    }
                }
                Zu.prototype.isImageBitmapLoader = !0;
                class Ju {
                    constructor() { this.type = "ShapePath", this.color = new Dr, this.subPaths = [], this.currentPath = null }
                    moveTo(t, e) { return this.currentPath = new yu, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this }
                    lineTo(t, e) { return this.currentPath.lineTo(t, e), this }
                    quadraticCurveTo(t, e, n, i) { return this.currentPath.quadraticCurveTo(t, e, n, i), this }
                    bezierCurveTo(t, e, n, i, r, s) { return this.currentPath.bezierCurveTo(t, e, n, i, r, s), this }
                    splineThru(t) { return this.currentPath.splineThru(t), this }
                    toShapes(t, e) {
                        function n(t) {
                            const e = [];
                            for (let n = 0, i = t.length; n < i; n++) {
                                const i = t[n],
                                    r = new xu;
                                r.curves = i.curves, e.push(r)
                            }
                            return e
                        }

                        function i(t, e) {
                            const n = e.length;
                            let i = !1;
                            for (let r = n - 1, s = 0; s < n; r = s++) {
                                let n = e[r],
                                    o = e[s],
                                    a = o.x - n.x,
                                    l = o.y - n.y;
                                if (Math.abs(l) > Number.EPSILON) {
                                    if (l < 0 && (n = e[s], a = -a, o = e[r], l = -l), t.y < n.y || t.y > o.y) continue;
                                    if (t.y === n.y) { if (t.x === n.x) return !0 } else {
                                        const e = l * (t.x - n.x) - a * (t.y - n.y);
                                        if (0 === e) return !0;
                                        if (e < 0) continue;
                                        i = !i
                                    }
                                } else { if (t.y !== n.y) continue; if (o.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= o.x) return !0 }
                            }
                            return i
                        }
                        const r = mh.isClockWise,
                            s = this.subPaths;
                        if (0 === s.length) return [];
                        if (!0 === e) return n(s);
                        let o, a, l;
                        const c = [];
                        if (1 === s.length) return a = s[0], l = new xu, l.curves = a.curves, c.push(l), c;
                        let h = !r(s[0].getPoints());
                        h = t ? !h : h;
                        const u = [],
                            d = [];
                        let p, m, f = [],
                            g = 0;
                        d[g] = void 0, f[g] = [];
                        for (let e = 0, n = s.length; e < n; e++) a = s[e], p = a.getPoints(), o = r(p), o = t ? !o : o, o ? (!h && d[g] && g++, d[g] = { s: new xu, p }, d[g].s.curves = a.curves, h && g++, f[g] = []) : f[g].push({ h: a, p: p[0] });
                        if (!d[0]) return n(s);
                        if (d.length > 1) {
                            let t = !1;
                            const e = [];
                            for (let t = 0, e = d.length; t < e; t++) u[t] = [];
                            for (let n = 0, r = d.length; n < r; n++) {
                                const r = f[n];
                                for (let s = 0; s < r.length; s++) {
                                    const o = r[s];
                                    let a = !0;
                                    for (let r = 0; r < d.length; r++) i(o.p, d[r].p) && (n !== r && e.push({ froms: n, tos: r, hole: s }), a ? (a = !1, u[r].push(o)) : t = !0);
                                    a && u[n].push(o)
                                }
                            }
                            e.length > 0 && (t || (f = u))
                        }
                        for (let t = 0, e = d.length; t < e; t++) { l = d[t].s, c.push(l), m = f[t]; for (let t = 0, e = m.length; t < e; t++) l.holes.push(m[t].h) }
                        return c
                    }
                }
                class Ku {
                    constructor(t) { this.type = "Font", this.data = t }
                    generateShapes(t, e = 100) {
                        const n = [],
                            i = function(t, e, n) {
                                const i = Array.from(t),
                                    r = e / n.resolution,
                                    s = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r,
                                    o = [];
                                let a = 0,
                                    l = 0;
                                for (let t = 0; t < i.length; t++) {
                                    const e = i[t];
                                    if ("\n" === e) a = 0, l -= s;
                                    else {
                                        const t = Qu(e, r, a, l, n);
                                        a += t.offsetX, o.push(t.path)
                                    }
                                }
                                return o
                            }(t, e, this.data);
                        for (let t = 0, e = i.length; t < e; t++) Array.prototype.push.apply(n, i[t].toShapes());
                        return n
                    }
                }

                function Qu(t, e, n, i, r) {
                    const s = r.glyphs[t] || r.glyphs["?"];
                    if (!s) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + r.familyName + ".");
                    const o = new Ju;
                    let a, l, c, h, u, d, p, m;
                    if (s.o) {
                        const t = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
                        for (let r = 0, s = t.length; r < s;) switch (t[r++]) {
                            case "m":
                                a = t[r++] * e + n, l = t[r++] * e + i, o.moveTo(a, l);
                                break;
                            case "l":
                                a = t[r++] * e + n, l = t[r++] * e + i, o.lineTo(a, l);
                                break;
                            case "q":
                                c = t[r++] * e + n, h = t[r++] * e + i, u = t[r++] * e + n, d = t[r++] * e + i, o.quadraticCurveTo(u, d, c, h);
                                break;
                            case "b":
                                c = t[r++] * e + n, h = t[r++] * e + i, u = t[r++] * e + n, d = t[r++] * e + i, p = t[r++] * e + n, m = t[r++] * e + i, o.bezierCurveTo(u, d, p, m, c, h)
                        }
                    }
                    return { offsetX: s.ha * e, path: o }
                }
                Ku.prototype.isFont = !0;
                class $u extends lu {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = this,
                            s = new hu(this.manager);
                        s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function(t) {
                            let n;
                            try { n = JSON.parse(t) } catch (e) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2)) }
                            const i = r.parse(n);
                            e && e(i)
                        }), n, i)
                    }
                    parse(t) { return new Ku(t) }
                }
                let td;
                const ed = { getContext: function() { return void 0 === td && (td = new(window.AudioContext || window.webkitAudioContext)), td }, setContext: function(t) { td = t } };
                class nd extends lu {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = this,
                            s = new hu(this.manager);
                        s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, (function(n) {
                            try {
                                const t = n.slice(0);
                                ed.getContext().decodeAudioData(t, (function(t) { e(t) }))
                            } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) }
                        }), n, i)
                    }
                }
                class id extends Uu {
                    constructor(t, e, n = 1) {
                        super(void 0, n);
                        const i = (new Dr).set(t),
                            r = (new Dr).set(e),
                            s = new ui(i.r, i.g, i.b),
                            o = new ui(r.r, r.g, r.b),
                            a = Math.sqrt(Math.PI),
                            l = a * Math.sqrt(.75);
                        this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a), this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l)
                    }
                }
                id.prototype.isHemisphereLightProbe = !0;
                class rd extends Uu {
                    constructor(t, e = 1) {
                        super(void 0, e);
                        const n = (new Dr).set(t);
                        this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
                    }
                }
                rd.prototype.isAmbientLightProbe = !0;
                const sd = new Gi,
                    od = new Gi;
                class ad {
                    constructor() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Cs, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Cs, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } }
                    update(t) {
                        const e = this._cache;
                        if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
                            e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep;
                            const n = t.projectionMatrix.clone(),
                                i = e.eyeSep / 2,
                                r = i * e.near / e.focus,
                                s = e.near * Math.tan(Vn * e.fov * .5) / e.zoom;
                            let o, a;
                            od.elements[12] = -i, sd.elements[12] = i, o = -s * e.aspect + r, a = s * e.aspect + r, n.elements[0] = 2 * e.near / (a - o), n.elements[8] = (a + o) / (a - o), this.cameraL.projectionMatrix.copy(n), o = -s * e.aspect - r, a = s * e.aspect - r, n.elements[0] = 2 * e.near / (a - o), n.elements[8] = (a + o) / (a - o), this.cameraR.projectionMatrix.copy(n)
                        }
                        this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(od), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(sd)
                    }
                }
                class ld {
                    constructor(t = !0) { this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 }
                    start() { this.startTime = cd(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 }
                    stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 }
                    getElapsedTime() { return this.getDelta(), this.elapsedTime }
                    getDelta() {
                        let t = 0;
                        if (this.autoStart && !this.running) return this.start(), 0;
                        if (this.running) {
                            const e = cd();
                            t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                        }
                        return t
                    }
                }

                function cd() { return ("undefined" == typeof performance ? Date : performance).now() }
                const hd = new ui,
                    ud = new hi,
                    dd = new ui,
                    pd = new ui;
                class md extends pr {
                    constructor() { super(), this.type = "AudioListener", this.context = ed.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new ld }
                    getInput() { return this.gain }
                    removeFilter() { return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this }
                    getFilter() { return this.filter }
                    setFilter(t) { return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this }
                    getMasterVolume() { return this.gain.gain.value }
                    setMasterVolume(t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this }
                    updateMatrixWorld(t) {
                        super.updateMatrixWorld(t);
                        const e = this.context.listener,
                            n = this.up;
                        if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(hd, ud, dd), pd.set(0, 0, -1).applyQuaternion(ud), e.positionX) {
                            const t = this.context.currentTime + this.timeDelta;
                            e.positionX.linearRampToValueAtTime(hd.x, t), e.positionY.linearRampToValueAtTime(hd.y, t), e.positionZ.linearRampToValueAtTime(hd.z, t), e.forwardX.linearRampToValueAtTime(pd.x, t), e.forwardY.linearRampToValueAtTime(pd.y, t), e.forwardZ.linearRampToValueAtTime(pd.z, t), e.upX.linearRampToValueAtTime(n.x, t), e.upY.linearRampToValueAtTime(n.y, t), e.upZ.linearRampToValueAtTime(n.z, t)
                        } else e.setPosition(hd.x, hd.y, hd.z), e.setOrientation(pd.x, pd.y, pd.z, n.x, n.y, n.z)
                    }
                }
                class fd extends pr {
                    constructor(t) { super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] }
                    getOutput() { return this.gain }
                    setNodeSource(t) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this }
                    setMediaElementSource(t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this }
                    setMediaStreamSource(t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this }
                    setBuffer(t) { return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this }
                    play(t = 0) {
                        if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                        if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                        this._startedAt = this.context.currentTime + t;
                        const e = this.context.createBufferSource();
                        return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                    }
                    pause() {
                        if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    stop() {
                        if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    connect() {
                        if (this.filters.length > 0) {
                            this.source.connect(this.filters[0]);
                            for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                            this.filters[this.filters.length - 1].connect(this.getOutput())
                        } else this.source.connect(this.getOutput());
                        return this._connected = !0, this
                    }
                    disconnect() {
                        if (this.filters.length > 0) {
                            this.source.disconnect(this.filters[0]);
                            for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                            this.filters[this.filters.length - 1].disconnect(this.getOutput())
                        } else this.source.disconnect(this.getOutput());
                        return this._connected = !1, this
                    }
                    getFilters() { return this.filters }
                    setFilters(t) { return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this }
                    setDetune(t) { if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this }
                    getDetune() { return this.detune }
                    getFilter() { return this.getFilters()[0] }
                    setFilter(t) { return this.setFilters(t ? [t] : []) }
                    setPlaybackRate(t) {
                        if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    getPlaybackRate() { return this.playbackRate }
                    onEnded() { this.isPlaying = !1 }
                    getLoop() { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop }
                    setLoop(t) {
                        if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    setLoopStart(t) { return this.loopStart = t, this }
                    setLoopEnd(t) { return this.loopEnd = t, this }
                    getVolume() { return this.gain.gain.value }
                    setVolume(t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this }
                }
                const gd = new ui,
                    vd = new hi,
                    yd = new ui,
                    xd = new ui;
                class _d extends fd {
                    constructor(t) { super(t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) }
                    getOutput() { return this.panner }
                    getRefDistance() { return this.panner.refDistance }
                    setRefDistance(t) { return this.panner.refDistance = t, this }
                    getRolloffFactor() { return this.panner.rolloffFactor }
                    setRolloffFactor(t) { return this.panner.rolloffFactor = t, this }
                    getDistanceModel() { return this.panner.distanceModel }
                    setDistanceModel(t) { return this.panner.distanceModel = t, this }
                    getMaxDistance() { return this.panner.maxDistance }
                    setMaxDistance(t) { return this.panner.maxDistance = t, this }
                    setDirectionalCone(t, e, n) { return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this }
                    updateMatrixWorld(t) {
                        if (super.updateMatrixWorld(t), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
                        this.matrixWorld.decompose(gd, vd, yd), xd.set(0, 0, 1).applyQuaternion(vd);
                        const e = this.panner;
                        if (e.positionX) {
                            const t = this.context.currentTime + this.listener.timeDelta;
                            e.positionX.linearRampToValueAtTime(gd.x, t), e.positionY.linearRampToValueAtTime(gd.y, t), e.positionZ.linearRampToValueAtTime(gd.z, t), e.orientationX.linearRampToValueAtTime(xd.x, t), e.orientationY.linearRampToValueAtTime(xd.y, t), e.orientationZ.linearRampToValueAtTime(xd.z, t)
                        } else e.setPosition(gd.x, gd.y, gd.z), e.setOrientation(xd.x, xd.y, xd.z)
                    }
                }
                class bd {
                    constructor(t, e = 2048) { this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser) }
                    getFrequencyData() { return this.analyser.getByteFrequencyData(this.data), this.data }
                    getAverageFrequency() { let t = 0; const e = this.getFrequencyData(); for (let n = 0; n < e.length; n++) t += e[n]; return t / e.length }
                }
                class wd {
                    constructor(t, e, n) {
                        let i, r, s;
                        switch (this.binding = t, this.valueSize = n, e) {
                            case "quaternion":
                                i = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                                break;
                            case "string":
                            case "bool":
                                i = this._select, r = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                                break;
                            default:
                                i = this._lerp, r = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                        }
                        this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                    }
                    accumulate(t, e) {
                        const n = this.buffer,
                            i = this.valueSize,
                            r = t * i + i;
                        let s = this.cumulativeWeight;
                        if (0 === s) {
                            for (let t = 0; t !== i; ++t) n[r + t] = n[t];
                            s = e
                        } else {
                            s += e;
                            const t = e / s;
                            this._mixBufferRegion(n, r, 0, t, i)
                        }
                        this.cumulativeWeight = s
                    }
                    accumulateAdditive(t) {
                        const e = this.buffer,
                            n = this.valueSize,
                            i = n * this._addIndex;
                        0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, i, 0, t, n), this.cumulativeWeightAdditive += t
                    }
                    apply(t) {
                        const e = this.valueSize,
                            n = this.buffer,
                            i = t * e + e,
                            r = this.cumulativeWeight,
                            s = this.cumulativeWeightAdditive,
                            o = this.binding;
                        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                            const t = e * this._origIndex;
                            this._mixBufferRegion(n, i, t, 1 - r, e)
                        }
                        s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
                        for (let t = e, r = e + e; t !== r; ++t)
                            if (n[t] !== n[t + e]) { o.setValue(n, i); break }
                    }
                    saveOriginalState() {
                        const t = this.binding,
                            e = this.buffer,
                            n = this.valueSize,
                            i = n * this._origIndex;
                        t.getValue(e, i);
                        for (let t = n, r = i; t !== r; ++t) e[t] = e[i + t % n];
                        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                    }
                    restoreOriginalState() {
                        const t = 3 * this.valueSize;
                        this.binding.setValue(this.buffer, t)
                    }
                    _setAdditiveIdentityNumeric() {
                        const t = this._addIndex * this.valueSize,
                            e = t + this.valueSize;
                        for (let n = t; n < e; n++) this.buffer[n] = 0
                    }
                    _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 }
                    _setAdditiveIdentityOther() {
                        const t = this._origIndex * this.valueSize,
                            e = this._addIndex * this.valueSize;
                        for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
                    }
                    _select(t, e, n, i, r) {
                        if (i >= .5)
                            for (let i = 0; i !== r; ++i) t[e + i] = t[n + i]
                    }
                    _slerp(t, e, n, i) { hi.slerpFlat(t, e, t, e, t, n, i) }
                    _slerpAdditive(t, e, n, i, r) {
                        const s = this._workIndex * r;
                        hi.multiplyQuaternionsFlat(t, s, t, e, t, n), hi.slerpFlat(t, e, t, e, t, s, i)
                    }
                    _lerp(t, e, n, i, r) {
                        const s = 1 - i;
                        for (let o = 0; o !== r; ++o) {
                            const r = e + o;
                            t[r] = t[r] * s + t[n + o] * i
                        }
                    }
                    _lerpAdditive(t, e, n, i, r) {
                        for (let s = 0; s !== r; ++s) {
                            const r = e + s;
                            t[r] = t[r] + t[n + s] * i
                        }
                    }
                }
                const Md = new RegExp("[\\[\\]\\.:\\/]", "g"),
                    Sd = "[^\\[\\]\\.:\\/]",
                    Td = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                    Ed = /((?:WC+[\/:])*)/.source.replace("WC", Sd),
                    Ad = /(WCOD+)?/.source.replace("WCOD", Td),
                    Ld = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Sd),
                    Rd = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Sd),
                    Cd = new RegExp("^" + Ed + Ad + Ld + Rd + "$"),
                    Pd = ["material", "materials", "bones"];
                class Id {
                    constructor(t, e, n) { this.path = e, this.parsedPath = n || Id.parseTrackName(e), this.node = Id.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound }
                    static create(t, e, n) { return t && t.isAnimationObjectGroup ? new Id.Composite(t, e, n) : new Id(t, e, n) }
                    static sanitizeNodeName(t) { return t.replace(/\s/g, "_").replace(Md, "") }
                    static parseTrackName(t) {
                        const e = Cd.exec(t);
                        if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                        const n = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] },
                            i = n.nodeName && n.nodeName.lastIndexOf(".");
                        if (void 0 !== i && -1 !== i) { const t = n.nodeName.substring(i + 1); - 1 !== Pd.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t) }
                        if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                        return n
                    }
                    static findNode(t, e) {
                        if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                        if (t.skeleton) { const n = t.skeleton.getBoneByName(e); if (void 0 !== n) return n }
                        if (t.children) {
                            const n = function(t) { for (let i = 0; i < t.length; i++) { const r = t[i]; if (r.name === e || r.uuid === e) return r; const s = n(r.children); if (s) return s } return null },
                                i = n(t.children);
                            if (i) return i
                        }
                        return null
                    }
                    _getValue_unavailable() {}
                    _setValue_unavailable() {}
                    _getValue_direct(t, e) { t[e] = this.node[this.propertyName] }
                    _getValue_array(t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i] }
                    _getValue_arrayElement(t, e) { t[e] = this.resolvedProperty[this.propertyIndex] }
                    _getValue_toArray(t, e) { this.resolvedProperty.toArray(t, e) }
                    _setValue_direct(t, e) { this.targetObject[this.propertyName] = t[e] }
                    _setValue_direct_setNeedsUpdate(t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0 }
                    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }
                    _setValue_array(t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++] }
                    _setValue_array_setNeedsUpdate(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_arrayElement(t, e) { this.resolvedProperty[this.propertyIndex] = t[e] }
                    _setValue_arrayElement_setNeedsUpdate(t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0 }
                    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }
                    _setValue_fromArray(t, e) { this.resolvedProperty.fromArray(t, e) }
                    _setValue_fromArray_setNeedsUpdate(t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0 }
                    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0 }
                    _getValue_unbound(t, e) { this.bind(), this.getValue(t, e) }
                    _setValue_unbound(t, e) { this.bind(), this.setValue(t, e) }
                    bind() {
                        let t = this.node;
                        const e = this.parsedPath,
                            n = e.objectName,
                            i = e.propertyName;
                        let r = e.propertyIndex;
                        if (t || (t = Id.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                        if (n) {
                            let i = e.objectIndex;
                            switch (n) {
                                case "materials":
                                    if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    t = t.material.materials;
                                    break;
                                case "bones":
                                    if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    t = t.skeleton.bones;
                                    for (let e = 0; e < t.length; e++)
                                        if (t[e].name === i) { i = e; break }
                                    break;
                                default:
                                    if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    t = t[n]
                            }
                            if (void 0 !== i) {
                                if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                t = t[i]
                            }
                        }
                        const s = t[i];
                        if (void 0 === s) { const n = e.nodeName; return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t) }
                        let o = this.Versioning.None;
                        this.targetObject = t, void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
                        let a = this.BindingType.Direct;
                        if (void 0 !== r) {
                            if ("morphTargetInfluences" === i) {
                                if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                                if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                            }
                            a = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                        } else void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                        this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o]
                    }
                    unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound }
                }
                Id.Composite = class {
                    constructor(t, e, n) {
                        const i = n || Id.parseTrackName(e);
                        this._targetGroup = t, this._bindings = t.subscribe_(e, i)
                    }
                    getValue(t, e) {
                        this.bind();
                        const n = this._targetGroup.nCachedObjects_,
                            i = this._bindings[n];
                        void 0 !== i && i.getValue(t, e)
                    }
                    setValue(t, e) { const n = this._bindings; for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e) }
                    bind() { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind() }
                    unbind() { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind() }
                }, Id.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Id.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, Id.prototype.GetterByBindingType = [Id.prototype._getValue_direct, Id.prototype._getValue_array, Id.prototype._getValue_arrayElement, Id.prototype._getValue_toArray], Id.prototype.SetterByBindingTypeAndVersioning = [
                    [Id.prototype._setValue_direct, Id.prototype._setValue_direct_setNeedsUpdate, Id.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                    [Id.prototype._setValue_array, Id.prototype._setValue_array_setNeedsUpdate, Id.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                    [Id.prototype._setValue_arrayElement, Id.prototype._setValue_arrayElement_setNeedsUpdate, Id.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                    [Id.prototype._setValue_fromArray, Id.prototype._setValue_fromArray_setNeedsUpdate, Id.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
                ];
                class Dd {
                    constructor() {
                        this.uuid = jn(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                        const t = {};
                        this._indicesByUUID = t;
                        for (let e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;
                        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                        const e = this;
                        this.stats = { objects: {get total() { return e._objects.length }, get inUse() { return this.total - e.nCachedObjects_ } }, get bindingsPerObject() { return e._bindings.length } }
                    }
                    add() {
                        const t = this._objects,
                            e = this._indicesByUUID,
                            n = this._paths,
                            i = this._parsedPaths,
                            r = this._bindings,
                            s = r.length;
                        let o, a = t.length,
                            l = this.nCachedObjects_;
                        for (let c = 0, h = arguments.length; c !== h; ++c) {
                            const h = arguments[c],
                                u = h.uuid;
                            let d = e[u];
                            if (void 0 === d) { d = a++, e[u] = d, t.push(h); for (let t = 0, e = s; t !== e; ++t) r[t].push(new Id(h, n[t], i[t])) } else if (d < l) {
                                o = t[d];
                                const a = --l,
                                    c = t[a];
                                e[c.uuid] = d, t[d] = c, e[u] = a, t[a] = h;
                                for (let t = 0, e = s; t !== e; ++t) {
                                    const e = r[t],
                                        s = e[a];
                                    let o = e[d];
                                    e[d] = s, void 0 === o && (o = new Id(h, n[t], i[t])), e[a] = o
                                }
                            } else t[d] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                        }
                        this.nCachedObjects_ = l
                    }
                    remove() {
                        const t = this._objects,
                            e = this._indicesByUUID,
                            n = this._bindings,
                            i = n.length;
                        let r = this.nCachedObjects_;
                        for (let s = 0, o = arguments.length; s !== o; ++s) {
                            const o = arguments[s],
                                a = o.uuid,
                                l = e[a];
                            if (void 0 !== l && l >= r) {
                                const s = r++,
                                    c = t[s];
                                e[c.uuid] = l, t[l] = c, e[a] = s, t[s] = o;
                                for (let t = 0, e = i; t !== e; ++t) {
                                    const e = n[t],
                                        i = e[s],
                                        r = e[l];
                                    e[l] = i, e[s] = r
                                }
                            }
                        }
                        this.nCachedObjects_ = r
                    }
                    uncache() {
                        const t = this._objects,
                            e = this._indicesByUUID,
                            n = this._bindings,
                            i = n.length;
                        let r = this.nCachedObjects_,
                            s = t.length;
                        for (let o = 0, a = arguments.length; o !== a; ++o) {
                            const a = arguments[o].uuid,
                                l = e[a];
                            if (void 0 !== l)
                                if (delete e[a], l < r) {
                                    const o = --r,
                                        a = t[o],
                                        c = --s,
                                        h = t[c];
                                    e[a.uuid] = l, t[l] = a, e[h.uuid] = o, t[o] = h, t.pop();
                                    for (let t = 0, e = i; t !== e; ++t) {
                                        const e = n[t],
                                            i = e[o],
                                            r = e[c];
                                        e[l] = i, e[o] = r, e.pop()
                                    }
                                } else {
                                    const r = --s,
                                        o = t[r];
                                    r > 0 && (e[o.uuid] = l), t[l] = o, t.pop();
                                    for (let t = 0, e = i; t !== e; ++t) {
                                        const e = n[t];
                                        e[l] = e[r], e.pop()
                                    }
                                }
                        }
                        this.nCachedObjects_ = r
                    }
                    subscribe_(t, e) {
                        const n = this._bindingsIndicesByPath;
                        let i = n[t];
                        const r = this._bindings;
                        if (void 0 !== i) return r[i];
                        const s = this._paths,
                            o = this._parsedPaths,
                            a = this._objects,
                            l = a.length,
                            c = this.nCachedObjects_,
                            h = new Array(l);
                        i = r.length, n[t] = i, s.push(t), o.push(e), r.push(h);
                        for (let n = c, i = a.length; n !== i; ++n) {
                            const i = a[n];
                            h[n] = new Id(i, t, e)
                        }
                        return h
                    }
                    unsubscribe_(t) {
                        const e = this._bindingsIndicesByPath,
                            n = e[t];
                        if (void 0 !== n) {
                            const i = this._paths,
                                r = this._parsedPaths,
                                s = this._bindings,
                                o = s.length - 1,
                                a = s[o];
                            e[t[o]] = n, s[n] = a, s.pop(), r[n] = r[o], r.pop(), i[n] = i[o], i.pop()
                        }
                    }
                }
                Dd.prototype.isAnimationObjectGroup = !0;
                class Nd {
                    constructor(t, e, n = null, i = e.blendMode) {
                        this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = i;
                        const r = e.tracks,
                            s = r.length,
                            o = new Array(s),
                            a = { endingStart: qe, endingEnd: qe };
                        for (let t = 0; t !== s; ++t) {
                            const e = r[t].createInterpolant(null);
                            o[t] = e, e.settings = a
                        }
                        this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = ke, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                    }
                    play() { return this._mixer._activateAction(this), this }
                    stop() { return this._mixer._deactivateAction(this), this.reset() }
                    reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() }
                    isRunning() { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) }
                    isScheduled() { return this._mixer._isActiveAction(this) }
                    startAt(t) { return this._startTime = t, this }
                    setLoop(t, e) { return this.loop = t, this.repetitions = e, this }
                    setEffectiveWeight(t) { return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading() }
                    getEffectiveWeight() { return this._effectiveWeight }
                    fadeIn(t) { return this._scheduleFading(t, 0, 1) }
                    fadeOut(t) { return this._scheduleFading(t, 1, 0) }
                    crossFadeFrom(t, e, n) {
                        if (t.fadeOut(e), this.fadeIn(e), n) {
                            const n = this._clip.duration,
                                i = t._clip.duration,
                                r = i / n,
                                s = n / i;
                            t.warp(1, r, e), this.warp(s, 1, e)
                        }
                        return this
                    }
                    crossFadeTo(t, e, n) { return t.crossFadeFrom(this, e, n) }
                    stopFading() { const t = this._weightInterpolant; return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }
                    setEffectiveTimeScale(t) { return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping() }
                    getEffectiveTimeScale() { return this._effectiveTimeScale }
                    setDuration(t) { return this.timeScale = this._clip.duration / t, this.stopWarping() }
                    syncWith(t) { return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping() }
                    halt(t) { return this.warp(this._effectiveTimeScale, 0, t) }
                    warp(t, e, n) {
                        const i = this._mixer,
                            r = i.time,
                            s = this.timeScale;
                        let o = this._timeScaleInterpolant;
                        null === o && (o = i._lendControlInterpolant(), this._timeScaleInterpolant = o);
                        const a = o.parameterPositions,
                            l = o.sampleValues;
                        return a[0] = r, a[1] = r + n, l[0] = t / s, l[1] = e / s, this
                    }
                    stopWarping() { const t = this._timeScaleInterpolant; return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }
                    getMixer() { return this._mixer }
                    getClip() { return this._clip }
                    getRoot() { return this._localRoot || this._mixer._root }
                    _update(t, e, n, i) {
                        if (!this.enabled) return void this._updateWeight(t);
                        const r = this._startTime;
                        if (null !== r) {
                            const i = (t - r) * n;
                            if (i < 0 || 0 === n) return;
                            this._startTime = null, e = n * i
                        }
                        e *= this._updateTimeScale(t);
                        const s = this._updateTime(e),
                            o = this._updateWeight(t);
                        if (o > 0) {
                            const t = this._interpolants,
                                e = this._propertyBindings;
                            if (this.blendMode === Je)
                                for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(s), e[n].accumulateAdditive(o);
                            else
                                for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(s), e[n].accumulate(i, o)
                        }
                    }
                    _updateWeight(t) {
                        let e = 0;
                        if (this.enabled) {
                            e = this.weight;
                            const n = this._weightInterpolant;
                            if (null !== n) {
                                const i = n.evaluate(t)[0];
                                e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = e, e
                    }
                    _updateTimeScale(t) {
                        let e = 0;
                        if (!this.paused) {
                            e = this.timeScale;
                            const n = this._timeScaleInterpolant;
                            null !== n && (e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e))
                        }
                        return this._effectiveTimeScale = e, e
                    }
                    _updateTime(t) {
                        const e = this._clip.duration,
                            n = this.loop;
                        let i = this.time + t,
                            r = this._loopCount;
                        const s = n === Ge;
                        if (0 === t) return -1 === r ? i : s && 1 == (1 & r) ? e - i : i;
                        if (n === He) {
                            -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                            t: {
                                if (i >= e) i = e;
                                else {
                                    if (!(i < 0)) { this.time = i; break t }
                                    i = 0
                                }
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                this.time = i,
                                this._mixer.dispatchEvent({ type: "finished", action: this, direction: t < 0 ? -1 : 1 })
                            }
                        } else {
                            if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), i >= e || i < 0) {
                                const n = Math.floor(i / e);
                                i -= e * n, r += Math.abs(n);
                                const o = this.repetitions - r;
                                if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = t > 0 ? e : 0, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t > 0 ? 1 : -1 });
                                else {
                                    if (1 === o) {
                                        const e = t < 0;
                                        this._setEndings(e, !e, s)
                                    } else this._setEndings(!1, !1, s);
                                    this._loopCount = r, this.time = i, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n })
                                }
                            } else this.time = i;
                            if (s && 1 == (1 & r)) return e - i
                        }
                        return i
                    }
                    _setEndings(t, e, n) {
                        const i = this._interpolantSettings;
                        n ? (i.endingStart = Xe, i.endingEnd = Xe) : (i.endingStart = t ? this.zeroSlopeAtStart ? Xe : qe : Ye, i.endingEnd = e ? this.zeroSlopeAtEnd ? Xe : qe : Ye)
                    }
                    _scheduleFading(t, e, n) {
                        const i = this._mixer,
                            r = i.time;
                        let s = this._weightInterpolant;
                        null === s && (s = i._lendControlInterpolant(), this._weightInterpolant = s);
                        const o = s.parameterPositions,
                            a = s.sampleValues;
                        return o[0] = r, a[0] = e, o[1] = r + t, a[1] = n, this
                    }
                }
                class Bd extends Hn {
                    constructor(t) { super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 }
                    _bindAction(t, e) {
                        const n = t._localRoot || this._root,
                            i = t._clip.tracks,
                            r = i.length,
                            s = t._propertyBindings,
                            o = t._interpolants,
                            a = n.uuid,
                            l = this._bindingsByRootAndName;
                        let c = l[a];
                        void 0 === c && (c = {}, l[a] = c);
                        for (let t = 0; t !== r; ++t) {
                            const r = i[t],
                                l = r.name;
                            let h = c[l];
                            if (void 0 !== h) s[t] = h;
                            else {
                                if (h = s[t], void 0 !== h) { null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, a, l)); continue }
                                const i = e && e._propertyBindings[t].binding.parsedPath;
                                h = new wd(Id.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, a, l), s[t] = h
                            }
                            o[t].resultBuffer = h.buffer
                        }
                    }
                    _activateAction(t) {
                        if (!this._isActiveAction(t)) {
                            if (null === t._cacheIndex) {
                                const e = (t._localRoot || this._root).uuid,
                                    n = t._clip.uuid,
                                    i = this._actionsByClip[n];
                                this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e)
                            }
                            const e = t._propertyBindings;
                            for (let t = 0, n = e.length; t !== n; ++t) {
                                const n = e[t];
                                0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                            }
                            this._lendAction(t)
                        }
                    }
                    _deactivateAction(t) {
                        if (this._isActiveAction(t)) {
                            const e = t._propertyBindings;
                            for (let t = 0, n = e.length; t !== n; ++t) {
                                const n = e[t];
                                0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                            }
                            this._takeBackAction(t)
                        }
                    }
                    _initMemoryManager() {
                        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                        const t = this;
                        this.stats = { actions: {get total() { return t._actions.length }, get inUse() { return t._nActiveActions } }, bindings: {get total() { return t._bindings.length }, get inUse() { return t._nActiveBindings } }, controlInterpolants: {get total() { return t._controlInterpolants.length }, get inUse() { return t._nActiveControlInterpolants } } }
                    }
                    _isActiveAction(t) { const e = t._cacheIndex; return null !== e && e < this._nActiveActions }
                    _addInactiveAction(t, e, n) {
                        const i = this._actions,
                            r = this._actionsByClip;
                        let s = r[e];
                        if (void 0 === s) s = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, r[e] = s;
                        else {
                            const e = s.knownActions;
                            t._byClipCacheIndex = e.length, e.push(t)
                        }
                        t._cacheIndex = i.length, i.push(t), s.actionByRoot[n] = t
                    }
                    _removeInactiveAction(t) {
                        const e = this._actions,
                            n = e[e.length - 1],
                            i = t._cacheIndex;
                        n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null;
                        const r = t._clip.uuid,
                            s = this._actionsByClip,
                            o = s[r],
                            a = o.knownActions,
                            l = a[a.length - 1],
                            c = t._byClipCacheIndex;
                        l._byClipCacheIndex = c, a[c] = l, a.pop(), t._byClipCacheIndex = null, delete o.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete s[r], this._removeInactiveBindingsForAction(t)
                    }
                    _removeInactiveBindingsForAction(t) {
                        const e = t._propertyBindings;
                        for (let t = 0, n = e.length; t !== n; ++t) {
                            const n = e[t];
                            0 == --n.referenceCount && this._removeInactiveBinding(n)
                        }
                    }
                    _lendAction(t) {
                        const e = this._actions,
                            n = t._cacheIndex,
                            i = this._nActiveActions++,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    }
                    _takeBackAction(t) {
                        const e = this._actions,
                            n = t._cacheIndex,
                            i = --this._nActiveActions,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    }
                    _addInactiveBinding(t, e, n) {
                        const i = this._bindingsByRootAndName,
                            r = this._bindings;
                        let s = i[e];
                        void 0 === s && (s = {}, i[e] = s), s[n] = t, t._cacheIndex = r.length, r.push(t)
                    }
                    _removeInactiveBinding(t) {
                        const e = this._bindings,
                            n = t.binding,
                            i = n.rootNode.uuid,
                            r = n.path,
                            s = this._bindingsByRootAndName,
                            o = s[i],
                            a = e[e.length - 1],
                            l = t._cacheIndex;
                        a._cacheIndex = l, e[l] = a, e.pop(), delete o[r], 0 === Object.keys(o).length && delete s[i]
                    }
                    _lendBinding(t) {
                        const e = this._bindings,
                            n = t._cacheIndex,
                            i = this._nActiveBindings++,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    }
                    _takeBackBinding(t) {
                        const e = this._bindings,
                            n = t._cacheIndex,
                            i = --this._nActiveBindings,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    }
                    _lendControlInterpolant() {
                        const t = this._controlInterpolants,
                            e = this._nActiveControlInterpolants++;
                        let n = t[e];
                        return void 0 === n && (n = new Xh(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
                    }
                    _takeBackControlInterpolant(t) {
                        const e = this._controlInterpolants,
                            n = t.__cacheIndex,
                            i = --this._nActiveControlInterpolants,
                            r = e[i];
                        t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
                    }
                    clipAction(t, e, n) {
                        const i = e || this._root,
                            r = i.uuid;
                        let s = "string" == typeof t ? iu.findByName(i, t) : t;
                        const o = null !== s ? s.uuid : t,
                            a = this._actionsByClip[o];
                        let l = null;
                        if (void 0 === n && (n = null !== s ? s.blendMode : Ze), void 0 !== a) {
                            const t = a.actionByRoot[r];
                            if (void 0 !== t && t.blendMode === n) return t;
                            l = a.knownActions[0], null === s && (s = l._clip)
                        }
                        if (null === s) return null;
                        const c = new Nd(this, s, e, n);
                        return this._bindAction(c, l), this._addInactiveAction(c, o, r), c
                    }
                    existingAction(t, e) {
                        const n = e || this._root,
                            i = n.uuid,
                            r = "string" == typeof t ? iu.findByName(n, t) : t,
                            s = r ? r.uuid : t,
                            o = this._actionsByClip[s];
                        return void 0 !== o && o.actionByRoot[i] || null
                    }
                    stopAllAction() { const t = this._actions; for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop(); return this }
                    update(t) {
                        t *= this.timeScale;
                        const e = this._actions,
                            n = this._nActiveActions,
                            i = this.time += t,
                            r = Math.sign(t),
                            s = this._accuIndex ^= 1;
                        for (let o = 0; o !== n; ++o) e[o]._update(i, t, r, s);
                        const o = this._bindings,
                            a = this._nActiveBindings;
                        for (let t = 0; t !== a; ++t) o[t].apply(s);
                        return this
                    }
                    setTime(t) { this.time = 0; for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0; return this.update(t) }
                    getRoot() { return this._root }
                    uncacheClip(t) {
                        const e = this._actions,
                            n = t.uuid,
                            i = this._actionsByClip,
                            r = i[n];
                        if (void 0 !== r) {
                            const t = r.knownActions;
                            for (let n = 0, i = t.length; n !== i; ++n) {
                                const i = t[n];
                                this._deactivateAction(i);
                                const r = i._cacheIndex,
                                    s = e[e.length - 1];
                                i._cacheIndex = null, i._byClipCacheIndex = null, s._cacheIndex = r, e[r] = s, e.pop(), this._removeInactiveBindingsForAction(i)
                            }
                            delete i[n]
                        }
                    }
                    uncacheRoot(t) {
                        const e = t.uuid,
                            n = this._actionsByClip;
                        for (const t in n) {
                            const i = n[t].actionByRoot[e];
                            void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                        }
                        const i = this._bindingsByRootAndName[e];
                        if (void 0 !== i)
                            for (const t in i) {
                                const e = i[t];
                                e.restoreOriginalState(), this._removeInactiveBinding(e)
                            }
                    }
                    uncacheAction(t, e) {
                        const n = this.existingAction(t, e);
                        null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                    }
                }
                Bd.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
                class Od {
                    constructor(t) { "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t }
                    clone() { return new Od(void 0 === this.value.clone ? this.value : this.value.clone()) }
                }
                class Fd extends ll {
                    constructor(t, e, n = 1) { super(t, e), this.meshPerAttribute = n }
                    copy(t) { return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this }
                    clone(t) { const e = super.clone(t); return e.meshPerAttribute = this.meshPerAttribute, e }
                    toJSON(t) { const e = super.toJSON(t); return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e }
                }
                Fd.prototype.isInstancedInterleavedBuffer = !0;
                class zd {
                    constructor(t, e, n, i, r) { this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0 }
                    set needsUpdate(t) {!0 === t && this.version++ }
                    setBuffer(t) { return this.buffer = t, this }
                    setType(t, e) { return this.type = t, this.elementSize = e, this }
                    setItemSize(t) { return this.itemSize = t, this }
                    setCount(t) { return this.count = t, this }
                }
                zd.prototype.isGLBufferAttribute = !0;
                class Ud {
                    constructor(t, e, n = 0, i = 1 / 0) { this.ray = new ki(t, e), this.near = n, this.far = i, this.camera = null, this.layers = new $i, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } }
                    set(t, e) { this.ray.set(t, e) }
                    setFromCamera(t, e) { e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type) }
                    intersectObject(t, e = !1, n = []) { return kd(t, this, n, e), n.sort(Hd), n }
                    intersectObjects(t, e = !1, n = []) { for (let i = 0, r = t.length; i < r; i++) kd(t[i], this, n, e); return n.sort(Hd), n }
                }

                function Hd(t, e) { return t.distance - e.distance }

                function kd(t, e, n, i) { if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i) { const i = t.children; for (let t = 0, r = i.length; t < r; t++) kd(i[t], e, n, !0) } }
                class Gd {
                    constructor(t = 1, e = 0, n = 0) { return this.radius = t, this.phi = e, this.theta = n, this }
                    set(t, e, n) { return this.radius = t, this.phi = e, this.theta = n, this }
                    copy(t) { return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this }
                    makeSafe() { const t = 1e-6; return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this }
                    setFromVector3(t) { return this.setFromCartesianCoords(t.x, t.y, t.z) }
                    setFromCartesianCoords(t, e, n) { return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(qn(e / this.radius, -1, 1))), this }
                    clone() { return (new this.constructor).copy(this) }
                }
                class Vd {
                    constructor(t = 1, e = 0, n = 0) { return this.radius = t, this.theta = e, this.y = n, this }
                    set(t, e, n) { return this.radius = t, this.theta = e, this.y = n, this }
                    copy(t) { return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this }
                    setFromVector3(t) { return this.setFromCartesianCoords(t.x, t.y, t.z) }
                    setFromCartesianCoords(t, e, n) { return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this }
                    clone() { return (new this.constructor).copy(this) }
                }
                const Wd = new $n;
                class jd {
                    constructor(t = new $n(1 / 0, 1 / 0), e = new $n(-1 / 0, -1 / 0)) { this.min = t, this.max = e }
                    set(t, e) { return this.min.copy(t), this.max.copy(e), this }
                    setFromPoints(t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]); return this }
                    setFromCenterAndSize(t, e) { const n = Wd.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { return this.min.copy(t.min), this.max.copy(t.max), this }
                    makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this }
                    isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y }
                    getCenter(t) { return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) }
                    getSize(t) { return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min) }
                    expandByPoint(t) { return this.min.min(t), this.max.max(t), this }
                    expandByVector(t) { return this.min.sub(t), this.max.add(t), this }
                    expandByScalar(t) { return this.min.addScalar(-t), this.max.addScalar(t), this }
                    containsPoint(t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y) }
                    containsBox(t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y }
                    getParameter(t, e) { return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y)) }
                    intersectsBox(t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y) }
                    clampPoint(t, e) { return e.copy(t).clamp(this.min, this.max) }
                    distanceToPoint(t) { return Wd.copy(t).clamp(this.min, this.max).sub(t).length() }
                    intersect(t) { return this.min.max(t.min), this.max.min(t.max), this }
                    union(t) { return this.min.min(t.min), this.max.max(t.max), this }
                    translate(t) { return this.min.add(t), this.max.add(t), this }
                    equals(t) { return t.min.equals(this.min) && t.max.equals(this.max) }
                }
                jd.prototype.isBox2 = !0;
                const qd = new ui,
                    Xd = new ui;
                class Yd {
                    constructor(t = new ui, e = new ui) { this.start = t, this.end = e }
                    set(t, e) { return this.start.copy(t), this.end.copy(e), this }
                    copy(t) { return this.start.copy(t.start), this.end.copy(t.end), this }
                    getCenter(t) { return t.addVectors(this.start, this.end).multiplyScalar(.5) }
                    delta(t) { return t.subVectors(this.end, this.start) }
                    distanceSq() { return this.start.distanceToSquared(this.end) }
                    distance() { return this.start.distanceTo(this.end) }
                    at(t, e) { return this.delta(e).multiplyScalar(t).add(this.start) }
                    closestPointToPointParameter(t, e) { qd.subVectors(t, this.start), Xd.subVectors(this.end, this.start); const n = Xd.dot(Xd); let i = Xd.dot(qd) / n; return e && (i = qn(i, 0, 1)), i }
                    closestPointToPoint(t, e, n) { const i = this.closestPointToPointParameter(t, e); return this.delta(n).multiplyScalar(i).add(this.start) }
                    applyMatrix4(t) { return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this }
                    equals(t) { return t.start.equals(this.start) && t.end.equals(this.end) }
                    clone() { return (new this.constructor).copy(this) }
                }
                class Zd extends pr { constructor(t) { super(), this.material = t, this.render = function() {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0 } }
                Zd.prototype.isImmediateRenderObject = !0;
                const Jd = new ui;
                class Kd extends pr {
                    constructor(t, e) {
                        super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
                        const n = new rs,
                            i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                        for (let t = 0, e = 1, n = 32; t < n; t++, e++) {
                            const r = t / n * Math.PI * 2,
                                s = e / n * Math.PI * 2;
                            i.push(Math.cos(r), Math.sin(r), 1, Math.cos(s), Math.sin(s), 1)
                        }
                        n.setAttribute("position", new qr(i, 3));
                        const r = new ql({ fog: !1, toneMapped: !1 });
                        this.cone = new ec(n, r), this.add(this.cone), this.update()
                    }
                    dispose() { this.cone.geometry.dispose(), this.cone.material.dispose() }
                    update() {
                        this.light.updateMatrixWorld();
                        const t = this.light.distance ? this.light.distance : 1e3,
                            e = t * Math.tan(this.light.angle);
                        this.cone.scale.set(e, e, t), Jd.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Jd), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                    }
                }
                const Qd = new ui,
                    $d = new Gi,
                    tp = new Gi;
                class ep extends ec {
                    constructor(t) {
                        const e = np(t),
                            n = new rs,
                            i = [],
                            r = [],
                            s = new Dr(0, 0, 1),
                            o = new Dr(0, 1, 0);
                        for (let t = 0; t < e.length; t++) {
                            const n = e[t];
                            n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(o.r, o.g, o.b))
                        }
                        n.setAttribute("position", new qr(i, 3)), n.setAttribute("color", new qr(r, 3)), super(n, new ql({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
                    }
                    updateMatrixWorld(t) {
                        const e = this.bones,
                            n = this.geometry,
                            i = n.getAttribute("position");
                        tp.copy(this.root.matrixWorld).invert();
                        for (let t = 0, n = 0; t < e.length; t++) {
                            const r = e[t];
                            r.parent && r.parent.isBone && ($d.multiplyMatrices(tp, r.matrixWorld), Qd.setFromMatrixPosition($d), i.setXYZ(n, Qd.x, Qd.y, Qd.z), $d.multiplyMatrices(tp, r.parent.matrixWorld), Qd.setFromMatrixPosition($d), i.setXYZ(n + 1, Qd.x, Qd.y, Qd.z), n += 2)
                        }
                        n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
                    }
                }

                function np(t) {
                    const e = [];
                    t && t.isBone && e.push(t);
                    for (let n = 0; n < t.children.length; n++) e.push.apply(e, np(t.children[n]));
                    return e
                }
                class ip extends ws {
                    constructor(t, e, n) { super(new Th(e, 4, 2), new Nr({ wireframe: !0, fog: !1, toneMapped: !1 })), this.light = t, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() }
                    dispose() { this.geometry.dispose(), this.material.dispose() }
                    update() { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) }
                }
                const rp = new ui,
                    sp = new Dr,
                    op = new Dr;
                class ap extends pr {
                    constructor(t, e, n) {
                        super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
                        const i = new bh(e);
                        i.rotateY(.5 * Math.PI), this.material = new Nr({ wireframe: !0, fog: !1, toneMapped: !1 }), void 0 === this.color && (this.material.vertexColors = !0);
                        const r = i.getAttribute("position"),
                            s = new Float32Array(3 * r.count);
                        i.setAttribute("color", new Fr(s, 3)), this.add(new ws(i, this.material)), this.update()
                    }
                    dispose() { this.children[0].geometry.dispose(), this.children[0].material.dispose() }
                    update() {
                        const t = this.children[0];
                        if (void 0 !== this.color) this.material.color.set(this.color);
                        else {
                            const e = t.geometry.getAttribute("color");
                            sp.copy(this.light.color), op.copy(this.light.groundColor);
                            for (let t = 0, n = e.count; t < n; t++) {
                                const i = t < n / 2 ? sp : op;
                                e.setXYZ(t, i.r, i.g, i.b)
                            }
                            e.needsUpdate = !0
                        }
                        t.lookAt(rp.setFromMatrixPosition(this.light.matrixWorld).negate())
                    }
                }
                class lp extends ec {
                    constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
                        n = new Dr(n), i = new Dr(i);
                        const r = e / 2,
                            s = t / e,
                            o = t / 2,
                            a = [],
                            l = [];
                        for (let t = 0, c = 0, h = -o; t <= e; t++, h += s) {
                            a.push(-o, 0, h, o, 0, h), a.push(h, 0, -o, h, 0, o);
                            const e = t === r ? n : i;
                            e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3
                        }
                        const c = new rs;
                        c.setAttribute("position", new qr(a, 3)), c.setAttribute("color", new qr(l, 3)), super(c, new ql({ vertexColors: !0, toneMapped: !1 })), this.type = "GridHelper"
                    }
                }
                class cp extends ec {
                    constructor(t = 10, e = 16, n = 8, i = 64, r = 4473924, s = 8947848) {
                        r = new Dr(r), s = new Dr(s);
                        const o = [],
                            a = [];
                        for (let n = 0; n <= e; n++) {
                            const i = n / e * (2 * Math.PI),
                                l = Math.sin(i) * t,
                                c = Math.cos(i) * t;
                            o.push(0, 0, 0), o.push(l, 0, c);
                            const h = 1 & n ? r : s;
                            a.push(h.r, h.g, h.b), a.push(h.r, h.g, h.b)
                        }
                        for (let e = 0; e <= n; e++) {
                            const l = 1 & e ? r : s,
                                c = t - t / n * e;
                            for (let t = 0; t < i; t++) {
                                let e = t / i * (2 * Math.PI),
                                    n = Math.sin(e) * c,
                                    r = Math.cos(e) * c;
                                o.push(n, 0, r), a.push(l.r, l.g, l.b), e = (t + 1) / i * (2 * Math.PI), n = Math.sin(e) * c, r = Math.cos(e) * c, o.push(n, 0, r), a.push(l.r, l.g, l.b)
                            }
                        }
                        const l = new rs;
                        l.setAttribute("position", new qr(o, 3)), l.setAttribute("color", new qr(a, 3)), super(l, new ql({ vertexColors: !0, toneMapped: !1 })), this.type = "PolarGridHelper"
                    }
                }
                const hp = new ui,
                    up = new ui,
                    dp = new ui;
                class pp extends pr {
                    constructor(t, e, n) {
                        super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1);
                        let i = new rs;
                        i.setAttribute("position", new qr([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
                        const r = new ql({ fog: !1, toneMapped: !1 });
                        this.lightPlane = new Ql(i, r), this.add(this.lightPlane), i = new rs, i.setAttribute("position", new qr([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Ql(i, r), this.add(this.targetLine), this.update()
                    }
                    dispose() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() }
                    update() { hp.setFromMatrixPosition(this.light.matrixWorld), up.setFromMatrixPosition(this.light.target.matrixWorld), dp.subVectors(up, hp), this.lightPlane.lookAt(up), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(up), this.targetLine.scale.z = dp.length() }
                }
                const mp = new ui,
                    fp = new Rs;
                class gp extends ec {
                    constructor(t) {
                        const e = new rs,
                            n = new ql({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
                            i = [],
                            r = [],
                            s = {},
                            o = new Dr(16755200),
                            a = new Dr(16711680),
                            l = new Dr(43775),
                            c = new Dr(16777215),
                            h = new Dr(3355443);

                        function u(t, e, n) { d(t, n), d(e, n) }

                        function d(t, e) { i.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === s[t] && (s[t] = []), s[t].push(i.length / 3 - 1) }
                        u("n1", "n2", o), u("n2", "n4", o), u("n4", "n3", o), u("n3", "n1", o), u("f1", "f2", o), u("f2", "f4", o), u("f4", "f3", o), u("f3", "f1", o), u("n1", "f1", o), u("n2", "f2", o), u("n3", "f3", o), u("n4", "f4", o), u("p", "n1", a), u("p", "n2", a), u("p", "n3", a), u("p", "n4", a), u("u1", "u2", l), u("u2", "u3", l), u("u3", "u1", l), u("c", "t", c), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), e.setAttribute("position", new qr(i, 3)), e.setAttribute("color", new qr(r, 3)), super(e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
                    }
                    update() {
                        const t = this.geometry,
                            e = this.pointMap;
                        fp.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), vp("c", e, t, fp, 0, 0, -1), vp("t", e, t, fp, 0, 0, 1), vp("n1", e, t, fp, -1, -1, -1), vp("n2", e, t, fp, 1, -1, -1), vp("n3", e, t, fp, -1, 1, -1), vp("n4", e, t, fp, 1, 1, -1), vp("f1", e, t, fp, -1, -1, 1), vp("f2", e, t, fp, 1, -1, 1), vp("f3", e, t, fp, -1, 1, 1), vp("f4", e, t, fp, 1, 1, 1), vp("u1", e, t, fp, .7, 1.1, -1), vp("u2", e, t, fp, -.7, 1.1, -1), vp("u3", e, t, fp, 0, 2, -1), vp("cf1", e, t, fp, -1, 0, 1), vp("cf2", e, t, fp, 1, 0, 1), vp("cf3", e, t, fp, 0, -1, 1), vp("cf4", e, t, fp, 0, 1, 1), vp("cn1", e, t, fp, -1, 0, -1), vp("cn2", e, t, fp, 1, 0, -1), vp("cn3", e, t, fp, 0, -1, -1), vp("cn4", e, t, fp, 0, 1, -1), t.getAttribute("position").needsUpdate = !0
                    }
                    dispose() { this.geometry.dispose(), this.material.dispose() }
                }

                function vp(t, e, n, i, r, s, o) { mp.set(r, s, o).unproject(i); const a = e[t]; if (void 0 !== a) { const t = n.getAttribute("position"); for (let e = 0, n = a.length; e < n; e++) t.setXYZ(a[e], mp.x, mp.y, mp.z) } }
                const yp = new mi;
                class xp extends ec {
                    constructor(t, e = 16776960) {
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                            i = new Float32Array(24),
                            r = new rs;
                        r.setIndex(new Fr(n, 1)), r.setAttribute("position", new Fr(i, 3)), super(r, new ql({ color: e, toneMapped: !1 })), this.object = t, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
                    }
                    update(t) {
                        if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && yp.setFromObject(this.object), yp.isEmpty()) return;
                        const e = yp.min,
                            n = yp.max,
                            i = this.geometry.attributes.position,
                            r = i.array;
                        r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = e.x, r[4] = n.y, r[5] = n.z, r[6] = e.x, r[7] = e.y, r[8] = n.z, r[9] = n.x, r[10] = e.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = e.z, r[15] = e.x, r[16] = n.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = n.x, r[22] = e.y, r[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
                    }
                    setFromObject(t) { return this.object = t, this.update(), this }
                    copy(t) { return ec.prototype.copy.call(this, t), this.object = t.object, this }
                }
                class _p extends ec {
                    constructor(t, e = 16776960) {
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                            i = new rs;
                        i.setIndex(new Fr(n, 1)), i.setAttribute("position", new qr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(i, new ql({ color: e, toneMapped: !1 })), this.box = t, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
                    }
                    updateMatrixWorld(t) {
                        const e = this.box;
                        e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(t))
                    }
                }
                class bp extends Ql {
                    constructor(t, e = 1, n = 16776960) {
                        const i = n,
                            r = new rs;
                        r.setAttribute("position", new qr([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), super(r, new ql({ color: i, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = t, this.size = e;
                        const s = new rs;
                        s.setAttribute("position", new qr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), s.computeBoundingSphere(), this.add(new ws(s, new Nr({ color: i, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 })))
                    }
                    updateMatrixWorld(t) {
                        let e = -this.plane.constant;
                        Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? x : y, this.lookAt(this.plane.normal), super.updateMatrixWorld(t)
                    }
                }
                const wp = new ui;
                let Mp, Sp;
                class Tp extends pr {
                    constructor(t = new ui(0, 0, 1), e = new ui(0, 0, 0), n = 1, i = 16776960, r = .2 * n, s = .2 * r) { super(), this.type = "ArrowHelper", void 0 === Mp && (Mp = new rs, Mp.setAttribute("position", new qr([0, 0, 0, 0, 1, 0], 3)), Sp = new fc(0, .5, 1, 5, 1), Sp.translate(0, -.5, 0)), this.position.copy(e), this.line = new Ql(Mp, new ql({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new ws(Sp, new Nr({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, r, s) }
                    setDirection(t) {
                        if (t.y > .99999) this.quaternion.set(0, 0, 0, 1);
                        else if (t.y < -.99999) this.quaternion.set(1, 0, 0, 0);
                        else {
                            wp.set(t.z, 0, -t.x).normalize();
                            const e = Math.acos(t.y);
                            this.quaternion.setFromAxisAngle(wp, e)
                        }
                    }
                    setLength(t, e = .2 * t, n = .2 * e) { this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix() }
                    setColor(t) { this.line.material.color.set(t), this.cone.material.color.set(t) }
                    copy(t) { return super.copy(t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this }
                }
                class Ep extends ec {
                    constructor(t = 1) {
                        const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                            n = new rs;
                        n.setAttribute("position", new qr(e, 3)), n.setAttribute("color", new qr([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(n, new ql({ vertexColors: !0, toneMapped: !1 })), this.type = "AxesHelper"
                    }
                    setColors(t, e, n) {
                        const i = new Dr,
                            r = this.geometry.attributes.color.array;
                        return i.set(t), i.toArray(r, 0), i.toArray(r, 3), i.set(e), i.toArray(r, 6), i.toArray(r, 9), i.set(n), i.toArray(r, 12), i.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this
                    }
                    dispose() { this.geometry.dispose(), this.material.dispose() }
                }
                const Ap = new Float32Array(1),
                    Lp = new Int32Array(Ap.buffer);
                class Rp {
                    static toHalfFloat(t) {
                        Ap[0] = t;
                        const e = Lp[0];
                        let n = e >> 16 & 32768,
                            i = e >> 12 & 2047;
                        const r = e >> 23 & 255;
                        return r < 103 ? n : r > 142 ? (n |= 31744, n |= (255 == r ? 0 : 1) && 8388607 & e, n) : r < 113 ? (i |= 2048, n |= (i >> 114 - r) + (i >> 113 - r & 1), n) : (n |= r - 112 << 10 | i >> 1, n += 1 & i, n)
                    }
                }
                const Cp = Math.pow(2, 8),
                    Pp = [.125, .215, .35, .446, .526, .582],
                    Ip = 5 + Pp.length,
                    Dp = {
                        [tn]: 0,
                        [en]: 1,
                        [rn]: 2,
                        [on]: 3,
                        [an]: 4,
                        [ln]: 5,
                        [nn]: 6
                    },
                    Np = new Nr({ side: x, depthWrite: !1, depthTest: !1 }),
                    Bp = new ws(new Ss, Np),
                    Op = new Du,
                    { _lodPlanes: Fp, _sizeLods: zp, _sigmas: Up } = Yp(),
                    Hp = new Dr;
                let kp = null;
                const Gp = (1 + Math.sqrt(5)) / 2,
                    Vp = 1 / Gp,
                    Wp = [new ui(1, 1, 1), new ui(-1, 1, 1), new ui(1, 1, -1), new ui(-1, 1, -1), new ui(0, Gp, Vp), new ui(0, Gp, -Vp), new ui(Vp, 0, Gp), new ui(-Vp, 0, Gp), new ui(Gp, Vp, 0), new ui(-Gp, Vp, 0)];

                function jp(t) {
                    const e = Math.max(t.r, t.g, t.b),
                        n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
                    return t.multiplyScalar(Math.pow(2, -n)), (n + 128) / 255
                }
                class qp {
                    constructor(t) {
                        this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = function(t) {
                            const e = new Float32Array(20),
                                n = new ui(0, 1, 0);
                            return new Nh({ name: "SphericalGaussianBlur", defines: { n: 20 }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: e }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: n }, inputEncoding: { value: Dp[tn] }, outputEncoding: { value: Dp[tn] } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t", blending: M, depthTest: !1, depthWrite: !1 })
                        }(), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
                    }
                    fromScene(t, e = 0, n = .1, i = 100) { kp = this._renderer.getRenderTarget(); const r = this._allocateTargets(); return this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r }
                    fromEquirectangular(t) { return this._fromTexture(t) }
                    fromCubemap(t) { return this._fromTexture(t) }
                    compileCubemapShader() { null === this._cubemapShader && (this._cubemapShader = Qp(), this._compileMaterial(this._cubemapShader)) }
                    compileEquirectangularShader() { null === this._equirectShader && (this._equirectShader = Kp(), this._compileMaterial(this._equirectShader)) }
                    dispose() { this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose(); for (let t = 0; t < Fp.length; t++) Fp[t].dispose() }
                    _cleanup(t) { this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(kp), t.scissorTest = !1, Jp(t, 0, 0, t.width, t.height) }
                    _fromTexture(t) { kp = this._renderer.getRenderTarget(); const e = this._allocateTargets(t); return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e }
                    _allocateTargets(t) {
                        const e = { magFilter: yt, minFilter: yt, generateMipmaps: !1, type: Lt, format: jt, encoding: Xp(t) ? t.encoding : rn, depthBuffer: !1 },
                            n = Zp(e);
                        return n.depthBuffer = !t, this._pingPongRenderTarget = Zp(e), n
                    }
                    _compileMaterial(t) {
                        const e = new ws(Fp[0], t);
                        this._renderer.compile(e, Op)
                    }
                    _sceneToCubeUV(t, e, n, i) {
                        const r = new Cs(90, 1, e, n),
                            s = [1, -1, 1, 1, 1, 1],
                            o = [1, 1, 1, -1, -1, -1],
                            a = this._renderer,
                            l = a.autoClear,
                            c = a.outputEncoding,
                            h = a.toneMapping;
                        a.getClearColor(Hp), a.toneMapping = nt, a.outputEncoding = tn, a.autoClear = !1;
                        let u = !1;
                        const d = t.background;
                        if (d) {
                            if (d.isColor) {
                                Np.color.copy(d).convertSRGBToLinear(), t.background = null;
                                const e = jp(Np.color);
                                Np.opacity = e, u = !0
                            }
                        } else {
                            Np.color.copy(Hp).convertSRGBToLinear();
                            const t = jp(Np.color);
                            Np.opacity = t, u = !0
                        }
                        for (let e = 0; e < 6; e++) {
                            const n = e % 3;
                            0 == n ? (r.up.set(0, s[e], 0), r.lookAt(o[e], 0, 0)) : 1 == n ? (r.up.set(0, 0, s[e]), r.lookAt(0, o[e], 0)) : (r.up.set(0, s[e], 0), r.lookAt(0, 0, o[e])), Jp(i, n * Cp, e > 2 ? Cp : 0, Cp, Cp), a.setRenderTarget(i), u && a.render(Bp, r), a.render(t, r)
                        }
                        a.toneMapping = h, a.outputEncoding = c, a.autoClear = l
                    }
                    _textureToCubeUV(t, e) {
                        const n = this._renderer;
                        t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Qp()) : null == this._equirectShader && (this._equirectShader = Kp());
                        const i = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
                            r = new ws(Fp[0], i),
                            s = i.uniforms;
                        s.envMap.value = t, t.isCubeTexture || s.texelSize.value.set(1 / t.image.width, 1 / t.image.height), s.inputEncoding.value = Dp[t.encoding], s.outputEncoding.value = Dp[e.texture.encoding], Jp(e, 0, 0, 3 * Cp, 2 * Cp), n.setRenderTarget(e), n.render(r, Op)
                    }
                    _applyPMREM(t) {
                        const e = this._renderer,
                            n = e.autoClear;
                        e.autoClear = !1;
                        for (let e = 1; e < Ip; e++) {
                            const n = Math.sqrt(Up[e] * Up[e] - Up[e - 1] * Up[e - 1]),
                                i = Wp[(e - 1) % Wp.length];
                            this._blur(t, e - 1, e, n, i)
                        }
                        e.autoClear = n
                    }
                    _blur(t, e, n, i, r) {
                        const s = this._pingPongRenderTarget;
                        this._halfBlur(t, s, e, n, i, "latitudinal", r), this._halfBlur(s, t, n, n, i, "longitudinal", r)
                    }
                    _halfBlur(t, e, n, i, r, s, o) {
                        const a = this._renderer,
                            l = this._blurMaterial;
                        "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
                        const c = new ws(Fp[i], l),
                            h = l.uniforms,
                            u = zp[n] - 1,
                            d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
                            p = r / d,
                            m = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
                        m > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);
                        const f = [];
                        let g = 0;
                        for (let t = 0; t < 20; ++t) {
                            const e = t / p,
                                n = Math.exp(-e * e / 2);
                            f.push(n), 0 == t ? g += n : t < m && (g += 2 * n)
                        }
                        for (let t = 0; t < f.length; t++) f[t] = f[t] / g;
                        h.envMap.value = t.texture, h.samples.value = m, h.weights.value = f, h.latitudinal.value = "latitudinal" === s, o && (h.poleAxis.value = o), h.dTheta.value = d, h.mipInt.value = 8 - n, h.inputEncoding.value = Dp[t.texture.encoding], h.outputEncoding.value = Dp[t.texture.encoding];
                        const v = zp[i];
                        Jp(e, 3 * Math.max(0, Cp - 2 * v), (0 === i ? 0 : 2 * Cp) + 2 * v * (i > 4 ? i - 8 + 4 : 0), 3 * v, 2 * v), a.setRenderTarget(e), a.render(c, Op)
                    }
                }

                function Xp(t) { return void 0 !== t && t.type === Lt && (t.encoding === tn || t.encoding === en || t.encoding === nn) }

                function Yp() {
                    const t = [],
                        e = [],
                        n = [];
                    let i = 8;
                    for (let r = 0; r < Ip; r++) {
                        const s = Math.pow(2, i);
                        e.push(s);
                        let o = 1 / s;
                        r > 4 ? o = Pp[r - 8 + 4 - 1] : 0 == r && (o = 0), n.push(o);
                        const a = 1 / (s - 1),
                            l = -a / 2,
                            c = 1 + a / 2,
                            h = [l, l, c, l, c, c, l, l, c, c, l, c],
                            u = 6,
                            d = 6,
                            p = 3,
                            m = 2,
                            f = 1,
                            g = new Float32Array(p * d * u),
                            v = new Float32Array(m * d * u),
                            y = new Float32Array(f * d * u);
                        for (let t = 0; t < u; t++) {
                            const e = t % 3 * 2 / 3 - 1,
                                n = t > 2 ? 0 : -1,
                                i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                            g.set(i, p * d * t), v.set(h, m * d * t);
                            const r = [t, t, t, t, t, t];
                            y.set(r, f * d * t)
                        }
                        const x = new rs;
                        x.setAttribute("position", new Fr(g, p)), x.setAttribute("uv", new Fr(v, m)), x.setAttribute("faceIndex", new Fr(y, f)), t.push(x), i > 4 && i--
                    }
                    return { _lodPlanes: t, _sizeLods: e, _sigmas: n }
                }

                function Zp(t) { const e = new ai(3 * Cp, 3 * Cp, t); return e.texture.mapping = pt, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e }

                function Jp(t, e, n, i, r) { t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r) }

                function Kp() { const t = new $n(1, 1); return new Nh({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null }, texelSize: { value: t }, inputEncoding: { value: Dp[tn] }, outputEncoding: { value: Dp[tn] } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t", blending: M, depthTest: !1, depthWrite: !1 }) }

                function Qp() { return new Nh({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, inputEncoding: { value: Dp[tn] }, outputEncoding: { value: Dp[tn] } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t", blending: M, depthTest: !1, depthWrite: !1 }) }
                const $p = 0,
                    tm = 1,
                    em = 0,
                    nm = 1,
                    im = 2;

                function rm(t) { return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t }

                function sm(t = []) { return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() { return t.slice() }, t }

                function om(t, e) { return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new lc(t, e) }

                function am(t) { return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Tl(t) }

                function lm(t, e) { return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new lc(t, e) }

                function cm(t) { return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new ic(t) }

                function hm(t) { return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new ic(t) }

                function um(t) { return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new ic(t) }

                function dm(t, e, n) { return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new ui(t, e, n) }

                function pm(t, e) { return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new Fr(t, e).setUsage(Cn) }

                function mm(t, e) { return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new zr(t, e) }

                function fm(t, e) { return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Ur(t, e) }

                function gm(t, e) { return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Hr(t, e) }

                function vm(t, e) { return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new kr(t, e) }

                function ym(t, e) { return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Gr(t, e) }

                function xm(t, e) { return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Vr(t, e) }

                function _m(t, e) { return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Wr(t, e) }

                function bm(t, e) { return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new qr(t, e) }

                function wm(t, e) { return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Xr(t, e) }

                function Mm(t) { return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Ep(t) }

                function Sm(t, e) { return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new xp(t, e) }

                function Tm(t, e) { return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new ec(new Mc(t.geometry), new ql({ color: void 0 !== e ? e : 16777215 })) }

                function Em(t, e) { return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new ec(new Ph(t.geometry), new ql({ color: void 0 !== e ? e : 16777215 })) }

                function Am(t) { return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new hu(t) }

                function Lm(t) { return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new fu(t) }

                function Rm(t, e, n) { return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new Ns(t, n) }

                function Cm() { console.error("THREE.CanvasRenderer has been removed") }

                function Pm() { console.error("THREE.JSONLoader has been removed.") }
                Sc.create = function(t, e) { return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Sc.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t }, yu.prototype.fromPoints = function(t) { return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t) }, lp.prototype.setColors = function() { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, ep.prototype.update = function() { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, lu.prototype.extractUrlBase = function(t) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), ku.extractUrlBase(t) }, lu.Handlers = { add: function() { console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.") }, get: function() { console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.") } }, jd.prototype.center = function(t) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t) }, jd.prototype.empty = function() { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, jd.prototype.isIntersectionBox = function(t) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, jd.prototype.size = function(t) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t) }, mi.prototype.center = function(t) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, mi.prototype.empty = function() { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, mi.prototype.isIntersectionBox = function(t) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, mi.prototype.isIntersectionSphere = function(t) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) }, mi.prototype.size = function(t) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t) }, Di.prototype.empty = function() { return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, ks.prototype.setFromMatrix = function(t) { return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t) }, Yd.prototype.center = function(t) { return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, ti.prototype.flattenToArrayOffset = function(t, e) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, ti.prototype.multiplyVector3 = function(t) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, ti.prototype.multiplyVector3Array = function() { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, ti.prototype.applyToBufferAttribute = function(t) { return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, ti.prototype.applyToVector3Array = function() { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") }, ti.prototype.getInverse = function(t) { return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert() }, Gi.prototype.extractPosition = function(t) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t) }, Gi.prototype.flattenToArrayOffset = function(t, e) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, Gi.prototype.getPosition = function() { return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new ui).setFromMatrixColumn(this, 3) }, Gi.prototype.setRotationFromQuaternion = function(t) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t) }, Gi.prototype.multiplyToArray = function() { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, Gi.prototype.multiplyVector3 = function(t) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, Gi.prototype.multiplyVector4 = function(t) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, Gi.prototype.multiplyVector3Array = function() { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, Gi.prototype.rotateAxis = function(t) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this) }, Gi.prototype.crossVector = function(t) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, Gi.prototype.translate = function() { console.error("THREE.Matrix4: .translate() has been removed.") }, Gi.prototype.rotateX = function() { console.error("THREE.Matrix4: .rotateX() has been removed.") }, Gi.prototype.rotateY = function() { console.error("THREE.Matrix4: .rotateY() has been removed.") }, Gi.prototype.rotateZ = function() { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, Gi.prototype.rotateByAxis = function() { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, Gi.prototype.applyToBufferAttribute = function(t) { return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, Gi.prototype.applyToVector3Array = function() { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, Gi.prototype.makeFrustum = function(t, e, n, i, r, s) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, s) }, Gi.prototype.getInverse = function(t) { return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert() }, zs.prototype.isIntersectionLine = function(t) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t) }, hi.prototype.multiplyVector3 = function(t) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this) }, hi.prototype.inverse = function() { return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert() }, ki.prototype.isIntersectionBox = function(t) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, ki.prototype.isIntersectionPlane = function(t) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t) }, ki.prototype.isIntersectionSphere = function(t) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) }, Sr.prototype.area = function() { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, Sr.prototype.barycoordFromPoint = function(t, e) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e) }, Sr.prototype.midpoint = function(t) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t) }, Sr.prototypenormal = function(t) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t) }, Sr.prototype.plane = function(t) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t) }, Sr.barycoordFromPoint = function(t, e, n, i, r) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Sr.getBarycoord(t, e, n, i, r) }, Sr.normal = function(t, e, n, i) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Sr.getNormal(t, e, n, i) }, xu.prototype.extractAllPoints = function(t) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t) }, xu.prototype.extrude = function(t) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new vh(this, t) }, xu.prototype.makeGeometry = function(t) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Sh(this, t) }, $n.prototype.fromAttribute = function(t, e, n) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, $n.prototype.distanceToManhattan = function(t) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, $n.prototype.lengthManhattan = function() { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, ui.prototype.setEulerFromRotationMatrix = function() { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, ui.prototype.setEulerFromQuaternion = function() { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, ui.prototype.getPositionFromMatrix = function(t) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t) }, ui.prototype.getScaleFromMatrix = function(t) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t) }, ui.prototype.getColumnFromMatrix = function(t, e) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t) }, ui.prototype.applyProjection = function(t) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t) }, ui.prototype.fromAttribute = function(t, e, n) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, ui.prototype.distanceToManhattan = function(t) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, ui.prototype.lengthManhattan = function() { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, oi.prototype.fromAttribute = function(t, e, n) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, oi.prototype.lengthManhattan = function() { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, pr.prototype.getChildByName = function(t) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t) }, pr.prototype.renderDepth = function() { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, pr.prototype.translate = function(t, e) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t) }, pr.prototype.getWorldRotation = function() { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") }, pr.prototype.applyMatrix = function(t) { return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) }, Object.defineProperties(pr.prototype, { eulerOrder: { get: function() { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function(t) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t } }, useQuaternion: { get: function() { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function() { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), ws.prototype.setDrawMode = function() { console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") }, Object.defineProperties(ws.prototype, { drawMode: { get: function() { return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), Ke }, set: function() { console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } } }), Bl.prototype.initBones = function() { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, Cs.prototype.setLens = function(t, e) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t) }, Object.defineProperties(_u.prototype, { onlyShadow: { set: function() { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function(t) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t } }, shadowCameraLeft: { set: function(t) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t } }, shadowCameraRight: { set: function(t) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t } }, shadowCameraTop: { set: function(t) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t } }, shadowCameraBottom: { set: function(t) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t } }, shadowCameraNear: { set: function(t) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t } }, shadowCameraFar: { set: function(t) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t } }, shadowCameraVisible: { set: function() { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function(t) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t } }, shadowDarkness: { set: function() { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function(t) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t } }, shadowMapHeight: { set: function(t) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t } } }), Object.defineProperties(Fr.prototype, { length: { get: function() { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, dynamic: { get: function() { return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === Cn }, set: function() { console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(Cn) } } }), Fr.prototype.setDynamic = function(t) { return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? Cn : Rn), this }, Fr.prototype.copyIndicesArray = function() { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") }, Fr.prototype.setArray = function() { console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, rs.prototype.addIndex = function(t) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t) }, rs.prototype.addAttribute = function(t, e) { return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Fr(arguments[1], arguments[2]))) }, rs.prototype.addDrawCall = function(t, e, n) { void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e) }, rs.prototype.clearDrawCalls = function() { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, rs.prototype.computeOffsets = function() { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") }, rs.prototype.removeAttribute = function(t) { return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t) }, rs.prototype.applyMatrix = function(t) { return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) }, Object.defineProperties(rs.prototype, { drawcalls: { get: function() { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function() { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), ll.prototype.setDynamic = function(t) { return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? Cn : Rn), this }, ll.prototype.setArray = function() { console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, vh.prototype.getArrays = function() { console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.") }, vh.prototype.addShapeList = function() { console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.") }, vh.prototype.addShape = function() { console.error("THREE.ExtrudeGeometry: .addShape() has been removed.") }, al.prototype.dispose = function() { console.error("THREE.Scene: .dispose() has been removed.") }, Od.prototype.onUpdate = function() { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this }, Object.defineProperties(Er.prototype, { wrapAround: { get: function() { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function() { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function() { console.warn("THREE.Material: .overdraw has been removed.") }, set: function() { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function() { return console.warn("THREE.Material: .wrapRGB has been removed."), new Dr } }, shading: { get: function() { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function(t) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t === b } }, stencilMask: { get: function() { return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask }, set: function(t) { console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t } } }), Object.defineProperties(Ls.prototype, { derivatives: { get: function() { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function(t) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t } } }), il.prototype.clearTarget = function(t, e, n, i) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i) }, il.prototype.animate = function(t) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t) }, il.prototype.getCurrentRenderTarget = function() { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, il.prototype.getMaxAnisotropy = function() { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, il.prototype.getPrecision = function() { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, il.prototype.resetGLState = function() { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, il.prototype.supportsFloatTextures = function() { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, il.prototype.supportsHalfFloatTextures = function() { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, il.prototype.supportsStandardDerivatives = function() { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, il.prototype.supportsCompressedTextureS3TC = function() { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, il.prototype.supportsCompressedTexturePVRTC = function() { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, il.prototype.supportsBlendMinMax = function() { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, il.prototype.supportsVertexTextures = function() { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, il.prototype.supportsInstancedArrays = function() { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, il.prototype.enableScissorTest = function(t) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t) }, il.prototype.initMaterial = function() { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, il.prototype.addPrePlugin = function() { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, il.prototype.addPostPlugin = function() { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, il.prototype.updateShadowMap = function() { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, il.prototype.setFaceCulling = function() { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, il.prototype.allocTextureUnit = function() { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, il.prototype.setTexture = function() { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, il.prototype.setTexture2D = function() { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, il.prototype.setTextureCube = function() { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") }, il.prototype.getActiveMipMapLevel = function() { return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel() }, Object.defineProperties(il.prototype, { shadowMapEnabled: { get: function() { return this.shadowMap.enabled }, set: function(t) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t } }, shadowMapType: { get: function() { return this.shadowMap.type }, set: function(t) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t } }, shadowMapCullFace: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } }, context: { get: function() { return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext() } }, vr: { get: function() { return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr } }, gammaInput: { get: function() { return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1 }, set: function() { console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.") } }, gammaOutput: { get: function() { return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1 }, set: function(t) { console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? en : tn } }, toneMappingWhitePoint: { get: function() { return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1 }, set: function() { console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.") } } }), Object.defineProperties(Xa.prototype, { cullFace: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(ai.prototype, { wrapS: { get: function() { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t } }, wrapT: { get: function() { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t } }, magFilter: { get: function() { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t } }, minFilter: { get: function() { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t } }, anisotropy: { get: function() { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t } }, offset: { get: function() { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t } }, repeat: { get: function() { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t } }, format: { get: function() { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t } }, type: { get: function() { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t } }, generateMipmaps: { get: function() { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t } } }), fd.prototype.load = function(t) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); const e = this; return (new nd).load(t, (function(t) { e.setBuffer(t) })), this }, bd.prototype.getData = function() { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() }, Is.prototype.updateCubeMap = function(t, e) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e) }, Is.prototype.clear = function(t, e, n, i) { return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, i) }, ni.crossOrigin = void 0, ni.loadTexture = function(t, e, n, i) {
                    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                    const r = new gu;
                    r.setCrossOrigin(this.crossOrigin);
                    const s = r.load(t, n, void 0, i);
                    return e && (s.mapping = e), s
                }, ni.loadTextureCube = function(t, e, n, i) {
                    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                    const r = new mu;
                    r.setCrossOrigin(this.crossOrigin);
                    const s = r.load(t, n, void 0, i);
                    return e && (s.mapping = e), s
                }, ni.loadCompressedTexture = function() { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, ni.loadCompressedTextureCube = function() { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") };
                const Im = { createMultiMaterialObject: function() { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, detach: function() { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, attach: function() { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") } };

                function Dm() { console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js") }
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: a } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = a);
                const Nm = new Gi,
                    Bm = new pr,
                    Om = new ui;
                class Fm extends Hn {
                    constructor() {
                        super(), this.uuid = Qn.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                            []
                        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
                    }
                    applyMatrix4(t) {
                        const e = (new ti).getNormalMatrix(t);
                        for (let e = 0, n = this.vertices.length; e < n; e++) this.vertices[e].applyMatrix4(t);
                        for (let t = 0, n = this.faces.length; t < n; t++) {
                            const n = this.faces[t];
                            n.normal.applyMatrix3(e).normalize();
                            for (let t = 0, i = n.vertexNormals.length; t < i; t++) n.vertexNormals[t].applyMatrix3(e).normalize()
                        }
                        return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                    }
                    rotateX(t) { return Nm.makeRotationX(t), this.applyMatrix4(Nm), this }
                    rotateY(t) { return Nm.makeRotationY(t), this.applyMatrix4(Nm), this }
                    rotateZ(t) { return Nm.makeRotationZ(t), this.applyMatrix4(Nm), this }
                    translate(t, e, n) { return Nm.makeTranslation(t, e, n), this.applyMatrix4(Nm), this }
                    scale(t, e, n) { return Nm.makeScale(t, e, n), this.applyMatrix4(Nm), this }
                    lookAt(t) { return Bm.lookAt(t), Bm.updateMatrix(), this.applyMatrix4(Bm.matrix), this }
                    fromBufferGeometry(t) {
                        const e = this,
                            n = null !== t.index ? t.index : void 0,
                            i = t.attributes;
                        if (void 0 === i.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
                        const r = i.position,
                            s = i.normal,
                            o = i.color,
                            a = i.uv,
                            l = i.uv2;
                        void 0 !== l && (this.faceVertexUvs[1] = []);
                        for (let t = 0; t < r.count; t++) e.vertices.push((new ui).fromBufferAttribute(r, t)), void 0 !== o && e.colors.push((new Dr).fromBufferAttribute(o, t));

                        function c(t, n, i, r) {
                            const c = void 0 === o ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[i].clone()],
                                h = void 0 === s ? [] : [(new ui).fromBufferAttribute(s, t), (new ui).fromBufferAttribute(s, n), (new ui).fromBufferAttribute(s, i)],
                                u = new Um(t, n, i, h, c, r);
                            e.faces.push(u), void 0 !== a && e.faceVertexUvs[0].push([(new $n).fromBufferAttribute(a, t), (new $n).fromBufferAttribute(a, n), (new $n).fromBufferAttribute(a, i)]), void 0 !== l && e.faceVertexUvs[1].push([(new $n).fromBufferAttribute(l, t), (new $n).fromBufferAttribute(l, n), (new $n).fromBufferAttribute(l, i)])
                        }
                        const h = t.groups;
                        if (h.length > 0)
                            for (let t = 0; t < h.length; t++) {
                                const e = h[t],
                                    i = e.start;
                                for (let t = i, r = i + e.count; t < r; t += 3) void 0 !== n ? c(n.getX(t), n.getX(t + 1), n.getX(t + 2), e.materialIndex) : c(t, t + 1, t + 2, e.materialIndex)
                            } else if (void 0 !== n)
                                for (let t = 0; t < n.count; t += 3) c(n.getX(t), n.getX(t + 1), n.getX(t + 2));
                            else
                                for (let t = 0; t < r.count; t += 3) c(t, t + 1, t + 2);
                        return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                    }
                    center() { return this.computeBoundingBox(), this.boundingBox.getCenter(Om).negate(), this.translate(Om.x, Om.y, Om.z), this }
                    normalize() {
                        this.computeBoundingSphere();
                        const t = this.boundingSphere.center,
                            e = this.boundingSphere.radius,
                            n = 0 === e ? 1 : 1 / e,
                            i = new Gi;
                        return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix4(i), this
                    }
                    computeFaceNormals() {
                        const t = new ui,
                            e = new ui;
                        for (let n = 0, i = this.faces.length; n < i; n++) {
                            const i = this.faces[n],
                                r = this.vertices[i.a],
                                s = this.vertices[i.b],
                                o = this.vertices[i.c];
                            t.subVectors(o, s), e.subVectors(r, s), t.cross(e), t.normalize(), i.normal.copy(t)
                        }
                    }
                    computeVertexNormals(t = !0) {
                        const e = new Array(this.vertices.length);
                        for (let t = 0, n = this.vertices.length; t < n; t++) e[t] = new ui;
                        if (t) {
                            const t = new ui,
                                n = new ui;
                            for (let i = 0, r = this.faces.length; i < r; i++) {
                                const r = this.faces[i],
                                    s = this.vertices[r.a],
                                    o = this.vertices[r.b],
                                    a = this.vertices[r.c];
                                t.subVectors(a, o), n.subVectors(s, o), t.cross(n), e[r.a].add(t), e[r.b].add(t), e[r.c].add(t)
                            }
                        } else {
                            this.computeFaceNormals();
                            for (let t = 0, n = this.faces.length; t < n; t++) {
                                const n = this.faces[t];
                                e[n.a].add(n.normal), e[n.b].add(n.normal), e[n.c].add(n.normal)
                            }
                        }
                        for (let t = 0, n = this.vertices.length; t < n; t++) e[t].normalize();
                        for (let t = 0, n = this.faces.length; t < n; t++) {
                            const n = this.faces[t],
                                i = n.vertexNormals;
                            3 === i.length ? (i[0].copy(e[n.a]), i[1].copy(e[n.b]), i[2].copy(e[n.c])) : (i[0] = e[n.a].clone(), i[1] = e[n.b].clone(), i[2] = e[n.c].clone())
                        }
                        this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                    }
                    computeFlatVertexNormals() {
                        this.computeFaceNormals();
                        for (let t = 0, e = this.faces.length; t < e; t++) {
                            const e = this.faces[t],
                                n = e.vertexNormals;
                            3 === n.length ? (n[0].copy(e.normal), n[1].copy(e.normal), n[2].copy(e.normal)) : (n[0] = e.normal.clone(), n[1] = e.normal.clone(), n[2] = e.normal.clone())
                        }
                        this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                    }
                    computeMorphNormals() {
                        for (let t = 0, e = this.faces.length; t < e; t++) {
                            const e = this.faces[t];
                            e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []);
                            for (let t = 0, n = e.vertexNormals.length; t < n; t++) e.__originalVertexNormals[t] ? e.__originalVertexNormals[t].copy(e.vertexNormals[t]) : e.__originalVertexNormals[t] = e.vertexNormals[t].clone()
                        }
                        const t = new Fm;
                        t.faces = this.faces;
                        for (let e = 0, n = this.morphTargets.length; e < n; e++) {
                            if (!this.morphNormals[e]) {
                                this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                                const t = this.morphNormals[e].faceNormals,
                                    n = this.morphNormals[e].vertexNormals;
                                for (let e = 0, i = this.faces.length; e < i; e++) {
                                    const e = new ui,
                                        i = { a: new ui, b: new ui, c: new ui };
                                    t.push(e), n.push(i)
                                }
                            }
                            const n = this.morphNormals[e];
                            t.vertices = this.morphTargets[e].vertices, t.computeFaceNormals(), t.computeVertexNormals();
                            for (let t = 0, e = this.faces.length; t < e; t++) {
                                const e = this.faces[t],
                                    i = n.faceNormals[t],
                                    r = n.vertexNormals[t];
                                i.copy(e.normal), r.a.copy(e.vertexNormals[0]), r.b.copy(e.vertexNormals[1]), r.c.copy(e.vertexNormals[2])
                            }
                        }
                        for (let t = 0, e = this.faces.length; t < e; t++) {
                            const e = this.faces[t];
                            e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals
                        }
                    }
                    computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new mi), this.boundingBox.setFromPoints(this.vertices) }
                    computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new Di), this.boundingSphere.setFromPoints(this.vertices) }
                    merge(t, e, n = 0) {
                        if (!t || !t.isGeometry) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
                        let i;
                        const r = this.vertices.length,
                            s = this.vertices,
                            o = t.vertices,
                            a = this.faces,
                            l = t.faces,
                            c = this.colors,
                            h = t.colors;
                        void 0 !== e && (i = (new ti).getNormalMatrix(e));
                        for (let t = 0, n = o.length; t < n; t++) {
                            const n = o[t].clone();
                            void 0 !== e && n.applyMatrix4(e), s.push(n)
                        }
                        for (let t = 0, e = h.length; t < e; t++) c.push(h[t].clone());
                        for (let t = 0, e = l.length; t < e; t++) {
                            const e = l[t];
                            let s, o;
                            const c = e.vertexNormals,
                                h = e.vertexColors,
                                u = new Um(e.a + r, e.b + r, e.c + r);
                            u.normal.copy(e.normal), void 0 !== i && u.normal.applyMatrix3(i).normalize();
                            for (let t = 0, e = c.length; t < e; t++) s = c[t].clone(), void 0 !== i && s.applyMatrix3(i).normalize(), u.vertexNormals.push(s);
                            u.color.copy(e.color);
                            for (let t = 0, e = h.length; t < e; t++) o = h[t], u.vertexColors.push(o.clone());
                            u.materialIndex = e.materialIndex + n, a.push(u)
                        }
                        for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                            const n = t.faceVertexUvs[e];
                            void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t],
                                    r = [];
                                for (let t = 0, e = i.length; t < e; t++) r.push(i[t].clone());
                                this.faceVertexUvs[e].push(r)
                            }
                        }
                    }
                    mergeMesh(t) { t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t) }
                    mergeVertices(t = 4) {
                        const e = {},
                            n = [],
                            i = [],
                            r = Math.pow(10, t);
                        for (let t = 0, s = this.vertices.length; t < s; t++) {
                            const s = this.vertices[t],
                                o = Math.round(s.x * r) + "_" + Math.round(s.y * r) + "_" + Math.round(s.z * r);
                            void 0 === e[o] ? (e[o] = t, n.push(this.vertices[t]), i[t] = n.length - 1) : i[t] = i[e[o]]
                        }
                        const s = [];
                        for (let t = 0, e = this.faces.length; t < e; t++) {
                            const e = this.faces[t];
                            e.a = i[e.a], e.b = i[e.b], e.c = i[e.c];
                            const n = [e.a, e.b, e.c];
                            for (let e = 0; e < 3; e++)
                                if (n[e] === n[(e + 1) % 3]) { s.push(t); break }
                        }
                        for (let t = s.length - 1; t >= 0; t--) {
                            const e = s[t];
                            this.faces.splice(e, 1);
                            for (let t = 0, n = this.faceVertexUvs.length; t < n; t++) this.faceVertexUvs[t].splice(e, 1)
                        }
                        const o = this.vertices.length - n.length;
                        return this.vertices = n, o
                    }
                    setFromPoints(t) {
                        this.vertices = [];
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            this.vertices.push(new ui(n.x, n.y, n.z || 0))
                        }
                        return this
                    }
                    sortFacesByMaterialIndex() {
                        const t = this.faces,
                            e = t.length;
                        for (let n = 0; n < e; n++) t[n]._id = n;
                        t.sort((function(t, e) { return t.materialIndex - e.materialIndex }));
                        const n = this.faceVertexUvs[0],
                            i = this.faceVertexUvs[1];
                        let r, s;
                        n && n.length === e && (r = []), i && i.length === e && (s = []);
                        for (let o = 0; o < e; o++) {
                            const e = t[o]._id;
                            r && r.push(n[e]), s && s.push(i[e])
                        }
                        r && (this.faceVertexUvs[0] = r), s && (this.faceVertexUvs[1] = s)
                    }
                    toJSON() {
                        const t = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } };
                        if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) { const e = this.parameters; for (const n in e) void 0 !== e[n] && (t[n] = e[n]); return t }
                        const e = [];
                        for (let t = 0; t < this.vertices.length; t++) {
                            const n = this.vertices[t];
                            e.push(n.x, n.y, n.z)
                        }
                        const n = [],
                            i = [],
                            r = {},
                            s = [],
                            o = {},
                            a = [],
                            l = {};
                        for (let t = 0; t < this.faces.length; t++) {
                            const e = this.faces[t],
                                i = !0,
                                r = !1,
                                s = void 0 !== this.faceVertexUvs[0][t],
                                o = e.normal.length() > 0,
                                a = e.vertexNormals.length > 0,
                                l = 1 !== e.color.r || 1 !== e.color.g || 1 !== e.color.b,
                                p = e.vertexColors.length > 0;
                            let m = 0;
                            if (m = c(m, 0, 0), m = c(m, 1, i), m = c(m, 2, r), m = c(m, 3, s), m = c(m, 4, o), m = c(m, 5, a), m = c(m, 6, l), m = c(m, 7, p), n.push(m), n.push(e.a, e.b, e.c), n.push(e.materialIndex), s) {
                                const e = this.faceVertexUvs[0][t];
                                n.push(d(e[0]), d(e[1]), d(e[2]))
                            }
                            if (o && n.push(h(e.normal)), a) {
                                const t = e.vertexNormals;
                                n.push(h(t[0]), h(t[1]), h(t[2]))
                            }
                            if (l && n.push(u(e.color)), p) {
                                const t = e.vertexColors;
                                n.push(u(t[0]), u(t[1]), u(t[2]))
                            }
                        }

                        function c(t, e, n) { return n ? t | 1 << e : t & ~(1 << e) }

                        function h(t) { const e = t.x.toString() + t.y.toString() + t.z.toString(); return void 0 !== r[e] || (r[e] = i.length / 3, i.push(t.x, t.y, t.z)), r[e] }

                        function u(t) { const e = t.r.toString() + t.g.toString() + t.b.toString(); return void 0 !== o[e] || (o[e] = s.length, s.push(t.getHex())), o[e] }

                        function d(t) { const e = t.x.toString() + t.y.toString(); return void 0 !== l[e] || (l[e] = a.length / 2, a.push(t.x, t.y)), l[e] }
                        return t.data = {}, t.data.vertices = e, t.data.normals = i, s.length > 0 && (t.data.colors = s), a.length > 0 && (t.data.uvs = [a]), t.data.faces = n, t
                    }
                    clone() { return (new Fm).copy(this) }
                    copy(t) {
                        this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                            []
                        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                        const e = t.vertices;
                        for (let t = 0, n = e.length; t < n; t++) this.vertices.push(e[t].clone());
                        const n = t.colors;
                        for (let t = 0, e = n.length; t < e; t++) this.colors.push(n[t].clone());
                        const i = t.faces;
                        for (let t = 0, e = i.length; t < e; t++) this.faces.push(i[t].clone());
                        for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                            const n = t.faceVertexUvs[e];
                            void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t],
                                    r = [];
                                for (let t = 0, e = i.length; t < e; t++) {
                                    const e = i[t];
                                    r.push(e.clone())
                                }
                                this.faceVertexUvs[e].push(r)
                            }
                        }
                        const r = t.morphTargets;
                        for (let t = 0, e = r.length; t < e; t++) {
                            const e = {};
                            if (e.name = r[t].name, void 0 !== r[t].vertices) { e.vertices = []; for (let n = 0, i = r[t].vertices.length; n < i; n++) e.vertices.push(r[t].vertices[n].clone()) }
                            if (void 0 !== r[t].normals) { e.normals = []; for (let n = 0, i = r[t].normals.length; n < i; n++) e.normals.push(r[t].normals[n].clone()) }
                            this.morphTargets.push(e)
                        }
                        const s = t.morphNormals;
                        for (let t = 0, e = s.length; t < e; t++) {
                            const e = {};
                            if (void 0 !== s[t].vertexNormals) {
                                e.vertexNormals = [];
                                for (let n = 0, i = s[t].vertexNormals.length; n < i; n++) {
                                    const i = s[t].vertexNormals[n],
                                        r = {};
                                    r.a = i.a.clone(), r.b = i.b.clone(), r.c = i.c.clone(), e.vertexNormals.push(r)
                                }
                            }
                            if (void 0 !== s[t].faceNormals) { e.faceNormals = []; for (let n = 0, i = s[t].faceNormals.length; n < i; n++) e.faceNormals.push(s[t].faceNormals[n].clone()) }
                            this.morphNormals.push(e)
                        }
                        const o = t.skinWeights;
                        for (let t = 0, e = o.length; t < e; t++) this.skinWeights.push(o[t].clone());
                        const a = t.skinIndices;
                        for (let t = 0, e = a.length; t < e; t++) this.skinIndices.push(a[t].clone());
                        const l = t.lineDistances;
                        for (let t = 0, e = l.length; t < e; t++) this.lineDistances.push(l[t]);
                        const c = t.boundingBox;
                        null !== c && (this.boundingBox = c.clone());
                        const h = t.boundingSphere;
                        return null !== h && (this.boundingSphere = h.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
                    }
                    toBufferGeometry() {
                        const t = (new zm).fromGeometry(this),
                            e = new rs,
                            n = new Float32Array(3 * t.vertices.length);
                        if (e.setAttribute("position", new Fr(n, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                            const n = new Float32Array(3 * t.normals.length);
                            e.setAttribute("normal", new Fr(n, 3).copyVector3sArray(t.normals))
                        }
                        if (t.colors.length > 0) {
                            const n = new Float32Array(3 * t.colors.length);
                            e.setAttribute("color", new Fr(n, 3).copyColorsArray(t.colors))
                        }
                        if (t.uvs.length > 0) {
                            const n = new Float32Array(2 * t.uvs.length);
                            e.setAttribute("uv", new Fr(n, 2).copyVector2sArray(t.uvs))
                        }
                        if (t.uvs2.length > 0) {
                            const n = new Float32Array(2 * t.uvs2.length);
                            e.setAttribute("uv2", new Fr(n, 2).copyVector2sArray(t.uvs2))
                        }
                        e.groups = t.groups;
                        for (const n in t.morphTargets) {
                            const i = [],
                                r = t.morphTargets[n];
                            for (let t = 0, e = r.length; t < e; t++) {
                                const e = r[t],
                                    n = new qr(3 * e.data.length, 3);
                                n.name = e.name, i.push(n.copyVector3sArray(e.data))
                            }
                            e.morphAttributes[n] = i
                        }
                        if (t.skinIndices.length > 0) {
                            const n = new qr(4 * t.skinIndices.length, 4);
                            e.setAttribute("skinIndex", n.copyVector4sArray(t.skinIndices))
                        }
                        if (t.skinWeights.length > 0) {
                            const n = new qr(4 * t.skinWeights.length, 4);
                            e.setAttribute("skinWeight", n.copyVector4sArray(t.skinWeights))
                        }
                        return null !== t.boundingSphere && (e.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (e.boundingBox = t.boundingBox.clone()), e
                    }
                    computeTangents() { console.error("THREE.Geometry: .computeTangents() has been removed.") }
                    computeLineDistances() { console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.") }
                    applyMatrix(t) { return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) }
                    dispose() { this.dispatchEvent({ type: "dispose" }) }
                    static createBufferGeometryFromObject(t) {
                        let e = new rs;
                        const n = t.geometry;
                        if (t.isPoints || t.isLine) {
                            const t = new qr(3 * n.vertices.length, 3),
                                i = new qr(3 * n.colors.length, 3);
                            if (e.setAttribute("position", t.copyVector3sArray(n.vertices)), e.setAttribute("color", i.copyColorsArray(n.colors)), n.lineDistances && n.lineDistances.length === n.vertices.length) {
                                const t = new qr(n.lineDistances.length, 1);
                                e.setAttribute("lineDistance", t.copyArray(n.lineDistances))
                            }
                            null !== n.boundingSphere && (e.boundingSphere = n.boundingSphere.clone()), null !== n.boundingBox && (e.boundingBox = n.boundingBox.clone())
                        } else t.isMesh && (e = n.toBufferGeometry());
                        return e
                    }
                }
                Fm.prototype.isGeometry = !0;
                class zm {
                    constructor() { this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1 }
                    computeGroups(t) {
                        const e = [];
                        let n, i, r;
                        const s = t.faces;
                        for (i = 0; i < s.length; i++) {
                            const t = s[i];
                            t.materialIndex !== r && (r = t.materialIndex, void 0 !== n && (n.count = 3 * i - n.start, e.push(n)), n = { start: 3 * i, materialIndex: r })
                        }
                        void 0 !== n && (n.count = 3 * i - n.start, e.push(n)), this.groups = e
                    }
                    fromGeometry(t) {
                        const e = t.faces,
                            n = t.vertices,
                            i = t.faceVertexUvs,
                            r = i[0] && i[0].length > 0,
                            s = i[1] && i[1].length > 0,
                            o = t.morphTargets,
                            a = o.length;
                        let l;
                        if (a > 0) {
                            l = [];
                            for (let t = 0; t < a; t++) l[t] = { name: o[t].name, data: [] };
                            this.morphTargets.position = l
                        }
                        const c = t.morphNormals,
                            h = c.length;
                        let u;
                        if (h > 0) {
                            u = [];
                            for (let t = 0; t < h; t++) u[t] = { name: c[t].name, data: [] };
                            this.morphTargets.normal = u
                        }
                        const d = t.skinIndices,
                            p = t.skinWeights,
                            m = d.length === n.length,
                            f = p.length === n.length;
                        n.length > 0 && 0 === e.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                        for (let t = 0; t < e.length; t++) {
                            const g = e[t];
                            this.vertices.push(n[g.a], n[g.b], n[g.c]);
                            const v = g.vertexNormals;
                            if (3 === v.length) this.normals.push(v[0], v[1], v[2]);
                            else {
                                const t = g.normal;
                                this.normals.push(t, t, t)
                            }
                            const y = g.vertexColors;
                            if (3 === y.length) this.colors.push(y[0], y[1], y[2]);
                            else {
                                const t = g.color;
                                this.colors.push(t, t, t)
                            }
                            if (!0 === r) {
                                const e = i[0][t];
                                void 0 !== e ? this.uvs.push(e[0], e[1], e[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", t), this.uvs.push(new $n, new $n, new $n))
                            }
                            if (!0 === s) {
                                const e = i[1][t];
                                void 0 !== e ? this.uvs2.push(e[0], e[1], e[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", t), this.uvs2.push(new $n, new $n, new $n))
                            }
                            for (let t = 0; t < a; t++) {
                                const e = o[t].vertices;
                                l[t].data.push(e[g.a], e[g.b], e[g.c])
                            }
                            for (let e = 0; e < h; e++) {
                                const n = c[e].vertexNormals[t];
                                u[e].data.push(n.a, n.b, n.c)
                            }
                            m && this.skinIndices.push(d[g.a], d[g.b], d[g.c]), f && this.skinWeights.push(p[g.a], p[g.b], p[g.c])
                        }
                        return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
                    }
                }
                class Um {
                    constructor(t, e, n, i, r, s = 0) { this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new ui, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new Dr, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = s }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex; for (let e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone(); for (let e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone(); return this }
                }
                class Hm {
                    constructor(t, e, n, i, r, s = 0) { this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new ui, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new Dr, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = s }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex; for (let e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone(); for (let e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone(); return this }
                }
                class km extends lu {
                    constructor(t) { super(t), this.defaultDPI = 90, this.defaultUnit = "px" }
                    load(t, e, n, i) {
                        const r = this,
                            s = new hu(r.manager);
                        s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function(n) { try { e(r.parse(n)) } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) } }), n, i)
                    }
                    parse(t) {
                        const e = this;

                        function n(t, e, n, r, s, o, a, l) {
                            if (0 == e || 0 == n) return void t.lineTo(l.x, l.y);
                            r = r * Math.PI / 180, e = Math.abs(e), n = Math.abs(n);
                            const c = (a.x - l.x) / 2,
                                h = (a.y - l.y) / 2,
                                u = Math.cos(r) * c + Math.sin(r) * h,
                                d = -Math.sin(r) * c + Math.cos(r) * h;
                            let p = e * e,
                                m = n * n;
                            const f = u * u,
                                g = d * d,
                                v = f / p + g / m;
                            if (v > 1) {
                                const t = Math.sqrt(v);
                                p = (e *= t) * e, m = (n *= t) * n
                            }
                            const y = p * g + m * f,
                                x = (p * m - y) / y;
                            let _ = Math.sqrt(Math.max(0, x));
                            s === o && (_ = -_);
                            const b = _ * e * d / n,
                                w = -_ * n * u / e,
                                M = Math.cos(r) * b - Math.sin(r) * w + (a.x + l.x) / 2,
                                S = Math.sin(r) * b + Math.cos(r) * w + (a.y + l.y) / 2,
                                T = i(1, 0, (u - b) / e, (d - w) / n),
                                E = i((u - b) / e, (d - w) / n, (-u - b) / e, (-d - w) / n) % (2 * Math.PI);
                            t.currentPath.absellipse(M, S, e, n, T, T + E, 0 === o, r)
                        }

                        function i(t, e, n, i) {
                            const r = t * n + e * i,
                                s = Math.sqrt(t * t + e * e) * Math.sqrt(n * n + i * i);
                            let o = Math.acos(Math.max(-1, Math.min(1, r / s)));
                            return t * i - e * n < 0 && (o = -o), o
                        }

                        function r(t, e) {
                            e = Object.assign({}, e);
                            let n = {};
                            if (t.hasAttribute("class")) { const e = t.getAttribute("class").split(/\s/).filter(Boolean).map((t => t.trim())); for (let t = 0; t < e.length; t++) n = Object.assign(n, p["." + e[t]]) }

                            function i(i, r, s) { void 0 === s && (s = function(t) { return t.startsWith("url") && console.warn("SVGLoader: url access in attributes is not implemented."), t }), t.hasAttribute(i) && (e[r] = s(t.getAttribute(i))), n[i] && (e[r] = s(n[i])), t.style && "" !== t.style[i] && (e[r] = s(t.style[i])) }

                            function r(t) { return Math.max(0, Math.min(1, c(t))) }

                            function s(t) { return Math.max(0, c(t)) }
                            return t.hasAttribute("id") && (n = Object.assign(n, p["#" + t.getAttribute("id")])), i("fill", "fill"), i("fill-opacity", "fillOpacity", r), i("opacity", "opacity", r), i("stroke", "stroke"), i("stroke-opacity", "strokeOpacity", r), i("stroke-width", "strokeWidth", s), i("stroke-linejoin", "strokeLineJoin"), i("stroke-linecap", "strokeLineCap"), i("stroke-miterlimit", "strokeMiterLimit", s), i("visibility", "visibility"), e
                        }

                        function s(t, e) { return t - (e - t) }

                        function o(t, e, n) {
                            if ("string" != typeof t) throw new TypeError("Invalid input: " + typeof t);
                            const i = { SEPARATOR: /[ \t\r\n\,.\-+]/, WHITESPACE: /[ \t\r\n]/, DIGIT: /[\d]/, SIGN: /[-+]/, POINT: /\./, COMMA: /,/, EXP: /e/i, FLAGS: /[01]/ };
                            let r = 0,
                                s = !0,
                                o = "",
                                a = "";
                            const l = [];

                            function c(t, e, n) { const i = new SyntaxError('Unexpected character "' + t + '" at index ' + e + "."); throw i.partial = n, i }

                            function h() { "" !== o && ("" === a ? l.push(Number(o)) : l.push(Number(o) * Math.pow(10, Number(a)))), o = "", a = "" }
                            let u;
                            const d = t.length;
                            for (let p = 0; p < d; p++)
                                if (u = t[p], Array.isArray(e) && e.includes(l.length % n) && i.FLAGS.test(u)) r = 1, o = u, h();
                                else {
                                    if (0 === r) {
                                        if (i.WHITESPACE.test(u)) continue;
                                        if (i.DIGIT.test(u) || i.SIGN.test(u)) { r = 1, o = u; continue }
                                        if (i.POINT.test(u)) { r = 2, o = u; continue }
                                        i.COMMA.test(u) && (s && c(u, p, l), s = !0)
                                    }
                                    if (1 === r) {
                                        if (i.DIGIT.test(u)) { o += u; continue }
                                        if (i.POINT.test(u)) { o += u, r = 2; continue }
                                        if (i.EXP.test(u)) { r = 3; continue }
                                        i.SIGN.test(u) && 1 === o.length && i.SIGN.test(o[0]) && c(u, p, l)
                                    }
                                    if (2 === r) {
                                        if (i.DIGIT.test(u)) { o += u; continue }
                                        if (i.EXP.test(u)) { r = 3; continue }
                                        i.POINT.test(u) && "." === o[o.length - 1] && c(u, p, l)
                                    }
                                    if (3 === r) {
                                        if (i.DIGIT.test(u)) { a += u; continue }
                                        if (i.SIGN.test(u)) {
                                            if ("" === a) { a += u; continue }
                                            1 === a.length && i.SIGN.test(a) && c(u, p, l)
                                        }
                                    }
                                    i.WHITESPACE.test(u) ? (h(), r = 0, s = !1) : i.COMMA.test(u) ? (h(), r = 0, s = !0) : i.SIGN.test(u) ? (h(), r = 1, o = u) : i.POINT.test(u) ? (h(), r = 2, o = u) : c(u, p, l)
                                }
                            return h(), l
                        }
                        const a = ["mm", "cm", "in", "pt", "pc", "px"],
                            l = { mm: { mm: 1, cm: .1, in: 1 / 25.4, pt: 72 / 25.4, pc: 6 / 25.4, px: -1 }, cm: { mm: 10, cm: 1, in: 1 / 2.54, pt: 72 / 2.54, pc: 6 / 2.54, px: -1 }, in: { mm: 25.4, cm: 2.54, in: 1, pt: 72, pc: 6, px: -1 }, pt: { mm: 25.4 / 72, cm: 2.54 / 72, in: 1 / 72, pt: 1, pc: 6 / 72, px: -1 }, pc: { mm: 25.4 / 6, cm: 2.54 / 6, in: 1 / 6, pt: 12, pc: 1, px: -1 }, px: { px: 1 } };

                        function c(t) {
                            let n, i = "px";
                            if ("string" == typeof t || t instanceof String)
                                for (let e = 0, n = a.length; e < n; e++) { const n = a[e]; if (t.endsWith(n)) { i = n, t = t.substring(0, t.length - n.length); break } }
                            return "px" === i && "px" !== e.defaultUnit ? n = l.in[e.defaultUnit] / e.defaultDPI : (n = l[i][e.defaultUnit], n < 0 && (n = l[i].in * e.defaultDPI)), n * parseFloat(t)
                        }

                        function h(t) { const e = t.elements; return Math.sqrt(e[0] * e[0] + e[1] * e[1]) }

                        function u(t) { const e = t.elements; return Math.sqrt(e[3] * e[3] + e[4] * e[4]) }
                        const d = [],
                            p = {},
                            m = [],
                            f = new ti,
                            g = new ti,
                            v = new ti,
                            y = new ti,
                            x = new $n,
                            _ = new ui,
                            b = new ti,
                            w = (new DOMParser).parseFromString(t, "image/svg+xml");
                        return function t(e, i) {
                            if (1 !== e.nodeType) return;
                            const a = function(t) {
                                if (!(t.hasAttribute("transform") || "use" === t.nodeName && (t.hasAttribute("x") || t.hasAttribute("y")))) return null;
                                const e = function(t) {
                                    const e = new ti,
                                        n = f;
                                    if ("use" === t.nodeName && (t.hasAttribute("x") || t.hasAttribute("y"))) {
                                        const n = c(t.getAttribute("x")),
                                            i = c(t.getAttribute("y"));
                                        e.translate(n, i)
                                    }
                                    if (t.hasAttribute("transform")) {
                                        const i = t.getAttribute("transform").split(")");
                                        for (let t = i.length - 1; t >= 0; t--) {
                                            const r = i[t].trim();
                                            if ("" === r) continue;
                                            const s = r.indexOf("("),
                                                a = r.length;
                                            if (s > 0 && s < a) {
                                                const t = r.substr(0, s),
                                                    e = o(r.substr(s + 1, a - s - 1));
                                                switch (n.identity(), t) {
                                                    case "translate":
                                                        if (e.length >= 1) {
                                                            const t = e[0];
                                                            let i = t;
                                                            e.length >= 2 && (i = e[1]), n.translate(t, i)
                                                        }
                                                        break;
                                                    case "rotate":
                                                        if (e.length >= 1) {
                                                            let t = 0,
                                                                i = 0,
                                                                r = 0;
                                                            t = -e[0] * Math.PI / 180, e.length >= 3 && (i = e[1], r = e[2]), g.identity().translate(-i, -r), v.identity().rotate(t), y.multiplyMatrices(v, g), g.identity().translate(i, r), n.multiplyMatrices(g, y)
                                                        }
                                                        break;
                                                    case "scale":
                                                        if (e.length >= 1) {
                                                            const t = e[0];
                                                            let i = t;
                                                            e.length >= 2 && (i = e[1]), n.scale(t, i)
                                                        }
                                                        break;
                                                    case "skewX":
                                                        1 === e.length && n.set(1, Math.tan(e[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);
                                                        break;
                                                    case "skewY":
                                                        1 === e.length && n.set(1, 0, 0, Math.tan(e[0] * Math.PI / 180), 1, 0, 0, 0, 1);
                                                        break;
                                                    case "matrix":
                                                        6 === e.length && n.set(e[0], e[2], e[4], e[1], e[3], e[5], 0, 0, 1)
                                                }
                                            }
                                            e.premultiply(n)
                                        }
                                    }
                                    return e
                                }(t);
                                return m.length > 0 && e.premultiply(m[m.length - 1]), b.copy(e), m.push(e), e
                            }(e);
                            let l = !0,
                                w = null;
                            switch (e.nodeName) {
                                case "svg":
                                    break;
                                case "style":
                                    ! function(t) {
                                        if (t.sheet && t.sheet.cssRules && t.sheet.cssRules.length)
                                            for (let e = 0; e < t.sheet.cssRules.length; e++) { const n = t.sheet.cssRules[e]; if (1 !== n.type) continue; const i = n.selectorText.split(/,/gm).filter(Boolean).map((t => t.trim())); for (let t = 0; t < i.length; t++) p[i[t]] = Object.assign(p[i[t]] || {}, n.style) }
                                    }(e);
                                    break;
                                case "g":
                                    i = r(e, i);
                                    break;
                                case "path":
                                    i = r(e, i), e.hasAttribute("d") && (w = function(t) {
                                        const e = new Ju,
                                            i = new $n,
                                            r = new $n,
                                            a = new $n;
                                        let l = !0,
                                            c = !1;
                                        const h = t.getAttribute("d").match(/[a-df-z][^a-df-z]*/gi);
                                        for (let t = 0, u = h.length; t < u; t++) {
                                            const u = h[t],
                                                d = u.charAt(0),
                                                p = u.substr(1).trim();
                                            let m;
                                            switch (!0 === l && (c = !0, l = !1), d) {
                                                case "M":
                                                    m = o(p);
                                                    for (let t = 0, n = m.length; t < n; t += 2) i.x = m[t + 0], i.y = m[t + 1], r.x = i.x, r.y = i.y, 0 === t ? e.moveTo(i.x, i.y) : e.lineTo(i.x, i.y), 0 === t && !0 === c && a.copy(i);
                                                    break;
                                                case "H":
                                                    m = o(p);
                                                    for (let t = 0, n = m.length; t < n; t++) i.x = m[t], r.x = i.x, r.y = i.y, e.lineTo(i.x, i.y), 0 === t && !0 === c && a.copy(i);
                                                    break;
                                                case "V":
                                                    m = o(p);
                                                    for (let t = 0, n = m.length; t < n; t++) i.y = m[t], r.x = i.x, r.y = i.y, e.lineTo(i.x, i.y), 0 === t && !0 === c && a.copy(i);
                                                    break;
                                                case "L":
                                                    m = o(p);
                                                    for (let t = 0, n = m.length; t < n; t += 2) i.x = m[t + 0], i.y = m[t + 1], r.x = i.x, r.y = i.y, e.lineTo(i.x, i.y), 0 === t && !0 === c && a.copy(i);
                                                    break;
                                                case "C":
                                                    m = o(p);
                                                    for (let t = 0, n = m.length; t < n; t += 6) e.bezierCurveTo(m[t + 0], m[t + 1], m[t + 2], m[t + 3], m[t + 4], m[t + 5]), r.x = m[t + 2], r.y = m[t + 3], i.x = m[t + 4], i.y = m[t + 5], 0 === t && !0 === c && a.copy(i);
                                                    break;
                                                case "S":
                                                    m = o(p);
                                                    for (let t = 0, n = m.length; t < n; t += 4) e.bezierCurveTo(s(i.x, r.x), s(i.y, r.y), m[t + 0], m[t + 1], m[t + 2], m[t + 3]), r.x = m[t + 0], r.y = m[t + 1], i.x = m[t + 2], i.y = m[t + 3], 0 === t && !0 === c && a.copy(i);
                                                    break;
                                                case "Q":
                                                    m = o(p);
                                                    for (let t = 0, n = m.length; t < n; t += 4) e.quadraticCurveTo(m[t + 0], m[t + 1], m[t + 2], m[t + 3]), r.x = m[t + 0], r.y = m[t + 1], i.x = m[t + 2], i.y = m[t + 3], 0 === t && !0 === c && a.copy(i);
                                                    break;
                                                case "T":
                                                    m = o(p);
                                                    for (let t = 0, n = m.length; t < n; t += 2) {
                                                        const n = s(i.x, r.x),
                                                            o = s(i.y, r.y);
                                                        e.quadraticCurveTo(n, o, m[t + 0], m[t + 1]), r.x = n, r.y = o, i.x = m[t + 0], i.y = m[t + 1], 0 === t && !0 === c && a.copy(i)
                                                    }
                                                    break;
                                                case "A":
                                                    m = o(p, [3, 4], 7);
                                                    for (let t = 0, s = m.length; t < s; t += 7) {
                                                        if (m[t + 5] == i.x && m[t + 6] == i.y) continue;
                                                        const s = i.clone();
                                                        i.x = m[t + 5], i.y = m[t + 6], r.x = i.x, r.y = i.y, n(e, m[t], m[t + 1], m[t + 2], m[t + 3], m[t + 4], s, i), 0 === t && !0 === c && a.copy(i)
                                                    }
                                                    break;
                                                case "m":
                                                    m = o(p);
                                                    for (let t = 0, n = m.length; t < n; t += 2) i.x += m[t + 0], i.y += m[t + 1], r.x = i.x, r.y = i.y, 0 === t ? e.moveTo(i.x, i.y) : e.lineTo(i.x, i.y), 0 === t && !0 === c && a.copy(i);
                                                    break;
                                                case "h":
                                                    m = o(p);
                                                    for (let t = 0, n = m.length; t < n; t++) i.x += m[t], r.x = i.x, r.y = i.y, e.lineTo(i.x, i.y), 0 === t && !0 === c && a.copy(i);
                                                    break;
                                                case "v":
                                                    m = o(p);
                                                    for (let t = 0, n = m.length; t < n; t++) i.y += m[t], r.x = i.x, r.y = i.y, e.lineTo(i.x, i.y), 0 === t && !0 === c && a.copy(i);
                                                    break;
                                                case "l":
                                                    m = o(p);
                                                    for (let t = 0, n = m.length; t < n; t += 2) i.x += m[t + 0], i.y += m[t + 1], r.x = i.x, r.y = i.y, e.lineTo(i.x, i.y), 0 === t && !0 === c && a.copy(i);
                                                    break;
                                                case "c":
                                                    m = o(p);
                                                    for (let t = 0, n = m.length; t < n; t += 6) e.bezierCurveTo(i.x + m[t + 0], i.y + m[t + 1], i.x + m[t + 2], i.y + m[t + 3], i.x + m[t + 4], i.y + m[t + 5]), r.x = i.x + m[t + 2], r.y = i.y + m[t + 3], i.x += m[t + 4], i.y += m[t + 5], 0 === t && !0 === c && a.copy(i);
                                                    break;
                                                case "s":
                                                    m = o(p);
                                                    for (let t = 0, n = m.length; t < n; t += 4) e.bezierCurveTo(s(i.x, r.x), s(i.y, r.y), i.x + m[t + 0], i.y + m[t + 1], i.x + m[t + 2], i.y + m[t + 3]), r.x = i.x + m[t + 0], r.y = i.y + m[t + 1], i.x += m[t + 2], i.y += m[t + 3], 0 === t && !0 === c && a.copy(i);
                                                    break;
                                                case "q":
                                                    m = o(p);
                                                    for (let t = 0, n = m.length; t < n; t += 4) e.quadraticCurveTo(i.x + m[t + 0], i.y + m[t + 1], i.x + m[t + 2], i.y + m[t + 3]), r.x = i.x + m[t + 0], r.y = i.y + m[t + 1], i.x += m[t + 2], i.y += m[t + 3], 0 === t && !0 === c && a.copy(i);
                                                    break;
                                                case "t":
                                                    m = o(p);
                                                    for (let t = 0, n = m.length; t < n; t += 2) {
                                                        const n = s(i.x, r.x),
                                                            o = s(i.y, r.y);
                                                        e.quadraticCurveTo(n, o, i.x + m[t + 0], i.y + m[t + 1]), r.x = n, r.y = o, i.x = i.x + m[t + 0], i.y = i.y + m[t + 1], 0 === t && !0 === c && a.copy(i)
                                                    }
                                                    break;
                                                case "a":
                                                    m = o(p, [3, 4], 7);
                                                    for (let t = 0, s = m.length; t < s; t += 7) {
                                                        if (0 == m[t + 5] && 0 == m[t + 6]) continue;
                                                        const s = i.clone();
                                                        i.x += m[t + 5], i.y += m[t + 6], r.x = i.x, r.y = i.y, n(e, m[t], m[t + 1], m[t + 2], m[t + 3], m[t + 4], s, i), 0 === t && !0 === c && a.copy(i)
                                                    }
                                                    break;
                                                case "Z":
                                                case "z":
                                                    e.currentPath.autoClose = !0, e.currentPath.curves.length > 0 && (i.copy(a), e.currentPath.currentPoint.copy(i), l = !0);
                                                    break;
                                                default:
                                                    console.warn(u)
                                            }
                                            c = !1
                                        }
                                        return e
                                    }(e));
                                    break;
                                case "rect":
                                    i = r(e, i), w = function(t) {
                                        const e = c(t.getAttribute("x") || 0),
                                            n = c(t.getAttribute("y") || 0),
                                            i = c(t.getAttribute("rx") || 0),
                                            r = c(t.getAttribute("ry") || 0),
                                            s = c(t.getAttribute("width")),
                                            o = c(t.getAttribute("height")),
                                            a = new Ju;
                                        return a.moveTo(e + 2 * i, n), a.lineTo(e + s - 2 * i, n), (0 !== i || 0 !== r) && a.bezierCurveTo(e + s, n, e + s, n, e + s, n + 2 * r), a.lineTo(e + s, n + o - 2 * r), (0 !== i || 0 !== r) && a.bezierCurveTo(e + s, n + o, e + s, n + o, e + s - 2 * i, n + o), a.lineTo(e + 2 * i, n + o), (0 !== i || 0 !== r) && a.bezierCurveTo(e, n + o, e, n + o, e, n + o - 2 * r), a.lineTo(e, n + 2 * r), (0 !== i || 0 !== r) && a.bezierCurveTo(e, n, e, n, e + 2 * i, n), a
                                    }(e);
                                    break;
                                case "polygon":
                                    i = r(e, i), w = function(t) {
                                        const e = new Ju;
                                        let n = 0;
                                        return t.getAttribute("points").replace(/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g, (function(t, i, r) {
                                            const s = c(i),
                                                o = c(r);
                                            0 === n ? e.moveTo(s, o) : e.lineTo(s, o), n++
                                        })), e.currentPath.autoClose = !0, e
                                    }(e);
                                    break;
                                case "polyline":
                                    i = r(e, i), w = function(t) {
                                        const e = new Ju;
                                        let n = 0;
                                        return t.getAttribute("points").replace(/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g, (function(t, i, r) {
                                            const s = c(i),
                                                o = c(r);
                                            0 === n ? e.moveTo(s, o) : e.lineTo(s, o), n++
                                        })), e.currentPath.autoClose = !1, e
                                    }(e);
                                    break;
                                case "circle":
                                    i = r(e, i), w = function(t) {
                                        const e = c(t.getAttribute("cx") || 0),
                                            n = c(t.getAttribute("cy") || 0),
                                            i = c(t.getAttribute("r") || 0),
                                            r = new yu;
                                        r.absarc(e, n, i, 0, 2 * Math.PI);
                                        const s = new Ju;
                                        return s.subPaths.push(r), s
                                    }(e);
                                    break;
                                case "ellipse":
                                    i = r(e, i), w = function(t) {
                                        const e = c(t.getAttribute("cx") || 0),
                                            n = c(t.getAttribute("cy") || 0),
                                            i = c(t.getAttribute("rx") || 0),
                                            r = c(t.getAttribute("ry") || 0),
                                            s = new yu;
                                        s.absellipse(e, n, i, r, 0, 2 * Math.PI);
                                        const o = new Ju;
                                        return o.subPaths.push(s), o
                                    }(e);
                                    break;
                                case "line":
                                    i = r(e, i), w = function(t) {
                                        const e = c(t.getAttribute("x1") || 0),
                                            n = c(t.getAttribute("y1") || 0),
                                            i = c(t.getAttribute("x2") || 0),
                                            r = c(t.getAttribute("y2") || 0),
                                            s = new Ju;
                                        return s.moveTo(e, n), s.lineTo(i, r), s.currentPath.autoClose = !1, s
                                    }(e);
                                    break;
                                case "defs":
                                    l = !1;
                                    break;
                                case "use":
                                    i = r(e, i);
                                    const a = e.href.baseVal.substring(1),
                                        h = e.viewportElement.getElementById(a);
                                    h ? t(h, i) : console.warn("SVGLoader: 'use node' references non-existent node id: " + a)
                            }
                            if (w && (void 0 !== i.fill && "none" !== i.fill && w.color.setStyle(i.fill), function(t, e) {
                                    function n(t) { _.set(t.x, t.y, 1).applyMatrix3(e), t.set(_.x, _.y) }
                                    const i = function(t) { return 0 !== t.elements[1] || 0 !== t.elements[3] }(e),
                                        r = t.subPaths;
                                    for (let t = 0, s = r.length; t < s; t++) {
                                        const s = r[t].curves;
                                        for (let t = 0; t < s.length; t++) {
                                            const r = s[t];
                                            r.isLineCurve ? (n(r.v1), n(r.v2)) : r.isCubicBezierCurve ? (n(r.v0), n(r.v1), n(r.v2), n(r.v3)) : r.isQuadraticBezierCurve ? (n(r.v0), n(r.v1), n(r.v2)) : r.isEllipseCurve && (i && console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented."), x.set(r.aX, r.aY), n(x), r.aX = x.x, r.aY = x.y, r.xRadius *= h(e), r.yRadius *= u(e))
                                        }
                                    }
                                }(w, b), d.push(w), w.userData = { node: e, style: i }), l) { const n = e.childNodes; for (let e = 0; e < n.length; e++) t(n[e], i) }
                            a && (m.pop(), m.length > 0 ? b.copy(m[m.length - 1]) : b.identity())
                        }(w.documentElement, { fill: "#000", fillOpacity: 1, strokeOpacity: 1, strokeWidth: 1, strokeLineJoin: "miter", strokeLineCap: "butt", strokeMiterLimit: 4 }), { paths: d, xml: w.documentElement }
                    }
                    static createShapes(t) {
                        const e = 999999999,
                            n = { loc: 0, t: 0 };

                        function i(t, e, i, s) {
                            const o = t.x,
                                a = e.x,
                                l = i.x,
                                c = s.x,
                                h = t.y,
                                u = e.y,
                                d = i.y,
                                p = s.y,
                                m = (c - l) * (h - d) - (p - d) * (o - l),
                                f = (p - d) * (a - o) - (c - l) * (u - h),
                                g = m / f,
                                v = ((a - o) * (h - d) - (u - h) * (o - l)) / f;
                            if (0 === f && 0 !== m || g <= 0 || g >= 1 || v < 0 || v > 1) return null;
                            if (0 === m && 0 === f) { for (let l = 0; l < 2; l++) { if (r(0 === l ? i : s, t, e), 0 == n.loc) { const t = 0 === l ? i : s; return { x: t.x, y: t.y, t: n.t } } if (2 == n.loc) return { x: +(o + n.t * (a - o)).toPrecision(10), y: +(h + n.t * (u - h)).toPrecision(10), t: n.t } } return null }
                            for (let o = 0; o < 2; o++)
                                if (r(0 === o ? i : s, t, e), 0 == n.loc) { const t = 0 === o ? i : s; return { x: t.x, y: t.y, t: n.t } }
                            return { x: +(o + g * (a - o)).toPrecision(10), y: +(h + g * (u - h)).toPrecision(10), t: g }
                        }

                        function r(t, e, i) {
                            const r = i.x - e.x,
                                s = i.y - e.y,
                                o = t.x - e.x,
                                a = t.y - e.y,
                                l = r * a - o * s;
                            if (t.x === e.x && t.y === e.y) return n.loc = 0, void(n.t = 0);
                            if (t.x === i.x && t.y === i.y) return n.loc = 1, void(n.t = 1);
                            if (l < -Number.EPSILON) return void(n.loc = 3);
                            if (l > Number.EPSILON) return void(n.loc = 4);
                            if (r * o < 0 || s * a < 0) return void(n.loc = 5);
                            if (Math.sqrt(r * r + s * s) < Math.sqrt(o * o + a * a)) return void(n.loc = 6);
                            let c;
                            c = 0 !== r ? o / r : a / s, n.loc = 2, n.t = c
                        }
                        let s = 0,
                            o = e,
                            a = -999999999,
                            l = t.subPaths.map((t => {
                                const n = t.getPoints();
                                let i = -999999999,
                                    r = e,
                                    l = -999999999,
                                    c = e;
                                for (let t = 0; t < n.length; t++) {
                                    const e = n[t];
                                    e.y > i && (i = e.y), e.y < r && (r = e.y), e.x > l && (l = e.x), e.x < c && (c = e.x)
                                }
                                return a <= l && (a = l + 1), o >= c && (o = c - 1), { points: n, isCW: mh.isClockWise(n), identifier: s++, boundingBox: new jd(new $n(c, r), new $n(l, i)) }
                            }));
                        l = l.filter((t => t.points.length > 1));
                        const c = l.map((e => function(t, e, n, r, s) {
                                null != s && "" !== s || (s = "nonzero");
                                const o = new $n;
                                t.boundingBox.getCenter(o);
                                const a = function(t, e, n) {
                                    const r = new $n;
                                    e.getCenter(r);
                                    const s = [];
                                    return n.forEach((e => {
                                        if (e.boundingBox.containsPoint(r)) {
                                            const n = function(t, e) {
                                                const n = [],
                                                    r = [];
                                                for (let s = 1; s < t.length; s++) {
                                                    const o = t[s - 1],
                                                        a = t[s];
                                                    for (let t = 1; t < e.length; t++) {
                                                        const s = i(o, a, e[t - 1], e[t]);
                                                        null !== s && void 0 === n.find((t => t.t <= s.t + Number.EPSILON && t.t >= s.t - Number.EPSILON)) && (n.push(s), r.push(new $n(s.x, s.y)))
                                                    }
                                                }
                                                return r
                                            }(t, e.points);
                                            n.forEach((t => { s.push({ identifier: e.identifier, isCW: e.isCW, point: t }) }))
                                        }
                                    })), s.sort(((t, e) => t.point.x - e.point.x)), s
                                }([new $n(n, o.y), new $n(r, o.y)], t.boundingBox, e);
                                a.sort(((t, e) => t.point.x - e.point.x));
                                const l = [],
                                    c = [];
                                a.forEach((e => { e.identifier === t.identifier ? l.push(e) : c.push(e) }));
                                const h = l[0].point.x,
                                    u = [];
                                let d = 0;
                                for (; d < c.length && c[d].point.x < h;) u.length > 0 && u[u.length - 1] === c[d].identifier ? u.pop() : u.push(c[d].identifier), d++;
                                if (u.push(t.identifier), "evenodd" === s) {
                                    const e = u.length % 2 == 0,
                                        n = u[u.length - 2];
                                    return { identifier: t.identifier, isHole: e, for: n }
                                }
                                if ("nonzero" === s) {
                                    let n = !0,
                                        i = null,
                                        r = null;
                                    for (let t = 0; t < u.length; t++) {
                                        const s = u[t];
                                        n ? (r = e[s].isCW, n = !1, i = s) : r !== e[s].isCW && (r = e[s].isCW, n = !0)
                                    }
                                    return { identifier: t.identifier, isHole: n, for: i }
                                }
                                console.warn('fill-rule: "' + s + '" is currently not implemented.')
                            }(e, l, o, a, t.userData.style.fillRule))),
                            h = [];
                        return l.forEach((t => {
                            if (!c[t.identifier].isHole) {
                                const e = new xu(t.points);
                                c.filter((e => e.isHole && e.for === t.identifier)).forEach((t => {
                                    const n = l[t.identifier];
                                    e.holes.push(new yu(n.points))
                                })), h.push(e)
                            }
                        })), h
                    }
                    static getStrokeStyle(t, e, n, i, r) { return { strokeColor: e = void 0 !== e ? e : "#000", strokeWidth: t = void 0 !== t ? t : 1, strokeLineJoin: n = void 0 !== n ? n : "miter", strokeLineCap: i = void 0 !== i ? i : "butt", strokeMiterLimit: r = void 0 !== r ? r : 4 } }
                    static pointsToStroke(t, e, n, i) {
                        const r = [],
                            s = [],
                            o = [];
                        if (0 === km.pointsToStrokeWithBuffers(t, e, n, i, r, s, o)) return null;
                        const a = new rs;
                        return a.setAttribute("position", new qr(r, 3)), a.setAttribute("normal", new qr(s, 3)), a.setAttribute("uv", new qr(o, 2)), a
                    }
                    static pointsToStrokeWithBuffers(t, e, n, i, r, s, o, a) {
                        const l = new $n,
                            c = new $n,
                            h = new $n,
                            u = new $n,
                            d = new $n,
                            p = new $n,
                            m = new $n,
                            f = new $n,
                            g = new $n,
                            v = new $n,
                            y = new $n,
                            x = new $n,
                            _ = new $n,
                            b = new $n,
                            w = new $n,
                            M = new $n,
                            S = new $n;
                        n = void 0 !== n ? n : 12, i = void 0 !== i ? i : .001, a = void 0 !== a ? a : 0, t = function(t) {
                            let e = !1;
                            for (let n = 1, r = t.length - 1; n < r; n++)
                                if (t[n].distanceTo(t[n + 1]) < i) { e = !0; break }
                            if (!e) return t;
                            const n = [];
                            n.push(t[0]);
                            for (let e = 1, r = t.length - 1; e < r; e++) t[e].distanceTo(t[e + 1]) >= i && n.push(t[e]);
                            return n.push(t[t.length - 1]), n
                        }(t);
                        const T = t.length;
                        if (T < 2) return 0;
                        const E = t[0].equals(t[T - 1]);
                        let A, L, R = t[0];
                        const C = e.strokeWidth / 2,
                            P = 1 / (T - 1);
                        let I, D, N, B, O = 0,
                            F = !1,
                            z = 0,
                            U = 3 * a,
                            H = 2 * a;
                        k(t[0], t[1], l).multiplyScalar(C), f.copy(t[0]).sub(l), g.copy(t[0]).add(l), v.copy(f), y.copy(g);
                        for (let n = 1; n < T; n++) {
                            A = t[n], L = n === T - 1 ? E ? t[1] : void 0 : t[n + 1];
                            const i = l;
                            if (k(R, A, i), h.copy(i).multiplyScalar(C), x.copy(A).sub(h), _.copy(A).add(h), I = O + P, D = !1, void 0 !== L) {
                                k(A, L, c), h.copy(c).multiplyScalar(C), b.copy(A).sub(h), w.copy(A).add(h), N = !0, h.subVectors(L, R), i.dot(h) < 0 && (N = !1), 1 === n && (F = N), h.subVectors(L, A), h.normalize();
                                const t = Math.abs(i.dot(h));
                                if (0 !== t) {
                                    const n = C / t;
                                    h.multiplyScalar(-n), u.subVectors(A, R), d.copy(u).setLength(n).add(h), M.copy(d).negate();
                                    const i = d.length(),
                                        r = u.length();
                                    u.divideScalar(r), p.subVectors(L, A);
                                    const s = p.length();
                                    switch (p.divideScalar(s), u.dot(M) < r && p.dot(M) < s && (D = !0), S.copy(d).add(A), M.add(A), B = !1, D ? N ? (w.copy(M), _.copy(M)) : (b.copy(M), x.copy(M)) : W(), e.strokeLineJoin) {
                                        case "bevel":
                                            j(N, D, I);
                                            break;
                                        case "round":
                                            q(N, D), N ? V(A, x, b, I, 0) : V(A, w, _, I, 1);
                                            break;
                                        default:
                                            const t = C * e.strokeMiterLimit / i;
                                            if (t < 1) {
                                                if ("miter-clip" !== e.strokeLineJoin) { j(N, D, I); break }
                                                q(N, D), N ? (p.subVectors(S, x).multiplyScalar(t).add(x), m.subVectors(S, b).multiplyScalar(t).add(b), G(x, I, 0), G(p, I, 0), G(A, I, .5), G(A, I, .5), G(p, I, 0), G(m, I, 0), G(A, I, .5), G(m, I, 0), G(b, I, 0)) : (p.subVectors(S, _).multiplyScalar(t).add(_), m.subVectors(S, w).multiplyScalar(t).add(w), G(_, I, 1), G(p, I, 1), G(A, I, .5), G(A, I, .5), G(p, I, 1), G(m, I, 1), G(A, I, .5), G(m, I, 1), G(w, I, 1))
                                            } else D ? (N ? (G(g, O, 1), G(f, O, 0), G(S, I, 0), G(g, O, 1), G(S, I, 0), G(M, I, 1)) : (G(g, O, 1), G(f, O, 0), G(S, I, 1), G(f, O, 0), G(M, I, 0), G(S, I, 1)), N ? b.copy(S) : w.copy(S)) : N ? (G(x, I, 0), G(S, I, 0), G(A, I, .5), G(A, I, .5), G(S, I, 0), G(b, I, 0)) : (G(_, I, 1), G(S, I, 1), G(A, I, .5), G(A, I, .5), G(S, I, 1), G(w, I, 1)), B = !0
                                    }
                                } else W()
                            } else W();
                            E || n !== T - 1 || X(t[0], v, y, N, !0, O), O = I, R = A, f.copy(b), g.copy(w)
                        }
                        if (E) {
                            if (D && r) {
                                let t = S,
                                    e = M;
                                F !== N && (t = M, e = S), N ? (B || F) && (e.toArray(r, 0), e.toArray(r, 9), B && t.toArray(r, 3)) : !B && F || (e.toArray(r, 3), e.toArray(r, 9), B && t.toArray(r, 0))
                            }
                        } else X(A, x, _, N, !1, I);
                        return z;

                        function k(t, e, n) { return n.subVectors(e, t), n.set(-n.y, n.x).normalize() }

                        function G(t, e, n) { r && (r[U] = t.x, r[U + 1] = t.y, r[U + 2] = 0, s && (s[U] = 0, s[U + 1] = 0, s[U + 2] = 1), U += 3, o && (o[H] = e, o[H + 1] = n, H += 2)), z += 3 }

                        function V(t, e, i, r, s) {
                            l.copy(e).sub(t).normalize(), c.copy(i).sub(t).normalize();
                            let o = Math.PI;
                            const a = l.dot(c);
                            Math.abs(a) < 1 && (o = Math.abs(Math.acos(a))), o /= n, h.copy(e);
                            for (let e = 0, i = n - 1; e < i; e++) u.copy(h).rotateAround(t, o), G(h, r, s), G(u, r, s), G(t, r, .5), h.copy(u);
                            G(u, r, s), G(i, r, s), G(t, r, .5)
                        }

                        function W() { G(g, O, 1), G(f, O, 0), G(x, I, 0), G(g, O, 1), G(x, I, 1), G(_, I, 0) }

                        function j(t, e, n) { e ? t ? (G(g, O, 1), G(f, O, 0), G(x, I, 0), G(g, O, 1), G(x, I, 0), G(M, I, 1), G(x, n, 0), G(b, n, 0), G(M, n, .5)) : (G(g, O, 1), G(f, O, 0), G(_, I, 1), G(f, O, 0), G(M, I, 0), G(_, I, 1), G(_, n, 1), G(w, n, 0), G(M, n, .5)) : t ? (G(x, n, 0), G(b, n, 0), G(A, n, .5)) : (G(_, n, 1), G(w, n, 0), G(A, n, .5)) }

                        function q(t, e) { e && (t ? (G(g, O, 1), G(f, O, 0), G(x, I, 0), G(g, O, 1), G(x, I, 0), G(M, I, 1), G(x, O, 0), G(A, I, .5), G(M, I, 1), G(A, I, .5), G(b, O, 0), G(M, I, 1)) : (G(g, O, 1), G(f, O, 0), G(_, I, 1), G(f, O, 0), G(M, I, 0), G(_, I, 1), G(_, O, 1), G(M, I, 0), G(A, I, .5), G(A, I, .5), G(M, I, 0), G(w, O, 1))) }

                        function X(t, n, i, s, o, a) {
                            switch (e.strokeLineCap) {
                                case "round":
                                    o ? V(t, i, n, a, .5) : V(t, n, i, a, .5);
                                    break;
                                case "square":
                                    if (o) l.subVectors(n, t), c.set(l.y, -l.x), h.addVectors(l, c).add(t), u.subVectors(c, l).add(t), s ? (h.toArray(r, 3), u.toArray(r, 0), u.toArray(r, 9)) : (h.toArray(r, 3), h.toArray(r, 9), u.toArray(r, 0));
                                    else {
                                        l.subVectors(i, t), c.set(l.y, -l.x), h.addVectors(l, c).add(t), u.subVectors(c, l).add(t);
                                        const e = r.length;
                                        s ? (h.toArray(r, e - 3), u.toArray(r, e - 6), u.toArray(r, e - 12)) : (h.toArray(r, e - 6), u.toArray(r, e - 3), u.toArray(r, e - 12))
                                    }
                            }
                        }
                    }
                }
                class Gm {
                    constructor() { this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1 }
                    computeGroups(t) {
                        const e = [];
                        let n, i, r;
                        const s = t.faces;
                        for (i = 0; i < s.length; i++) {
                            const t = s[i];
                            t.materialIndex !== r && (r = t.materialIndex, void 0 !== n && (n.count = 3 * i - n.start, e.push(n)), n = { start: 3 * i, materialIndex: r })
                        }
                        void 0 !== n && (n.count = 3 * i - n.start, e.push(n)), this.groups = e
                    }
                    fromGeometry(t) {
                        const e = t.faces,
                            n = t.vertices,
                            i = t.faceVertexUvs,
                            r = i[0] && i[0].length > 0,
                            s = i[1] && i[1].length > 0,
                            o = t.morphTargets,
                            a = o.length;
                        let l;
                        if (a > 0) {
                            l = [];
                            for (let t = 0; t < a; t++) l[t] = { name: o[t].name, data: [] };
                            this.morphTargets.position = l
                        }
                        const c = t.morphNormals,
                            h = c.length;
                        let u;
                        if (h > 0) {
                            u = [];
                            for (let t = 0; t < h; t++) u[t] = { name: c[t].name, data: [] };
                            this.morphTargets.normal = u
                        }
                        const d = t.skinIndices,
                            p = t.skinWeights,
                            m = d.length === n.length,
                            f = p.length === n.length;
                        n.length > 0 && 0 === e.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                        for (let t = 0; t < e.length; t++) {
                            const g = e[t];
                            this.vertices.push(n[g.a], n[g.b], n[g.c]);
                            const v = g.vertexNormals;
                            if (3 === v.length) this.normals.push(v[0], v[1], v[2]);
                            else {
                                const t = g.normal;
                                this.normals.push(t, t, t)
                            }
                            const y = g.vertexColors;
                            if (3 === y.length) this.colors.push(y[0], y[1], y[2]);
                            else {
                                const t = g.color;
                                this.colors.push(t, t, t)
                            }
                            if (!0 === r) {
                                const e = i[0][t];
                                void 0 !== e ? this.uvs.push(e[0], e[1], e[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", t), this.uvs.push(new $n, new $n, new $n))
                            }
                            if (!0 === s) {
                                const e = i[1][t];
                                void 0 !== e ? this.uvs2.push(e[0], e[1], e[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", t), this.uvs2.push(new $n, new $n, new $n))
                            }
                            for (let t = 0; t < a; t++) {
                                const e = o[t].vertices;
                                l[t].data.push(e[g.a], e[g.b], e[g.c])
                            }
                            for (let e = 0; e < h; e++) {
                                const n = c[e].vertexNormals[t];
                                u[e].data.push(n.a, n.b, n.c)
                            }
                            m && this.skinIndices.push(d[g.a], d[g.b], d[g.c]), f && this.skinWeights.push(p[g.a], p[g.b], p[g.c])
                        }
                        return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
                    }
                }
                const Vm = (t, e) => { const n = (new Gm).fromGeometry(e); return Wm(t, n) },
                    Wm = (t, e) => {
                        var n, i;
                        const r = new Float32Array(3 * e.vertices.length);
                        if (t.setAttribute("position", new Fr(r, 3).copyVector3sArray(e.vertices)), e.normals.length > 0) {
                            const n = new Float32Array(3 * e.normals.length);
                            t.setAttribute("normal", new Fr(n, 3).copyVector3sArray(e.normals))
                        }
                        if (e.colors.length > 0) {
                            const n = new Float32Array(3 * e.colors.length);
                            t.setAttribute("color", new Fr(n, 3).copyColorsArray(e.colors))
                        }
                        if (e.uvs.length > 0) {
                            const n = new Float32Array(2 * e.uvs.length);
                            t.setAttribute("uv", new Fr(n, 2).copyVector2sArray(e.uvs))
                        }
                        if (e.uvs2.length > 0) {
                            const n = new Float32Array(2 * e.uvs2.length);
                            t.setAttribute("uv2", new Fr(n, 2).copyVector2sArray(e.uvs2))
                        }
                        t.groups = e.groups;
                        for (const n in e.morphTargets) {
                            const i = [],
                                r = e.morphTargets[n];
                            for (let t = 0, e = r.length; t < e; t++) {
                                const e = r[t],
                                    n = new qr(3 * e.data.length, 3);
                                n.name = e.name, i.push(n.copyVector3sArray(e.data))
                            }
                            t.morphAttributes[n] = i
                        }
                        if (e.skinIndices.length > 0) {
                            const n = new qr(4 * e.skinIndices.length, 4);
                            t.setAttribute("skinIndex", n.copyVector4sArray(e.skinIndices))
                        }
                        if (e.skinWeights.length > 0) {
                            const n = new qr(4 * e.skinWeights.length, 4);
                            t.setAttribute("skinWeight", n.copyVector4sArray(e.skinWeights))
                        }
                        return null !== e.boundingSphere && (t.boundingSphere = null === (n = e.boundingSphere) || void 0 === n ? void 0 : n.clone()), null !== e.boundingBox && (t.boundingBox = null === (i = e.boundingBox) || void 0 === i ? void 0 : i.clone()), t
                    };
                class jm {
                    constructor(t, e) { this.camera = t, this.renderer = e }
                    static geometryToBufferGeometry(t) { return t.isGeometry ? Vm(new rs, t) : t }
                    static bufferGeometryToGeometry(t) { return t.isBufferGeometry ? (new Fm).fromBufferGeometry(t) : t }
                    fromSVGtoShape(t, e = !1, n) {
                        if (t) {
                            const i = new km,
                                r = [];
                            return i.parse(t).paths.forEach((t => { t.toShapes(e, n).forEach((t => { r.push(t) })) })), r
                        }
                        return []
                    }
                    from3dto2d(t) {
                        const e = new ui(t.x, t.y, t.z),
                            n = this.renderer.domElement;
                        this.camera.updateMatrixWorld(), e.project(this.camera);
                        const i = Math.round((e.x + 1) * (n.width / 2)),
                            r = Math.round((1 - e.y) * (n.height / 2));
                        return new $n(i, r)
                    }
                    from2dto3d(t, e, n) {
                        var i;
                        if (!this.tmpPlane) {
                            const t = new Ws(1e4, 1e4),
                                e = new Nr({ transparent: !0, opacity: .25 });
                            this.tmpPlane = new ws(t, e), this.tmpPlane.name = "_tmp_raycast_plane"
                        }
                        let r;
                        this.tmpRaycaster || (this.tmpRaycaster = new Ud), this.tmpVector3 || (this.tmpVector3 = new ui), this.tmpPlane.setRotationFromEuler(this.camera.rotation);
                        const s = this.camera.position;
                        this.tmpPlane.position.set(s.x, s.y, s.z), this.camera.getWorldDirection(this.tmpVector3), this.tmpPlane.position.add(this.tmpVector3.clone().multiplyScalar(n)), this.tmpPlane.updateMatrix(), this.tmpPlane.updateMatrixWorld(!0), this.tmpRaycaster.setFromCamera({ x: t, y: e }, this.camera);
                        const o = this.tmpRaycaster.intersectObjects([this.tmpPlane]);
                        return "_tmp_raycast_plane" === (null === (i = o[0]) || void 0 === i ? void 0 : i.object.name) && (r = o[0].point), r
                    }
                }
                class qm {
                    static toGeometry(t, e) { t.geometry = jm.bufferGeometryToGeometry(t.geometry), e.geometry = jm.bufferGeometryToGeometry(e.geometry) }
                    static toBufferGeometry(t) { t.geometry = jm.geometryToBufferGeometry(t.geometry) }
                    static union(t, e) { this.toGeometry(t, e); const n = this.doCSG(t, e, "union"); return this.toBufferGeometry(n), n }
                    static subtract(t, e) { this.toGeometry(t, e); const n = this.doCSG(t, e, "subtract"); return this.toBufferGeometry(n), n }
                    static intersect(t, e) { this.toGeometry(t, e); const n = this.doCSG(t, e, "intersect"); return this.toBufferGeometry(n), n }
                    static doCSG(t, e, n) {
                        t.updateMatrix(), e.updateMatrix();
                        const i = Xm.fromMesh(t),
                            r = Xm.fromMesh(e),
                            s = i[n](r);
                        return Xm.toMesh(s, t.matrix)
                    }
                }
                class Xm {
                    constructor() { this.polygons = [] }
                    static fromPolygons(t) { const e = new Xm; return e.polygons = t, e }
                    static fromGeometry(t) {
                        t.isBufferGeometry && (t = (new Fm).fromBufferGeometry(t));
                        const e = t.faces,
                            n = t.vertices,
                            i = [],
                            r = ["a", "b", "c"];
                        for (let s = 0; s < e.length; s++) {
                            const o = e[s],
                                a = [];
                            for (let e = 0; e < 3; e++) {
                                const i = void 0 !== t.faceVertexUvs[0][s] && void 0 !== t.faceVertexUvs[0][s][e] ? t.faceVertexUvs[0][s][e] : void 0;
                                a.push(new Zm(n[o[r[e]]], o.vertexNormals[e], i))
                            }
                            i.push(new Km(a))
                        }
                        return Xm.fromPolygons(i)
                    }
                    static fromMesh(t) {
                        const e = Xm.fromGeometry(t.geometry);
                        Xm._tmpm3.getNormalMatrix(t.matrix);
                        for (const n of e.polygons)
                            for (const e of n.vertices) e.pos.applyMatrix4(t.matrix), e.normal.applyMatrix3(Xm._tmpm3);
                        return e
                    }
                    static toMesh(t, e) {
                        const n = new Fm,
                            i = t.polygons,
                            r = n.vertices,
                            s = n.faceVertexUvs[0];
                        for (const t of i) {
                            const e = t.vertices,
                                i = r.length,
                                o = e.length;
                            for (const t of e) r.push((new ui).copy(t.pos));
                            for (let r = 3; r <= o; r++) {
                                const o = new Hm(i, i + r - 2, i + r - 1),
                                    a = [];
                                s.push(a);
                                const l = o.vertexNormals;
                                l.push((new ui).copy(e[0].normal)), l.push((new ui).copy(e[r - 2].normal)), l.push((new ui).copy(e[r - 1].normal)), e[0].uv && e[r - 2].uv && e[r - 1].uv && (a.push((new ui).copy(e[0].uv)), a.push((new ui).copy(e[r - 2].uv)), a.push((new ui).copy(e[r - 1].uv))), o.normal = (new ui).copy(t.plane.normal), n.faces.push(o)
                            }
                        }
                        const o = parseInt(a) >= 123 ? (new Gi).copy(e).invert() : (new Gi).getInverse(e);
                        n.applyMatrix4(o), n.verticesNeedUpdate = n.elementsNeedUpdate = n.normalsNeedUpdate = !0, n.computeBoundingSphere(), n.computeBoundingBox();
                        const l = new ws(n);
                        return l.matrix.copy(e), l.matrix.decompose(l.position, l.rotation, l.scale), l.updateMatrixWorld(), l
                    }
                    static iEval(t, e = 0) {
                        var n;
                        if ("string" == typeof t) Xm.currentOp = t;
                        else if (t instanceof Array)
                            for (const e of t) Xm.iEval(e, 0);
                        else if ("object" == typeof t) {
                            const e = Xm.currentOp;
                            t.updateMatrix(), t.updateMatrixWorld(), Xm.sourceMesh ? (Xm.nextPrim = Xm.fromMesh(t), Xm.currentPrim = Xm.currentPrim[e](Xm.nextPrim)) : Xm.currentPrim = Xm.fromMesh(Xm.sourceMesh = t), Xm.doRemove && (null === (n = null == t ? void 0 : t.parent) || void 0 === n || n.remove(t))
                        }
                    }
                    static eval(t, e) { delete Xm.currentOp, delete Xm.sourceMesh, Xm.doRemove = e, Xm.iEval(t); const n = Xm.toMesh(Xm.currentPrim, Xm.sourceMesh.matrix); return n.material = Xm.sourceMesh.material, n.castShadow = n.receiveShadow = !0, n }
                    clone() { const t = new Xm; return t.polygons = this.polygons.map((t => t.clone())), t }
                    toPolygons() { return this.polygons }
                    union(t) {
                        const e = new Qm(this.clone().polygons),
                            n = new Qm(t.clone().polygons);
                        return e.clipTo(n), n.clipTo(e), n.invert(), n.clipTo(e), n.invert(), e.build(n.allPolygons()), Xm.fromPolygons(e.allPolygons())
                    }
                    subtract(t) {
                        const e = new Qm(this.clone().polygons),
                            n = new Qm(t.clone().polygons);
                        return e.invert(), e.clipTo(n), n.clipTo(e), n.invert(), n.clipTo(e), n.invert(), e.build(n.allPolygons()), e.invert(), Xm.fromPolygons(e.allPolygons())
                    }
                    intersect(t) {
                        const e = new Qm(this.clone().polygons),
                            n = new Qm(t.clone().polygons);
                        return e.invert(), n.clipTo(e), n.invert(), e.clipTo(n), n.clipTo(e), e.build(n.allPolygons()), e.invert(), Xm.fromPolygons(e.allPolygons())
                    }
                    inverse() { const t = this.clone(); return t.polygons.map((t => { t.flip() })), t }
                }
                Xm._tmpm3 = new ti;
                class Ym extends ui {
                    constructor(t, e, n) {
                        if (3 === arguments.length) super(t, e, n);
                        else if (Array.isArray(t)) super(t[0], t[1], t[2]);
                        else {
                            if ("object" != typeof t) throw new Error("Invalid constructor to vector");
                            this.copy(t)
                        }
                    }
                    clone() { return new Ym(this.x, this.y, this.z) }
                    negated() { return this.clone().multiplyScalar(-1) }
                    plus(t) { return this.clone().add(t) }
                    minus(t) { return this.clone().sub(t) }
                    times(t) { return this.clone().multiplyScalar(t) }
                    dividedBy(t) { return this.clone().divideScalar(t) }
                    lerp(t, e) { return this.plus(t.minus(this).times(e)) }
                    unit() { return this.dividedBy(this.length()) }
                    cross(t, e) { return ui.prototype.cross.call(this.clone(), t) }
                }
                class Zm {
                    constructor(t, e, n) { this.pos = new Ym(t.x, t.y, t.z), this.normal = new Ym(e.x, e.y, e.z), n && (this.uv = new Ym(n.x, n.y, n.z)) }
                    clone() { return new Zm(this.pos.clone(), this.normal.clone(), this.uv ? this.uv.clone() : void 0) }
                    flip() { this.normal = this.normal.negated() }
                    interpolate(t, e) { return new Zm(this.pos.lerp(t.pos, e), this.normal.lerp(t.normal, e), this.uv ? this.uv.lerp(t.uv, e) : void 0) }
                }
                class Jm {
                    constructor(t, e) { this.normal = t, this.w = e }
                    static fromPoints(t, e, n) { const i = e.minus(t).cross(n.minus(t)).unit(); return new Jm(i, i.dot(t)) }
                    clone() { return new Jm(this.normal.clone(), this.w) }
                    flip() { this.normal = this.normal.negated(), this.w = -this.w }
                    splitPolygon(t, e, n, i, r) {
                        let s = 0;
                        const o = [];
                        for (const e of t.vertices) {
                            const t = this.normal.dot(e.pos) - this.w,
                                n = t < -Jm.EPSILON ? 2 : t > Jm.EPSILON ? 1 : 0;
                            s |= n, o.push(n)
                        }
                        switch (s) {
                            case 0:
                                this.normal.dot(t.plane.normal) > 0 ? e.push(t) : n.push(t);
                                break;
                            case 1:
                                i.push(t);
                                break;
                            case 2:
                                r.push(t);
                                break;
                            case 3:
                                const s = [],
                                    a = [];
                                for (let e = 0; e < t.vertices.length; e++) {
                                    const n = (e + 1) % t.vertices.length,
                                        i = o[e],
                                        r = o[n],
                                        l = t.vertices[e],
                                        c = t.vertices[n];
                                    if (2 !== i && s.push(l), 1 !== i && a.push(2 !== i ? l.clone() : l), 3 == (i | r)) {
                                        const t = (this.w - this.normal.dot(l.pos)) / this.normal.dot(c.pos.minus(l.pos)),
                                            e = l.interpolate(c, t);
                                        s.push(e), a.push(e.clone())
                                    }
                                }
                                s.length >= 3 && i.push(new Km(s, t.shared)), a.length >= 3 && r.push(new Km(a, t.shared))
                        }
                    }
                }
                Jm.EPSILON = 1e-5;
                class Km {
                    constructor(t, e = null) { this.vertices = t, this.shared = e, this.plane = Jm.fromPoints(t[0].pos, t[1].pos, t[2].pos) }
                    clone() { const t = this.vertices.map((t => t.clone())); return new Km(t, this.shared) }
                    flip() { this.vertices.reverse().map((t => { t.flip() })), this.plane.flip() }
                }
                class Qm {
                    constructor(t) { delete this.plane, delete this.front, delete this.back, this.polygons = [], t && this.build(t) }
                    clone() { const t = new Qm; return t.plane = this.plane && this.plane.clone(), t.front = this.front && this.front.clone(), t.back = this.back && this.back.clone(), t.polygons = this.polygons.map((t => t.clone())), t }
                    invert() {
                        for (const t of this.polygons) t.flip();
                        this.plane.flip(), this.front && this.front.invert(), this.back && this.back.invert();
                        const t = this.front;
                        this.front = this.back, this.back = t
                    }
                    clipPolygons(t) {
                        if (!this.plane) return t.slice();
                        let e = [],
                            n = [];
                        for (const i of t) this.plane.splitPolygon(i, e, n, e, n);
                        return this.front && (e = this.front.clipPolygons(e)), n = this.back ? this.back.clipPolygons(n) : [], e.concat(n)
                    }
                    clipTo(t) { this.polygons = t.clipPolygons(this.polygons), this.front && this.front.clipTo(t), this.back && this.back.clipTo(t) }
                    allPolygons() { let t = this.polygons.slice(); return this.front && (t = t.concat(this.front.allPolygons())), this.back && (t = t.concat(this.back.allPolygons())), t }
                    build(t) {
                        if (!t.length) return;
                        this.plane || (this.plane = t[0].plane.clone());
                        const e = [],
                            n = [];
                        for (const i of t) this.plane.splitPolygon(i, this.polygons, this.polygons, e, n);
                        e.length && (this.front || (this.front = new Qm), this.front.build(e)), n.length && (this.back || (this.back = new Qm), this.back.build(n))
                    }
                }
                var $m = {},
                    tf = function(t) { return URL.createObjectURL(new Blob([t], { type: "text/javascript" })) },
                    ef = function(t) { return new Worker(t) };
                try { URL.revokeObjectURL(tf("")) } catch (t) { tf = function(t) { return "data:application/javascript;charset=UTF-8," + encodeURI(t) }, ef = function(t) { return new Worker(t, { type: "module" }) } }
                var nf = Uint8Array,
                    rf = Uint16Array,
                    sf = Uint32Array,
                    of = new nf([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
                    af = new nf([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
                    lf = new nf([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
                    cf = function(t, e) {
                        for (var n = new rf(31), i = 0; i < 31; ++i) n[i] = e += 1 << t[i - 1];
                        var r = new sf(n[30]);
                        for (i = 1; i < 30; ++i)
                            for (var s = n[i]; s < n[i + 1]; ++s) r[s] = s - n[i] << 5 | i;
                        return [n, r]
                    },
                    hf = cf(of, 2),
                    uf = hf[0],
                    df = hf[1];
                uf[28] = 258, df[258] = 28;
                for (var pf = cf(af, 0), mf = pf[0], ff = pf[1], gf = new rf(32768), vf = 0; vf < 32768; ++vf) {
                    var yf = (43690 & vf) >>> 1 | (21845 & vf) << 1;
                    yf = (61680 & (yf = (52428 & yf) >>> 2 | (13107 & yf) << 2)) >>> 4 | (3855 & yf) << 4, gf[vf] = ((65280 & yf) >>> 8 | (255 & yf) << 8) >>> 1
                }
                var xf = function(t, e, n) {
                        for (var i = t.length, r = 0, s = new rf(e); r < i; ++r) ++s[t[r] - 1];
                        var o, a = new rf(e);
                        for (r = 0; r < e; ++r) a[r] = a[r - 1] + s[r - 1] << 1;
                        if (n) {
                            o = new rf(1 << e);
                            var l = 15 - e;
                            for (r = 0; r < i; ++r)
                                if (t[r])
                                    for (var c = r << 4 | t[r], h = e - t[r], u = a[t[r] - 1]++ << h, d = u | (1 << h) - 1; u <= d; ++u) o[gf[u] >>> l] = c
                        } else
                            for (o = new rf(i), r = 0; r < i; ++r) t[r] && (o[r] = gf[a[t[r] - 1]++] >>> 15 - t[r]);
                        return o
                    },
                    _f = new nf(288);
                for (vf = 0; vf < 144; ++vf) _f[vf] = 8;
                for (vf = 144; vf < 256; ++vf) _f[vf] = 9;
                for (vf = 256; vf < 280; ++vf) _f[vf] = 7;
                for (vf = 280; vf < 288; ++vf) _f[vf] = 8;
                var bf = new nf(32);
                for (vf = 0; vf < 32; ++vf) bf[vf] = 5;
                var wf = xf(_f, 9, 0),
                    Mf = xf(_f, 9, 1),
                    Sf = xf(bf, 5, 0),
                    Tf = xf(bf, 5, 1),
                    Ef = function(t) { for (var e = t[0], n = 1; n < t.length; ++n) t[n] > e && (e = t[n]); return e },
                    Af = function(t, e, n) { var i = e / 8 | 0; return (t[i] | t[i + 1] << 8) >> (7 & e) & n },
                    Lf = function(t, e) { var n = e / 8 | 0; return (t[n] | t[n + 1] << 8 | t[n + 2] << 16) >> (7 & e) },
                    Rf = function(t) { return (t / 8 | 0) + (7 & t && 1) },
                    Cf = function(t, e, n) {
                        (null == e || e < 0) && (e = 0), (null == n || n > t.length) && (n = t.length);
                        var i = new(t instanceof rf ? rf : t instanceof sf ? sf : nf)(n - e);
                        return i.set(t.subarray(e, n)), i
                    },
                    Pf = function(t, e, n) {
                        var i = t.length;
                        if (!i || n && !n.l && i < 5) return e || new nf(0);
                        var r = !e || n,
                            s = !n || n.i;
                        n || (n = {}), e || (e = new nf(3 * i));
                        var o = function(t) {
                                var n = e.length;
                                if (t > n) {
                                    var i = new nf(Math.max(2 * n, t));
                                    i.set(e), e = i
                                }
                            },
                            a = n.f || 0,
                            l = n.p || 0,
                            c = n.b || 0,
                            h = n.l,
                            u = n.d,
                            d = n.m,
                            p = n.n,
                            m = 8 * i;
                        do {
                            if (!h) {
                                n.f = a = Af(t, l, 1);
                                var f = Af(t, l + 1, 3);
                                if (l += 3, !f) {
                                    var g = t[(A = Rf(l) + 4) - 4] | t[A - 3] << 8,
                                        v = A + g;
                                    if (v > i) { if (s) throw "unexpected EOF"; break }
                                    r && o(c + g), e.set(t.subarray(A, v), c), n.b = c += g, n.p = l = 8 * v;
                                    continue
                                }
                                if (1 == f) h = Mf, u = Tf, d = 9, p = 5;
                                else {
                                    if (2 != f) throw "invalid block type";
                                    var y = Af(t, l, 31) + 257,
                                        x = Af(t, l + 10, 15) + 4,
                                        _ = y + Af(t, l + 5, 31) + 1;
                                    l += 14;
                                    for (var b = new nf(_), w = new nf(19), M = 0; M < x; ++M) w[lf[M]] = Af(t, l + 3 * M, 7);
                                    l += 3 * x;
                                    var S = Ef(w),
                                        T = (1 << S) - 1,
                                        E = xf(w, S, 1);
                                    for (M = 0; M < _;) {
                                        var A, L = E[Af(t, l, T)];
                                        if (l += 15 & L, (A = L >>> 4) < 16) b[M++] = A;
                                        else {
                                            var R = 0,
                                                C = 0;
                                            for (16 == A ? (C = 3 + Af(t, l, 3), l += 2, R = b[M - 1]) : 17 == A ? (C = 3 + Af(t, l, 7), l += 3) : 18 == A && (C = 11 + Af(t, l, 127), l += 7); C--;) b[M++] = R
                                        }
                                    }
                                    var P = b.subarray(0, y),
                                        I = b.subarray(y);
                                    d = Ef(P), p = Ef(I), h = xf(P, d, 1), u = xf(I, p, 1)
                                }
                                if (l > m) { if (s) throw "unexpected EOF"; break }
                            }
                            r && o(c + 131072);
                            for (var D = (1 << d) - 1, N = (1 << p) - 1, B = l;; B = l) {
                                var O = (R = h[Lf(t, l) & D]) >>> 4;
                                if ((l += 15 & R) > m) { if (s) throw "unexpected EOF"; break }
                                if (!R) throw "invalid length/literal";
                                if (O < 256) e[c++] = O;
                                else {
                                    if (256 == O) { B = l, h = null; break }
                                    var F = O - 254;
                                    if (O > 264) {
                                        var z = of[M = O - 257];
                                        F = Af(t, l, (1 << z) - 1) + uf[M], l += z
                                    }
                                    var U = u[Lf(t, l) & N],
                                        H = U >>> 4;
                                    if (!U) throw "invalid distance";
                                    if (l += 15 & U, I = mf[H], H > 3 && (z = af[H], I += Lf(t, l) & (1 << z) - 1, l += z), l > m) { if (s) throw "unexpected EOF"; break }
                                    r && o(c + 131072);
                                    for (var k = c + F; c < k; c += 4) e[c] = e[c - I], e[c + 1] = e[c + 1 - I], e[c + 2] = e[c + 2 - I], e[c + 3] = e[c + 3 - I];
                                    c = k
                                }
                            }
                            n.l = h, n.p = B, n.b = c, h && (a = 1, n.m = d, n.d = u, n.n = p)
                        } while (!a);
                        return c == e.length ? e : Cf(e, 0, c)
                    },
                    If = function(t, e, n) {
                        n <<= 7 & e;
                        var i = e / 8 | 0;
                        t[i] |= n, t[i + 1] |= n >>> 8
                    },
                    Df = function(t, e, n) {
                        n <<= 7 & e;
                        var i = e / 8 | 0;
                        t[i] |= n, t[i + 1] |= n >>> 8, t[i + 2] |= n >>> 16
                    },
                    Nf = function(t, e) {
                        for (var n = [], i = 0; i < t.length; ++i) t[i] && n.push({ s: i, f: t[i] });
                        var r = n.length,
                            s = n.slice();
                        if (!r) return [kf, 0];
                        if (1 == r) { var o = new nf(n[0].s + 1); return o[n[0].s] = 1, [o, 1] }
                        n.sort((function(t, e) { return t.f - e.f })), n.push({ s: -1, f: 25001 });
                        var a = n[0],
                            l = n[1],
                            c = 0,
                            h = 1,
                            u = 2;
                        for (n[0] = { s: -1, f: a.f + l.f, l: a, r: l }; h != r - 1;) a = n[n[c].f < n[u].f ? c++ : u++], l = n[c != h && n[c].f < n[u].f ? c++ : u++], n[h++] = { s: -1, f: a.f + l.f, l: a, r: l };
                        var d = s[0].s;
                        for (i = 1; i < r; ++i) s[i].s > d && (d = s[i].s);
                        var p = new rf(d + 1),
                            m = Bf(n[h - 1], p, 0);
                        if (m > e) {
                            i = 0;
                            var f = 0,
                                g = m - e,
                                v = 1 << g;
                            for (s.sort((function(t, e) { return p[e.s] - p[t.s] || t.f - e.f })); i < r; ++i) {
                                var y = s[i].s;
                                if (!(p[y] > e)) break;
                                f += v - (1 << m - p[y]), p[y] = e
                            }
                            for (f >>>= g; f > 0;) {
                                var x = s[i].s;
                                p[x] < e ? f -= 1 << e - p[x]++ - 1 : ++i
                            }
                            for (; i >= 0 && f; --i) {
                                var _ = s[i].s;
                                p[_] == e && (--p[_], ++f)
                            }
                            m = e
                        }
                        return [new nf(p), m]
                    },
                    Bf = function(t, e, n) { return -1 == t.s ? Math.max(Bf(t.l, e, n + 1), Bf(t.r, e, n + 1)) : e[t.s] = n },
                    Of = function(t) {
                        for (var e = t.length; e && !t[--e];);
                        for (var n = new rf(++e), i = 0, r = t[0], s = 1, o = function(t) { n[i++] = t }, a = 1; a <= e; ++a)
                            if (t[a] == r && a != e) ++s;
                            else {
                                if (!r && s > 2) {
                                    for (; s > 138; s -= 138) o(32754);
                                    s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0)
                                } else if (s > 3) {
                                    for (o(r), --s; s > 6; s -= 6) o(8304);
                                    s > 2 && (o(s - 3 << 5 | 8208), s = 0)
                                }
                                for (; s--;) o(r);
                                s = 1, r = t[a]
                            }
                        return [n.subarray(0, i), e]
                    },
                    Ff = function(t, e) { for (var n = 0, i = 0; i < e.length; ++i) n += t[i] * e[i]; return n },
                    zf = function(t, e, n) {
                        var i = n.length,
                            r = Rf(e + 2);
                        t[r] = 255 & i, t[r + 1] = i >>> 8, t[r + 2] = 255 ^ t[r], t[r + 3] = 255 ^ t[r + 1];
                        for (var s = 0; s < i; ++s) t[r + s + 4] = n[s];
                        return 8 * (r + 4 + i)
                    },
                    Uf = function(t, e, n, i, r, s, o, a, l, c, h) {
                        If(e, h++, n), ++r[256];
                        for (var u = Nf(r, 15), d = u[0], p = u[1], m = Nf(s, 15), f = m[0], g = m[1], v = Of(d), y = v[0], x = v[1], _ = Of(f), b = _[0], w = _[1], M = new rf(19), S = 0; S < y.length; ++S) M[31 & y[S]]++;
                        for (S = 0; S < b.length; ++S) M[31 & b[S]]++;
                        for (var T = Nf(M, 7), E = T[0], A = T[1], L = 19; L > 4 && !E[lf[L - 1]]; --L);
                        var R, C, P, I, D = c + 5 << 3,
                            N = Ff(r, _f) + Ff(s, bf) + o,
                            B = Ff(r, d) + Ff(s, f) + o + 14 + 3 * L + Ff(M, E) + (2 * M[16] + 3 * M[17] + 7 * M[18]);
                        if (D <= N && D <= B) return zf(e, h, t.subarray(l, l + c));
                        if (If(e, h, 1 + (B < N)), h += 2, B < N) {
                            R = xf(d, p, 0), C = d, P = xf(f, g, 0), I = f;
                            var O = xf(E, A, 0);
                            for (If(e, h, x - 257), If(e, h + 5, w - 1), If(e, h + 10, L - 4), h += 14, S = 0; S < L; ++S) If(e, h + 3 * S, E[lf[S]]);
                            h += 3 * L;
                            for (var F = [y, b], z = 0; z < 2; ++z) {
                                var U = F[z];
                                for (S = 0; S < U.length; ++S) {
                                    var H = 31 & U[S];
                                    If(e, h, O[H]), h += E[H], H > 15 && (If(e, h, U[S] >>> 5 & 127), h += U[S] >>> 12)
                                }
                            }
                        } else R = wf, C = _f, P = Sf, I = bf;
                        for (S = 0; S < a; ++S)
                            if (i[S] > 255) {
                                H = i[S] >>> 18 & 31, Df(e, h, R[H + 257]), h += C[H + 257], H > 7 && (If(e, h, i[S] >>> 23 & 31), h += of[H]);
                                var k = 31 & i[S];
                                Df(e, h, P[k]), h += I[k], k > 3 && (Df(e, h, i[S] >>> 5 & 8191), h += af[k])
                            } else Df(e, h, R[i[S]]), h += C[i[S]];
                        return Df(e, h, R[256]), h + C[256]
                    },
                    Hf = new sf([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
                    kf = new nf(0),
                    Gf = function(t, e, n, i, r, s) {
                        var o = t.length,
                            a = new nf(i + o + 5 * (1 + Math.ceil(o / 7e3)) + r),
                            l = a.subarray(i, a.length - r),
                            c = 0;
                        if (!e || o < 8)
                            for (var h = 0; h <= o; h += 65535) {
                                var u = h + 65535;
                                u < o ? c = zf(l, c, t.subarray(h, u)) : (l[h] = s, c = zf(l, c, t.subarray(h, o)))
                            } else {
                                for (var d = Hf[e - 1], p = d >>> 13, m = 8191 & d, f = (1 << n) - 1, g = new rf(32768), v = new rf(f + 1), y = Math.ceil(n / 3), x = 2 * y, _ = function(e) { return (t[e] ^ t[e + 1] << y ^ t[e + 2] << x) & f }, b = new sf(25e3), w = new rf(288), M = new rf(32), S = 0, T = 0, E = (h = 0, 0), A = 0, L = 0; h < o; ++h) {
                                    var R = _(h),
                                        C = 32767 & h,
                                        P = v[R];
                                    if (g[C] = P, v[R] = C, A <= h) {
                                        var I = o - h;
                                        if ((S > 7e3 || E > 24576) && I > 423) { c = Uf(t, l, 0, b, w, M, T, E, L, h - L, c), E = S = T = 0, L = h; for (var D = 0; D < 286; ++D) w[D] = 0; for (D = 0; D < 30; ++D) M[D] = 0 }
                                        var N = 2,
                                            B = 0,
                                            O = m,
                                            F = C - P & 32767;
                                        if (I > 2 && R == _(h - F))
                                            for (var z = Math.min(p, I) - 1, U = Math.min(32767, h), H = Math.min(258, I); F <= U && --O && C != P;) {
                                                if (t[h + N] == t[h + N - F]) {
                                                    for (var k = 0; k < H && t[h + k] == t[h + k - F]; ++k);
                                                    if (k > N) {
                                                        if (N = k, B = F, k > z) break;
                                                        var G = Math.min(F, k - 2),
                                                            V = 0;
                                                        for (D = 0; D < G; ++D) {
                                                            var W = h - F + D + 32768 & 32767,
                                                                j = W - g[W] + 32768 & 32767;
                                                            j > V && (V = j, P = W)
                                                        }
                                                    }
                                                }
                                                F += (C = P) - (P = g[C]) + 32768 & 32767
                                            }
                                        if (B) {
                                            b[E++] = 268435456 | df[N] << 18 | ff[B];
                                            var q = 31 & df[N],
                                                X = 31 & ff[B];
                                            T += of[q] + af[X], ++w[257 + q], ++M[X], A = h + N, ++S
                                        } else b[E++] = t[h], ++w[t[h]]
                                    }
                                }
                                c = Uf(t, l, s, b, w, M, T, E, L, h - L, c), !s && 7 & c && (c = zf(l, c + 1, kf))
                            }
                        return Cf(a, 0, i + Rf(c) + r)
                    },
                    Vf = function() {
                        for (var t = new sf(256), e = 0; e < 256; ++e) {
                            for (var n = e, i = 9; --i;) n = (1 & n && 3988292384) ^ n >>> 1;
                            t[e] = n
                        }
                        return t
                    }(),
                    Wf = function() {
                        var t = -1;
                        return {
                            p: function(e) {
                                for (var n = t, i = 0; i < e.length; ++i) n = Vf[255 & n ^ e[i]] ^ n >>> 8;
                                t = n
                            },
                            d: function() { return ~t }
                        }
                    },
                    jf = function() {
                        var t = 1,
                            e = 0;
                        return {
                            p: function(n) {
                                for (var i = t, r = e, s = n.length, o = 0; o != s;) {
                                    for (var a = Math.min(o + 2655, s); o < a; ++o) r += i += n[o];
                                    i = (65535 & i) + 15 * (i >> 16), r = (65535 & r) + 15 * (r >> 16)
                                }
                                t = i, e = r
                            },
                            d: function() { return (255 & (t %= 65521)) << 24 | t >>> 8 << 16 | (255 & (e %= 65521)) << 8 | e >>> 8 }
                        }
                    },
                    qf = function(t, e, n, i, r) { return Gf(t, null == e.level ? 6 : e.level, null == e.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t.length)))) : 12 + e.mem, n, i, !r) },
                    Xf = function(t, e) { var n = {}; for (var i in t) n[i] = t[i]; for (var i in e) n[i] = e[i]; return n },
                    Yf = function(t, e, n) {
                        for (var i = t(), r = t.toString(), s = r.slice(r.indexOf("[") + 1, r.lastIndexOf("]")).replace(/ /g, "").split(","), o = 0; o < i.length; ++o) {
                            var a = i[o],
                                l = s[o];
                            if ("function" == typeof a) {
                                e += ";" + l + "=";
                                var c = a.toString();
                                if (a.prototype)
                                    if (-1 != c.indexOf("[native code]")) {
                                        var h = c.indexOf(" ", 8) + 1;
                                        e += c.slice(h, c.indexOf("(", h))
                                    } else
                                        for (var u in e += c, a.prototype) e += ";" + l + ".prototype." + u + "=" + a.prototype[u].toString();
                                else e += c
                            } else n[l] = a
                        }
                        return [e, n]
                    },
                    Zf = [],
                    Jf = function(t, e, n, i) {
                        var r;
                        if (!Zf[n]) {
                            for (var s = "", o = {}, a = t.length - 1, l = 0; l < a; ++l) s = (r = Yf(t[l], s, o))[0], o = r[1];
                            Zf[n] = Yf(t[a], s, o)
                        }
                        var c = Xf({}, Zf[n][1]);
                        return function(t, e, n, i, r) { var s = ef($m[e] || ($m[e] = tf(t))); return s.onerror = function(t) { return r(t.error, null) }, s.onmessage = function(t) { return r(null, t.data) }, s.postMessage(n, i), s }(Zf[n][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + e.toString() + "}", n, c, function(t) { var e = []; for (var n in t)(t[n] instanceof nf || t[n] instanceof rf || t[n] instanceof sf) && e.push((t[n] = new t[n].constructor(t[n])).buffer); return e }(c), i)
                    },
                    Kf = function() { return [nf, rf, sf, of, af, lf, uf, mf, Mf, Tf, gf, xf, Ef, Af, Lf, Rf, Cf, Pf, Eg, ig, rg] },
                    Qf = function() { return [nf, rf, sf, of, af, lf, df, ff, wf, _f, Sf, bf, gf, Hf, kf, xf, If, Df, Nf, Bf, Of, Ff, zf, Uf, Rf, Cf, Gf, qf, wg, ig] },
                    $f = function() { return [dg, fg, ug, Wf, Vf] },
                    tg = function() { return [pg, mg] },
                    eg = function() { return [gg, ug, jf] },
                    ng = function() { return [vg] },
                    ig = function(t) { return postMessage(t, [t.buffer]) },
                    rg = function(t) { return t && t.size && new nf(t.size) },
                    sg = function(t, e, n, i, r, s) {
                        var o = Jf(n, i, r, (function(t, e) { o.terminate(), s(t, e) }));
                        return o.postMessage([t, e], e.consume ? [t.buffer] : []),
                            function() { o.terminate() }
                    },
                    og = function(t) {
                        return t.ondata = function(t, e) { return postMessage([t, e], [t.buffer]) },
                            function(e) { return t.push(e.data[0], e.data[1]) }
                    },
                    ag = function(t, e, n, i, r) {
                        var s, o = Jf(t, i, r, (function(t, n) { t ? (o.terminate(), e.ondata.call(e, t)) : (n[1] && o.terminate(), e.ondata.call(e, t, n[0], n[1])) }));
                        o.postMessage(n), e.push = function(t, n) {
                            if (s) throw "stream finished";
                            if (!e.ondata) throw "no stream handler";
                            o.postMessage([t, s = n], [t.buffer])
                        }, e.terminate = function() { o.terminate() }
                    },
                    lg = function(t, e) { return t[e] | t[e + 1] << 8 },
                    cg = function(t, e) { return (t[e] | t[e + 1] << 8 | t[e + 2] << 16 | t[e + 3] << 24) >>> 0 },
                    hg = function(t, e) { return cg(t, e) + 4294967296 * cg(t, e + 4) },
                    ug = function(t, e, n) { for (; n; ++e) t[e] = n, n >>>= 8 },
                    dg = function(t, e) { var n = e.filename; if (t[0] = 31, t[1] = 139, t[2] = 8, t[8] = e.level < 2 ? 4 : 9 == e.level ? 2 : 0, t[9] = 3, 0 != e.mtime && ug(t, 4, Math.floor(new Date(e.mtime || Date.now()) / 1e3)), n) { t[3] = 8; for (var i = 0; i <= n.length; ++i) t[i + 10] = n.charCodeAt(i) } },
                    pg = function(t) {
                        if (31 != t[0] || 139 != t[1] || 8 != t[2]) throw "invalid gzip data";
                        var e = t[3],
                            n = 10;
                        4 & e && (n += t[10] | 2 + (t[11] << 8));
                        for (var i = (e >> 3 & 1) + (e >> 4 & 1); i > 0; i -= !t[n++]);
                        return n + (2 & e)
                    },
                    mg = function(t) { var e = t.length; return (t[e - 4] | t[e - 3] << 8 | t[e - 2] << 16 | t[e - 1] << 24) >>> 0 },
                    fg = function(t) { return 10 + (t.filename && t.filename.length + 1 || 0) },
                    gg = function(t, e) {
                        var n = e.level,
                            i = 0 == n ? 0 : n < 6 ? 1 : 9 == n ? 3 : 2;
                        t[0] = 120, t[1] = i << 6 | (i ? 32 - 2 * i : 1)
                    },
                    vg = function(t) { if (8 != (15 & t[0]) || t[0] >>> 4 > 7 || (t[0] << 8 | t[1]) % 31) throw "invalid zlib data"; if (32 & t[1]) throw "invalid zlib data: preset dictionaries not supported" };

                function yg(t, e) { return e || "function" != typeof t || (e = t, t = {}), this.ondata = e, t }
                var xg = function() {
                        function t(t, e) { e || "function" != typeof t || (e = t, t = {}), this.ondata = e, this.o = t || {} }
                        return t.prototype.p = function(t, e) { this.ondata(qf(t, this.o, 0, 0, !e), e) }, t.prototype.push = function(t, e) {
                            if (this.d) throw "stream finished";
                            if (!this.ondata) throw "no stream handler";
                            this.d = e, this.p(t, e || !1)
                        }, t
                    }(),
                    _g = function() {
                        return function(t, e) {
                            ag([Qf, function() { return [og, xg] }], this, yg.call(this, t, e), (function(t) {
                                var e = new xg(t.data);
                                onmessage = og(e)
                            }), 6)
                        }
                    }();

                function bg(t, e, n) { if (n || (n = e, e = {}), "function" != typeof n) throw "no callback"; return sg(t, e, [Qf], (function(t) { return ig(wg(t.data[0], t.data[1])) }), 0, n) }

                function wg(t, e) { return qf(t, e || {}, 0, 0) }
                var Mg = function() {
                        function t(t) { this.s = {}, this.p = new nf(0), this.ondata = t }
                        return t.prototype.e = function(t) {
                            if (this.d) throw "stream finished";
                            if (!this.ondata) throw "no stream handler";
                            var e = this.p.length,
                                n = new nf(e + t.length);
                            n.set(this.p), n.set(t, e), this.p = n
                        }, t.prototype.c = function(t) {
                            this.d = this.s.i = t || !1;
                            var e = this.s.b,
                                n = Pf(this.p, this.o, this.s);
                            this.ondata(Cf(n, e, this.s.b), this.d), this.o = Cf(n, this.s.b - 32768), this.s.b = this.o.length, this.p = Cf(this.p, this.s.p / 8 | 0), this.s.p &= 7
                        }, t.prototype.push = function(t, e) { this.e(t), this.c(e) }, t
                    }(),
                    Sg = function() {
                        return function(t) {
                            this.ondata = t, ag([Kf, function() { return [og, Mg] }], this, 0, (function() {
                                var t = new Mg;
                                onmessage = og(t)
                            }), 7)
                        }
                    }();

                function Tg(t, e, n) { if (n || (n = e, e = {}), "function" != typeof n) throw "no callback"; return sg(t, e, [Kf], (function(t) { return ig(Eg(t.data[0], rg(t.data[1]))) }), 1, n) }

                function Eg(t, e) { return Pf(t, e) }
                var Ag = function() {
                        function t(t, e) { this.c = Wf(), this.l = 0, this.v = 1, xg.call(this, t, e) }
                        return t.prototype.push = function(t, e) { xg.prototype.push.call(this, t, e) }, t.prototype.p = function(t, e) {
                            this.c.p(t), this.l += t.length;
                            var n = qf(t, this.o, this.v && fg(this.o), e && 8, !e);
                            this.v && (dg(n, this.o), this.v = 0), e && (ug(n, n.length - 8, this.c.d()), ug(n, n.length - 4, this.l)), this.ondata(n, e)
                        }, t
                    }(),
                    Lg = function() {
                        return function(t, e) {
                            ag([Qf, $f, function() { return [og, xg, Ag] }], this, yg.call(this, t, e), (function(t) {
                                var e = new Ag(t.data);
                                onmessage = og(e)
                            }), 8)
                        }
                    }();

                function Rg(t, e, n) { if (n || (n = e, e = {}), "function" != typeof n) throw "no callback"; return sg(t, e, [Qf, $f, function() { return [Cg] }], (function(t) { return ig(Cg(t.data[0], t.data[1])) }), 2, n) }

                function Cg(t, e) {
                    e || (e = {});
                    var n = Wf(),
                        i = t.length;
                    n.p(t);
                    var r = qf(t, e, fg(e), 8),
                        s = r.length;
                    return dg(r, e), ug(r, s - 8, n.d()), ug(r, s - 4, i), r
                }
                var Pg = function() {
                        function t(t) { this.v = 1, Mg.call(this, t) }
                        return t.prototype.push = function(t, e) {
                            if (Mg.prototype.e.call(this, t), this.v) {
                                var n = this.p.length > 3 ? pg(this.p) : 4;
                                if (n >= this.p.length && !e) return;
                                this.p = this.p.subarray(n), this.v = 0
                            }
                            if (e) {
                                if (this.p.length < 8) throw "invalid gzip stream";
                                this.p = this.p.subarray(0, -8)
                            }
                            Mg.prototype.c.call(this, e)
                        }, t
                    }(),
                    Ig = function() {
                        return function(t) {
                            this.ondata = t, ag([Kf, tg, function() { return [og, Mg, Pg] }], this, 0, (function() {
                                var t = new Pg;
                                onmessage = og(t)
                            }), 9)
                        }
                    }();

                function Dg(t, e, n) { if (n || (n = e, e = {}), "function" != typeof n) throw "no callback"; return sg(t, e, [Kf, tg, function() { return [Ng] }], (function(t) { return ig(Ng(t.data[0])) }), 3, n) }

                function Ng(t, e) { return Pf(t.subarray(pg(t), -8), e || new nf(mg(t))) }
                var Bg = function() {
                        function t(t, e) { this.c = jf(), this.v = 1, xg.call(this, t, e) }
                        return t.prototype.push = function(t, e) { xg.prototype.push.call(this, t, e) }, t.prototype.p = function(t, e) {
                            this.c.p(t);
                            var n = qf(t, this.o, this.v && 2, e && 4, !e);
                            this.v && (gg(n, this.o), this.v = 0), e && ug(n, n.length - 4, this.c.d()), this.ondata(n, e)
                        }, t
                    }(),
                    Og = function() {
                        return function(t, e) {
                            ag([Qf, eg, function() { return [og, xg, Bg] }], this, yg.call(this, t, e), (function(t) {
                                var e = new Bg(t.data);
                                onmessage = og(e)
                            }), 10)
                        }
                    }();

                function Fg(t, e, n) { if (n || (n = e, e = {}), "function" != typeof n) throw "no callback"; return sg(t, e, [Qf, eg, function() { return [zg] }], (function(t) { return ig(zg(t.data[0], t.data[1])) }), 4, n) }

                function zg(t, e) {
                    e || (e = {});
                    var n = jf();
                    n.p(t);
                    var i = qf(t, e, 2, 4);
                    return gg(i, e), ug(i, i.length - 4, n.d()), i
                }
                var Ug = function() {
                        function t(t) { this.v = 1, Mg.call(this, t) }
                        return t.prototype.push = function(t, e) {
                            if (Mg.prototype.e.call(this, t), this.v) {
                                if (this.p.length < 2 && !e) return;
                                this.p = this.p.subarray(2), this.v = 0
                            }
                            if (e) {
                                if (this.p.length < 4) throw "invalid zlib stream";
                                this.p = this.p.subarray(0, -4)
                            }
                            Mg.prototype.c.call(this, e)
                        }, t
                    }(),
                    Hg = function() {
                        return function(t) {
                            this.ondata = t, ag([Kf, ng, function() { return [og, Mg, Ug] }], this, 0, (function() {
                                var t = new Ug;
                                onmessage = og(t)
                            }), 11)
                        }
                    }();

                function kg(t, e, n) { if (n || (n = e, e = {}), "function" != typeof n) throw "no callback"; return sg(t, e, [Kf, ng, function() { return [Gg] }], (function(t) { return ig(Gg(t.data[0], rg(t.data[1]))) }), 5, n) }

                function Gg(t, e) { return Pf((vg(t), t.subarray(2, -4)), e) }
                var Vg = function() {
                        function t(t) { this.G = Pg, this.I = Mg, this.Z = Ug, this.ondata = t }
                        return t.prototype.push = function(t, e) {
                            if (!this.ondata) throw "no stream handler";
                            if (this.s) this.s.push(t, e);
                            else {
                                if (this.p && this.p.length) {
                                    var n = new nf(this.p.length + t.length);
                                    n.set(this.p), n.set(t, this.p.length)
                                } else this.p = t;
                                if (this.p.length > 2) {
                                    var i = this,
                                        r = function() { i.ondata.apply(i, arguments) };
                                    this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(r) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(r) : new this.Z(r), this.s.push(this.p, e), this.p = null
                                }
                            }
                        }, t
                    }(),
                    Wg = function() {
                        function t(t) { this.G = Ig, this.I = Sg, this.Z = Hg, this.ondata = t }
                        return t.prototype.push = function(t, e) { Vg.prototype.push.call(this, t, e) }, t
                    }();

                function jg(t, e, n) { if (n || (n = e, e = {}), "function" != typeof n) throw "no callback"; return 31 == t[0] && 139 == t[1] && 8 == t[2] ? Dg(t, e, n) : 8 != (15 & t[0]) || t[0] >> 4 > 7 || (t[0] << 8 | t[1]) % 31 ? Tg(t, e, n) : kg(t, e, n) }

                function qg(t, e) { return 31 == t[0] && 139 == t[1] && 8 == t[2] ? Ng(t, e) : 8 != (15 & t[0]) || t[0] >> 4 > 7 || (t[0] << 8 | t[1]) % 31 ? Eg(t, e) : Gg(t, e) }
                var Xg = function(t, e, n, i) {
                        for (var r in t) {
                            var s = t[r],
                                o = e + r;
                            s instanceof nf ? n[o] = [s, i] : Array.isArray(s) ? n[o] = [s[0], Xf(i, s[1])] : Xg(s, o + "/", n, i)
                        }
                    },
                    Yg = "undefined" != typeof TextEncoder && new TextEncoder,
                    Zg = "undefined" != typeof TextDecoder && new TextDecoder,
                    Jg = 0;
                try { Zg.decode(kf, { stream: !0 }), Jg = 1 } catch (t) {}
                var Kg = function(t) {
                        for (var e = "", n = 0;;) {
                            var i = t[n++],
                                r = (i > 127) + (i > 223) + (i > 239);
                            if (n + r > t.length) return [e, Cf(t, n - 1)];
                            r ? 3 == r ? (i = ((15 & i) << 18 | (63 & t[n++]) << 12 | (63 & t[n++]) << 6 | 63 & t[n++]) - 65536, e += String.fromCharCode(55296 | i >> 10, 56320 | 1023 & i)) : e += 1 & r ? String.fromCharCode((31 & i) << 6 | 63 & t[n++]) : String.fromCharCode((15 & i) << 12 | (63 & t[n++]) << 6 | 63 & t[n++]) : e += String.fromCharCode(i)
                        }
                    },
                    Qg = function() {
                        function t(t) { this.ondata = t, Jg ? this.t = new TextDecoder : this.p = kf }
                        return t.prototype.push = function(t, e) {
                            if (!this.ondata) throw "no callback";
                            if (e = !!e, this.t) {
                                if (this.ondata(this.t.decode(t, { stream: !0 }), e), e) {
                                    if (this.t.decode().length) throw "invalid utf-8 data";
                                    this.t = null
                                }
                            } else {
                                if (!this.p) throw "stream finished";
                                var n = new nf(this.p.length + t.length);
                                n.set(this.p), n.set(t, this.p.length);
                                var i = Kg(n),
                                    r = i[0],
                                    s = i[1];
                                if (e) {
                                    if (s.length) throw "invalid utf-8 data";
                                    this.p = null
                                } else this.p = s;
                                this.ondata(r, e)
                            }
                        }, t
                    }(),
                    $g = function() {
                        function t(t) { this.ondata = t }
                        return t.prototype.push = function(t, e) {
                            if (!this.ondata) throw "no callback";
                            if (this.d) throw "stream finished";
                            this.ondata(tv(t), this.d = e || !1)
                        }, t
                    }();

                function tv(t, e) {
                    if (e) { for (var n = new nf(t.length), i = 0; i < t.length; ++i) n[i] = t.charCodeAt(i); return n }
                    if (Yg) return Yg.encode(t);
                    var r = t.length,
                        s = new nf(t.length + (t.length >> 1)),
                        o = 0,
                        a = function(t) { s[o++] = t };
                    for (i = 0; i < r; ++i) {
                        if (o + 5 > s.length) {
                            var l = new nf(o + 8 + (r - i << 1));
                            l.set(s), s = l
                        }
                        var c = t.charCodeAt(i);
                        c < 128 || e ? a(c) : c < 2048 ? (a(192 | c >> 6), a(128 | 63 & c)) : c > 55295 && c < 57344 ? (a(240 | (c = 65536 + (1047552 & c) | 1023 & t.charCodeAt(++i)) >> 18), a(128 | c >> 12 & 63), a(128 | c >> 6 & 63), a(128 | 63 & c)) : (a(224 | c >> 12), a(128 | c >> 6 & 63), a(128 | 63 & c))
                    }
                    return Cf(s, 0, o)
                }

                function ev(t, e) {
                    if (e) { for (var n = "", i = 0; i < t.length; i += 16384) n += String.fromCharCode.apply(null, t.subarray(i, i + 16384)); return n }
                    if (Zg) return Zg.decode(t);
                    var r = Kg(t),
                        s = r[0];
                    if (r[1].length) throw "invalid utf-8 data";
                    return s
                }
                var nv = function(t) { return 1 == t ? 3 : t < 6 ? 2 : 9 == t ? 1 : 0 },
                    iv = function(t, e) { return e + 30 + lg(t, e + 26) + lg(t, e + 28) },
                    rv = function(t, e, n) {
                        var i = lg(t, e + 28),
                            r = ev(t.subarray(e + 46, e + 46 + i), !(2048 & lg(t, e + 8))),
                            s = e + 46 + i,
                            o = cg(t, e + 20),
                            a = n && 4294967295 == o ? sv(t, s) : [o, cg(t, e + 24), cg(t, e + 42)],
                            l = a[0],
                            c = a[1],
                            h = a[2];
                        return [lg(t, e + 10), l, c, r, s + lg(t, e + 30) + lg(t, e + 32), h]
                    },
                    sv = function(t, e) { for (; 1 != lg(t, e); e += 4 + lg(t, e + 2)); return [hg(t, e + 12), hg(t, e + 4), hg(t, e + 20)] },
                    ov = function(t) {
                        var e = 0;
                        if (t)
                            for (var n in t) {
                                var i = t[n].length;
                                if (i > 65535) throw "extra field too long";
                                e += i + 4
                            }
                        return e
                    },
                    av = function(t, e, n, i, r, s, o, a) {
                        var l = i.length,
                            c = n.extra,
                            h = a && a.length,
                            u = ov(c);
                        ug(t, e, null != o ? 33639248 : 67324752), e += 4, null != o && (t[e++] = 20, t[e++] = n.os), t[e] = 20, e += 2, t[e++] = n.flag << 1 | (null == s && 8), t[e++] = r && 8, t[e++] = 255 & n.compression, t[e++] = n.compression >> 8;
                        var d = new Date(null == n.mtime ? Date.now() : n.mtime),
                            p = d.getFullYear() - 1980;
                        if (p < 0 || p > 119) throw "date not in range 1980-2099";
                        if (ug(t, e, p << 25 | d.getMonth() + 1 << 21 | d.getDate() << 16 | d.getHours() << 11 | d.getMinutes() << 5 | d.getSeconds() >>> 1), e += 4, null != s && (ug(t, e, n.crc), ug(t, e + 4, s), ug(t, e + 8, n.size)), ug(t, e + 12, l), ug(t, e + 14, u), e += 16, null != o && (ug(t, e, h), ug(t, e + 6, n.attrs), ug(t, e + 10, o), e += 14), t.set(i, e), e += l, u)
                            for (var m in c) {
                                var f = c[m],
                                    g = f.length;
                                ug(t, e, +m), ug(t, e + 2, g), t.set(f, e + 4), e += 4 + g
                            }
                        return h && (t.set(a, e), e += h), e
                    },
                    lv = function(t, e, n, i, r) { ug(t, e, 101010256), ug(t, e + 8, n), ug(t, e + 10, n), ug(t, e + 12, i), ug(t, e + 16, r) },
                    cv = function() {
                        function t(t) { this.filename = t, this.c = Wf(), this.size = 0, this.compression = 0 }
                        return t.prototype.process = function(t, e) { this.ondata(null, t, e) }, t.prototype.push = function(t, e) {
                            if (!this.ondata) throw "no callback - add to ZIP archive before pushing";
                            this.c.p(t), this.size += t.length, e && (this.crc = this.c.d()), this.process(t, e || !1)
                        }, t
                    }(),
                    hv = function() {
                        function t(t, e) {
                            var n = this;
                            e || (e = {}), cv.call(this, t), this.d = new xg(e, (function(t, e) { n.ondata(null, t, e) })), this.compression = 8, this.flag = nv(e.level)
                        }
                        return t.prototype.process = function(t, e) { try { this.d.push(t, e) } catch (t) { this.ondata(t, null, e) } }, t.prototype.push = function(t, e) { cv.prototype.push.call(this, t, e) }, t
                    }(),
                    uv = function() {
                        function t(t, e) {
                            var n = this;
                            e || (e = {}), cv.call(this, t), this.d = new _g(e, (function(t, e, i) { n.ondata(t, e, i) })), this.compression = 8, this.flag = nv(e.level), this.terminate = this.d.terminate
                        }
                        return t.prototype.process = function(t, e) { this.d.push(t, e) }, t.prototype.push = function(t, e) { cv.prototype.push.call(this, t, e) }, t
                    }(),
                    dv = function() {
                        function t(t) { this.ondata = t, this.u = [], this.d = 1 }
                        return t.prototype.add = function(t) {
                            var e = this;
                            if (2 & this.d) throw "stream finished";
                            var n = tv(t.filename),
                                i = n.length,
                                r = t.comment,
                                s = r && tv(r),
                                o = i != t.filename.length || s && r.length != s.length,
                                a = i + ov(t.extra) + 30;
                            if (i > 65535) throw "filename too long";
                            var l = new nf(a);
                            av(l, 0, t, n, o);
                            var c = [l],
                                h = function() {
                                    for (var t = 0, n = c; t < n.length; t++) {
                                        var i = n[t];
                                        e.ondata(null, i, !1)
                                    }
                                    c = []
                                },
                                u = this.d;
                            this.d = 0;
                            var d = this.u.length,
                                p = Xf(t, {
                                    f: n,
                                    u: o,
                                    o: s,
                                    t: function() { t.terminate && t.terminate() },
                                    r: function() {
                                        if (h(), u) {
                                            var t = e.u[d + 1];
                                            t ? t.r() : e.d = 1
                                        }
                                        u = 1
                                    }
                                }),
                                m = 0;
                            t.ondata = function(n, i, r) {
                                if (n) e.ondata(n, i, r), e.terminate();
                                else if (m += i.length, c.push(i), r) {
                                    var s = new nf(16);
                                    ug(s, 0, 134695760), ug(s, 4, t.crc), ug(s, 8, m), ug(s, 12, t.size), c.push(s), p.c = m, p.b = a + m + 16, p.crc = t.crc, p.size = t.size, u && p.r(), u = 1
                                } else u && h()
                            }, this.u.push(p)
                        }, t.prototype.end = function() {
                            var t = this;
                            if (2 & this.d) { if (1 & this.d) throw "stream finishing"; throw "stream finished" }
                            this.d ? this.e() : this.u.push({ r: function() { 1 & t.d && (t.u.splice(-1, 1), t.e()) }, t: function() {} }), this.d = 3
                        }, t.prototype.e = function() {
                            for (var t = 0, e = 0, n = 0, i = 0, r = this.u; i < r.length; i++) n += 46 + (l = r[i]).f.length + ov(l.extra) + (l.o ? l.o.length : 0);
                            for (var s = new nf(n + 22), o = 0, a = this.u; o < a.length; o++) {
                                var l = a[o];
                                av(s, t, l, l.f, l.u, l.c, e, l.o), t += 46 + l.f.length + ov(l.extra) + (l.o ? l.o.length : 0), e += l.b
                            }
                            lv(s, t, this.u.length, n, e), this.ondata(null, s, !0), this.d = 2
                        }, t.prototype.terminate = function() {
                            for (var t = 0, e = this.u; t < e.length; t++) e[t].t();
                            this.d = 2
                        }, t
                    }();

                function pv(t, e, n) {
                    if (n || (n = e, e = {}), "function" != typeof n) throw "no callback";
                    var i = {};
                    Xg(t, "", i, e);
                    var r = Object.keys(i),
                        s = r.length,
                        o = 0,
                        a = 0,
                        l = s,
                        c = new Array(s),
                        h = [],
                        u = function() { for (var t = 0; t < h.length; ++t) h[t]() },
                        d = function() {
                            var t = new nf(a + 22),
                                e = o,
                                i = a - o;
                            a = 0;
                            for (var r = 0; r < l; ++r) {
                                var s = c[r];
                                try {
                                    var h = s.c.length;
                                    av(t, a, s, s.f, s.u, h);
                                    var u = 30 + s.f.length + ov(s.extra),
                                        d = a + u;
                                    t.set(s.c, d), av(t, o, s, s.f, s.u, h, a, s.m), o += 16 + u + (s.m ? s.m.length : 0), a = d + h
                                } catch (t) { return n(t, null) }
                            }
                            lv(t, o, c.length, i, e), n(null, t)
                        };
                    s || d();
                    for (var p = function(t) {
                            var e = r[t],
                                l = i[e],
                                p = l[0],
                                m = l[1],
                                f = Wf(),
                                g = p.length;
                            f.p(p);
                            var v = tv(e),
                                y = v.length,
                                x = m.comment,
                                _ = x && tv(x),
                                b = _ && _.length,
                                w = ov(m.extra),
                                M = 0 == m.level ? 0 : 8,
                                S = function(i, r) {
                                    if (i) u(), n(i, null);
                                    else {
                                        var l = r.length;
                                        c[t] = Xf(m, { size: g, crc: f.d(), c: r, f: v, m: _, u: y != e.length || _ && x.length != b, compression: M }), o += 30 + y + w + l, a += 76 + 2 * (y + w) + (b || 0) + l, --s || d()
                                    }
                                };
                            if (y > 65535 && S("filename too long", null), M)
                                if (g < 16e4) try { S(null, wg(p, m)) } catch (t) { S(t, null) } else h.push(bg(p, m, S));
                                else S(null, p)
                        }, m = 0; m < l; ++m) p(m);
                    return u
                }

                function mv(t, e) {
                    e || (e = {});
                    var n = {},
                        i = [];
                    Xg(t, "", n, e);
                    var r = 0,
                        s = 0;
                    for (var o in n) {
                        var a = n[o],
                            l = a[0],
                            c = a[1],
                            h = 0 == c.level ? 0 : 8,
                            u = (M = tv(o)).length,
                            d = c.comment,
                            p = d && tv(d),
                            m = p && p.length,
                            f = ov(c.extra);
                        if (u > 65535) throw "filename too long";
                        var g = h ? wg(l, c) : l,
                            v = g.length,
                            y = Wf();
                        y.p(l), i.push(Xf(c, { size: l.length, crc: y.d(), c: g, f: M, m: p, u: u != o.length || p && d.length != m, o: r, compression: h })), r += 30 + u + f + v, s += 76 + 2 * (u + f) + (m || 0) + v
                    }
                    for (var x = new nf(s + 22), _ = r, b = s - r, w = 0; w < i.length; ++w) {
                        var M = i[w];
                        av(x, M.o, M, M.f, M.u, M.c.length);
                        var S = 30 + M.f.length + ov(M.extra);
                        x.set(M.c, M.o + S), av(x, r, M, M.f, M.u, M.c.length, M.o, M.m), r += 16 + S + (M.m ? M.m.length : 0)
                    }
                    return lv(x, r, i.length, b, _), x
                }
                var fv = function() {
                        function t() {}
                        return t.prototype.push = function(t, e) { this.ondata(null, t, e) }, t.compression = 0, t
                    }(),
                    gv = function() {
                        function t() {
                            var t = this;
                            this.i = new Mg((function(e, n) { t.ondata(null, e, n) }))
                        }
                        return t.prototype.push = function(t, e) { try { this.i.push(t, e) } catch (n) { this.ondata(n, t, e) } }, t.compression = 8, t
                    }(),
                    vv = function() {
                        function t(t, e) {
                            var n = this;
                            e < 32e4 ? this.i = new Mg((function(t, e) { n.ondata(null, t, e) })) : (this.i = new Sg((function(t, e, i) { n.ondata(t, e, i) })), this.terminate = this.i.terminate)
                        }
                        return t.prototype.push = function(t, e) { this.i.terminate && (t = Cf(t, 0)), this.i.push(t, e) }, t.compression = 8, t
                    }(),
                    yv = function() {
                        function t(t) { this.onfile = t, this.k = [], this.o = { 0: fv }, this.p = kf }
                        return t.prototype.push = function(t, e) {
                            var n = this;
                            if (!this.onfile) throw "no callback";
                            if (!this.p) throw "stream finished";
                            if (this.c > 0) {
                                var i = Math.min(this.c, t.length),
                                    r = t.subarray(0, i);
                                if (this.c -= i, this.d ? this.d.push(r, !this.c) : this.k[0].push(r), (t = t.subarray(i)).length) return this.push(t, e)
                            } else {
                                var s = 0,
                                    o = 0,
                                    a = void 0,
                                    l = void 0;
                                this.p.length ? t.length ? ((l = new nf(this.p.length + t.length)).set(this.p), l.set(t, this.p.length)) : l = this.p : l = t;
                                for (var c = l.length, h = this.c, u = h && this.d, d = function() {
                                        var t, e = cg(l, o);
                                        if (67324752 == e) {
                                            s = 1, a = o, p.d = null, p.c = 0;
                                            var i = lg(l, o + 6),
                                                r = lg(l, o + 8),
                                                u = 2048 & i,
                                                d = 8 & i,
                                                m = lg(l, o + 26),
                                                f = lg(l, o + 28);
                                            if (c > o + 30 + m + f) {
                                                var g = [];
                                                p.k.unshift(g), s = 2;
                                                var v, y = cg(l, o + 18),
                                                    x = cg(l, o + 22),
                                                    _ = ev(l.subarray(o + 30, o += 30 + m), !u);
                                                4294967295 == y ? (t = d ? [-2] : sv(l, o), y = t[0], x = t[1]) : d && (y = -1), o += f, p.c = y;
                                                var b = {
                                                    name: _,
                                                    compression: r,
                                                    start: function() {
                                                        if (!b.ondata) throw "no callback";
                                                        if (y) {
                                                            var t = n.o[r];
                                                            if (!t) throw "unknown compression type " + r;
                                                            (v = y < 0 ? new t(_) : new t(_, y, x)).ondata = function(t, e, n) { b.ondata(t, e, n) };
                                                            for (var e = 0, i = g; e < i.length; e++) {
                                                                var s = i[e];
                                                                v.push(s, !1)
                                                            }
                                                            n.k[0] == g && n.c ? n.d = v : v.push(kf, !0)
                                                        } else b.ondata(null, kf, !0)
                                                    },
                                                    terminate: function() { v && v.terminate && v.terminate() }
                                                };
                                                y >= 0 && (b.size = y, b.originalSize = x), p.onfile(b)
                                            }
                                            return "break"
                                        }
                                        if (h) { if (134695760 == e) return a = o += 12 + (-2 == h && 8), s = 3, p.c = 0, "break"; if (33639248 == e) return a = o -= 4, s = 3, p.c = 0, "break" }
                                    }, p = this; o < c - 4 && "break" !== d(); ++o);
                                if (this.p = kf, h < 0) {
                                    var m = s ? l.subarray(0, a - 12 - (-2 == h && 8) - (134695760 == cg(l, a - 16) && 4)) : l.subarray(0, o);
                                    u ? u.push(m, !!s) : this.k[+(2 == s)].push(m)
                                }
                                if (2 & s) return this.push(l.subarray(o), e);
                                this.p = l.subarray(o)
                            }
                            if (e) {
                                if (this.c) throw "invalid zip file";
                                this.p = null
                            }
                        }, t.prototype.register = function(t) { this.o[t.compression] = t }, t
                    }();

                function xv(t, e) {
                    if ("function" != typeof e) throw "no callback";
                    for (var n = [], i = function() { for (var t = 0; t < n.length; ++t) n[t]() }, r = {}, s = t.length - 22; 101010256 != cg(t, s); --s)
                        if (!s || t.length - s > 65558) return void e("invalid zip file", null);
                    var o = lg(t, s + 8);
                    o || e(null, {});
                    var a = o,
                        l = cg(t, s + 16),
                        c = 4294967295 == l;
                    if (c) {
                        if (s = cg(t, s - 12), 101075792 != cg(t, s)) return void e("invalid zip file", null);
                        a = o = cg(t, s + 32), l = cg(t, s + 48)
                    }
                    for (var h = function(s) {
                            var a = rv(t, l, c),
                                h = a[0],
                                u = a[1],
                                d = a[2],
                                p = a[3],
                                m = a[4],
                                f = a[5],
                                g = iv(t, f);
                            l = m;
                            var v = function(t, n) { t ? (i(), e(t, null)) : (r[p] = n, --o || e(null, r)) };
                            if (h)
                                if (8 == h) { var y = t.subarray(g, g + u); if (u < 32e4) try { v(null, Eg(y, new nf(d))) } catch (t) { v(t, null) } else n.push(Tg(y, { size: d }, v)) } else v("unknown compression type " + h, null);
                            else v(null, Cf(t, g, g + u))
                        }, u = 0; u < a; ++u) h();
                    return i
                }

                function _v(t) {
                    for (var e = {}, n = t.length - 22; 101010256 != cg(t, n); --n)
                        if (!n || t.length - n > 65558) throw "invalid zip file";
                    var i = lg(t, n + 8);
                    if (!i) return {};
                    var r = cg(t, n + 16),
                        s = 4294967295 == r;
                    if (s) {
                        if (n = cg(t, n - 12), 101075792 != cg(t, n)) throw "invalid zip file";
                        i = cg(t, n + 32), r = cg(t, n + 48)
                    }
                    for (var o = 0; o < i; ++o) {
                        var a = rv(t, r, s),
                            l = a[0],
                            c = a[1],
                            h = a[2],
                            u = a[3],
                            d = a[4],
                            p = a[5],
                            m = iv(t, p);
                        if (r = d, l) {
                            if (8 != l) throw "unknown compression type " + l;
                            e[u] = Eg(t.subarray(m, m + c), new nf(h))
                        } else e[u] = Cf(t, m, m + c)
                    }
                    return e
                }
                class bv {
                    static findSpan(t, e, n) {
                        const i = n.length - t - 1;
                        if (e >= n[i]) return i - 1;
                        if (e <= n[t]) return t;
                        let r = t,
                            s = i,
                            o = Math.floor((r + s) / 2);
                        for (; e < n[o] || e >= n[o + 1];) e < n[o] ? s = o : r = o, o = Math.floor((r + s) / 2);
                        return o
                    }
                    static calcBasisFunctions(t, e, n, i) {
                        const r = [],
                            s = [],
                            o = [];
                        r[0] = 1;
                        for (let a = 1; a <= n; ++a) {
                            s[a] = e - i[t + 1 - a], o[a] = i[t + a] - e;
                            let n = 0;
                            for (let t = 0; t < a; ++t) {
                                const e = o[t + 1],
                                    i = s[a - t],
                                    l = r[t] / (e + i);
                                r[t] = n + e * l, n = i * l
                            }
                            r[a] = n
                        }
                        return r
                    }
                    static calcBSplinePoint(t, e, n, i) {
                        const r = this.findSpan(t, i, e),
                            s = this.calcBasisFunctions(r, i, t, e),
                            o = new oi(0, 0, 0, 0);
                        for (let e = 0; e <= t; ++e) {
                            const i = n[r - t + e],
                                a = s[e],
                                l = i.w * a;
                            o.x += i.x * l, o.y += i.y * l, o.z += i.z * l, o.w += i.w * a
                        }
                        return o
                    }
                    static calcBasisFunctionDerivatives(t, e, n, i, r) {
                        const s = [];
                        for (let t = 0; t <= n; ++t) s[t] = 0;
                        const o = [];
                        for (let t = 0; t <= i; ++t) o[t] = s.slice(0);
                        const a = [];
                        for (let t = 0; t <= n; ++t) a[t] = s.slice(0);
                        a[0][0] = 1;
                        const l = s.slice(0),
                            c = s.slice(0);
                        for (let i = 1; i <= n; ++i) {
                            l[i] = e - r[t + 1 - i], c[i] = r[t + i] - e;
                            let n = 0;
                            for (let t = 0; t < i; ++t) {
                                const e = c[t + 1],
                                    r = l[i - t];
                                a[i][t] = e + r;
                                const s = a[t][i - 1] / a[i][t];
                                a[t][i] = n + e * s, n = r * s
                            }
                            a[i][i] = n
                        }
                        for (let t = 0; t <= n; ++t) o[0][t] = a[t][n];
                        for (let t = 0; t <= n; ++t) {
                            let e = 0,
                                r = 1;
                            const l = [];
                            for (let t = 0; t <= n; ++t) l[t] = s.slice(0);
                            l[0][0] = 1;
                            for (let s = 1; s <= i; ++s) {
                                let i = 0;
                                const c = t - s,
                                    h = n - s;
                                t >= s && (l[r][0] = l[e][0] / a[h + 1][c], i = l[r][0] * a[c][h]);
                                const u = t - 1 <= h ? s - 1 : n - t;
                                for (let t = c >= -1 ? 1 : -c; t <= u; ++t) l[r][t] = (l[e][t] - l[e][t - 1]) / a[h + 1][c + t], i += l[r][t] * a[c + t][h];
                                t <= h && (l[r][s] = -l[e][s - 1] / a[h + 1][t], i += l[r][s] * a[t][h]), o[s][t] = i;
                                const d = e;
                                e = r, r = d
                            }
                        }
                        let h = n;
                        for (let t = 1; t <= i; ++t) {
                            for (let e = 0; e <= n; ++e) o[t][e] *= h;
                            h *= n - t
                        }
                        return o
                    }
                    static calcBSplineDerivatives(t, e, n, i, r) {
                        const s = r < t ? r : t,
                            o = [],
                            a = this.findSpan(t, i, e),
                            l = this.calcBasisFunctionDerivatives(a, i, t, s, e),
                            c = [];
                        for (let t = 0; t < n.length; ++t) {
                            const e = n[t].clone(),
                                i = e.w;
                            e.x *= i, e.y *= i, e.z *= i, c[t] = e
                        }
                        for (let e = 0; e <= s; ++e) {
                            const n = c[a - t].clone().multiplyScalar(l[e][0]);
                            for (let i = 1; i <= t; ++i) n.add(c[a - t + i].clone().multiplyScalar(l[e][i]));
                            o[e] = n
                        }
                        for (let t = s + 1; t <= r + 1; ++t) o[t] = new oi(0, 0, 0);
                        return o
                    }
                    static calcKoverI(t, e) { let n = 1; for (let e = 2; e <= t; ++e) n *= e; let i = 1; for (let t = 2; t <= e; ++t) i *= t; for (let n = 2; n <= t - e; ++n) i *= n; return n / i }
                    static calcRationalCurveDerivatives(t) {
                        const e = t.length,
                            n = [],
                            i = [];
                        for (let r = 0; r < e; ++r) {
                            const e = t[r];
                            n[r] = new ui(e.x, e.y, e.z), i[r] = e.w
                        }
                        const r = [];
                        for (let t = 0; t < e; ++t) {
                            const e = n[t].clone();
                            for (let n = 1; n <= t; ++n) e.sub(r[t - n].clone().multiplyScalar(this.calcKoverI(t, n) * i[n]));
                            r[t] = e.divideScalar(i[0])
                        }
                        return r
                    }
                    static calcNURBSDerivatives(t, e, n, i, r) { const s = this.calcBSplineDerivatives(t, e, n, i, r); return this.calcRationalCurveDerivatives(s) }
                    static calcSurfacePoint(t, e, n, i, r, s, o, a) {
                        const l = this.findSpan(t, s, n),
                            c = this.findSpan(e, o, i),
                            h = this.calcBasisFunctions(l, s, t, n),
                            u = this.calcBasisFunctions(c, o, e, i),
                            d = [];
                        for (let n = 0; n <= e; ++n) {
                            d[n] = new oi(0, 0, 0, 0);
                            for (let i = 0; i <= t; ++i) {
                                const s = r[l - t + i][c - e + n].clone(),
                                    o = s.w;
                                s.x *= o, s.y *= o, s.z *= o, d[n].add(s.multiplyScalar(h[i]))
                            }
                        }
                        const p = new oi(0, 0, 0, 0);
                        for (let t = 0; t <= e; ++t) p.add(d[t].multiplyScalar(u[t]));
                        p.divideScalar(p.w), a.set(p.x, p.y, p.z)
                    }
                }
                class wv extends Sc {
                    constructor(t, e, n, i, r) {
                        super(), this.degree = t, this.knots = e, this.controlPoints = [], this.startKnot = i || 0, this.endKnot = r || this.knots.length - 1;
                        for (let t = 0; t < n.length; ++t) {
                            const e = n[t];
                            this.controlPoints[t] = new oi(e.x, e.y, e.z, e.w)
                        }
                    }
                    getPoint(t, e = new ui) {
                        const n = e,
                            i = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]),
                            r = bv.calcBSplinePoint(this.degree, this.knots, this.controlPoints, i);
                        return 1 !== r.w && r.divideScalar(r.w), n.set(r.x, r.y, r.z)
                    }
                    getTangent(t, e = new ui) {
                        const n = e,
                            i = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]),
                            r = bv.calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, i, 1);
                        return n.copy(r[1]).normalize(), n
                    }
                }
                let Mv, Sv, Tv;
                class Ev extends lu {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = this,
                            s = "" === r.path ? ku.extractUrlBase(t) : r.path,
                            o = new hu(this.manager);
                        o.setPath(r.path), o.setResponseType("arraybuffer"), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(t, (function(n) { try { e(r.parse(n, s)) } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) } }), n, i)
                    }
                    parse(t, e) {
                        if (function(t) { const e = "Kaydara FBX Binary  \0"; return t.byteLength >= e.length && e === Vv(t, 0, e.length) }(t)) Mv = (new Pv).parse(t);
                        else {
                            const e = Vv(t);
                            if (! function(t) {
                                    const e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
                                    let n = 0;

                                    function i(e) { const i = t[e - 1]; return t = t.slice(n + e), n++, i }
                                    for (let t = 0; t < e.length; ++t)
                                        if (i(1) === e[t]) return !1;
                                    return !0
                                }(e)) throw new Error("THREE.FBXLoader: Unknown format.");
                            if (Nv(e) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + Nv(e));
                            Mv = (new Cv).parse(e)
                        }
                        const n = new gu(this.manager).setPath(this.resourcePath || e).setCrossOrigin(this.crossOrigin);
                        return new Av(n, this.manager).parse(Mv)
                    }
                }
                class Av {
                    constructor(t, e) { this.textureLoader = t, this.manager = e }
                    parse() {
                        Sv = this.parseConnections();
                        const t = this.parseImages(),
                            e = this.parseTextures(t),
                            n = this.parseMaterials(e),
                            i = this.parseDeformers(),
                            r = (new Lv).parse(i);
                        return this.parseScene(i, r, n), Tv
                    }
                    parseConnections() {
                        const t = new Map;
                        return "Connections" in Mv && Mv.Connections.connections.forEach((function(e) {
                            const n = e[0],
                                i = e[1],
                                r = e[2];
                            t.has(n) || t.set(n, { parents: [], children: [] });
                            const s = { ID: i, relationship: r };
                            t.get(n).parents.push(s), t.has(i) || t.set(i, { parents: [], children: [] });
                            const o = { ID: n, relationship: r };
                            t.get(i).children.push(o)
                        })), t
                    }
                    parseImages() {
                        const t = {},
                            e = {};
                        if ("Video" in Mv.Objects) {
                            const n = Mv.Objects.Video;
                            for (const i in n) {
                                const r = n[i];
                                if (t[parseInt(i)] = r.RelativeFilename || r.Filename, "Content" in r) {
                                    const t = r.Content instanceof ArrayBuffer && r.Content.byteLength > 0,
                                        s = "string" == typeof r.Content && "" !== r.Content;
                                    if (t || s) {
                                        const t = this.parseImage(n[i]);
                                        e[r.RelativeFilename || r.Filename] = t
                                    }
                                }
                            }
                        }
                        for (const n in t) {
                            const i = t[n];
                            void 0 !== e[i] ? t[n] = e[i] : t[n] = t[n].split("\\").pop()
                        }
                        return t
                    }
                    parseImage(t) {
                        const e = t.Content,
                            n = t.RelativeFilename || t.Filename,
                            i = n.slice(n.lastIndexOf(".") + 1).toLowerCase();
                        let r;
                        switch (i) {
                            case "bmp":
                                r = "image/bmp";
                                break;
                            case "jpg":
                            case "jpeg":
                                r = "image/jpeg";
                                break;
                            case "png":
                                r = "image/png";
                                break;
                            case "tif":
                                r = "image/tiff";
                                break;
                            case "tga":
                                null === this.manager.getHandler(".tga") && console.warn("FBXLoader: TGA loader not found, skipping ", n), r = "image/tga";
                                break;
                            default:
                                return void console.warn('FBXLoader: Image type "' + i + '" is not supported.')
                        }
                        if ("string" == typeof e) return "data:" + r + ";base64," + e; { const t = new Uint8Array(e); return window.URL.createObjectURL(new Blob([t], { type: r })) }
                    }
                    parseTextures(t) {
                        const e = new Map;
                        if ("Texture" in Mv.Objects) {
                            const n = Mv.Objects.Texture;
                            for (const i in n) {
                                const r = this.parseTexture(n[i], t);
                                e.set(parseInt(i), r)
                            }
                        }
                        return e
                    }
                    parseTexture(t, e) {
                        const n = this.loadTexture(t, e);
                        n.ID = t.id, n.name = t.attrName;
                        const i = t.WrapModeU,
                            r = t.WrapModeV,
                            s = void 0 !== i ? i.value : 0,
                            o = void 0 !== r ? r.value : 0;
                        if (n.wrapS = 0 === s ? ft : gt, n.wrapT = 0 === o ? ft : gt, "Scaling" in t) {
                            const e = t.Scaling.value;
                            n.repeat.x = e[0], n.repeat.y = e[1]
                        }
                        return n
                    }
                    loadTexture(t, e) {
                        let n;
                        const i = this.textureLoader.path,
                            r = Sv.get(t.id).children;
                        let s;
                        void 0 !== r && r.length > 0 && void 0 !== e[r[0].ID] && (n = e[r[0].ID], 0 !== n.indexOf("blob:") && 0 !== n.indexOf("data:") || this.textureLoader.setPath(void 0));
                        const o = t.FileName.slice(-3).toLowerCase();
                        if ("tga" === o) {
                            const e = this.manager.getHandler(".tga");
                            null === e ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", t.RelativeFilename), s = new ri) : (e.setPath(this.textureLoader.path), s = e.load(n))
                        } else "psd" === o ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", t.RelativeFilename), s = new ri) : s = this.textureLoader.load(n);
                        return this.textureLoader.setPath(i), s
                    }
                    parseMaterials(t) {
                        const e = new Map;
                        if ("Material" in Mv.Objects) {
                            const n = Mv.Objects.Material;
                            for (const i in n) {
                                const r = this.parseMaterial(n[i], t);
                                null !== r && e.set(parseInt(i), r)
                            }
                        }
                        return e
                    }
                    parseMaterial(t, e) {
                        const n = t.id,
                            i = t.attrName;
                        let r = t.ShadingModel;
                        if ("object" == typeof r && (r = r.value), !Sv.has(n)) return null;
                        const s = this.parseParameters(t, e, n);
                        let o;
                        switch (r.toLowerCase()) {
                            case "phong":
                                o = new Fh;
                                break;
                            case "lambert":
                                o = new Hh;
                                break;
                            default:
                                console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', r), o = new Fh
                        }
                        return o.setValues(s), o.name = i, o
                    }
                    parseParameters(t, e, n) {
                        const i = {};
                        t.BumpFactor && (i.bumpScale = t.BumpFactor.value), t.Diffuse ? i.color = (new Dr).fromArray(t.Diffuse.value) : !t.DiffuseColor || "Color" !== t.DiffuseColor.type && "ColorRGB" !== t.DiffuseColor.type || (i.color = (new Dr).fromArray(t.DiffuseColor.value)), t.DisplacementFactor && (i.displacementScale = t.DisplacementFactor.value), t.Emissive ? i.emissive = (new Dr).fromArray(t.Emissive.value) : !t.EmissiveColor || "Color" !== t.EmissiveColor.type && "ColorRGB" !== t.EmissiveColor.type || (i.emissive = (new Dr).fromArray(t.EmissiveColor.value)), t.EmissiveFactor && (i.emissiveIntensity = parseFloat(t.EmissiveFactor.value)), t.Opacity && (i.opacity = parseFloat(t.Opacity.value)), i.opacity < 1 && (i.transparent = !0), t.ReflectionFactor && (i.reflectivity = t.ReflectionFactor.value), t.Shininess && (i.shininess = t.Shininess.value), t.Specular ? i.specular = (new Dr).fromArray(t.Specular.value) : t.SpecularColor && "Color" === t.SpecularColor.type && (i.specular = (new Dr).fromArray(t.SpecularColor.value));
                        const r = this;
                        return Sv.get(n).children.forEach((function(t) {
                            const n = t.relationship;
                            switch (n) {
                                case "Bump":
                                    i.bumpMap = r.getTexture(e, t.ID);
                                    break;
                                case "Maya|TEX_ao_map":
                                    i.aoMap = r.getTexture(e, t.ID);
                                    break;
                                case "DiffuseColor":
                                case "Maya|TEX_color_map":
                                    i.map = r.getTexture(e, t.ID), i.map.encoding = en;
                                    break;
                                case "DisplacementColor":
                                    i.displacementMap = r.getTexture(e, t.ID);
                                    break;
                                case "EmissiveColor":
                                    i.emissiveMap = r.getTexture(e, t.ID), i.emissiveMap.encoding = en;
                                    break;
                                case "NormalMap":
                                case "Maya|TEX_normal_map":
                                    i.normalMap = r.getTexture(e, t.ID);
                                    break;
                                case "ReflectionColor":
                                    i.envMap = r.getTexture(e, t.ID), i.envMap.mapping = ut, i.envMap.encoding = en;
                                    break;
                                case "SpecularColor":
                                    i.specularMap = r.getTexture(e, t.ID), i.specularMap.encoding = en;
                                    break;
                                case "TransparentColor":
                                case "TransparencyFactor":
                                    i.alphaMap = r.getTexture(e, t.ID), i.transparent = !0;
                                    break;
                                default:
                                    console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", n)
                            }
                        })), i
                    }
                    getTexture(t, e) { return "LayeredTexture" in Mv.Objects && e in Mv.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), e = Sv.get(e).children[0].ID), t.get(e) }
                    parseDeformers() {
                        const t = {},
                            e = {};
                        if ("Deformer" in Mv.Objects) {
                            const n = Mv.Objects.Deformer;
                            for (const i in n) {
                                const r = n[i],
                                    s = Sv.get(parseInt(i));
                                if ("Skin" === r.attrType) {
                                    const e = this.parseSkeleton(s, n);
                                    e.ID = i, s.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), e.geometryID = s.parents[0].ID, t[i] = e
                                } else if ("BlendShape" === r.attrType) {
                                    const t = { id: i };
                                    t.rawTargets = this.parseMorphTargets(s, n), t.id = i, s.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), e[i] = t
                                }
                            }
                        }
                        return { skeletons: t, morphTargets: e }
                    }
                    parseSkeleton(t, e) { const n = []; return t.children.forEach((function(t) { const i = e[t.ID]; if ("Cluster" !== i.attrType) return; const r = { ID: t.ID, indices: [], weights: [], transformLink: (new Gi).fromArray(i.TransformLink.a) }; "Indexes" in i && (r.indices = i.Indexes.a, r.weights = i.Weights.a), n.push(r) })), { rawBones: n, bones: [] } }
                    parseMorphTargets(t, e) {
                        const n = [];
                        for (let i = 0; i < t.children.length; i++) {
                            const r = t.children[i],
                                s = e[r.ID],
                                o = { name: s.attrName, initialWeight: s.DeformPercent, id: s.id, fullWeights: s.FullWeights.a };
                            if ("BlendShapeChannel" !== s.attrType) return;
                            o.geoID = Sv.get(parseInt(r.ID)).children.filter((function(t) { return void 0 === t.relationship }))[0].ID, n.push(o)
                        }
                        return n
                    }
                    parseScene(t, e, n) {
                        Tv = new Qa;
                        const i = this.parseModels(t.skeletons, e, n),
                            r = Mv.Objects.Model,
                            s = this;
                        i.forEach((function(t) {
                            const e = r[t.ID];
                            s.setLookAtProperties(t, e), Sv.get(t.ID).parents.forEach((function(e) {
                                const n = i.get(e.ID);
                                void 0 !== n && n.add(t)
                            })), null === t.parent && Tv.add(t)
                        })), this.bindSkeleton(t.skeletons, e, i), this.createAmbientLight(), this.setupMorphMaterials(), Tv.traverse((function(t) {
                            if (t.userData.transformData) {
                                t.parent && (t.userData.transformData.parentMatrix = t.parent.matrix, t.userData.transformData.parentMatrixWorld = t.parent.matrixWorld);
                                const e = Hv(t.userData.transformData);
                                t.applyMatrix4(e), t.updateWorldMatrix()
                            }
                        }));
                        const o = (new Rv).parse();
                        1 === Tv.children.length && Tv.children[0].isGroup && (Tv.children[0].animations = o, Tv = Tv.children[0]), Tv.animations = o
                    }
                    parseModels(t, e, n) {
                        const i = new Map,
                            r = Mv.Objects.Model;
                        for (const s in r) {
                            const o = parseInt(s),
                                a = r[s],
                                l = Sv.get(o);
                            let c = this.buildSkeleton(l, t, o, a.attrName);
                            if (!c) {
                                switch (a.attrType) {
                                    case "Camera":
                                        c = this.createCamera(l);
                                        break;
                                    case "Light":
                                        c = this.createLight(l);
                                        break;
                                    case "Mesh":
                                        c = this.createMesh(l, e, n);
                                        break;
                                    case "NurbsCurve":
                                        c = this.createCurve(l, e);
                                        break;
                                    case "LimbNode":
                                    case "Root":
                                        c = new Ol;
                                        break;
                                    default:
                                        c = new Qa
                                }
                                c.name = a.attrName ? Id.sanitizeNodeName(a.attrName) : "", c.ID = o
                            }
                            this.getTransformData(c, a), i.set(o, c)
                        }
                        return i
                    }
                    buildSkeleton(t, e, n, i) {
                        let r = null;
                        return t.parents.forEach((function(t) {
                            for (const s in e) {
                                const o = e[s];
                                o.rawBones.forEach((function(e, s) {
                                    if (e.ID === t.ID) {
                                        const t = r;
                                        r = new Ol, r.matrixWorld.copy(e.transformLink), r.name = i ? Id.sanitizeNodeName(i) : "", r.ID = n, o.bones[s] = r, null !== t && r.add(t)
                                    }
                                }))
                            }
                        })), r
                    }
                    createCamera(t) {
                        let e, n;
                        if (t.children.forEach((function(t) {
                                const e = Mv.Objects.NodeAttribute[t.ID];
                                void 0 !== e && (n = e)
                            })), void 0 === n) e = new pr;
                        else {
                            let t = 0;
                            void 0 !== n.CameraProjectionType && 1 === n.CameraProjectionType.value && (t = 1);
                            let i = 1;
                            void 0 !== n.NearPlane && (i = n.NearPlane.value / 1e3);
                            let r = 1e3;
                            void 0 !== n.FarPlane && (r = n.FarPlane.value / 1e3);
                            let s = window.innerWidth,
                                o = window.innerHeight;
                            void 0 !== n.AspectWidth && void 0 !== n.AspectHeight && (s = n.AspectWidth.value, o = n.AspectHeight.value);
                            const a = s / o;
                            let l = 45;
                            void 0 !== n.FieldOfView && (l = n.FieldOfView.value);
                            const c = n.FocalLength ? n.FocalLength.value : null;
                            switch (t) {
                                case 0:
                                    e = new Cs(l, a, i, r), null !== c && e.setFocalLength(c);
                                    break;
                                case 1:
                                    e = new Du(-s / 2, s / 2, o / 2, -o / 2, i, r);
                                    break;
                                default:
                                    console.warn("THREE.FBXLoader: Unknown camera type " + t + "."), e = new pr
                            }
                        }
                        return e
                    }
                    createLight(t) {
                        let e, n;
                        if (t.children.forEach((function(t) {
                                const e = Mv.Objects.NodeAttribute[t.ID];
                                void 0 !== e && (n = e)
                            })), void 0 === n) e = new pr;
                        else {
                            let t;
                            t = void 0 === n.LightType ? 0 : n.LightType.value;
                            let i = 16777215;
                            void 0 !== n.Color && (i = (new Dr).fromArray(n.Color.value));
                            let r = void 0 === n.Intensity ? 1 : n.Intensity.value / 100;
                            void 0 !== n.CastLightOnObject && 0 === n.CastLightOnObject.value && (r = 0);
                            let s = 0;
                            void 0 !== n.FarAttenuationEnd && (s = void 0 !== n.EnableFarAttenuation && 0 === n.EnableFarAttenuation.value ? 0 : n.FarAttenuationEnd.value);
                            const o = 1;
                            switch (t) {
                                case 0:
                                    e = new Iu(i, r, s, o);
                                    break;
                                case 1:
                                    e = new Bu(i, r);
                                    break;
                                case 2:
                                    let t = Math.PI / 3;
                                    void 0 !== n.InnerAngle && (t = Qn.degToRad(n.InnerAngle.value));
                                    let a = 0;
                                    void 0 !== n.OuterAngle && (a = Qn.degToRad(n.OuterAngle.value), a = Math.max(a, 1)), e = new Au(i, r, s, t, a, o);
                                    break;
                                default:
                                    console.warn("THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."), e = new Iu(i, r)
                            }
                            void 0 !== n.CastShadows && 1 === n.CastShadows.value && (e.castShadow = !0)
                        }
                        return e
                    }
                    createMesh(t, e, n) {
                        let i, r = null,
                            s = null;
                        const o = [];
                        return t.children.forEach((function(t) { e.has(t.ID) && (r = e.get(t.ID)), n.has(t.ID) && o.push(n.get(t.ID)) })), o.length > 1 ? s = o : o.length > 0 ? s = o[0] : (s = new Fh({ color: 13421772 }), o.push(s)), "color" in r.attributes && o.forEach((function(t) { t.vertexColors = !0 })), r.FBX_Deformer ? (i = new Bl(r, s), i.normalizeSkinWeights()) : i = new ws(r, s), i
                    }
                    createCurve(t, e) {
                        const n = t.children.reduce((function(t, n) { return e.has(n.ID) && (t = e.get(n.ID)), t }), null),
                            i = new ql({ color: 3342591, linewidth: 1 });
                        return new Ql(n, i)
                    }
                    getTransformData(t, e) { const n = {}; "InheritType" in e && (n.inheritType = parseInt(e.InheritType.value)), n.eulerOrder = "RotationOrder" in e ? kv(e.RotationOrder.value) : "ZYX", "Lcl_Translation" in e && (n.translation = e.Lcl_Translation.value), "PreRotation" in e && (n.preRotation = e.PreRotation.value), "Lcl_Rotation" in e && (n.rotation = e.Lcl_Rotation.value), "PostRotation" in e && (n.postRotation = e.PostRotation.value), "Lcl_Scaling" in e && (n.scale = e.Lcl_Scaling.value), "ScalingOffset" in e && (n.scalingOffset = e.ScalingOffset.value), "ScalingPivot" in e && (n.scalingPivot = e.ScalingPivot.value), "RotationOffset" in e && (n.rotationOffset = e.RotationOffset.value), "RotationPivot" in e && (n.rotationPivot = e.RotationPivot.value), t.userData.transformData = n }
                    setLookAtProperties(t, e) {
                        "LookAtProperty" in e && Sv.get(t.ID).children.forEach((function(e) {
                            if ("LookAtProperty" === e.relationship) {
                                const n = Mv.Objects.Model[e.ID];
                                if ("Lcl_Translation" in n) {
                                    const e = n.Lcl_Translation.value;
                                    void 0 !== t.target ? (t.target.position.fromArray(e), Tv.add(t.target)) : t.lookAt((new ui).fromArray(e))
                                }
                            }
                        }))
                    }
                    bindSkeleton(t, e, n) {
                        const i = this.parsePoseNodes();
                        for (const r in t) {
                            const s = t[r];
                            Sv.get(parseInt(s.ID)).parents.forEach((function(t) {
                                if (e.has(t.ID)) {
                                    const e = t.ID;
                                    Sv.get(e).parents.forEach((function(t) { n.has(t.ID) && n.get(t.ID).bind(new Hl(s.bones), i[t.ID]) }))
                                }
                            }))
                        }
                    }
                    parsePoseNodes() {
                        const t = {};
                        if ("Pose" in Mv.Objects) {
                            const e = Mv.Objects.Pose;
                            for (const n in e)
                                if ("BindPose" === e[n].attrType) {
                                    const i = e[n].PoseNode;
                                    Array.isArray(i) ? i.forEach((function(e) { t[e.Node] = (new Gi).fromArray(e.Matrix.a) })) : t[i.Node] = (new Gi).fromArray(i.Matrix.a)
                                }
                        }
                        return t
                    }
                    createAmbientLight() {
                        if ("GlobalSettings" in Mv && "AmbientColor" in Mv.GlobalSettings) {
                            const t = Mv.GlobalSettings.AmbientColor.value,
                                e = t[0],
                                n = t[1],
                                i = t[2];
                            if (0 !== e || 0 !== n || 0 !== i) {
                                const t = new Dr(e, n, i);
                                Tv.add(new Ou(t, 1))
                            }
                        }
                    }
                    setupMorphMaterials() {
                        const t = this;
                        Tv.traverse((function(e) { e.isMesh && e.geometry.morphAttributes.position && e.geometry.morphAttributes.position.length && (Array.isArray(e.material) ? e.material.forEach((function(n, i) { t.setupMorphMaterial(e, n, i) })) : t.setupMorphMaterial(e, e.material)) }))
                    }
                    setupMorphMaterial(t, e, n) {
                        const i = t.uuid,
                            r = e.uuid;
                        let s = !1;
                        if (Tv.traverse((function(t) { t.isMesh && (Array.isArray(t.material) ? t.material.forEach((function(e) { e.uuid === r && t.uuid !== i && (s = !0) })) : t.material.uuid === r && t.uuid !== i && (s = !0)) })), !0 === s) {
                            const i = e.clone();
                            i.morphTargets = !0, void 0 === n ? t.material = i : t.material[n] = i
                        } else e.morphTargets = !0
                    }
                }
                class Lv {
                    parse(t) {
                        const e = new Map;
                        if ("Geometry" in Mv.Objects) {
                            const n = Mv.Objects.Geometry;
                            for (const i in n) {
                                const r = Sv.get(parseInt(i)),
                                    s = this.parseGeometry(r, n[i], t);
                                e.set(parseInt(i), s)
                            }
                        }
                        return e
                    }
                    parseGeometry(t, e, n) {
                        switch (e.attrType) {
                            case "Mesh":
                                return this.parseMeshGeometry(t, e, n);
                            case "NurbsCurve":
                                return this.parseNurbsGeometry(e)
                        }
                    }
                    parseMeshGeometry(t, e, n) {
                        const i = n.skeletons,
                            r = [],
                            s = t.parents.map((function(t) { return Mv.Objects.Model[t.ID] }));
                        if (0 === s.length) return;
                        const o = t.children.reduce((function(t, e) { return void 0 !== i[e.ID] && (t = i[e.ID]), t }), null);
                        t.children.forEach((function(t) { void 0 !== n.morphTargets[t.ID] && r.push(n.morphTargets[t.ID]) }));
                        const a = s[0],
                            l = {};
                        "RotationOrder" in a && (l.eulerOrder = kv(a.RotationOrder.value)), "InheritType" in a && (l.inheritType = parseInt(a.InheritType.value)), "GeometricTranslation" in a && (l.translation = a.GeometricTranslation.value), "GeometricRotation" in a && (l.rotation = a.GeometricRotation.value), "GeometricScaling" in a && (l.scale = a.GeometricScaling.value);
                        const c = Hv(l);
                        return this.genGeometry(e, o, r, c)
                    }
                    genGeometry(t, e, n, i) {
                        const r = new rs;
                        t.attrName && (r.name = t.attrName);
                        const s = this.parseGeoNode(t, e),
                            o = this.genBuffers(s),
                            a = new qr(o.vertex, 3);
                        if (a.applyMatrix4(i), r.setAttribute("position", a), o.colors.length > 0 && r.setAttribute("color", new qr(o.colors, 3)), e && (r.setAttribute("skinIndex", new Gr(o.weightsIndices, 4)), r.setAttribute("skinWeight", new qr(o.vertexWeights, 4)), r.FBX_Deformer = e), o.normal.length > 0) {
                            const t = (new ti).getNormalMatrix(i),
                                e = new qr(o.normal, 3);
                            e.applyNormalMatrix(t), r.setAttribute("normal", e)
                        }
                        if (o.uvs.forEach((function(t, e) {
                                let n = "uv" + (e + 1).toString();
                                0 === e && (n = "uv"), r.setAttribute(n, new qr(o.uvs[e], 2))
                            })), s.material && "AllSame" !== s.material.mappingType) {
                            let t = o.materialIndex[0],
                                e = 0;
                            if (o.materialIndex.forEach((function(n, i) { n !== t && (r.addGroup(e, i - e, t), t = n, e = i) })), r.groups.length > 0) {
                                const e = r.groups[r.groups.length - 1],
                                    n = e.start + e.count;
                                n !== o.materialIndex.length && r.addGroup(n, o.materialIndex.length - n, t)
                            }
                            0 === r.groups.length && r.addGroup(0, o.materialIndex.length, o.materialIndex[0])
                        }
                        return this.addMorphTargets(r, t, n, i), r
                    }
                    parseGeoNode(t, e) { const n = {}; if (n.vertexPositions = void 0 !== t.Vertices ? t.Vertices.a : [], n.vertexIndices = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [], t.LayerElementColor && (n.color = this.parseVertexColors(t.LayerElementColor[0])), t.LayerElementMaterial && (n.material = this.parseMaterialIndices(t.LayerElementMaterial[0])), t.LayerElementNormal && (n.normal = this.parseNormals(t.LayerElementNormal[0])), t.LayerElementUV) { n.uv = []; let e = 0; for (; t.LayerElementUV[e];) t.LayerElementUV[e].UV && n.uv.push(this.parseUVs(t.LayerElementUV[e])), e++ } return n.weightTable = {}, null !== e && (n.skeleton = e, e.rawBones.forEach((function(t, e) { t.indices.forEach((function(i, r) { void 0 === n.weightTable[i] && (n.weightTable[i] = []), n.weightTable[i].push({ id: e, weight: t.weights[r] }) })) }))), n }
                    genBuffers(t) {
                        const e = { vertex: [], normal: [], colors: [], uvs: [], materialIndex: [], vertexWeights: [], weightsIndices: [] };
                        let n = 0,
                            i = 0,
                            r = !1,
                            s = [],
                            o = [],
                            a = [],
                            l = [],
                            c = [],
                            h = [];
                        const u = this;
                        return t.vertexIndices.forEach((function(d, p) {
                            let m, f = !1;
                            d < 0 && (d ^= -1, f = !0);
                            let g = [],
                                v = [];
                            if (s.push(3 * d, 3 * d + 1, 3 * d + 2), t.color) {
                                const e = Fv(p, n, d, t.color);
                                a.push(e[0], e[1], e[2])
                            }
                            if (t.skeleton) {
                                if (void 0 !== t.weightTable[d] && t.weightTable[d].forEach((function(t) { v.push(t.weight), g.push(t.id) })), v.length > 4) {
                                    r || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), r = !0);
                                    const t = [0, 0, 0, 0],
                                        e = [0, 0, 0, 0];
                                    v.forEach((function(n, i) {
                                        let r = n,
                                            s = g[i];
                                        e.forEach((function(e, n, i) {
                                            if (r > e) {
                                                i[n] = r, r = e;
                                                const o = t[n];
                                                t[n] = s, s = o
                                            }
                                        }))
                                    })), g = t, v = e
                                }
                                for (; v.length < 4;) v.push(0), g.push(0);
                                for (let t = 0; t < 4; ++t) c.push(v[t]), h.push(g[t])
                            }
                            if (t.normal) {
                                const e = Fv(p, n, d, t.normal);
                                o.push(e[0], e[1], e[2])
                            }
                            t.material && "AllSame" !== t.material.mappingType && (m = Fv(p, n, d, t.material)[0]), t.uv && t.uv.forEach((function(t, e) {
                                const i = Fv(p, n, d, t);
                                void 0 === l[e] && (l[e] = []), l[e].push(i[0]), l[e].push(i[1])
                            })), i++, f && (u.genFace(e, t, s, m, o, a, l, c, h, i), n++, i = 0, s = [], o = [], a = [], l = [], c = [], h = [])
                        })), e
                    }
                    genFace(t, e, n, i, r, s, o, a, l, c) { for (let h = 2; h < c; h++) t.vertex.push(e.vertexPositions[n[0]]), t.vertex.push(e.vertexPositions[n[1]]), t.vertex.push(e.vertexPositions[n[2]]), t.vertex.push(e.vertexPositions[n[3 * (h - 1)]]), t.vertex.push(e.vertexPositions[n[3 * (h - 1) + 1]]), t.vertex.push(e.vertexPositions[n[3 * (h - 1) + 2]]), t.vertex.push(e.vertexPositions[n[3 * h]]), t.vertex.push(e.vertexPositions[n[3 * h + 1]]), t.vertex.push(e.vertexPositions[n[3 * h + 2]]), e.skeleton && (t.vertexWeights.push(a[0]), t.vertexWeights.push(a[1]), t.vertexWeights.push(a[2]), t.vertexWeights.push(a[3]), t.vertexWeights.push(a[4 * (h - 1)]), t.vertexWeights.push(a[4 * (h - 1) + 1]), t.vertexWeights.push(a[4 * (h - 1) + 2]), t.vertexWeights.push(a[4 * (h - 1) + 3]), t.vertexWeights.push(a[4 * h]), t.vertexWeights.push(a[4 * h + 1]), t.vertexWeights.push(a[4 * h + 2]), t.vertexWeights.push(a[4 * h + 3]), t.weightsIndices.push(l[0]), t.weightsIndices.push(l[1]), t.weightsIndices.push(l[2]), t.weightsIndices.push(l[3]), t.weightsIndices.push(l[4 * (h - 1)]), t.weightsIndices.push(l[4 * (h - 1) + 1]), t.weightsIndices.push(l[4 * (h - 1) + 2]), t.weightsIndices.push(l[4 * (h - 1) + 3]), t.weightsIndices.push(l[4 * h]), t.weightsIndices.push(l[4 * h + 1]), t.weightsIndices.push(l[4 * h + 2]), t.weightsIndices.push(l[4 * h + 3])), e.color && (t.colors.push(s[0]), t.colors.push(s[1]), t.colors.push(s[2]), t.colors.push(s[3 * (h - 1)]), t.colors.push(s[3 * (h - 1) + 1]), t.colors.push(s[3 * (h - 1) + 2]), t.colors.push(s[3 * h]), t.colors.push(s[3 * h + 1]), t.colors.push(s[3 * h + 2])), e.material && "AllSame" !== e.material.mappingType && (t.materialIndex.push(i), t.materialIndex.push(i), t.materialIndex.push(i)), e.normal && (t.normal.push(r[0]), t.normal.push(r[1]), t.normal.push(r[2]), t.normal.push(r[3 * (h - 1)]), t.normal.push(r[3 * (h - 1) + 1]), t.normal.push(r[3 * (h - 1) + 2]), t.normal.push(r[3 * h]), t.normal.push(r[3 * h + 1]), t.normal.push(r[3 * h + 2])), e.uv && e.uv.forEach((function(e, n) { void 0 === t.uvs[n] && (t.uvs[n] = []), t.uvs[n].push(o[n][0]), t.uvs[n].push(o[n][1]), t.uvs[n].push(o[n][2 * (h - 1)]), t.uvs[n].push(o[n][2 * (h - 1) + 1]), t.uvs[n].push(o[n][2 * h]), t.uvs[n].push(o[n][2 * h + 1]) })) }
                    addMorphTargets(t, e, n, i) {
                        if (0 === n.length) return;
                        t.morphTargetsRelative = !0, t.morphAttributes.position = [];
                        const r = this;
                        n.forEach((function(n) {
                            n.rawTargets.forEach((function(n) {
                                const s = Mv.Objects.Geometry[n.geoID];
                                void 0 !== s && r.genMorphGeometry(t, e, s, i, n.name)
                            }))
                        }))
                    }
                    genMorphGeometry(t, e, n, i, r) {
                        const s = void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : [],
                            o = void 0 !== n.Vertices ? n.Vertices.a : [],
                            a = void 0 !== n.Indexes ? n.Indexes.a : [],
                            l = 3 * t.attributes.position.count,
                            c = new Float32Array(l);
                        for (let t = 0; t < a.length; t++) {
                            const e = 3 * a[t];
                            c[e] = o[3 * t], c[e + 1] = o[3 * t + 1], c[e + 2] = o[3 * t + 2]
                        }
                        const h = { vertexIndices: s, vertexPositions: c },
                            u = this.genBuffers(h),
                            d = new qr(u.vertex, 3);
                        d.name = r || n.attrName, d.applyMatrix4(i), t.morphAttributes.position.push(d)
                    }
                    parseNormals(t) {
                        const e = t.MappingInformationType,
                            n = t.ReferenceInformationType,
                            i = t.Normals.a;
                        let r = [];
                        return "IndexToDirect" === n && ("NormalIndex" in t ? r = t.NormalIndex.a : "NormalsIndex" in t && (r = t.NormalsIndex.a)), { dataSize: 3, buffer: i, indices: r, mappingType: e, referenceType: n }
                    }
                    parseUVs(t) {
                        const e = t.MappingInformationType,
                            n = t.ReferenceInformationType,
                            i = t.UV.a;
                        let r = [];
                        return "IndexToDirect" === n && (r = t.UVIndex.a), { dataSize: 2, buffer: i, indices: r, mappingType: e, referenceType: n }
                    }
                    parseVertexColors(t) {
                        const e = t.MappingInformationType,
                            n = t.ReferenceInformationType,
                            i = t.Colors.a;
                        let r = [];
                        return "IndexToDirect" === n && (r = t.ColorIndex.a), { dataSize: 4, buffer: i, indices: r, mappingType: e, referenceType: n }
                    }
                    parseMaterialIndices(t) {
                        const e = t.MappingInformationType,
                            n = t.ReferenceInformationType;
                        if ("NoMappingInformation" === e) return { dataSize: 1, buffer: [0], indices: [0], mappingType: "AllSame", referenceType: n };
                        const i = t.Materials.a,
                            r = [];
                        for (let t = 0; t < i.length; ++t) r.push(t);
                        return { dataSize: 1, buffer: i, indices: r, mappingType: e, referenceType: n }
                    }
                    parseNurbsGeometry(t) {
                        if (void 0 === wv) return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new rs;
                        const e = parseInt(t.Order);
                        if (isNaN(e)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", t.Order, t.id), new rs;
                        const n = e - 1,
                            i = t.KnotVector.a,
                            r = [],
                            s = t.Points.a;
                        for (let t = 0, e = s.length; t < e; t += 4) r.push((new oi).fromArray(s, t));
                        let o, a;
                        if ("Closed" === t.Form) r.push(r[0]);
                        else if ("Periodic" === t.Form) { o = n, a = i.length - 1 - o; for (let t = 0; t < n; ++t) r.push(r[t]) }
                        const l = new wv(n, i, r, o, a).getPoints(7 * r.length),
                            c = new Float32Array(3 * l.length);
                        l.forEach((function(t, e) { t.toArray(c, 3 * e) }));
                        const h = new rs;
                        return h.setAttribute("position", new Fr(c, 3)), h
                    }
                }
                class Rv {
                    parse() {
                        const t = [],
                            e = this.parseClips();
                        if (void 0 !== e)
                            for (const n in e) {
                                const i = e[n],
                                    r = this.addClip(i);
                                t.push(r)
                            }
                        return t
                    }
                    parseClips() {
                        if (void 0 === Mv.Objects.AnimationCurve) return;
                        const t = this.parseAnimationCurveNodes();
                        this.parseAnimationCurves(t);
                        const e = this.parseAnimationLayers(t);
                        return this.parseAnimStacks(e)
                    }
                    parseAnimationCurveNodes() {
                        const t = Mv.Objects.AnimationCurveNode,
                            e = new Map;
                        for (const n in t) {
                            const i = t[n];
                            if (null !== i.attrName.match(/S|R|T|DeformPercent/)) {
                                const t = { id: i.id, attr: i.attrName, curves: {} };
                                e.set(t.id, t)
                            }
                        }
                        return e
                    }
                    parseAnimationCurves(t) {
                        const e = Mv.Objects.AnimationCurve;
                        for (const n in e) {
                            const i = { id: e[n].id, times: e[n].KeyTime.a.map(Bv), values: e[n].KeyValueFloat.a },
                                r = Sv.get(i.id);
                            if (void 0 !== r) {
                                const e = r.parents[0].ID,
                                    n = r.parents[0].relationship;
                                n.match(/X/) ? t.get(e).curves.x = i : n.match(/Y/) ? t.get(e).curves.y = i : n.match(/Z/) ? t.get(e).curves.z = i : n.match(/d|DeformPercent/) && t.has(e) && (t.get(e).curves.morph = i)
                            }
                        }
                    }
                    parseAnimationLayers(t) {
                        const e = Mv.Objects.AnimationLayer,
                            n = new Map;
                        for (const i in e) {
                            const e = [],
                                r = Sv.get(parseInt(i));
                            void 0 !== r && (r.children.forEach((function(n, i) {
                                if (t.has(n.ID)) {
                                    const r = t.get(n.ID);
                                    if (void 0 !== r.curves.x || void 0 !== r.curves.y || void 0 !== r.curves.z) {
                                        if (void 0 === e[i]) {
                                            const t = Sv.get(n.ID).parents.filter((function(t) { return void 0 !== t.relationship }))[0].ID;
                                            if (void 0 !== t) {
                                                const r = Mv.Objects.Model[t.toString()];
                                                if (void 0 === r) return void console.warn("THREE.FBXLoader: Encountered a unused curve.", n);
                                                const s = { modelName: r.attrName ? Id.sanitizeNodeName(r.attrName) : "", ID: r.id, initialPosition: [0, 0, 0], initialRotation: [0, 0, 0], initialScale: [1, 1, 1] };
                                                Tv.traverse((function(t) { t.ID === r.id && (s.transform = t.matrix, t.userData.transformData && (s.eulerOrder = t.userData.transformData.eulerOrder)) })), s.transform || (s.transform = new Gi), "PreRotation" in r && (s.preRotation = r.PreRotation.value), "PostRotation" in r && (s.postRotation = r.PostRotation.value), e[i] = s
                                            }
                                        }
                                        e[i] && (e[i][r.attr] = r)
                                    } else if (void 0 !== r.curves.morph) {
                                        if (void 0 === e[i]) {
                                            const t = Sv.get(n.ID).parents.filter((function(t) { return void 0 !== t.relationship }))[0].ID,
                                                r = Sv.get(t).parents[0].ID,
                                                s = Sv.get(r).parents[0].ID,
                                                o = Sv.get(s).parents[0].ID,
                                                a = Mv.Objects.Model[o],
                                                l = { modelName: a.attrName ? Id.sanitizeNodeName(a.attrName) : "", morphName: Mv.Objects.Deformer[t].attrName };
                                            e[i] = l
                                        }
                                        e[i][r.attr] = r
                                    }
                                }
                            })), n.set(parseInt(i), e))
                        }
                        return n
                    }
                    parseAnimStacks(t) {
                        const e = Mv.Objects.AnimationStack,
                            n = {};
                        for (const i in e) {
                            const r = Sv.get(parseInt(i)).children;
                            r.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
                            const s = t.get(r[0].ID);
                            n[i] = { name: e[i].attrName, layer: s }
                        }
                        return n
                    }
                    addClip(t) { let e = []; const n = this; return t.layer.forEach((function(t) { e = e.concat(n.generateTracks(t)) })), new iu(t.name, -1, e) }
                    generateTracks(t) {
                        const e = [];
                        let n = new ui,
                            i = new hi,
                            r = new ui;
                        if (t.transform && t.transform.decompose(n, i, r), n = n.toArray(), i = (new Qi).setFromQuaternion(i, t.eulerOrder).toArray(), r = r.toArray(), void 0 !== t.T && Object.keys(t.T.curves).length > 0) {
                            const i = this.generateVectorTrack(t.modelName, t.T.curves, n, "position");
                            void 0 !== i && e.push(i)
                        }
                        if (void 0 !== t.R && Object.keys(t.R.curves).length > 0) {
                            const n = this.generateRotationTrack(t.modelName, t.R.curves, i, t.preRotation, t.postRotation, t.eulerOrder);
                            void 0 !== n && e.push(n)
                        }
                        if (void 0 !== t.S && Object.keys(t.S.curves).length > 0) {
                            const n = this.generateVectorTrack(t.modelName, t.S.curves, r, "scale");
                            void 0 !== n && e.push(n)
                        }
                        if (void 0 !== t.DeformPercent) {
                            const n = this.generateMorphTrack(t);
                            void 0 !== n && e.push(n)
                        }
                        return e
                    }
                    generateVectorTrack(t, e, n, i) {
                        const r = this.getTimesForAllAxes(e),
                            s = this.getKeyframeTrackValues(r, e, n);
                        return new nu(t + "." + i, r, s)
                    }
                    generateRotationTrack(t, e, n, i, r, s) {
                        void 0 !== e.x && (this.interpolateRotations(e.x), e.x.values = e.x.values.map(Qn.degToRad)), void 0 !== e.y && (this.interpolateRotations(e.y), e.y.values = e.y.values.map(Qn.degToRad)), void 0 !== e.z && (this.interpolateRotations(e.z), e.z.values = e.z.values.map(Qn.degToRad));
                        const o = this.getTimesForAllAxes(e),
                            a = this.getKeyframeTrackValues(o, e, n);
                        void 0 !== i && ((i = i.map(Qn.degToRad)).push(s), i = (new Qi).fromArray(i), i = (new hi).setFromEuler(i)), void 0 !== r && ((r = r.map(Qn.degToRad)).push(s), r = (new Qi).fromArray(r), r = (new hi).setFromEuler(r).invert());
                        const l = new hi,
                            c = new Qi,
                            h = [];
                        for (let t = 0; t < a.length; t += 3) c.set(a[t], a[t + 1], a[t + 2], s), l.setFromEuler(c), void 0 !== i && l.premultiply(i), void 0 !== r && l.multiply(r), l.toArray(h, t / 3 * 4);
                        return new tu(t + ".quaternion", o, h)
                    }
                    generateMorphTrack(t) {
                        const e = t.DeformPercent.curves.morph,
                            n = e.values.map((function(t) { return t / 100 })),
                            i = Tv.getObjectByName(t.modelName).morphTargetDictionary[t.morphName];
                        return new Qh(t.modelName + ".morphTargetInfluences[" + i + "]", e.times, n)
                    }
                    getTimesForAllAxes(t) {
                        let e = [];
                        if (void 0 !== t.x && (e = e.concat(t.x.times)), void 0 !== t.y && (e = e.concat(t.y.times)), void 0 !== t.z && (e = e.concat(t.z.times)), e = e.sort((function(t, e) { return t - e })), e.length > 1) {
                            let t = 1,
                                n = e[0];
                            for (let i = 1; i < e.length; i++) {
                                const r = e[i];
                                r !== n && (e[t] = r, n = r, t++)
                            }
                            e = e.slice(0, t)
                        }
                        return e
                    }
                    getKeyframeTrackValues(t, e, n) {
                        const i = n,
                            r = [];
                        let s = -1,
                            o = -1,
                            a = -1;
                        return t.forEach((function(t) {
                            if (e.x && (s = e.x.times.indexOf(t)), e.y && (o = e.y.times.indexOf(t)), e.z && (a = e.z.times.indexOf(t)), -1 !== s) {
                                const t = e.x.values[s];
                                r.push(t), i[0] = t
                            } else r.push(i[0]);
                            if (-1 !== o) {
                                const t = e.y.values[o];
                                r.push(t), i[1] = t
                            } else r.push(i[1]);
                            if (-1 !== a) {
                                const t = e.z.values[a];
                                r.push(t), i[2] = t
                            } else r.push(i[2])
                        })), r
                    }
                    interpolateRotations(t) {
                        for (let e = 1; e < t.values.length; e++) {
                            const n = t.values[e - 1],
                                i = t.values[e] - n,
                                r = Math.abs(i);
                            if (r >= 180) {
                                const s = r / 180,
                                    o = i / s;
                                let a = n + o;
                                const l = t.times[e - 1],
                                    c = (t.times[e] - l) / s;
                                let h = l + c;
                                const u = [],
                                    d = [];
                                for (; h < t.times[e];) u.push(h), h += c, d.push(a), a += o;
                                t.times = Wv(t.times, e, u), t.values = Wv(t.values, e, d)
                            }
                        }
                    }
                }
                class Cv {
                    getPrevNode() { return this.nodeStack[this.currentIndent - 2] }
                    getCurrentNode() { return this.nodeStack[this.currentIndent - 1] }
                    getCurrentProp() { return this.currentProp }
                    pushStack(t) { this.nodeStack.push(t), this.currentIndent += 1 }
                    popStack() { this.nodeStack.pop(), this.currentIndent -= 1 }
                    setCurrentProp(t, e) { this.currentProp = t, this.currentPropName = e }
                    parse(t) {
                        this.currentIndent = 0, this.allNodes = new Dv, this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
                        const e = this,
                            n = t.split(/[\r\n]+/);
                        return n.forEach((function(t, i) {
                            const r = t.match(/^[\s\t]*;/),
                                s = t.match(/^[\s\t]*$/);
                            if (r || s) return;
                            const o = t.match("^\\t{" + e.currentIndent + "}(\\w+):(.*){", ""),
                                a = t.match("^\\t{" + e.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"),
                                l = t.match("^\\t{" + (e.currentIndent - 1) + "}}");
                            o ? e.parseNodeBegin(t, o) : a ? e.parseNodeProperty(t, a, n[++i]) : l ? e.popStack() : t.match(/^[^\s\t}]/) && e.parseNodePropertyContinued(t)
                        })), this.allNodes
                    }
                    parseNodeBegin(t, e) {
                        const n = e[1].trim().replace(/^"/, "").replace(/"$/, ""),
                            i = e[2].split(",").map((function(t) { return t.trim().replace(/^"/, "").replace(/"$/, "") })),
                            r = { name: n },
                            s = this.parseNodeAttr(i),
                            o = this.getCurrentNode();
                        0 === this.currentIndent ? this.allNodes.add(n, r) : n in o ? ("PoseNode" === n ? o.PoseNode.push(r) : void 0 !== o[n].id && (o[n] = {}, o[n][o[n].id] = o[n]), "" !== s.id && (o[n][s.id] = r)) : "number" == typeof s.id ? (o[n] = {}, o[n][s.id] = r) : "Properties70" !== n && (o[n] = "PoseNode" === n ? [r] : r), "number" == typeof s.id && (r.id = s.id), "" !== s.name && (r.attrName = s.name), "" !== s.type && (r.attrType = s.type), this.pushStack(r)
                    }
                    parseNodeAttr(t) {
                        let e = t[0];
                        "" !== t[0] && (e = parseInt(t[0]), isNaN(e) && (e = t[0]));
                        let n = "",
                            i = "";
                        return t.length > 1 && (n = t[1].replace(/^(\w+)::/, ""), i = t[2]), { id: e, name: n, type: i }
                    }
                    parseNodeProperty(t, e, n) {
                        let i = e[1].replace(/^"/, "").replace(/"$/, "").trim(),
                            r = e[2].replace(/^"/, "").replace(/"$/, "").trim();
                        "Content" === i && "," === r && (r = n.replace(/"/g, "").replace(/,$/, "").trim());
                        const s = this.getCurrentNode();
                        if ("Properties70" !== s.name) {
                            if ("C" === i) {
                                const t = r.split(",").slice(1),
                                    e = parseInt(t[0]),
                                    n = parseInt(t[1]);
                                let o = r.split(",").slice(3);
                                o = o.map((function(t) { return t.trim().replace(/^"/, "") })), i = "connections", r = [e, n],
                                    function(t, e) { for (let n = 0, i = t.length, r = e.length; n < r; n++, i++) t[i] = e[n] }(r, o), void 0 === s[i] && (s[i] = [])
                            }
                            "Node" === i && (s.id = r), i in s && Array.isArray(s[i]) ? s[i].push(r) : "a" !== i ? s[i] = r : s.a = r, this.setCurrentProp(s, i), "a" === i && "," !== r.slice(-1) && (s.a = Gv(r))
                        } else this.parseNodeSpecialProperty(t, i, r)
                    }
                    parseNodePropertyContinued(t) {
                        const e = this.getCurrentNode();
                        e.a += t, "," !== t.slice(-1) && (e.a = Gv(e.a))
                    }
                    parseNodeSpecialProperty(t, e, n) {
                        const i = n.split('",').map((function(t) { return t.trim().replace(/^\"/, "").replace(/\s/, "_") })),
                            r = i[0],
                            s = i[1],
                            o = i[2],
                            a = i[3];
                        let l = i[4];
                        switch (s) {
                            case "int":
                            case "enum":
                            case "bool":
                            case "ULongLong":
                            case "double":
                            case "Number":
                            case "FieldOfView":
                                l = parseFloat(l);
                                break;
                            case "Color":
                            case "ColorRGB":
                            case "Vector3D":
                            case "Lcl_Translation":
                            case "Lcl_Rotation":
                            case "Lcl_Scaling":
                                l = Gv(l)
                        }
                        this.getPrevNode()[r] = { type: s, type2: o, flag: a, value: l }, this.setCurrentProp(this.getPrevNode(), r)
                    }
                }
                class Pv {
                    parse(t) {
                        const e = new Iv(t);
                        e.skip(23);
                        const n = e.getUint32();
                        if (n < 6400) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n);
                        const i = new Dv;
                        for (; !this.endOfContent(e);) {
                            const t = this.parseNode(e, n);
                            null !== t && i.add(t.name, t)
                        }
                        return i
                    }
                    endOfContent(t) { return t.size() % 16 == 0 ? (t.getOffset() + 160 + 16 & -16) >= t.size() : t.getOffset() + 160 + 16 >= t.size() }
                    parseNode(t, e) {
                        const n = {},
                            i = e >= 7500 ? t.getUint64() : t.getUint32(),
                            r = e >= 7500 ? t.getUint64() : t.getUint32();
                        e >= 7500 ? t.getUint64() : t.getUint32();
                        const s = t.getUint8(),
                            o = t.getString(s);
                        if (0 === i) return null;
                        const a = [];
                        for (let e = 0; e < r; e++) a.push(this.parseProperty(t));
                        const l = a.length > 0 ? a[0] : "",
                            c = a.length > 1 ? a[1] : "",
                            h = a.length > 2 ? a[2] : "";
                        for (n.singleProperty = 1 === r && t.getOffset() === i; i > t.getOffset();) {
                            const i = this.parseNode(t, e);
                            null !== i && this.parseSubNode(o, n, i)
                        }
                        return n.propertyList = a, "number" == typeof l && (n.id = l), "" !== c && (n.attrName = c), "" !== h && (n.attrType = h), "" !== o && (n.name = o), n
                    }
                    parseSubNode(t, e, n) {
                        if (!0 === n.singleProperty) {
                            const t = n.propertyList[0];
                            Array.isArray(t) ? (e[n.name] = n, n.a = t) : e[n.name] = t
                        } else if ("Connections" === t && "C" === n.name) {
                            const t = [];
                            n.propertyList.forEach((function(e, n) { 0 !== n && t.push(e) })), void 0 === e.connections && (e.connections = []), e.connections.push(t)
                        } else if ("Properties70" === n.name) Object.keys(n).forEach((function(t) { e[t] = n[t] }));
                        else if ("Properties70" === t && "P" === n.name) {
                            let t = n.propertyList[0],
                                i = n.propertyList[1];
                            const r = n.propertyList[2],
                                s = n.propertyList[3];
                            let o;
                            0 === t.indexOf("Lcl ") && (t = t.replace("Lcl ", "Lcl_")), 0 === i.indexOf("Lcl ") && (i = i.replace("Lcl ", "Lcl_")), o = "Color" === i || "ColorRGB" === i || "Vector" === i || "Vector3D" === i || 0 === i.indexOf("Lcl_") ? [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : n.propertyList[4], e[t] = { type: i, type2: r, flag: s, value: o }
                        } else void 0 === e[n.name] ? "number" == typeof n.id ? (e[n.name] = {}, e[n.name][n.id] = n) : e[n.name] = n : "PoseNode" === n.name ? (Array.isArray(e[n.name]) || (e[n.name] = [e[n.name]]), e[n.name].push(n)) : void 0 === e[n.name][n.id] && (e[n.name][n.id] = n)
                    }
                    parseProperty(t) {
                        const e = t.getString(1);
                        let n;
                        switch (e) {
                            case "C":
                                return t.getBoolean();
                            case "D":
                                return t.getFloat64();
                            case "F":
                                return t.getFloat32();
                            case "I":
                                return t.getInt32();
                            case "L":
                                return t.getInt64();
                            case "R":
                                return n = t.getUint32(), t.getArrayBuffer(n);
                            case "S":
                                return n = t.getUint32(), t.getString(n);
                            case "Y":
                                return t.getInt16();
                            case "b":
                            case "c":
                            case "d":
                            case "f":
                            case "i":
                            case "l":
                                const i = t.getUint32(),
                                    s = t.getUint32(),
                                    o = t.getUint32();
                                if (0 === s) switch (e) {
                                    case "b":
                                    case "c":
                                        return t.getBooleanArray(i);
                                    case "d":
                                        return t.getFloat64Array(i);
                                    case "f":
                                        return t.getFloat32Array(i);
                                    case "i":
                                        return t.getInt32Array(i);
                                    case "l":
                                        return t.getInt64Array(i)
                                }
                                void 0 === r && console.error("THREE.FBXLoader: External library fflate.min.js required.");
                                const a = Gg(new Uint8Array(t.getArrayBuffer(o))),
                                    l = new Iv(a.buffer);
                                switch (e) {
                                    case "b":
                                    case "c":
                                        return l.getBooleanArray(i);
                                    case "d":
                                        return l.getFloat64Array(i);
                                    case "f":
                                        return l.getFloat32Array(i);
                                    case "i":
                                        return l.getInt32Array(i);
                                    case "l":
                                        return l.getInt64Array(i)
                                }
                            default:
                                throw new Error("THREE.FBXLoader: Unknown property type " + e)
                        }
                    }
                }
                class Iv {
                    constructor(t, e) { this.dv = new DataView(t), this.offset = 0, this.littleEndian = void 0 === e || e }
                    getOffset() { return this.offset }
                    size() { return this.dv.buffer.byteLength }
                    skip(t) { this.offset += t }
                    getBoolean() { return 1 == (1 & this.getUint8()) }
                    getBooleanArray(t) { const e = []; for (let n = 0; n < t; n++) e.push(this.getBoolean()); return e }
                    getUint8() { const t = this.dv.getUint8(this.offset); return this.offset += 1, t }
                    getInt16() { const t = this.dv.getInt16(this.offset, this.littleEndian); return this.offset += 2, t }
                    getInt32() { const t = this.dv.getInt32(this.offset, this.littleEndian); return this.offset += 4, t }
                    getInt32Array(t) { const e = []; for (let n = 0; n < t; n++) e.push(this.getInt32()); return e }
                    getUint32() { const t = this.dv.getUint32(this.offset, this.littleEndian); return this.offset += 4, t }
                    getInt64() { let t, e; return this.littleEndian ? (t = this.getUint32(), e = this.getUint32()) : (e = this.getUint32(), t = this.getUint32()), 2147483648 & e ? (e = 4294967295 & ~e, t = 4294967295 & ~t, 4294967295 === t && (e = e + 1 & 4294967295), t = t + 1 & 4294967295, -(4294967296 * e + t)) : 4294967296 * e + t }
                    getInt64Array(t) { const e = []; for (let n = 0; n < t; n++) e.push(this.getInt64()); return e }
                    getUint64() { let t, e; return this.littleEndian ? (t = this.getUint32(), e = this.getUint32()) : (e = this.getUint32(), t = this.getUint32()), 4294967296 * e + t }
                    getFloat32() { const t = this.dv.getFloat32(this.offset, this.littleEndian); return this.offset += 4, t }
                    getFloat32Array(t) { const e = []; for (let n = 0; n < t; n++) e.push(this.getFloat32()); return e }
                    getFloat64() { const t = this.dv.getFloat64(this.offset, this.littleEndian); return this.offset += 8, t }
                    getFloat64Array(t) { const e = []; for (let n = 0; n < t; n++) e.push(this.getFloat64()); return e }
                    getArrayBuffer(t) { const e = this.dv.buffer.slice(this.offset, this.offset + t); return this.offset += t, e }
                    getString(t) { let e = []; for (let n = 0; n < t; n++) e[n] = this.getUint8(); const n = e.indexOf(0); return n >= 0 && (e = e.slice(0, n)), ku.decodeText(new Uint8Array(e)) }
                }
                class Dv { add(t, e) { this[t] = e } }

                function Nv(t) { const e = t.match(/FBXVersion: (\d+)/); if (e) return parseInt(e[1]); throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.") }

                function Bv(t) { return t / 46186158e3 }
                const Ov = [];

                function Fv(t, e, n, i) {
                    let r;
                    switch (i.mappingType) {
                        case "ByPolygonVertex":
                            r = t;
                            break;
                        case "ByPolygon":
                            r = e;
                            break;
                        case "ByVertice":
                            r = n;
                            break;
                        case "AllSame":
                            r = i.indices[0];
                            break;
                        default:
                            console.warn("THREE.FBXLoader: unknown attribute mapping type " + i.mappingType)
                    }
                    "IndexToDirect" === i.referenceType && (r = i.indices[r]);
                    const s = r * i.dataSize,
                        o = s + i.dataSize;
                    return function(t, e, n, i) { for (let r = n, s = 0; r < i; r++, s++) t[s] = e[r]; return t }(Ov, i.buffer, s, o)
                }
                const zv = new Qi,
                    Uv = new ui;

                function Hv(t) {
                    const e = new Gi,
                        n = new Gi,
                        i = new Gi,
                        r = new Gi,
                        s = new Gi,
                        o = new Gi,
                        a = new Gi,
                        l = new Gi,
                        c = new Gi,
                        h = new Gi,
                        u = new Gi,
                        d = new Gi,
                        p = t.inheritType ? t.inheritType : 0;
                    if (t.translation && e.setPosition(Uv.fromArray(t.translation)), t.preRotation) {
                        const e = t.preRotation.map(Qn.degToRad);
                        e.push(t.eulerOrder), n.makeRotationFromEuler(zv.fromArray(e))
                    }
                    if (t.rotation) {
                        const e = t.rotation.map(Qn.degToRad);
                        e.push(t.eulerOrder), i.makeRotationFromEuler(zv.fromArray(e))
                    }
                    if (t.postRotation) {
                        const e = t.postRotation.map(Qn.degToRad);
                        e.push(t.eulerOrder), r.makeRotationFromEuler(zv.fromArray(e)), r.invert()
                    }
                    t.scale && s.scale(Uv.fromArray(t.scale)), t.scalingOffset && a.setPosition(Uv.fromArray(t.scalingOffset)), t.scalingPivot && o.setPosition(Uv.fromArray(t.scalingPivot)), t.rotationOffset && l.setPosition(Uv.fromArray(t.rotationOffset)), t.rotationPivot && c.setPosition(Uv.fromArray(t.rotationPivot)), t.parentMatrixWorld && (u.copy(t.parentMatrix), h.copy(t.parentMatrixWorld));
                    const m = n.clone().multiply(i).multiply(r),
                        f = new Gi;
                    f.extractRotation(h);
                    const g = new Gi;
                    g.copyPosition(h);
                    const v = g.clone().invert().multiply(h),
                        y = f.clone().invert().multiply(v),
                        x = s,
                        _ = new Gi;
                    if (0 === p) _.copy(f).multiply(m).multiply(y).multiply(x);
                    else if (1 === p) _.copy(f).multiply(y).multiply(m).multiply(x);
                    else {
                        const t = (new Gi).scale((new ui).setFromMatrixScale(u)).clone().invert(),
                            e = y.clone().multiply(t);
                        _.copy(f).multiply(m).multiply(e).multiply(x)
                    }
                    const b = c.clone().invert(),
                        w = o.clone().invert();
                    let M = e.clone().multiply(l).multiply(c).multiply(n).multiply(i).multiply(r).multiply(b).multiply(a).multiply(o).multiply(s).multiply(w);
                    const S = (new Gi).copyPosition(M),
                        T = h.clone().multiply(S);
                    return d.copyPosition(T), M = d.clone().multiply(_), M.premultiply(h.invert()), M
                }

                function kv(t) { const e = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"]; return 6 === (t = t || 0) ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[t] }

                function Gv(t) { return t.split(",").map((function(t) { return parseFloat(t) })) }

                function Vv(t, e, n) { return void 0 === e && (e = 0), void 0 === n && (n = t.byteLength), ku.decodeText(new Uint8Array(t, e, n)) }

                function Wv(t, e, n) { return t.slice(0, e).concat(n).concat(t.slice(e)) }
                class jv extends lu {
                    constructor(t) { super(t), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(t) { return new Jv(t) })), this.register((function(t) { return new Qv(t) })), this.register((function(t) { return new $v(t) })), this.register((function(t) { return new Kv(t) })), this.register((function(t) { return new Yv(t) })), this.register((function(t) { return new ty(t) })) }
                    load(t, e, n, i) {
                        const r = this;
                        let s;
                        s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : ku.extractUrlBase(t), this.manager.itemStart(t);
                        const o = function(e) { i ? i(e) : console.error(e), r.manager.itemError(t), r.manager.itemEnd(t) },
                            a = new hu(this.manager);
                        a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, (function(n) { try { r.parse(n, s, (function(n) { e(n), r.manager.itemEnd(t) }), o) } catch (t) { o(t) } }), n, o)
                    }
                    setDRACOLoader(t) { return this.dracoLoader = t, this }
                    setDDSLoader() { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') }
                    setKTX2Loader(t) { return this.ktx2Loader = t, this }
                    setMeshoptDecoder(t) { return this.meshoptDecoder = t, this }
                    register(t) { return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this }
                    unregister(t) { return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this }
                    parse(t, e, n, i) {
                        let r;
                        const s = {},
                            o = {};
                        if ("string" == typeof t) r = t;
                        else if (ku.decodeText(new Uint8Array(t, 0, 4)) === ey) {
                            try { s[Xv.KHR_BINARY_GLTF] = new ny(t) } catch (t) { return void(i && i(t)) }
                            r = s[Xv.KHR_BINARY_GLTF].content
                        } else r = ku.decodeText(new Uint8Array(t));
                        const a = JSON.parse(r);
                        if (void 0 === a.asset || a.asset.version[0] < 2) return void(i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                        const l = new My(a, { path: e || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder });
                        l.fileLoader.setRequestHeader(this.requestHeader);
                        for (let t = 0; t < this.pluginCallbacks.length; t++) {
                            const e = this.pluginCallbacks[t](l);
                            o[e.name] = e, s[e.name] = !0
                        }
                        if (a.extensionsUsed)
                            for (let t = 0; t < a.extensionsUsed.length; ++t) {
                                const e = a.extensionsUsed[t],
                                    n = a.extensionsRequired || [];
                                switch (e) {
                                    case Xv.KHR_MATERIALS_UNLIT:
                                        s[e] = new Zv;
                                        break;
                                    case Xv.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                        s[e] = new oy;
                                        break;
                                    case Xv.KHR_DRACO_MESH_COMPRESSION:
                                        s[e] = new iy(a, this.dracoLoader);
                                        break;
                                    case Xv.KHR_TEXTURE_TRANSFORM:
                                        s[e] = new ry;
                                        break;
                                    case Xv.KHR_MESH_QUANTIZATION:
                                        s[e] = new ay;
                                        break;
                                    default:
                                        n.indexOf(e) >= 0 && void 0 === o[e] && console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".')
                                }
                            }
                        l.setExtensions(s), l.setPlugins(o), l.parse(n, i)
                    }
                }

                function qv() { let t = {}; return { get: function(e) { return t[e] }, add: function(e, n) { t[e] = n }, remove: function(e) { delete t[e] }, removeAll: function() { t = {} } } }
                const Xv = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" };
                class Yv {
                    constructor(t) { this.parser = t, this.name = Xv.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } }
                    _markDefs() {
                        const t = this.parser,
                            e = this.parser.json.nodes || [];
                        for (let n = 0, i = e.length; n < i; n++) {
                            const i = e[n];
                            i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && t._addNodeRef(this.cache, i.extensions[this.name].light)
                        }
                    }
                    _loadLight(t) {
                        const e = this.parser,
                            n = "light:" + t;
                        let i = e.cache.get(n);
                        if (i) return i;
                        const r = e.json,
                            s = ((r.extensions && r.extensions[this.name] || {}).lights || [])[t];
                        let o;
                        const a = new Dr(16777215);
                        void 0 !== s.color && a.fromArray(s.color);
                        const l = void 0 !== s.range ? s.range : 0;
                        switch (s.type) {
                            case "directional":
                                o = new Bu(a), o.target.position.set(0, 0, -1), o.add(o.target);
                                break;
                            case "point":
                                o = new Iu(a), o.distance = l;
                                break;
                            case "spot":
                                o = new Au(a), o.distance = l, s.spot = s.spot || {}, s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0, s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4, o.angle = s.spot.outerConeAngle, o.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle, o.target.position.set(0, 0, -1), o.add(o.target);
                                break;
                            default:
                                throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type)
                        }
                        return o.position.set(0, 0, 0), o.decay = 2, void 0 !== s.intensity && (o.intensity = s.intensity), o.name = e.createUniqueName(s.name || "light_" + t), i = Promise.resolve(o), e.cache.add(n, i), i
                    }
                    createNodeAttachment(t) {
                        const e = this,
                            n = this.parser,
                            i = n.json.nodes[t],
                            r = (i.extensions && i.extensions[this.name] || {}).light;
                        return void 0 === r ? null : this._loadLight(r).then((function(t) { return n._getNodeRef(e.cache, r, t) }))
                    }
                }
                class Zv {
                    constructor() { this.name = Xv.KHR_MATERIALS_UNLIT }
                    getMaterialType() { return Nr }
                    extendParams(t, e, n) {
                        const i = [];
                        t.color = new Dr(1, 1, 1), t.opacity = 1;
                        const r = e.pbrMetallicRoughness;
                        if (r) {
                            if (Array.isArray(r.baseColorFactor)) {
                                const e = r.baseColorFactor;
                                t.color.fromArray(e), t.opacity = e[3]
                            }
                            void 0 !== r.baseColorTexture && i.push(n.assignTexture(t, "map", r.baseColorTexture))
                        }
                        return Promise.all(i)
                    }
                }
                class Jv {
                    constructor(t) { this.parser = t, this.name = Xv.KHR_MATERIALS_CLEARCOAT }
                    getMaterialType(t) { const e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? Oh : null }
                    extendMaterialParams(t, e) {
                        const n = this.parser,
                            i = n.json.materials[t];
                        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                        const r = [],
                            s = i.extensions[this.name];
                        if (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor), void 0 !== s.clearcoatTexture && r.push(n.assignTexture(e, "clearcoatMap", s.clearcoatTexture)), void 0 !== s.clearcoatRoughnessFactor && (e.clearcoatRoughness = s.clearcoatRoughnessFactor), void 0 !== s.clearcoatRoughnessTexture && r.push(n.assignTexture(e, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), void 0 !== s.clearcoatNormalTexture && (r.push(n.assignTexture(e, "clearcoatNormalMap", s.clearcoatNormalTexture)), void 0 !== s.clearcoatNormalTexture.scale)) {
                            const t = s.clearcoatNormalTexture.scale;
                            e.clearcoatNormalScale = new $n(t, -t)
                        }
                        return Promise.all(r)
                    }
                }
                class Kv {
                    constructor(t) { this.parser = t, this.name = Xv.KHR_MATERIALS_TRANSMISSION }
                    getMaterialType(t) { const e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? Oh : null }
                    extendMaterialParams(t, e) {
                        const n = this.parser,
                            i = n.json.materials[t];
                        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                        const r = [],
                            s = i.extensions[this.name];
                        return void 0 !== s.transmissionFactor && (e.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && r.push(n.assignTexture(e, "transmissionMap", s.transmissionTexture)), Promise.all(r)
                    }
                }
                class Qv {
                    constructor(t) { this.parser = t, this.name = Xv.KHR_TEXTURE_BASISU }
                    loadTexture(t) {
                        const e = this.parser,
                            n = e.json,
                            i = n.textures[t];
                        if (!i.extensions || !i.extensions[this.name]) return null;
                        const r = i.extensions[this.name],
                            s = n.images[r.source],
                            o = e.options.ktx2Loader;
                        if (!o) { if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null }
                        return e.loadTextureImage(t, s, o)
                    }
                }
                class $v {
                    constructor(t) { this.parser = t, this.name = Xv.EXT_TEXTURE_WEBP, this.isSupported = null }
                    loadTexture(t) {
                        const e = this.name,
                            n = this.parser,
                            i = n.json,
                            r = i.textures[t];
                        if (!r.extensions || !r.extensions[e]) return null;
                        const s = r.extensions[e],
                            o = i.images[s.source];
                        let a = n.textureLoader;
                        if (o.uri) {
                            const t = n.options.manager.getHandler(o.uri);
                            null !== t && (a = t)
                        }
                        return this.detectSupport().then((function(r) { if (r) return n.loadTextureImage(t, o, a); if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return n.loadTexture(t) }))
                    }
                    detectSupport() {
                        return this.isSupported || (this.isSupported = new Promise((function(t) {
                            const e = new Image;
                            e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function() { t(1 === e.height) }
                        }))), this.isSupported
                    }
                }
                class ty {
                    constructor(t) { this.name = Xv.EXT_MESHOPT_COMPRESSION, this.parser = t }
                    loadBufferView(t) {
                        const e = this.parser.json,
                            n = e.bufferViews[t];
                        if (n.extensions && n.extensions[this.name]) {
                            const t = n.extensions[this.name],
                                i = this.parser.getDependency("buffer", t.buffer),
                                r = this.parser.options.meshoptDecoder;
                            if (!r || !r.supported) { if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null }
                            return Promise.all([i, r.ready]).then((function(e) {
                                const n = t.byteOffset || 0,
                                    i = t.byteLength || 0,
                                    s = t.count,
                                    o = t.byteStride,
                                    a = new ArrayBuffer(s * o),
                                    l = new Uint8Array(e[0], n, i);
                                return r.decodeGltfBuffer(new Uint8Array(a), s, o, l, t.mode, t.filter), a
                            }))
                        }
                        return null
                    }
                }
                const ey = "glTF";
                class ny {
                    constructor(t) {
                        this.name = Xv.KHR_BINARY_GLTF, this.content = null, this.body = null;
                        const e = new DataView(t, 0, 12);
                        if (this.header = { magic: ku.decodeText(new Uint8Array(t.slice(0, 4))), version: e.getUint32(4, !0), length: e.getUint32(8, !0) }, this.header.magic !== ey) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                        if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                        const n = this.header.length - 12,
                            i = new DataView(t, 12);
                        let r = 0;
                        for (; r < n;) {
                            const e = i.getUint32(r, !0);
                            r += 4;
                            const n = i.getUint32(r, !0);
                            if (r += 4, 1313821514 === n) {
                                const n = new Uint8Array(t, 12 + r, e);
                                this.content = ku.decodeText(n)
                            } else if (5130562 === n) {
                                const n = 12 + r;
                                this.body = t.slice(n, n + e)
                            }
                            r += e
                        }
                        if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
                    }
                }
                class iy {
                    constructor(t, e) {
                        if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                        this.name = Xv.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload()
                    }
                    decodePrimitive(t, e) {
                        const n = this.json,
                            i = this.dracoLoader,
                            r = t.extensions[this.name].bufferView,
                            s = t.extensions[this.name].attributes,
                            o = {},
                            a = {},
                            l = {};
                        for (const t in s) {
                            const e = py[t] || t.toLowerCase();
                            o[e] = s[t]
                        }
                        for (const e in t.attributes) {
                            const i = py[e] || e.toLowerCase();
                            if (void 0 !== s[e]) {
                                const r = n.accessors[t.attributes[e]],
                                    s = cy[r.componentType];
                                l[i] = s, a[i] = !0 === r.normalized
                            }
                        }
                        return e.getDependency("bufferView", r).then((function(t) {
                            return new Promise((function(e) {
                                i.decodeDracoFile(t, (function(t) {
                                    for (const e in t.attributes) {
                                        const n = t.attributes[e],
                                            i = a[e];
                                        void 0 !== i && (n.normalized = i)
                                    }
                                    e(t)
                                }), o, l)
                            }))
                        }))
                    }
                }
                class ry {
                    constructor() { this.name = Xv.KHR_TEXTURE_TRANSFORM }
                    extendTexture(t, e) { return void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale || (t = t.clone(), void 0 !== e.offset && t.offset.fromArray(e.offset), void 0 !== e.rotation && (t.rotation = e.rotation), void 0 !== e.scale && t.repeat.fromArray(e.scale), t.needsUpdate = !0), t }
                }
                class sy extends Bh {
                    constructor(t) {
                        super(), this.isGLTFSpecularGlossinessMaterial = !0;
                        const e = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                            n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                            i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                            r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                            s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
                            o = { specular: { value: (new Dr).setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } };
                        this._extraUniforms = o, this.onBeforeCompile = function(t) {
                            for (const e in o) t.uniforms[e] = o[e];
                            t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", s)
                        }, Object.defineProperties(this, { specular: { get: function() { return o.specular.value }, set: function(t) { o.specular.value = t } }, specularMap: { get: function() { return o.specularMap.value }, set: function(t) { o.specularMap.value = t, t ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP } }, glossiness: { get: function() { return o.glossiness.value }, set: function(t) { o.glossiness.value = t } }, glossinessMap: { get: function() { return o.glossinessMap.value }, set: function(t) { o.glossinessMap.value = t, t ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV) } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(t)
                    }
                    copy(t) { return super.copy(t), this.specularMap = t.specularMap, this.specular.copy(t.specular), this.glossinessMap = t.glossinessMap, this.glossiness = t.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this }
                }
                class oy {
                    constructor() { this.name = Xv.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"] }
                    getMaterialType() { return sy }
                    extendParams(t, e, n) {
                        const i = e.extensions[this.name];
                        t.color = new Dr(1, 1, 1), t.opacity = 1;
                        const r = [];
                        if (Array.isArray(i.diffuseFactor)) {
                            const e = i.diffuseFactor;
                            t.color.fromArray(e), t.opacity = e[3]
                        }
                        if (void 0 !== i.diffuseTexture && r.push(n.assignTexture(t, "map", i.diffuseTexture)), t.emissive = new Dr(0, 0, 0), t.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1, t.specular = new Dr(1, 1, 1), Array.isArray(i.specularFactor) && t.specular.fromArray(i.specularFactor), void 0 !== i.specularGlossinessTexture) {
                            const e = i.specularGlossinessTexture;
                            r.push(n.assignTexture(t, "glossinessMap", e)), r.push(n.assignTexture(t, "specularMap", e))
                        }
                        return Promise.all(r)
                    }
                    createMaterial(t) { const e = new sy(t); return e.fog = !0, e.color = t.color, e.map = void 0 === t.map ? null : t.map, e.lightMap = null, e.lightMapIntensity = 1, e.aoMap = void 0 === t.aoMap ? null : t.aoMap, e.aoMapIntensity = 1, e.emissive = t.emissive, e.emissiveIntensity = 1, e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap, e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap, e.bumpScale = 1, e.normalMap = void 0 === t.normalMap ? null : t.normalMap, e.normalMapType = un, t.normalScale && (e.normalScale = t.normalScale), e.displacementMap = null, e.displacementScale = 1, e.displacementBias = 0, e.specularMap = void 0 === t.specularMap ? null : t.specularMap, e.specular = t.specular, e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap, e.glossiness = t.glossiness, e.alphaMap = null, e.envMap = void 0 === t.envMap ? null : t.envMap, e.envMapIntensity = 1, e.refractionRatio = .98, e }
                }
                class ay { constructor() { this.name = Xv.KHR_MESH_QUANTIZATION } }
                class ly extends jh {
                    constructor(t, e, n, i) { super(t, e, n, i) }
                    copySampleValue_(t) {
                        const e = this.resultBuffer,
                            n = this.sampleValues,
                            i = this.valueSize,
                            r = t * i * 3 + i;
                        for (let t = 0; t !== i; t++) e[t] = n[r + t];
                        return e
                    }
                }
                ly.prototype.beforeStart_ = ly.prototype.copySampleValue_, ly.prototype.afterEnd_ = ly.prototype.copySampleValue_, ly.prototype.interpolate_ = function(t, e, n, i) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        o = this.valueSize,
                        a = 2 * o,
                        l = 3 * o,
                        c = i - e,
                        h = (n - e) / c,
                        u = h * h,
                        d = u * h,
                        p = t * l,
                        m = p - l,
                        f = -2 * d + 3 * u,
                        g = d - u,
                        v = 1 - f,
                        y = g - u + h;
                    for (let t = 0; t !== o; t++) {
                        const e = s[m + t + o],
                            n = s[m + t + a] * c,
                            i = s[p + t + o],
                            l = s[p + t] * c;
                        r[t] = v * e + y * n + f * i + g * l
                    }
                    return r
                };
                const cy = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array },
                    hy = { 9728: yt, 9729: Mt, 9984: xt, 9985: St, 9986: bt, 9987: Et },
                    uy = { 33071: gt, 33648: vt, 10497: ft },
                    dy = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
                    py = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" },
                    my = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" },
                    fy = { CUBICSPLINE: void 0, LINEAR: We, STEP: Ve };

                function gy(t, e) { return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t) }

                function vy(t, e, n) { for (const i in n.extensions) void 0 === t[i] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = n.extensions[i]) }

                function yy(t, e) { void 0 !== e.extras && ("object" == typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras)) }

                function xy(t, e) {
                    if (t.updateMorphTargets(), void 0 !== e.weights)
                        for (let n = 0, i = e.weights.length; n < i; n++) t.morphTargetInfluences[n] = e.weights[n];
                    if (e.extras && Array.isArray(e.extras.targetNames)) { const n = e.extras.targetNames; if (t.morphTargetInfluences.length === n.length) { t.morphTargetDictionary = {}; for (let e = 0, i = n.length; e < i; e++) t.morphTargetDictionary[n[e]] = e } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") }
                }

                function _y(t) { const e = t.extensions && t.extensions[Xv.KHR_DRACO_MESH_COMPRESSION]; let n; return n = e ? "draco:" + e.bufferView + ":" + e.indices + ":" + by(e.attributes) : t.indices + ":" + by(t.attributes) + ":" + t.mode, n }

                function by(t) { let e = ""; const n = Object.keys(t).sort(); for (let i = 0, r = n.length; i < r; i++) e += n[i] + ":" + t[n[i]] + ";"; return e }

                function wy(t) {
                    switch (t) {
                        case Int8Array:
                            return 1 / 127;
                        case Uint8Array:
                            return 1 / 255;
                        case Int16Array:
                            return 1 / 32767;
                        case Uint16Array:
                            return 1 / 65535;
                        default:
                            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
                    }
                }
                class My {
                    constructor(t = {}, e = {}) { this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new qv, this.associations = new Map, this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.textureCache = {}, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new Zu(this.options.manager) : this.textureLoader = new gu(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new hu(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) }
                    setExtensions(t) { this.extensions = t }
                    setPlugins(t) { this.plugins = t }
                    parse(t, e) {
                        const n = this,
                            i = this.json,
                            r = this.extensions;
                        this.cache.removeAll(), this._invokeAll((function(t) { return t._markDefs && t._markDefs() })), Promise.all(this._invokeAll((function(t) { return t.beforeRoot && t.beforeRoot() }))).then((function() { return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")]) })).then((function(e) {
                            const s = { scene: e[0][i.scene || 0], scenes: e[0], animations: e[1], cameras: e[2], asset: i.asset, parser: n, userData: {} };
                            vy(r, s, i), yy(s, i), Promise.all(n._invokeAll((function(t) { return t.afterRoot && t.afterRoot(s) }))).then((function() { t(s) }))
                        })).catch(e)
                    }
                    _markDefs() {
                        const t = this.json.nodes || [],
                            e = this.json.skins || [],
                            n = this.json.meshes || [];
                        for (let n = 0, i = e.length; n < i; n++) { const i = e[n].joints; for (let e = 0, n = i.length; e < n; e++) t[i[e]].isBone = !0 }
                        for (let e = 0, i = t.length; e < i; e++) {
                            const i = t[e];
                            void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh), void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)), void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
                        }
                    }
                    _addNodeRef(t, e) { void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++) }
                    _getNodeRef(t, e, n) { if (t.refs[e] <= 1) return n; const i = n.clone(); return i.name += "_instance_" + t.uses[e]++, i }
                    _invokeOne(t) {
                        const e = Object.values(this.plugins);
                        e.push(this);
                        for (let n = 0; n < e.length; n++) { const i = t(e[n]); if (i) return i }
                        return null
                    }
                    _invokeAll(t) {
                        const e = Object.values(this.plugins);
                        e.unshift(this);
                        const n = [];
                        for (let i = 0; i < e.length; i++) {
                            const r = t(e[i]);
                            r && n.push(r)
                        }
                        return n
                    }
                    getDependency(t, e) {
                        const n = t + ":" + e;
                        let i = this.cache.get(n);
                        if (!i) {
                            switch (t) {
                                case "scene":
                                    i = this.loadScene(e);
                                    break;
                                case "node":
                                    i = this.loadNode(e);
                                    break;
                                case "mesh":
                                    i = this._invokeOne((function(t) { return t.loadMesh && t.loadMesh(e) }));
                                    break;
                                case "accessor":
                                    i = this.loadAccessor(e);
                                    break;
                                case "bufferView":
                                    i = this._invokeOne((function(t) { return t.loadBufferView && t.loadBufferView(e) }));
                                    break;
                                case "buffer":
                                    i = this.loadBuffer(e);
                                    break;
                                case "material":
                                    i = this._invokeOne((function(t) { return t.loadMaterial && t.loadMaterial(e) }));
                                    break;
                                case "texture":
                                    i = this._invokeOne((function(t) { return t.loadTexture && t.loadTexture(e) }));
                                    break;
                                case "skin":
                                    i = this.loadSkin(e);
                                    break;
                                case "animation":
                                    i = this.loadAnimation(e);
                                    break;
                                case "camera":
                                    i = this.loadCamera(e);
                                    break;
                                default:
                                    throw new Error("Unknown type: " + t)
                            }
                            this.cache.add(n, i)
                        }
                        return i
                    }
                    getDependencies(t) {
                        let e = this.cache.get(t);
                        if (!e) {
                            const n = this,
                                i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
                            e = Promise.all(i.map((function(e, i) { return n.getDependency(t, i) }))), this.cache.add(t, e)
                        }
                        return e
                    }
                    loadBuffer(t) {
                        const e = this.json.buffers[t],
                            n = this.fileLoader;
                        if (e.type && "arraybuffer" !== e.type) throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
                        if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[Xv.KHR_BINARY_GLTF].body);
                        const i = this.options;
                        return new Promise((function(t, r) { n.load(gy(e.uri, i.path), t, void 0, (function() { r(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".')) })) }))
                    }
                    loadBufferView(t) {
                        const e = this.json.bufferViews[t];
                        return this.getDependency("buffer", e.buffer).then((function(t) {
                            const n = e.byteLength || 0,
                                i = e.byteOffset || 0;
                            return t.slice(i, i + n)
                        }))
                    }
                    loadAccessor(t) {
                        const e = this,
                            n = this.json,
                            i = this.json.accessors[t];
                        if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null);
                        const r = [];
                        return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then((function(t) {
                            const r = t[0],
                                s = dy[i.type],
                                o = cy[i.componentType],
                                a = o.BYTES_PER_ELEMENT,
                                l = a * s,
                                c = i.byteOffset || 0,
                                h = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
                                u = !0 === i.normalized;
                            let d, p;
                            if (h && h !== l) {
                                const t = Math.floor(c / h),
                                    n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + t + ":" + i.count;
                                let l = e.cache.get(n);
                                l || (d = new o(r, t * h, i.count * h / a), l = new ll(d, h / a), e.cache.add(n, l)), p = new hl(l, s, c % h / a, u)
                            } else d = null === r ? new o(i.count * s) : new o(r, c, i.count * s), p = new Fr(d, s, u);
                            if (void 0 !== i.sparse) {
                                const e = dy.SCALAR,
                                    n = cy[i.sparse.indices.componentType],
                                    a = i.sparse.indices.byteOffset || 0,
                                    l = i.sparse.values.byteOffset || 0,
                                    c = new n(t[1], a, i.sparse.count * e),
                                    h = new o(t[2], l, i.sparse.count * s);
                                null !== r && (p = new Fr(p.array.slice(), p.itemSize, p.normalized));
                                for (let t = 0, e = c.length; t < e; t++) { const e = c[t]; if (p.setX(e, h[t * s]), s >= 2 && p.setY(e, h[t * s + 1]), s >= 3 && p.setZ(e, h[t * s + 2]), s >= 4 && p.setW(e, h[t * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") }
                            }
                            return p
                        }))
                    }
                    loadTexture(t) {
                        const e = this.json,
                            n = this.options,
                            i = e.textures[t],
                            r = e.images[i.source];
                        let s = this.textureLoader;
                        if (r.uri) {
                            const t = n.manager.getHandler(r.uri);
                            null !== t && (s = t)
                        }
                        return this.loadTextureImage(t, r, s)
                    }
                    loadTextureImage(t, e, n) {
                        const i = this,
                            r = this.json,
                            s = this.options,
                            o = r.textures[t],
                            a = (e.uri || e.bufferView) + ":" + o.sampler;
                        if (this.textureCache[a]) return this.textureCache[a];
                        const l = self.URL || self.webkitURL;
                        let c = e.uri || "",
                            h = !1,
                            u = !0;
                        const d = c.search(/\.jpe?g($|\?)/i) > 0 || 0 === c.search(/^data\:image\/jpeg/);
                        if (("image/jpeg" === e.mimeType || d) && (u = !1), void 0 !== e.bufferView) c = i.getDependency("bufferView", e.bufferView).then((function(t) {
                            if ("image/png" === e.mimeType) {
                                const e = new DataView(t, 25, 1).getUint8(0, !1);
                                u = 6 === e || 4 === e || 3 === e
                            }
                            h = !0;
                            const n = new Blob([t], { type: e.mimeType });
                            return c = l.createObjectURL(n), c
                        }));
                        else if (void 0 === e.uri) throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
                        const p = Promise.resolve(c).then((function(t) {
                            return new Promise((function(e, i) {
                                let r = e;
                                !0 === n.isImageBitmapLoader && (r = function(t) {
                                    const n = new ri(t);
                                    n.needsUpdate = !0, e(n)
                                }), n.load(gy(t, s.path), r, void 0, i)
                            }))
                        })).then((function(e) {!0 === h && l.revokeObjectURL(c), e.flipY = !1, o.name && (e.name = o.name), u || (e.format = kt); const n = (r.samplers || {})[o.sampler] || {}; return e.magFilter = hy[n.magFilter] || Mt, e.minFilter = hy[n.minFilter] || Et, e.wrapS = uy[n.wrapS] || ft, e.wrapT = uy[n.wrapT] || ft, i.associations.set(e, { type: "textures", index: t }), e })).catch((function() { return console.error("THREE.GLTFLoader: Couldn't load texture", c), null }));
                        return this.textureCache[a] = p, p
                    }
                    assignTexture(t, e, n) {
                        const i = this;
                        return this.getDependency("texture", n.index).then((function(r) {
                            if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === e && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + e + " not yet supported."), i.extensions[Xv.KHR_TEXTURE_TRANSFORM]) {
                                const t = void 0 !== n.extensions ? n.extensions[Xv.KHR_TEXTURE_TRANSFORM] : void 0;
                                if (t) {
                                    const e = i.associations.get(r);
                                    r = i.extensions[Xv.KHR_TEXTURE_TRANSFORM].extendTexture(r, t), i.associations.set(r, e)
                                }
                            }
                            t[e] = r
                        }))
                    }
                    assignFinalMaterial(t) {
                        const e = t.geometry;
                        let n = t.material;
                        const i = void 0 !== e.attributes.tangent,
                            r = void 0 !== e.attributes.color,
                            s = void 0 === e.attributes.normal,
                            o = Object.keys(e.morphAttributes).length > 0,
                            a = o && void 0 !== e.morphAttributes.normal;
                        if (t.isPoints) {
                            const t = "PointsMaterial:" + n.uuid;
                            let e = this.cache.get(t);
                            e || (e = new ic, Er.prototype.copy.call(e, n), e.color.copy(n.color), e.map = n.map, e.sizeAttenuation = !1, this.cache.add(t, e)), n = e
                        } else if (t.isLine) {
                            const t = "LineBasicMaterial:" + n.uuid;
                            let e = this.cache.get(t);
                            e || (e = new ql, Er.prototype.copy.call(e, n), e.color.copy(n.color), this.cache.add(t, e)), n = e
                        }
                        if (i || r || s || o) {
                            let t = "ClonedMaterial:" + n.uuid + ":";
                            n.isGLTFSpecularGlossinessMaterial && (t += "specular-glossiness:"), i && (t += "vertex-tangents:"), r && (t += "vertex-colors:"), s && (t += "flat-shading:"), o && (t += "morph-targets:"), a && (t += "morph-normals:");
                            let e = this.cache.get(t);
                            e || (e = n.clone(), r && (e.vertexColors = !0), s && (e.flatShading = !0), o && (e.morphTargets = !0), a && (e.morphNormals = !0), i && (e.vertexTangents = !0, e.normalScale && (e.normalScale.y *= -1), e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)), this.cache.add(t, e), this.associations.set(e, this.associations.get(n))), n = e
                        }
                        n.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv), t.material = n
                    }
                    getMaterialType() { return Bh }
                    loadMaterial(t) {
                        const e = this,
                            n = this.json,
                            i = this.extensions,
                            r = n.materials[t];
                        let s;
                        const o = {},
                            a = r.extensions || {},
                            l = [];
                        if (a[Xv.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                            const t = i[Xv.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                            s = t.getMaterialType(), l.push(t.extendParams(o, r, e))
                        } else if (a[Xv.KHR_MATERIALS_UNLIT]) {
                            const t = i[Xv.KHR_MATERIALS_UNLIT];
                            s = t.getMaterialType(), l.push(t.extendParams(o, r, e))
                        } else {
                            const n = r.pbrMetallicRoughness || {};
                            if (o.color = new Dr(1, 1, 1), o.opacity = 1, Array.isArray(n.baseColorFactor)) {
                                const t = n.baseColorFactor;
                                o.color.fromArray(t), o.opacity = t[3]
                            }
                            void 0 !== n.baseColorTexture && l.push(e.assignTexture(o, "map", n.baseColorTexture)), o.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, o.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (l.push(e.assignTexture(o, "metalnessMap", n.metallicRoughnessTexture)), l.push(e.assignTexture(o, "roughnessMap", n.metallicRoughnessTexture))), s = this._invokeOne((function(e) { return e.getMaterialType && e.getMaterialType(t) })), l.push(Promise.all(this._invokeAll((function(e) { return e.extendMaterialParams && e.extendMaterialParams(t, o) }))))
                        }!0 === r.doubleSided && (o.side = _);
                        const c = r.alphaMode || "OPAQUE";
                        return "BLEND" === c ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, "MASK" === c && (o.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)), void 0 !== r.normalTexture && s !== Nr && (l.push(e.assignTexture(o, "normalMap", r.normalTexture)), o.normalScale = new $n(1, -1), void 0 !== r.normalTexture.scale && o.normalScale.set(r.normalTexture.scale, -r.normalTexture.scale)), void 0 !== r.occlusionTexture && s !== Nr && (l.push(e.assignTexture(o, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (o.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && s !== Nr && (o.emissive = (new Dr).fromArray(r.emissiveFactor)), void 0 !== r.emissiveTexture && s !== Nr && l.push(e.assignTexture(o, "emissiveMap", r.emissiveTexture)), Promise.all(l).then((function() { let n; return n = s === sy ? i[Xv.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o) : new s(o), r.name && (n.name = r.name), n.map && (n.map.encoding = en), n.emissiveMap && (n.emissiveMap.encoding = en), yy(n, r), e.associations.set(n, { type: "materials", index: t }), r.extensions && vy(i, n, r), n }))
                    }
                    createUniqueName(t) { const e = Id.sanitizeNodeName(t || ""); let n = e; for (let t = 1; this.nodeNamesUsed[n]; ++t) n = e + "_" + t; return this.nodeNamesUsed[n] = !0, n }
                    loadGeometries(t) {
                        const e = this,
                            n = this.extensions,
                            i = this.primitiveCache;

                        function r(t) { return n[Xv.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function(n) { return Ty(n, t, e) })) }
                        const s = [];
                        for (let n = 0, o = t.length; n < o; n++) {
                            const o = t[n],
                                a = _y(o),
                                l = i[a];
                            if (l) s.push(l.promise);
                            else {
                                let t;
                                t = o.extensions && o.extensions[Xv.KHR_DRACO_MESH_COMPRESSION] ? r(o) : Ty(new rs, o, e), i[a] = { primitive: o, promise: t }, s.push(t)
                            }
                        }
                        return Promise.all(s)
                    }
                    loadMesh(t) {
                        const e = this,
                            n = this.json,
                            i = this.extensions,
                            r = n.meshes[t],
                            s = r.primitives,
                            o = [];
                        for (let t = 0, e = s.length; t < e; t++) {
                            const e = void 0 === s[t].material ? (void 0 === (a = this.cache).DefaultMaterial && (a.DefaultMaterial = new Bh({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: y })), a.DefaultMaterial) : this.getDependency("material", s[t].material);
                            o.push(e)
                        }
                        var a;
                        return o.push(e.loadGeometries(s)), Promise.all(o).then((function(n) {
                            const o = n.slice(0, n.length - 1),
                                a = n[n.length - 1],
                                l = [];
                            for (let n = 0, c = a.length; n < c; n++) {
                                const c = a[n],
                                    h = s[n];
                                let u;
                                const d = o[n];
                                if (4 === h.mode || 5 === h.mode || 6 === h.mode || void 0 === h.mode) u = !0 === r.isSkinnedMesh ? new Bl(c, d) : new ws(c, d), !0 !== u.isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(), 5 === h.mode ? u.geometry = Ey(u.geometry, Qe) : 6 === h.mode && (u.geometry = Ey(u.geometry, $e));
                                else if (1 === h.mode) u = new ec(c, d);
                                else if (3 === h.mode) u = new Ql(c, d);
                                else if (2 === h.mode) u = new nc(c, d);
                                else {
                                    if (0 !== h.mode) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode);
                                    u = new lc(c, d)
                                }
                                Object.keys(u.geometry.morphAttributes).length > 0 && xy(u, r), u.name = e.createUniqueName(r.name || "mesh_" + t), yy(u, r), h.extensions && vy(i, u, h), e.assignFinalMaterial(u), l.push(u)
                            }
                            if (1 === l.length) return l[0];
                            const c = new Qa;
                            for (let t = 0, e = l.length; t < e; t++) c.add(l[t]);
                            return c
                        }))
                    }
                    loadCamera(t) {
                        let e;
                        const n = this.json.cameras[t],
                            i = n[n.type];
                        if (i) return "perspective" === n.type ? e = new Cs(Qn.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (e = new Du(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (e.name = this.createUniqueName(n.name)), yy(e, n), Promise.resolve(e);
                        console.warn("THREE.GLTFLoader: Missing camera parameters.")
                    }
                    loadSkin(t) {
                        const e = this.json.skins[t],
                            n = { joints: e.joints };
                        return void 0 === e.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", e.inverseBindMatrices).then((function(t) { return n.inverseBindMatrices = t, n }))
                    }
                    loadAnimation(t) {
                        const e = this.json.animations[t],
                            n = [],
                            i = [],
                            r = [],
                            s = [],
                            o = [];
                        for (let t = 0, a = e.channels.length; t < a; t++) {
                            const a = e.channels[t],
                                l = e.samplers[a.sampler],
                                c = a.target,
                                h = void 0 !== c.node ? c.node : c.id,
                                u = void 0 !== e.parameters ? e.parameters[l.input] : l.input,
                                d = void 0 !== e.parameters ? e.parameters[l.output] : l.output;
                            n.push(this.getDependency("node", h)), i.push(this.getDependency("accessor", u)), r.push(this.getDependency("accessor", d)), s.push(l), o.push(c)
                        }
                        return Promise.all([Promise.all(n), Promise.all(i), Promise.all(r), Promise.all(s), Promise.all(o)]).then((function(n) {
                            const i = n[0],
                                r = n[1],
                                s = n[2],
                                o = n[3],
                                a = n[4],
                                l = [];
                            for (let t = 0, e = i.length; t < e; t++) {
                                const e = i[t],
                                    n = r[t],
                                    c = s[t],
                                    h = o[t],
                                    u = a[t];
                                if (void 0 === e) continue;
                                let d;
                                switch (e.updateMatrix(), e.matrixAutoUpdate = !0, my[u.path]) {
                                    case my.weights:
                                        d = Qh;
                                        break;
                                    case my.rotation:
                                        d = tu;
                                        break;
                                    default:
                                        d = nu
                                }
                                const p = e.name ? e.name : e.uuid,
                                    m = void 0 !== h.interpolation ? fy[h.interpolation] : We,
                                    f = [];
                                my[u.path] === my.weights ? e.traverse((function(t) {!0 === t.isMesh && t.morphTargetInfluences && f.push(t.name ? t.name : t.uuid) })) : f.push(p);
                                let g = c.array;
                                if (c.normalized) {
                                    const t = wy(g.constructor),
                                        e = new Float32Array(g.length);
                                    for (let n = 0, i = g.length; n < i; n++) e[n] = g[n] * t;
                                    g = e
                                }
                                for (let t = 0, e = f.length; t < e; t++) { const e = new d(f[t] + "." + my[u.path], n.array, g, m); "CUBICSPLINE" === h.interpolation && (e.createInterpolant = function(t) { return new ly(this.times, this.values, this.getValueSize() / 3, t) }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(e) }
                            }
                            const c = e.name ? e.name : "animation_" + t;
                            return new iu(c, void 0, l)
                        }))
                    }
                    createNodeMesh(t) {
                        const e = this.json,
                            n = this,
                            i = e.nodes[t];
                        return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(t) {
                            const e = n._getNodeRef(n.meshCache, i.mesh, t);
                            return void 0 !== i.weights && e.traverse((function(t) {
                                if (t.isMesh)
                                    for (let e = 0, n = i.weights.length; e < n; e++) t.morphTargetInfluences[e] = i.weights[e]
                            })), e
                        }))
                    }
                    loadNode(t) {
                        const e = this.json,
                            n = this.extensions,
                            i = this,
                            r = e.nodes[t],
                            s = r.name ? i.createUniqueName(r.name) : "";
                        return function() {
                            const e = [],
                                n = i._invokeOne((function(e) { return e.createNodeMesh && e.createNodeMesh(t) }));
                            return n && e.push(n), void 0 !== r.camera && e.push(i.getDependency("camera", r.camera).then((function(t) { return i._getNodeRef(i.cameraCache, r.camera, t) }))), i._invokeAll((function(e) { return e.createNodeAttachment && e.createNodeAttachment(t) })).forEach((function(t) { e.push(t) })), Promise.all(e)
                        }().then((function(e) {
                            let o;
                            if (o = !0 === r.isBone ? new Ol : e.length > 1 ? new Qa : 1 === e.length ? e[0] : new pr, o !== e[0])
                                for (let t = 0, n = e.length; t < n; t++) o.add(e[t]);
                            if (r.name && (o.userData.name = r.name, o.name = s), yy(o, r), r.extensions && vy(n, o, r), void 0 !== r.matrix) {
                                const t = new Gi;
                                t.fromArray(r.matrix), o.applyMatrix4(t)
                            } else void 0 !== r.translation && o.position.fromArray(r.translation), void 0 !== r.rotation && o.quaternion.fromArray(r.rotation), void 0 !== r.scale && o.scale.fromArray(r.scale);
                            return i.associations.set(o, { type: "nodes", index: t }), o
                        }))
                    }
                    loadScene(t) {
                        const e = this.json,
                            n = this.extensions,
                            i = this.json.scenes[t],
                            r = this,
                            s = new Qa;
                        i.name && (s.name = r.createUniqueName(i.name)), yy(s, i), i.extensions && vy(n, s, i);
                        const o = i.nodes || [],
                            a = [];
                        for (let t = 0, n = o.length; t < n; t++) a.push(Sy(o[t], s, e, r));
                        return Promise.all(a).then((function() { return s }))
                    }
                }

                function Sy(t, e, n, i) {
                    const r = n.nodes[t];
                    return i.getDependency("node", t).then((function(t) {
                        if (void 0 === r.skin) return t;
                        let e;
                        return i.getDependency("skin", r.skin).then((function(t) { e = t; const n = []; for (let t = 0, r = e.joints.length; t < r; t++) n.push(i.getDependency("node", e.joints[t])); return Promise.all(n) })).then((function(n) {
                            return t.traverse((function(t) {
                                if (!t.isMesh) return;
                                const i = [],
                                    r = [];
                                for (let t = 0, s = n.length; t < s; t++) {
                                    const s = n[t];
                                    if (s) {
                                        i.push(s);
                                        const n = new Gi;
                                        void 0 !== e.inverseBindMatrices && n.fromArray(e.inverseBindMatrices.array, 16 * t), r.push(n)
                                    } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[t])
                                }
                                t.bind(new Hl(i, r), t.matrixWorld)
                            })), t
                        }))
                    })).then((function(t) {
                        e.add(t);
                        const s = [];
                        if (r.children) {
                            const e = r.children;
                            for (let r = 0, o = e.length; r < o; r++) {
                                const o = e[r];
                                s.push(Sy(o, t, n, i))
                            }
                        }
                        return Promise.all(s)
                    }))
                }

                function Ty(t, e, n) {
                    const i = e.attributes,
                        r = [];

                    function s(e, i) { return n.getDependency("accessor", e).then((function(e) { t.setAttribute(i, e) })) }
                    for (const e in i) {
                        const n = py[e] || e.toLowerCase();
                        n in t.attributes || r.push(s(i[e], n))
                    }
                    if (void 0 !== e.indices && !t.index) {
                        const i = n.getDependency("accessor", e.indices).then((function(e) { t.setIndex(e) }));
                        r.push(i)
                    }
                    return yy(t, e),
                        function(t, e, n) {
                            const i = e.attributes,
                                r = new mi;
                            if (void 0 === i.POSITION) return; {
                                const t = n.json.accessors[i.POSITION],
                                    e = t.min,
                                    s = t.max;
                                if (void 0 === e || void 0 === s) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                                if (r.set(new ui(e[0], e[1], e[2]), new ui(s[0], s[1], s[2])), t.normalized) {
                                    const e = wy(cy[t.componentType]);
                                    r.min.multiplyScalar(e), r.max.multiplyScalar(e)
                                }
                            }
                            const s = e.targets;
                            if (void 0 !== s) {
                                const t = new ui,
                                    e = new ui;
                                for (let i = 0, r = s.length; i < r; i++) {
                                    const r = s[i];
                                    if (void 0 !== r.POSITION) {
                                        const i = n.json.accessors[r.POSITION],
                                            s = i.min,
                                            o = i.max;
                                        if (void 0 !== s && void 0 !== o) {
                                            if (e.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))), e.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))), e.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))), i.normalized) {
                                                const t = wy(cy[i.componentType]);
                                                e.multiplyScalar(t)
                                            }
                                            t.max(e)
                                        } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                                    }
                                }
                                r.expandByVector(t)
                            }
                            t.boundingBox = r;
                            const o = new Di;
                            r.getCenter(o.center), o.radius = r.min.distanceTo(r.max) / 2, t.boundingSphere = o
                        }(t, e, n), Promise.all(r).then((function() {
                            return void 0 !== e.targets ? function(t, e, n) {
                                let i = !1,
                                    r = !1;
                                for (let t = 0, n = e.length; t < n; t++) { const n = e[t]; if (void 0 !== n.POSITION && (i = !0), void 0 !== n.NORMAL && (r = !0), i && r) break }
                                if (!i && !r) return Promise.resolve(t);
                                const s = [],
                                    o = [];
                                for (let a = 0, l = e.length; a < l; a++) {
                                    const l = e[a];
                                    if (i) {
                                        const e = void 0 !== l.POSITION ? n.getDependency("accessor", l.POSITION) : t.attributes.position;
                                        s.push(e)
                                    }
                                    if (r) {
                                        const e = void 0 !== l.NORMAL ? n.getDependency("accessor", l.NORMAL) : t.attributes.normal;
                                        o.push(e)
                                    }
                                }
                                return Promise.all([Promise.all(s), Promise.all(o)]).then((function(e) {
                                    const n = e[0],
                                        s = e[1];
                                    return i && (t.morphAttributes.position = n), r && (t.morphAttributes.normal = s), t.morphTargetsRelative = !0, t
                                }))
                            }(t, e.targets, n) : t
                        }))
                }

                function Ey(t, e) {
                    let n = t.getIndex();
                    if (null === n) {
                        const e = [],
                            i = t.getAttribute("position");
                        if (void 0 === i) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t;
                        for (let t = 0; t < i.count; t++) e.push(t);
                        t.setIndex(e), n = t.getIndex()
                    }
                    const i = n.count - 2,
                        r = [];
                    if (e === $e)
                        for (let t = 1; t <= i; t++) r.push(n.getX(0)), r.push(n.getX(t)), r.push(n.getX(t + 1));
                    else
                        for (let t = 0; t < i; t++) t % 2 == 0 ? (r.push(n.getX(t)), r.push(n.getX(t + 1)), r.push(n.getX(t + 2))) : (r.push(n.getX(t + 2)), r.push(n.getX(t + 1)), r.push(n.getX(t)));
                    r.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                    const s = t.clone();
                    return s.setIndex(r), s
                }
                var Ay = function(t, e, n, i) {
                    return new(n || (n = Promise))((function(r, s) {
                        function o(t) { try { l(i.next(t)) } catch (t) { s(t) } }

                        function a(t) { try { l(i.throw(t)) } catch (t) { s(t) } }

                        function l(t) {
                            var e;
                            t.done ? r(t.value) : (e = t.value, e instanceof n ? e : new n((function(t) { t(e) }))).then(o, a)
                        }
                        l((i = i.apply(t, e || [])).next())
                    }))
                };
                class Ly {
                    constructor(t, e) { this.cache = t, this.textureAnisotropy = e }
                    get fileLoader() { return this._fileLoader || (this._fileLoader = new hu), this._fileLoader }
                    get imageLoader() { return this._imgLoader || (this._imgLoader = new pu), this._imgLoader }
                    get svgLoader() { return this._svgLoader || (this._svgLoader = new km), this._svgLoader }
                    get textureLoader() { return this._textureLoader || (this._textureLoader = new gu), this._textureLoader }
                    get objectLoader() { return this._objectLoader || (this._objectLoader = new ju), this._objectLoader }
                    get gltfLoader() { return this._gltfLoader || (this._gltfLoader = new jv), this._gltfLoader }
                    get fbxLoader() { return this._fbxLoader || (this._fbxLoader = new Ev), this._fbxLoader }
                    preload(t, e) { return Ay(this, void 0, void 0, (function*() { return this.cache.add(t, e), new Promise((t => { const n = /\.fbx$|\.glb$|\.gltf$/.test(e); /\.jpe?g$|\.png$/.test(e) ? this.textureLoader.load(e, (e => t(e))) : (n && this.fileLoader.setResponseType("arraybuffer"), this.fileLoader.load(e, (e => t(e)))) })) })) }
                    textureAtlas(t, e, n = "JSONHash") {
                        return Ay(this, void 0, void 0, (function*() {
                            let n = JSON.parse(yield this.file(e));
                            if (n.textures) {
                                const t = n.textures[0].frames;
                                let e = { frames: {} };
                                t.forEach((t => {
                                    e = Object.assign(Object.assign({}, e), {
                                        frames: Object.assign(Object.assign({}, e.frames), {
                                            [t.filename]: { frame: t.frame, rotated: t.rotated, sourceSize: t.sourceSize, spriteSourceSize: t.spriteSourceSize, trimmed: t.trimmed }
                                        })
                                    })
                                })), n = e
                            }
                            return { texture: yield this.texture(t), json: n }
                        }))
                    }
                    file(t) { const e = this.cache.get(t); return t = e || t, new Promise((e => { this.fileLoader.load(t, (t => e(t))) })) }
                    svg(t) { const e = this.cache.get(t); return t = e || t, new Promise((e => { this.svgLoader.load(t, (t => e(t))) })) }
                    texture(t) {
                        if (!/^data:image\/[\S]+;base64,/gm.test(t)) {
                            const e = this.cache.get(t);
                            t = e || t
                        }
                        return new Promise((e => { this.textureLoader.load(t, (t => { t.anisotropy = this.textureAnisotropy, t.needsUpdate = !0, e(t) })) }))
                    }
                    object(t) { const e = this.cache.get(t); return t = e || t, new Promise((e => { this.objectLoader.load(t, (t => { e(t) })) })) }
                    gltf(t) { const e = this.cache.get(t); return t = e || t, new Promise((e => { this.gltfLoader.load(t, (t => { e(t) })) })) }
                    fbx(t) { const e = this.cache.get(t); return t = e || t, new Promise((e => { this.fbxLoader.load(t, (t => { e(t) })) })) }
                }
                class Ry extends pr {
                    constructor(t, e, n, i) { super(), this.scene = t, this.light = e, this.size = n, this.color = i, this.geo = new Th(n || .2, 16, 8), this.mat = new Nr({ color: i || e.color }), this.mesh = new ws(this.geo, this.mat), this.add(this.mesh), e.add(this) }
                    dispose() { this.mesh.geometry.dispose(), Array.isArray(this.mesh.material) ? this.mesh.material.forEach((t => t.dispose())) : this.mesh.material.dispose(), this.remove(this.mesh) }
                    update() {}
                }
                class Cy {
                    constructor(t) { this.scene = t }
                    get helper() { return { directionalLightHelper: (t, e, n) => { const i = new pp(t, e, n); return this.scene.add(i), i }, spotLightHelper: (t, e) => { const n = new Kd(t, e); return this.scene.add(n), n }, pointLightHelper: (t, e, n) => new Ry(this.scene, t, e, n) } }
                    directionalLight(t = {}) { const { color: e = 16777215, intensity: n = 1 } = t, i = new Bu(e, n); return i.castShadow = !0, this.scene.add(i), i }
                    hemisphereLight(t = {}) { const { skyColor: e = 16777215, groundColor: n = 16777215, intensity: i = 1 } = t, r = new bu(e, n, i); return this.scene.add(r), r }
                    ambientLight(t = {}) { const { color: e = 16777215, intensity: n = 1 } = t, i = new Ou(e, n); return this.scene.add(i), i }
                    pointLight(t = {}) { const { color: e = 16777215, intensity: n = 1, distance: i = 0, decay: r = 1 } = t, s = new Iu(e, n, i, r); return s.castShadow = !0, this.scene.add(s), s }
                    spotLight(t = {}) { const { color: e = 16777215, intensity: n = 1, distance: i = 0, angle: r = Math.PI / 8, penumbra: s = 0, decay: o = 1 } = t, a = new Au(e, n, i, r, s, o); return a.castShadow = !0, this.scene.add(a), a }
                    rectAreaLight(t = {}) { const { color: e = 16777215, intensity: n = 1, width: i = 10, height: r = 10 } = t, s = new Fu(e, n, i, r); return this.scene.add(s), s }
                }
                const Py = 100,
                    Iy = 1e3,
                    Dy = 1001,
                    Ny = 1002,
                    By = 1003,
                    Oy = 1006,
                    Fy = 1008,
                    zy = 1009,
                    Uy = 1012,
                    Hy = 1014,
                    ky = 1015,
                    Gy = 1016,
                    Vy = 1020,
                    Wy = 1022,
                    jy = 1023,
                    qy = 1026,
                    Xy = 1027,
                    Yy = 2300,
                    Zy = 2301,
                    Jy = 2302,
                    Ky = 2400,
                    Qy = 2401,
                    $y = 2402,
                    tx = 3e3,
                    ex = 7680,
                    nx = 35044,
                    ix = 35048,
                    rx = "300 es";
                class sx {
                    addEventListener(t, e) {
                        void 0 === this._listeners && (this._listeners = {});
                        const n = this._listeners;
                        void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
                    }
                    hasEventListener(t, e) { if (void 0 === this._listeners) return !1; const n = this._listeners; return void 0 !== n[t] && -1 !== n[t].indexOf(e) }
                    removeEventListener(t, e) { if (void 0 === this._listeners) return; const n = this._listeners[t]; if (void 0 !== n) { const t = n.indexOf(e); - 1 !== t && n.splice(t, 1) } }
                    dispatchEvent(t) {
                        if (void 0 === this._listeners) return;
                        const e = this._listeners[t.type];
                        if (void 0 !== e) {
                            t.target = this;
                            const n = e.slice(0);
                            for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
                            t.target = null
                        }
                    }
                }
                const ox = [];
                for (let t = 0; t < 256; t++) ox[t] = (t < 16 ? "0" : "") + t.toString(16);
                let ax = 1234567;
                const lx = Math.PI / 180,
                    cx = 180 / Math.PI;

                function hx() {
                    const t = 4294967295 * Math.random() | 0,
                        e = 4294967295 * Math.random() | 0,
                        n = 4294967295 * Math.random() | 0,
                        i = 4294967295 * Math.random() | 0;
                    return (ox[255 & t] + ox[t >> 8 & 255] + ox[t >> 16 & 255] + ox[t >> 24 & 255] + "-" + ox[255 & e] + ox[e >> 8 & 255] + "-" + ox[e >> 16 & 15 | 64] + ox[e >> 24 & 255] + "-" + ox[63 & n | 128] + ox[n >> 8 & 255] + "-" + ox[n >> 16 & 255] + ox[n >> 24 & 255] + ox[255 & i] + ox[i >> 8 & 255] + ox[i >> 16 & 255] + ox[i >> 24 & 255]).toUpperCase()
                }

                function ux(t, e, n) { return Math.max(e, Math.min(n, t)) }

                function dx(t, e) { return (t % e + e) % e }

                function px(t, e, n) { return (1 - n) * t + n * e }

                function mx(t) { return 0 == (t & t - 1) && 0 !== t }

                function fx(t) { return Math.pow(2, Math.floor(Math.log(t) / Math.LN2)) }
                var gx = Object.freeze({
                    __proto__: null,
                    DEG2RAD: lx,
                    RAD2DEG: cx,
                    generateUUID: hx,
                    clamp: ux,
                    euclideanModulo: dx,
                    mapLinear: function(t, e, n, i, r) { return i + (t - e) * (r - i) / (n - e) },
                    inverseLerp: function(t, e, n) { return t !== e ? (n - t) / (e - t) : 0 },
                    lerp: px,
                    damp: function(t, e, n, i) { return px(t, e, 1 - Math.exp(-n * i)) },
                    pingpong: function(t, e = 1) { return e - Math.abs(dx(t, 2 * e) - e) },
                    smoothstep: function(t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t) },
                    smootherstep: function(t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10) },
                    randInt: function(t, e) { return t + Math.floor(Math.random() * (e - t + 1)) },
                    randFloat: function(t, e) { return t + Math.random() * (e - t) },
                    randFloatSpread: function(t) { return t * (.5 - Math.random()) },
                    seededRandom: function(t) { return void 0 !== t && (ax = t % 2147483647), ax = 16807 * ax % 2147483647, (ax - 1) / 2147483646 },
                    degToRad: function(t) { return t * lx },
                    radToDeg: function(t) { return t * cx },
                    isPowerOfTwo: mx,
                    ceilPowerOfTwo: function(t) { return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)) },
                    floorPowerOfTwo: fx,
                    setQuaternionFromProperEuler: function(t, e, n, i, r) {
                        const s = Math.cos,
                            o = Math.sin,
                            a = s(n / 2),
                            l = o(n / 2),
                            c = s((e + i) / 2),
                            h = o((e + i) / 2),
                            u = s((e - i) / 2),
                            d = o((e - i) / 2),
                            p = s((i - e) / 2),
                            m = o((i - e) / 2);
                        switch (r) {
                            case "XYX":
                                t.set(a * h, l * u, l * d, a * c);
                                break;
                            case "YZY":
                                t.set(l * d, a * h, l * u, a * c);
                                break;
                            case "ZXZ":
                                t.set(l * u, l * d, a * h, a * c);
                                break;
                            case "XZX":
                                t.set(a * h, l * m, l * p, a * c);
                                break;
                            case "YXY":
                                t.set(l * p, a * h, l * m, a * c);
                                break;
                            case "ZYZ":
                                t.set(l * m, l * p, a * h, a * c);
                                break;
                            default:
                                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                        }
                    }
                });
                class vx {
                    constructor(t = 0, e = 0) { this.x = t, this.y = e }
                    get width() { return this.x }
                    set width(t) { this.x = t }
                    get height() { return this.y }
                    set height(t) { this.y = t }
                    set(t, e) { return this.x = t, this.y = e, this }
                    setScalar(t) { return this.x = t, this.y = t, this }
                    setX(t) { return this.x = t, this }
                    setY(t) { return this.y = t, this }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() { return new this.constructor(this.x, this.y) }
                    copy(t) { return this.x = t.x, this.y = t.y, this }
                    add(t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this) }
                    addScalar(t) { return this.x += t, this.y += t, this }
                    addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this }
                    addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this }
                    sub(t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this) }
                    subScalar(t) { return this.x -= t, this.y -= t, this }
                    subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this }
                    multiply(t) { return this.x *= t.x, this.y *= t.y, this }
                    multiplyScalar(t) { return this.x *= t, this.y *= t, this }
                    divide(t) { return this.x /= t.x, this.y /= t.y, this }
                    divideScalar(t) { return this.multiplyScalar(1 / t) }
                    applyMatrix3(t) {
                        const e = this.x,
                            n = this.y,
                            i = t.elements;
                        return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
                    }
                    min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this }
                    max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this }
                    clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this }
                    clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this }
                    clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }
                    floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }
                    ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }
                    round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }
                    roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this }
                    negate() { return this.x = -this.x, this.y = -this.y, this }
                    dot(t) { return this.x * t.x + this.y * t.y }
                    cross(t) { return this.x * t.y - this.y * t.x }
                    lengthSq() { return this.x * this.x + this.y * this.y }
                    length() { return Math.sqrt(this.x * this.x + this.y * this.y) }
                    manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) }
                    normalize() { return this.divideScalar(this.length() || 1) }
                    angle() { return Math.atan2(-this.y, -this.x) + Math.PI }
                    distanceTo(t) { return Math.sqrt(this.distanceToSquared(t)) }
                    distanceToSquared(t) {
                        const e = this.x - t.x,
                            n = this.y - t.y;
                        return e * e + n * n
                    }
                    manhattanDistanceTo(t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) }
                    setLength(t) { return this.normalize().multiplyScalar(t) }
                    lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this }
                    lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this }
                    equals(t) { return t.x === this.x && t.y === this.y }
                    fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this }
                    toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t }
                    fromBufferAttribute(t, e, n) { return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this }
                    rotateAround(t, e) {
                        const n = Math.cos(e),
                            i = Math.sin(e),
                            r = this.x - t.x,
                            s = this.y - t.y;
                        return this.x = r * n - s * i + t.x, this.y = r * i + s * n + t.y, this
                    }
                    random() { return this.x = Math.random(), this.y = Math.random(), this }
                }
                vx.prototype.isVector2 = !0;
                class yx {
                    constructor() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") }
                    set(t, e, n, i, r, s, o, a, l) { const c = this.elements; return c[0] = t, c[1] = i, c[2] = o, c[3] = e, c[4] = r, c[5] = a, c[6] = n, c[7] = s, c[8] = l, this }
                    identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this }
                    copy(t) {
                        const e = this.elements,
                            n = t.elements;
                        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
                    }
                    extractBasis(t, e, n) { return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this }
                    setFromMatrix4(t) { const e = t.elements; return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this }
                    multiply(t) { return this.multiplyMatrices(this, t) }
                    premultiply(t) { return this.multiplyMatrices(t, this) }
                    multiplyMatrices(t, e) {
                        const n = t.elements,
                            i = e.elements,
                            r = this.elements,
                            s = n[0],
                            o = n[3],
                            a = n[6],
                            l = n[1],
                            c = n[4],
                            h = n[7],
                            u = n[2],
                            d = n[5],
                            p = n[8],
                            m = i[0],
                            f = i[3],
                            g = i[6],
                            v = i[1],
                            y = i[4],
                            x = i[7],
                            _ = i[2],
                            b = i[5],
                            w = i[8];
                        return r[0] = s * m + o * v + a * _, r[3] = s * f + o * y + a * b, r[6] = s * g + o * x + a * w, r[1] = l * m + c * v + h * _, r[4] = l * f + c * y + h * b, r[7] = l * g + c * x + h * w, r[2] = u * m + d * v + p * _, r[5] = u * f + d * y + p * b, r[8] = u * g + d * x + p * w, this
                    }
                    multiplyScalar(t) { const e = this.elements; return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this }
                    determinant() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            i = t[2],
                            r = t[3],
                            s = t[4],
                            o = t[5],
                            a = t[6],
                            l = t[7],
                            c = t[8];
                        return e * s * c - e * o * l - n * r * c + n * o * a + i * r * l - i * s * a
                    }
                    invert() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            i = t[2],
                            r = t[3],
                            s = t[4],
                            o = t[5],
                            a = t[6],
                            l = t[7],
                            c = t[8],
                            h = c * s - o * l,
                            u = o * a - c * r,
                            d = l * r - s * a,
                            p = e * h + n * u + i * d;
                        if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const m = 1 / p;
                        return t[0] = h * m, t[1] = (i * l - c * n) * m, t[2] = (o * n - i * s) * m, t[3] = u * m, t[4] = (c * e - i * a) * m, t[5] = (i * r - o * e) * m, t[6] = d * m, t[7] = (n * a - l * e) * m, t[8] = (s * e - n * r) * m, this
                    }
                    transpose() { let t; const e = this.elements; return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this }
                    getNormalMatrix(t) { return this.setFromMatrix4(t).invert().transpose() }
                    transposeIntoArray(t) { const e = this.elements; return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this }
                    setUvTransform(t, e, n, i, r, s, o) {
                        const a = Math.cos(r),
                            l = Math.sin(r);
                        return this.set(n * a, n * l, -n * (a * s + l * o) + s + t, -i * l, i * a, -i * (-l * s + a * o) + o + e, 0, 0, 1), this
                    }
                    scale(t, e) { const n = this.elements; return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this }
                    rotate(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t),
                            i = this.elements,
                            r = i[0],
                            s = i[3],
                            o = i[6],
                            a = i[1],
                            l = i[4],
                            c = i[7];
                        return i[0] = e * r + n * a, i[3] = e * s + n * l, i[6] = e * o + n * c, i[1] = -n * r + e * a, i[4] = -n * s + e * l, i[7] = -n * o + e * c, this
                    }
                    translate(t, e) { const n = this.elements; return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this }
                    equals(t) {
                        const e = this.elements,
                            n = t.elements;
                        for (let t = 0; t < 9; t++)
                            if (e[t] !== n[t]) return !1;
                        return !0
                    }
                    fromArray(t, e = 0) { for (let n = 0; n < 9; n++) this.elements[n] = t[n + e]; return this }
                    toArray(t = [], e = 0) { const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t }
                    clone() { return (new this.constructor).fromArray(this.elements) }
                }
                let xx;
                yx.prototype.isMatrix3 = !0;
                class _x {
                    static getDataURL(t) {
                        if (/^data:/i.test(t.src)) return t.src;
                        if ("undefined" == typeof HTMLCanvasElement) return t.src;
                        let e;
                        if (t instanceof HTMLCanvasElement) e = t;
                        else {
                            void 0 === xx && (xx = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), xx.width = t.width, xx.height = t.height;
                            const n = xx.getContext("2d");
                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = xx
                        }
                        return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
                    }
                }
                let bx = 0;
                class wx extends sx {
                    constructor(t = wx.DEFAULT_IMAGE, e = wx.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, s = 1008, o = 1023, a = 1009, l = 1, c = 3e3) { super(), Object.defineProperty(this, "id", { value: bx++ }), this.uuid = hx(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new vx(0, 0), this.repeat = new vx(1, 1), this.center = new vx(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new yx, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.version = 0, this.onUpdate = null }
                    updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t;
                        if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                        const n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
                        if (void 0 !== this.image) {
                            const i = this.image;
                            if (void 0 === i.uuid && (i.uuid = hx()), !e && void 0 === t.images[i.uuid]) {
                                let e;
                                if (Array.isArray(i)) { e = []; for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(Mx(i[t].image)) : e.push(Mx(i[t])) } else e = Mx(i);
                                t.images[i.uuid] = { uuid: i.uuid, url: e }
                            }
                            n.image = i.uuid
                        }
                        return e || (t.textures[this.uuid] = n), n
                    }
                    dispose() { this.dispatchEvent({ type: "dispose" }) }
                    transformUv(t) {
                        if (300 !== this.mapping) return t;
                        if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                            case Iy:
                                t.x = t.x - Math.floor(t.x);
                                break;
                            case Dy:
                                t.x = t.x < 0 ? 0 : 1;
                                break;
                            case Ny:
                                1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                        }
                        if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                            case Iy:
                                t.y = t.y - Math.floor(t.y);
                                break;
                            case Dy:
                                t.y = t.y < 0 ? 0 : 1;
                                break;
                            case Ny:
                                1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                        }
                        return this.flipY && (t.y = 1 - t.y), t
                    }
                    set needsUpdate(t) {!0 === t && this.version++ }
                }

                function Mx(t) { return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? _x.getDataURL(t) : t.data ? { data: Array.prototype.slice.call(t.data), width: t.width, height: t.height, type: t.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) }
                wx.DEFAULT_IMAGE = void 0, wx.DEFAULT_MAPPING = 300, wx.prototype.isTexture = !0;
                class Sx {
                    constructor(t = 0, e = 0, n = 0, i = 1) { this.x = t, this.y = e, this.z = n, this.w = i }
                    get width() { return this.z }
                    set width(t) { this.z = t }
                    get height() { return this.w }
                    set height(t) { this.w = t }
                    set(t, e, n, i) { return this.x = t, this.y = e, this.z = n, this.w = i, this }
                    setScalar(t) { return this.x = t, this.y = t, this.z = t, this.w = t, this }
                    setX(t) { return this.x = t, this }
                    setY(t) { return this.y = t, this }
                    setZ(t) { return this.z = t, this }
                    setW(t) { return this.w = t, this }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            case 3:
                                this.w = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            case 3:
                                return this.w;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() { return new this.constructor(this.x, this.y, this.z, this.w) }
                    copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this }
                    add(t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this) }
                    addScalar(t) { return this.x += t, this.y += t, this.z += t, this.w += t, this }
                    addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this }
                    addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this }
                    sub(t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this) }
                    subScalar(t) { return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this }
                    subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this }
                    multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this }
                    multiplyScalar(t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this }
                    applyMatrix4(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = this.w,
                            s = t.elements;
                        return this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r, this
                    }
                    divideScalar(t) { return this.multiplyScalar(1 / t) }
                    setAxisAngleFromQuaternion(t) { this.w = 2 * Math.acos(t.w); const e = Math.sqrt(1 - t.w * t.w); return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this }
                    setAxisAngleFromRotationMatrix(t) {
                        let e, n, i, r;
                        const s = .01,
                            o = .1,
                            a = t.elements,
                            l = a[0],
                            c = a[4],
                            h = a[8],
                            u = a[1],
                            d = a[5],
                            p = a[9],
                            m = a[2],
                            f = a[6],
                            g = a[10];
                        if (Math.abs(c - u) < s && Math.abs(h - m) < s && Math.abs(p - f) < s) {
                            if (Math.abs(c + u) < o && Math.abs(h + m) < o && Math.abs(p + f) < o && Math.abs(l + d + g - 3) < o) return this.set(1, 0, 0, 0), this;
                            e = Math.PI;
                            const t = (l + 1) / 2,
                                a = (d + 1) / 2,
                                v = (g + 1) / 2,
                                y = (c + u) / 4,
                                x = (h + m) / 4,
                                _ = (p + f) / 4;
                            return t > a && t > v ? t < s ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(t), i = y / n, r = x / n) : a > v ? a < s ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(a), n = y / i, r = _ / i) : v < s ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(v), n = x / r, i = _ / r), this.set(n, i, r, e), this
                        }
                        let v = Math.sqrt((f - p) * (f - p) + (h - m) * (h - m) + (u - c) * (u - c));
                        return Math.abs(v) < .001 && (v = 1), this.x = (f - p) / v, this.y = (h - m) / v, this.z = (u - c) / v, this.w = Math.acos((l + d + g - 1) / 2), this
                    }
                    min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this }
                    max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this }
                    clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this }
                    clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this }
                    clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }
                    floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this }
                    ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this }
                    round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this }
                    roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this }
                    negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this }
                    dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w }
                    lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }
                    length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }
                    manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) }
                    normalize() { return this.divideScalar(this.length() || 1) }
                    setLength(t) { return this.normalize().multiplyScalar(t) }
                    lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this }
                    lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this }
                    equals(t) { return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w }
                    fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this }
                    toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t }
                    fromBufferAttribute(t, e, n) { return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this }
                    random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this }
                }
                Sx.prototype.isVector4 = !0;
                class Tx extends sx {
                    constructor(t, e, n = {}) { super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new Sx(0, 0, t, e), this.scissorTest = !1, this.viewport = new Sx(0, 0, t, e), this.texture = new wx(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = { width: t, height: e, depth: 1 }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Oy, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null }
                    setTexture(t) { t.image = { width: this.width, height: this.height, depth: this.depth }, this.texture = t }
                    setSize(t, e, n = 1) { this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e) }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { return this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.image = {...this.texture.image }, this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this }
                    dispose() { this.dispatchEvent({ type: "dispose" }) }
                }
                Tx.prototype.isWebGLRenderTarget = !0, class extends Tx {
                    constructor(t, e, n) {
                        super(t, e);
                        const i = this.texture;
                        this.texture = [];
                        for (let t = 0; t < n; t++) this.texture[t] = i.clone()
                    }
                    setSize(t, e, n = 1) {
                        if (this.width !== t || this.height !== e || this.depth !== n) {
                            this.width = t, this.height = e, this.depth = n;
                            for (let i = 0, r = this.texture.length; i < r; i++) this.texture[i].image.width = t, this.texture[i].image.height = e, this.texture[i].image.depth = n;
                            this.dispose()
                        }
                        return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
                    }
                    copy(t) { this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this.texture.length = 0; for (let e = 0, n = t.texture.length; e < n; e++) this.texture[e] = t.texture[e].clone(); return this }
                }.prototype.isWebGLMultipleRenderTargets = !0;
                class Ex extends Tx {
                    constructor(t, e, n) { super(t, e, n), this.samples = 4 }
                    copy(t) { return super.copy.call(this, t), this.samples = t.samples, this }
                }
                Ex.prototype.isWebGLMultisampleRenderTarget = !0;
                class Ax {
                    constructor(t = 0, e = 0, n = 0, i = 1) { this._x = t, this._y = e, this._z = n, this._w = i }
                    static slerp(t, e, n, i) { return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, i) }
                    static slerpFlat(t, e, n, i, r, s, o) {
                        let a = n[i + 0],
                            l = n[i + 1],
                            c = n[i + 2],
                            h = n[i + 3];
                        const u = r[s + 0],
                            d = r[s + 1],
                            p = r[s + 2],
                            m = r[s + 3];
                        if (0 === o) return t[e + 0] = a, t[e + 1] = l, t[e + 2] = c, void(t[e + 3] = h);
                        if (1 === o) return t[e + 0] = u, t[e + 1] = d, t[e + 2] = p, void(t[e + 3] = m);
                        if (h !== m || a !== u || l !== d || c !== p) {
                            let t = 1 - o;
                            const e = a * u + l * d + c * p + h * m,
                                n = e >= 0 ? 1 : -1,
                                i = 1 - e * e;
                            if (i > Number.EPSILON) {
                                const r = Math.sqrt(i),
                                    s = Math.atan2(r, e * n);
                                t = Math.sin(t * s) / r, o = Math.sin(o * s) / r
                            }
                            const r = o * n;
                            if (a = a * t + u * r, l = l * t + d * r, c = c * t + p * r, h = h * t + m * r, t === 1 - o) {
                                const t = 1 / Math.sqrt(a * a + l * l + c * c + h * h);
                                a *= t, l *= t, c *= t, h *= t
                            }
                        }
                        t[e] = a, t[e + 1] = l, t[e + 2] = c, t[e + 3] = h
                    }
                    static multiplyQuaternionsFlat(t, e, n, i, r, s) {
                        const o = n[i],
                            a = n[i + 1],
                            l = n[i + 2],
                            c = n[i + 3],
                            h = r[s],
                            u = r[s + 1],
                            d = r[s + 2],
                            p = r[s + 3];
                        return t[e] = o * p + c * h + a * d - l * u, t[e + 1] = a * p + c * u + l * h - o * d, t[e + 2] = l * p + c * d + o * u - a * h, t[e + 3] = c * p - o * h - a * u - l * d, t
                    }
                    get x() { return this._x }
                    set x(t) { this._x = t, this._onChangeCallback() }
                    get y() { return this._y }
                    set y(t) { this._y = t, this._onChangeCallback() }
                    get z() { return this._z }
                    set z(t) { this._z = t, this._onChangeCallback() }
                    get w() { return this._w }
                    set w(t) { this._w = t, this._onChangeCallback() }
                    set(t, e, n, i) { return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this }
                    clone() { return new this.constructor(this._x, this._y, this._z, this._w) }
                    copy(t) { return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this }
                    setFromEuler(t, e) {
                        if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                        const n = t._x,
                            i = t._y,
                            r = t._z,
                            s = t._order,
                            o = Math.cos,
                            a = Math.sin,
                            l = o(n / 2),
                            c = o(i / 2),
                            h = o(r / 2),
                            u = a(n / 2),
                            d = a(i / 2),
                            p = a(r / 2);
                        switch (s) {
                            case "XYZ":
                                this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                                break;
                            case "YXZ":
                                this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                                break;
                            case "ZXY":
                                this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                                break;
                            case "ZYX":
                                this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                                break;
                            case "YZX":
                                this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p;
                                break;
                            case "XZY":
                                this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p;
                                break;
                            default:
                                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                        }
                        return !1 !== e && this._onChangeCallback(), this
                    }
                    setFromAxisAngle(t, e) {
                        const n = e / 2,
                            i = Math.sin(n);
                        return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
                    }
                    setFromRotationMatrix(t) {
                        const e = t.elements,
                            n = e[0],
                            i = e[4],
                            r = e[8],
                            s = e[1],
                            o = e[5],
                            a = e[9],
                            l = e[2],
                            c = e[6],
                            h = e[10],
                            u = n + o + h;
                        if (u > 0) {
                            const t = .5 / Math.sqrt(u + 1);
                            this._w = .25 / t, this._x = (c - a) * t, this._y = (r - l) * t, this._z = (s - i) * t
                        } else if (n > o && n > h) {
                            const t = 2 * Math.sqrt(1 + n - o - h);
                            this._w = (c - a) / t, this._x = .25 * t, this._y = (i + s) / t, this._z = (r + l) / t
                        } else if (o > h) {
                            const t = 2 * Math.sqrt(1 + o - n - h);
                            this._w = (r - l) / t, this._x = (i + s) / t, this._y = .25 * t, this._z = (a + c) / t
                        } else {
                            const t = 2 * Math.sqrt(1 + h - n - o);
                            this._w = (s - i) / t, this._x = (r + l) / t, this._y = (a + c) / t, this._z = .25 * t
                        }
                        return this._onChangeCallback(), this
                    }
                    setFromUnitVectors(t, e) { let n = t.dot(e) + 1; return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize() }
                    angleTo(t) { return 2 * Math.acos(Math.abs(ux(this.dot(t), -1, 1))) }
                    rotateTowards(t, e) { const n = this.angleTo(t); if (0 === n) return this; const i = Math.min(1, e / n); return this.slerp(t, i), this }
                    identity() { return this.set(0, 0, 0, 1) }
                    invert() { return this.conjugate() }
                    conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this }
                    dot(t) { return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w }
                    lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w }
                    length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) }
                    normalize() { let t = this.length(); return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this }
                    multiply(t, e) { return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t) }
                    premultiply(t) { return this.multiplyQuaternions(t, this) }
                    multiplyQuaternions(t, e) {
                        const n = t._x,
                            i = t._y,
                            r = t._z,
                            s = t._w,
                            o = e._x,
                            a = e._y,
                            l = e._z,
                            c = e._w;
                        return this._x = n * c + s * o + i * l - r * a, this._y = i * c + s * a + r * o - n * l, this._z = r * c + s * l + n * a - i * o, this._w = s * c - n * o - i * a - r * l, this._onChangeCallback(), this
                    }
                    slerp(t, e) {
                        if (0 === e) return this;
                        if (1 === e) return this.copy(t);
                        const n = this._x,
                            i = this._y,
                            r = this._z,
                            s = this._w;
                        let o = s * t._w + n * t._x + i * t._y + r * t._z;
                        if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this;
                        const a = 1 - o * o;
                        if (a <= Number.EPSILON) { const t = 1 - e; return this._w = t * s + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this }
                        const l = Math.sqrt(a),
                            c = Math.atan2(l, o),
                            h = Math.sin((1 - e) * c) / l,
                            u = Math.sin(e * c) / l;
                        return this._w = s * h + this._w * u, this._x = n * h + this._x * u, this._y = i * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this
                    }
                    slerpQuaternions(t, e, n) { this.copy(t).slerp(e, n) }
                    equals(t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w }
                    fromArray(t, e = 0) { return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this }
                    toArray(t = [], e = 0) { return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t }
                    fromBufferAttribute(t, e) { return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this }
                    _onChange(t) { return this._onChangeCallback = t, this }
                    _onChangeCallback() {}
                }
                Ax.prototype.isQuaternion = !0;
                class Lx {
                    constructor(t = 0, e = 0, n = 0) { this.x = t, this.y = e, this.z = n }
                    set(t, e, n) { return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this }
                    setScalar(t) { return this.x = t, this.y = t, this.z = t, this }
                    setX(t) { return this.x = t, this }
                    setY(t) { return this.y = t, this }
                    setZ(t) { return this.z = t, this }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() { return new this.constructor(this.x, this.y, this.z) }
                    copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this }
                    add(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this) }
                    addScalar(t) { return this.x += t, this.y += t, this.z += t, this }
                    addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this }
                    addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this }
                    sub(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) }
                    subScalar(t) { return this.x -= t, this.y -= t, this.z -= t, this }
                    subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this }
                    multiply(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this) }
                    multiplyScalar(t) { return this.x *= t, this.y *= t, this.z *= t, this }
                    multiplyVectors(t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this }
                    applyEuler(t) { return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Cx.setFromEuler(t)) }
                    applyAxisAngle(t, e) { return this.applyQuaternion(Cx.setFromAxisAngle(t, e)) }
                    applyMatrix3(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.elements;
                        return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
                    }
                    applyNormalMatrix(t) { return this.applyMatrix3(t).normalize() }
                    applyMatrix4(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.elements,
                            s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                        return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s, this
                    }
                    applyQuaternion(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.x,
                            s = t.y,
                            o = t.z,
                            a = t.w,
                            l = a * e + s * i - o * n,
                            c = a * n + o * e - r * i,
                            h = a * i + r * n - s * e,
                            u = -r * e - s * n - o * i;
                        return this.x = l * a + u * -r + c * -o - h * -s, this.y = c * a + u * -s + h * -r - l * -o, this.z = h * a + u * -o + l * -s - c * -r, this
                    }
                    project(t) { return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix) }
                    unproject(t) { return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld) }
                    transformDirection(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.elements;
                        return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
                    }
                    divide(t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this }
                    divideScalar(t) { return this.multiplyScalar(1 / t) }
                    min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this }
                    max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this }
                    clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this }
                    clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this }
                    clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }
                    floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this }
                    ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this }
                    round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this }
                    roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this }
                    negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }
                    dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z }
                    lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z }
                    length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }
                    manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }
                    normalize() { return this.divideScalar(this.length() || 1) }
                    setLength(t) { return this.normalize().multiplyScalar(t) }
                    lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this }
                    lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this }
                    cross(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t) }
                    crossVectors(t, e) {
                        const n = t.x,
                            i = t.y,
                            r = t.z,
                            s = e.x,
                            o = e.y,
                            a = e.z;
                        return this.x = i * a - r * o, this.y = r * s - n * a, this.z = n * o - i * s, this
                    }
                    projectOnVector(t) { const e = t.lengthSq(); if (0 === e) return this.set(0, 0, 0); const n = t.dot(this) / e; return this.copy(t).multiplyScalar(n) }
                    projectOnPlane(t) { return Rx.copy(this).projectOnVector(t), this.sub(Rx) }
                    reflect(t) { return this.sub(Rx.copy(t).multiplyScalar(2 * this.dot(t))) }
                    angleTo(t) { const e = Math.sqrt(this.lengthSq() * t.lengthSq()); if (0 === e) return Math.PI / 2; const n = this.dot(t) / e; return Math.acos(ux(n, -1, 1)) }
                    distanceTo(t) { return Math.sqrt(this.distanceToSquared(t)) }
                    distanceToSquared(t) {
                        const e = this.x - t.x,
                            n = this.y - t.y,
                            i = this.z - t.z;
                        return e * e + n * n + i * i
                    }
                    manhattanDistanceTo(t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z) }
                    setFromSpherical(t) { return this.setFromSphericalCoords(t.radius, t.phi, t.theta) }
                    setFromSphericalCoords(t, e, n) { const i = Math.sin(e) * t; return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this }
                    setFromCylindrical(t) { return this.setFromCylindricalCoords(t.radius, t.theta, t.y) }
                    setFromCylindricalCoords(t, e, n) { return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this }
                    setFromMatrixPosition(t) { const e = t.elements; return this.x = e[12], this.y = e[13], this.z = e[14], this }
                    setFromMatrixScale(t) {
                        const e = this.setFromMatrixColumn(t, 0).length(),
                            n = this.setFromMatrixColumn(t, 1).length(),
                            i = this.setFromMatrixColumn(t, 2).length();
                        return this.x = e, this.y = n, this.z = i, this
                    }
                    setFromMatrixColumn(t, e) { return this.fromArray(t.elements, 4 * e) }
                    setFromMatrix3Column(t, e) { return this.fromArray(t.elements, 3 * e) }
                    equals(t) { return t.x === this.x && t.y === this.y && t.z === this.z }
                    fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this }
                    toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t }
                    fromBufferAttribute(t, e, n) { return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this }
                    random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this }
                }
                Lx.prototype.isVector3 = !0;
                const Rx = new Lx,
                    Cx = new Ax;
                class Px {
                    constructor(t = new Lx(1 / 0, 1 / 0, 1 / 0), e = new Lx(-1 / 0, -1 / 0, -1 / 0)) { this.min = t, this.max = e }
                    set(t, e) { return this.min.copy(t), this.max.copy(e), this }
                    setFromArray(t) {
                        let e = 1 / 0,
                            n = 1 / 0,
                            i = 1 / 0,
                            r = -1 / 0,
                            s = -1 / 0,
                            o = -1 / 0;
                        for (let a = 0, l = t.length; a < l; a += 3) {
                            const l = t[a],
                                c = t[a + 1],
                                h = t[a + 2];
                            l < e && (e = l), c < n && (n = c), h < i && (i = h), l > r && (r = l), c > s && (s = c), h > o && (o = h)
                        }
                        return this.min.set(e, n, i), this.max.set(r, s, o), this
                    }
                    setFromBufferAttribute(t) {
                        let e = 1 / 0,
                            n = 1 / 0,
                            i = 1 / 0,
                            r = -1 / 0,
                            s = -1 / 0,
                            o = -1 / 0;
                        for (let a = 0, l = t.count; a < l; a++) {
                            const l = t.getX(a),
                                c = t.getY(a),
                                h = t.getZ(a);
                            l < e && (e = l), c < n && (n = c), h < i && (i = h), l > r && (r = l), c > s && (s = c), h > o && (o = h)
                        }
                        return this.min.set(e, n, i), this.max.set(r, s, o), this
                    }
                    setFromPoints(t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]); return this }
                    setFromCenterAndSize(t, e) { const n = Dx.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this }
                    setFromObject(t) { return this.makeEmpty(), this.expandByObject(t) }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { return this.min.copy(t.min), this.max.copy(t.max), this }
                    makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this }
                    isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z }
                    getCenter(t) { return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) }
                    getSize(t) { return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min) }
                    expandByPoint(t) { return this.min.min(t), this.max.max(t), this }
                    expandByVector(t) { return this.min.sub(t), this.max.add(t), this }
                    expandByScalar(t) { return this.min.addScalar(-t), this.max.addScalar(t), this }
                    expandByObject(t) {
                        t.updateWorldMatrix(!1, !1);
                        const e = t.geometry;
                        void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), Nx.copy(e.boundingBox), Nx.applyMatrix4(t.matrixWorld), this.union(Nx));
                        const n = t.children;
                        for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);
                        return this
                    }
                    containsPoint(t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z) }
                    containsBox(t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z }
                    getParameter(t, e) { return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z)) }
                    intersectsBox(t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z) }
                    intersectsSphere(t) { return this.clampPoint(t.center, Dx), Dx.distanceToSquared(t.center) <= t.radius * t.radius }
                    intersectsPlane(t) { let e, n; return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant }
                    intersectsTriangle(t) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(kx), Gx.subVectors(this.max, kx), Bx.subVectors(t.a, kx), Ox.subVectors(t.b, kx), Fx.subVectors(t.c, kx), zx.subVectors(Ox, Bx), Ux.subVectors(Fx, Ox), Hx.subVectors(Bx, Fx);
                        let e = [0, -zx.z, zx.y, 0, -Ux.z, Ux.y, 0, -Hx.z, Hx.y, zx.z, 0, -zx.x, Ux.z, 0, -Ux.x, Hx.z, 0, -Hx.x, -zx.y, zx.x, 0, -Ux.y, Ux.x, 0, -Hx.y, Hx.x, 0];
                        return !!jx(e, Bx, Ox, Fx, Gx) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!jx(e, Bx, Ox, Fx, Gx) && (Vx.crossVectors(zx, Ux), e = [Vx.x, Vx.y, Vx.z], jx(e, Bx, Ox, Fx, Gx)))
                    }
                    clampPoint(t, e) { return e.copy(t).clamp(this.min, this.max) }
                    distanceToPoint(t) { return Dx.copy(t).clamp(this.min, this.max).sub(t).length() }
                    getBoundingSphere(t) { return this.getCenter(t.center), t.radius = .5 * this.getSize(Dx).length(), t }
                    intersect(t) { return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this }
                    union(t) { return this.min.min(t.min), this.max.max(t.max), this }
                    applyMatrix4(t) { return this.isEmpty() || (Ix[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Ix[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Ix[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Ix[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Ix[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Ix[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Ix[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Ix[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Ix)), this }
                    translate(t) { return this.min.add(t), this.max.add(t), this }
                    equals(t) { return t.min.equals(this.min) && t.max.equals(this.max) }
                }
                Px.prototype.isBox3 = !0;
                const Ix = [new Lx, new Lx, new Lx, new Lx, new Lx, new Lx, new Lx, new Lx],
                    Dx = new Lx,
                    Nx = new Px,
                    Bx = new Lx,
                    Ox = new Lx,
                    Fx = new Lx,
                    zx = new Lx,
                    Ux = new Lx,
                    Hx = new Lx,
                    kx = new Lx,
                    Gx = new Lx,
                    Vx = new Lx,
                    Wx = new Lx;

                function jx(t, e, n, i, r) {
                    for (let s = 0, o = t.length - 3; s <= o; s += 3) {
                        Wx.fromArray(t, s);
                        const o = r.x * Math.abs(Wx.x) + r.y * Math.abs(Wx.y) + r.z * Math.abs(Wx.z),
                            a = e.dot(Wx),
                            l = n.dot(Wx),
                            c = i.dot(Wx);
                        if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1
                    }
                    return !0
                }
                const qx = new Px,
                    Xx = new Lx,
                    Yx = new Lx,
                    Zx = new Lx;
                class Jx {
                    constructor(t = new Lx, e = -1) { this.center = t, this.radius = e }
                    set(t, e) { return this.center.copy(t), this.radius = e, this }
                    setFromPoints(t, e) {
                        const n = this.center;
                        void 0 !== e ? n.copy(e) : qx.setFromPoints(t).getCenter(n);
                        let i = 0;
                        for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
                        return this.radius = Math.sqrt(i), this
                    }
                    copy(t) { return this.center.copy(t.center), this.radius = t.radius, this }
                    isEmpty() { return this.radius < 0 }
                    makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this }
                    containsPoint(t) { return t.distanceToSquared(this.center) <= this.radius * this.radius }
                    distanceToPoint(t) { return t.distanceTo(this.center) - this.radius }
                    intersectsSphere(t) { const e = this.radius + t.radius; return t.center.distanceToSquared(this.center) <= e * e }
                    intersectsBox(t) { return t.intersectsSphere(this) }
                    intersectsPlane(t) { return Math.abs(t.distanceToPoint(this.center)) <= this.radius }
                    clampPoint(t, e) { const n = this.center.distanceToSquared(t); return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e }
                    getBoundingBox(t) { return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t) }
                    applyMatrix4(t) { return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this }
                    translate(t) { return this.center.add(t), this }
                    expandByPoint(t) {
                        Zx.subVectors(t, this.center);
                        const e = Zx.lengthSq();
                        if (e > this.radius * this.radius) {
                            const t = Math.sqrt(e),
                                n = .5 * (t - this.radius);
                            this.center.add(Zx.multiplyScalar(n / t)), this.radius += n
                        }
                        return this
                    }
                    union(t) { return Yx.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(Xx.copy(t.center).add(Yx)), this.expandByPoint(Xx.copy(t.center).sub(Yx)), this }
                    equals(t) { return t.center.equals(this.center) && t.radius === this.radius }
                    clone() { return (new this.constructor).copy(this) }
                }
                const Kx = new Lx,
                    Qx = new Lx,
                    $x = new Lx,
                    t_ = new Lx,
                    e_ = new Lx,
                    n_ = new Lx,
                    i_ = new Lx;
                class r_ {
                    constructor(t = new Lx, e = new Lx(0, 0, -1)) { this.origin = t, this.direction = e }
                    set(t, e) { return this.origin.copy(t), this.direction.copy(e), this }
                    copy(t) { return this.origin.copy(t.origin), this.direction.copy(t.direction), this }
                    at(t, e) { return e.copy(this.direction).multiplyScalar(t).add(this.origin) }
                    lookAt(t) { return this.direction.copy(t).sub(this.origin).normalize(), this }
                    recast(t) { return this.origin.copy(this.at(t, Kx)), this }
                    closestPointToPoint(t, e) { e.subVectors(t, this.origin); const n = e.dot(this.direction); return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin) }
                    distanceToPoint(t) { return Math.sqrt(this.distanceSqToPoint(t)) }
                    distanceSqToPoint(t) { const e = Kx.subVectors(t, this.origin).dot(this.direction); return e < 0 ? this.origin.distanceToSquared(t) : (Kx.copy(this.direction).multiplyScalar(e).add(this.origin), Kx.distanceToSquared(t)) }
                    distanceSqToSegment(t, e, n, i) {
                        Qx.copy(t).add(e).multiplyScalar(.5), $x.copy(e).sub(t).normalize(), t_.copy(this.origin).sub(Qx);
                        const r = .5 * t.distanceTo(e),
                            s = -this.direction.dot($x),
                            o = t_.dot(this.direction),
                            a = -t_.dot($x),
                            l = t_.lengthSq(),
                            c = Math.abs(1 - s * s);
                        let h, u, d, p;
                        if (c > 0)
                            if (h = s * a - o, u = s * o - a, p = r * c, h >= 0)
                                if (u >= -p)
                                    if (u <= p) {
                                        const t = 1 / c;
                                        h *= t, u *= t, d = h * (h + s * u + 2 * o) + u * (s * h + u + 2 * a) + l
                                    } else u = r, h = Math.max(0, -(s * u + o)), d = -h * h + u * (u + 2 * a) + l;
                        else u = -r, h = Math.max(0, -(s * u + o)), d = -h * h + u * (u + 2 * a) + l;
                        else u <= -p ? (h = Math.max(0, -(-s * r + o)), u = h > 0 ? -r : Math.min(Math.max(-r, -a), r), d = -h * h + u * (u + 2 * a) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-r, -a), r), d = u * (u + 2 * a) + l) : (h = Math.max(0, -(s * r + o)), u = h > 0 ? r : Math.min(Math.max(-r, -a), r), d = -h * h + u * (u + 2 * a) + l);
                        else u = s > 0 ? -r : r, h = Math.max(0, -(s * u + o)), d = -h * h + u * (u + 2 * a) + l;
                        return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy($x).multiplyScalar(u).add(Qx), d
                    }
                    intersectSphere(t, e) {
                        Kx.subVectors(t.center, this.origin);
                        const n = Kx.dot(this.direction),
                            i = Kx.dot(Kx) - n * n,
                            r = t.radius * t.radius;
                        if (i > r) return null;
                        const s = Math.sqrt(r - i),
                            o = n - s,
                            a = n + s;
                        return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e)
                    }
                    intersectsSphere(t) { return this.distanceSqToPoint(t.center) <= t.radius * t.radius }
                    distanceToPlane(t) { const e = t.normal.dot(this.direction); if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null; const n = -(this.origin.dot(t.normal) + t.constant) / e; return n >= 0 ? n : null }
                    intersectPlane(t, e) { const n = this.distanceToPlane(t); return null === n ? null : this.at(n, e) }
                    intersectsPlane(t) { const e = t.distanceToPoint(this.origin); return 0 === e || t.normal.dot(this.direction) * e < 0 }
                    intersectBox(t, e) {
                        let n, i, r, s, o, a;
                        const l = 1 / this.direction.x,
                            c = 1 / this.direction.y,
                            h = 1 / this.direction.z,
                            u = this.origin;
                        return l >= 0 ? (n = (t.min.x - u.x) * l, i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, i = (t.min.x - u.x) * l), c >= 0 ? (r = (t.min.y - u.y) * c, s = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c, s = (t.min.y - u.y) * c), n > s || r > i ? null : ((r > n || n != n) && (n = r), (s < i || i != i) && (i = s), h >= 0 ? (o = (t.min.z - u.z) * h, a = (t.max.z - u.z) * h) : (o = (t.max.z - u.z) * h, a = (t.min.z - u.z) * h), n > a || o > i ? null : ((o > n || n != n) && (n = o), (a < i || i != i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
                    }
                    intersectsBox(t) { return null !== this.intersectBox(t, Kx) }
                    intersectTriangle(t, e, n, i, r) {
                        e_.subVectors(e, t), n_.subVectors(n, t), i_.crossVectors(e_, n_);
                        let s, o = this.direction.dot(i_);
                        if (o > 0) {
                            if (i) return null;
                            s = 1
                        } else {
                            if (!(o < 0)) return null;
                            s = -1, o = -o
                        }
                        t_.subVectors(this.origin, t);
                        const a = s * this.direction.dot(n_.crossVectors(t_, n_));
                        if (a < 0) return null;
                        const l = s * this.direction.dot(e_.cross(t_));
                        if (l < 0) return null;
                        if (a + l > o) return null;
                        const c = -s * t_.dot(i_);
                        return c < 0 ? null : this.at(c / o, r)
                    }
                    applyMatrix4(t) { return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this }
                    equals(t) { return t.origin.equals(this.origin) && t.direction.equals(this.direction) }
                    clone() { return (new this.constructor).copy(this) }
                }
                class s_ {
                    constructor() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") }
                    set(t, e, n, i, r, s, o, a, l, c, h, u, d, p, m, f) { const g = this.elements; return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = o, g[13] = a, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = m, g[15] = f, this }
                    identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }
                    clone() { return (new s_).fromArray(this.elements) }
                    copy(t) {
                        const e = this.elements,
                            n = t.elements;
                        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
                    }
                    copyPosition(t) {
                        const e = this.elements,
                            n = t.elements;
                        return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
                    }
                    setFromMatrix3(t) { const e = t.elements; return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this }
                    extractBasis(t, e, n) { return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this }
                    makeBasis(t, e, n) { return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this }
                    extractRotation(t) {
                        const e = this.elements,
                            n = t.elements,
                            i = 1 / o_.setFromMatrixColumn(t, 0).length(),
                            r = 1 / o_.setFromMatrixColumn(t, 1).length(),
                            s = 1 / o_.setFromMatrixColumn(t, 2).length();
                        return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                    }
                    makeRotationFromEuler(t) {
                        t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                        const e = this.elements,
                            n = t.x,
                            i = t.y,
                            r = t.z,
                            s = Math.cos(n),
                            o = Math.sin(n),
                            a = Math.cos(i),
                            l = Math.sin(i),
                            c = Math.cos(r),
                            h = Math.sin(r);
                        if ("XYZ" === t.order) {
                            const t = s * c,
                                n = s * h,
                                i = o * c,
                                r = o * h;
                            e[0] = a * c, e[4] = -a * h, e[8] = l, e[1] = n + i * l, e[5] = t - r * l, e[9] = -o * a, e[2] = r - t * l, e[6] = i + n * l, e[10] = s * a
                        } else if ("YXZ" === t.order) {
                            const t = a * c,
                                n = a * h,
                                i = l * c,
                                r = l * h;
                            e[0] = t + r * o, e[4] = i * o - n, e[8] = s * l, e[1] = s * h, e[5] = s * c, e[9] = -o, e[2] = n * o - i, e[6] = r + t * o, e[10] = s * a
                        } else if ("ZXY" === t.order) {
                            const t = a * c,
                                n = a * h,
                                i = l * c,
                                r = l * h;
                            e[0] = t - r * o, e[4] = -s * h, e[8] = i + n * o, e[1] = n + i * o, e[5] = s * c, e[9] = r - t * o, e[2] = -s * l, e[6] = o, e[10] = s * a
                        } else if ("ZYX" === t.order) {
                            const t = s * c,
                                n = s * h,
                                i = o * c,
                                r = o * h;
                            e[0] = a * c, e[4] = i * l - n, e[8] = t * l + r, e[1] = a * h, e[5] = r * l + t, e[9] = n * l - i, e[2] = -l, e[6] = o * a, e[10] = s * a
                        } else if ("YZX" === t.order) {
                            const t = s * a,
                                n = s * l,
                                i = o * a,
                                r = o * l;
                            e[0] = a * c, e[4] = r - t * h, e[8] = i * h + n, e[1] = h, e[5] = s * c, e[9] = -o * c, e[2] = -l * c, e[6] = n * h + i, e[10] = t - r * h
                        } else if ("XZY" === t.order) {
                            const t = s * a,
                                n = s * l,
                                i = o * a,
                                r = o * l;
                            e[0] = a * c, e[4] = -h, e[8] = l * c, e[1] = t * h + r, e[5] = s * c, e[9] = n * h - i, e[2] = i * h - n, e[6] = o * c, e[10] = r * h + t
                        }
                        return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                    }
                    makeRotationFromQuaternion(t) { return this.compose(l_, t, c_) }
                    lookAt(t, e, n) { const i = this.elements; return d_.subVectors(t, e), 0 === d_.lengthSq() && (d_.z = 1), d_.normalize(), h_.crossVectors(n, d_), 0 === h_.lengthSq() && (1 === Math.abs(n.z) ? d_.x += 1e-4 : d_.z += 1e-4, d_.normalize(), h_.crossVectors(n, d_)), h_.normalize(), u_.crossVectors(d_, h_), i[0] = h_.x, i[4] = u_.x, i[8] = d_.x, i[1] = h_.y, i[5] = u_.y, i[9] = d_.y, i[2] = h_.z, i[6] = u_.z, i[10] = d_.z, this }
                    multiply(t, e) { return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t) }
                    premultiply(t) { return this.multiplyMatrices(t, this) }
                    multiplyMatrices(t, e) {
                        const n = t.elements,
                            i = e.elements,
                            r = this.elements,
                            s = n[0],
                            o = n[4],
                            a = n[8],
                            l = n[12],
                            c = n[1],
                            h = n[5],
                            u = n[9],
                            d = n[13],
                            p = n[2],
                            m = n[6],
                            f = n[10],
                            g = n[14],
                            v = n[3],
                            y = n[7],
                            x = n[11],
                            _ = n[15],
                            b = i[0],
                            w = i[4],
                            M = i[8],
                            S = i[12],
                            T = i[1],
                            E = i[5],
                            A = i[9],
                            L = i[13],
                            R = i[2],
                            C = i[6],
                            P = i[10],
                            I = i[14],
                            D = i[3],
                            N = i[7],
                            B = i[11],
                            O = i[15];
                        return r[0] = s * b + o * T + a * R + l * D, r[4] = s * w + o * E + a * C + l * N, r[8] = s * M + o * A + a * P + l * B, r[12] = s * S + o * L + a * I + l * O, r[1] = c * b + h * T + u * R + d * D, r[5] = c * w + h * E + u * C + d * N, r[9] = c * M + h * A + u * P + d * B, r[13] = c * S + h * L + u * I + d * O, r[2] = p * b + m * T + f * R + g * D, r[6] = p * w + m * E + f * C + g * N, r[10] = p * M + m * A + f * P + g * B, r[14] = p * S + m * L + f * I + g * O, r[3] = v * b + y * T + x * R + _ * D, r[7] = v * w + y * E + x * C + _ * N, r[11] = v * M + y * A + x * P + _ * B, r[15] = v * S + y * L + x * I + _ * O, this
                    }
                    multiplyScalar(t) { const e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this }
                    determinant() {
                        const t = this.elements,
                            e = t[0],
                            n = t[4],
                            i = t[8],
                            r = t[12],
                            s = t[1],
                            o = t[5],
                            a = t[9],
                            l = t[13],
                            c = t[2],
                            h = t[6],
                            u = t[10],
                            d = t[14];
                        return t[3] * (+r * a * h - i * l * h - r * o * u + n * l * u + i * o * d - n * a * d) + t[7] * (+e * a * d - e * l * u + r * s * u - i * s * d + i * l * c - r * a * c) + t[11] * (+e * l * h - e * o * d - r * s * h + n * s * d + r * o * c - n * l * c) + t[15] * (-i * o * c - e * a * h + e * o * u + i * s * h - n * s * u + n * a * c)
                    }
                    transpose() { const t = this.elements; let e; return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this }
                    setPosition(t, e, n) { const i = this.elements; return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this }
                    invert() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            i = t[2],
                            r = t[3],
                            s = t[4],
                            o = t[5],
                            a = t[6],
                            l = t[7],
                            c = t[8],
                            h = t[9],
                            u = t[10],
                            d = t[11],
                            p = t[12],
                            m = t[13],
                            f = t[14],
                            g = t[15],
                            v = h * f * l - m * u * l + m * a * d - o * f * d - h * a * g + o * u * g,
                            y = p * u * l - c * f * l - p * a * d + s * f * d + c * a * g - s * u * g,
                            x = c * m * l - p * h * l + p * o * d - s * m * d - c * o * g + s * h * g,
                            _ = p * h * a - c * m * a - p * o * u + s * m * u + c * o * f - s * h * f,
                            b = e * v + n * y + i * x + r * _;
                        if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const w = 1 / b;
                        return t[0] = v * w, t[1] = (m * u * r - h * f * r - m * i * d + n * f * d + h * i * g - n * u * g) * w, t[2] = (o * f * r - m * a * r + m * i * l - n * f * l - o * i * g + n * a * g) * w, t[3] = (h * a * r - o * u * r - h * i * l + n * u * l + o * i * d - n * a * d) * w, t[4] = y * w, t[5] = (c * f * r - p * u * r + p * i * d - e * f * d - c * i * g + e * u * g) * w, t[6] = (p * a * r - s * f * r - p * i * l + e * f * l + s * i * g - e * a * g) * w, t[7] = (s * u * r - c * a * r + c * i * l - e * u * l - s * i * d + e * a * d) * w, t[8] = x * w, t[9] = (p * h * r - c * m * r - p * n * d + e * m * d + c * n * g - e * h * g) * w, t[10] = (s * m * r - p * o * r + p * n * l - e * m * l - s * n * g + e * o * g) * w, t[11] = (c * o * r - s * h * r - c * n * l + e * h * l + s * n * d - e * o * d) * w, t[12] = _ * w, t[13] = (c * m * i - p * h * i + p * n * u - e * m * u - c * n * f + e * h * f) * w, t[14] = (p * o * i - s * m * i - p * n * a + e * m * a + s * n * f - e * o * f) * w, t[15] = (s * h * i - c * o * i + c * n * a - e * h * a - s * n * u + e * o * u) * w, this
                    }
                    scale(t) {
                        const e = this.elements,
                            n = t.x,
                            i = t.y,
                            r = t.z;
                        return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
                    }
                    getMaxScaleOnAxis() {
                        const t = this.elements,
                            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                            i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                        return Math.sqrt(Math.max(e, n, i))
                    }
                    makeTranslation(t, e, n) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this }
                    makeRotationX(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
                    }
                    makeRotationY(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
                    }
                    makeRotationZ(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                    }
                    makeRotationAxis(t, e) {
                        const n = Math.cos(e),
                            i = Math.sin(e),
                            r = 1 - n,
                            s = t.x,
                            o = t.y,
                            a = t.z,
                            l = r * s,
                            c = r * o;
                        return this.set(l * s + n, l * o - i * a, l * a + i * o, 0, l * o + i * a, c * o + n, c * a - i * s, 0, l * a - i * o, c * a + i * s, r * a * a + n, 0, 0, 0, 0, 1), this
                    }
                    makeScale(t, e, n) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this }
                    makeShear(t, e, n, i, r, s) { return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this }
                    compose(t, e, n) {
                        const i = this.elements,
                            r = e._x,
                            s = e._y,
                            o = e._z,
                            a = e._w,
                            l = r + r,
                            c = s + s,
                            h = o + o,
                            u = r * l,
                            d = r * c,
                            p = r * h,
                            m = s * c,
                            f = s * h,
                            g = o * h,
                            v = a * l,
                            y = a * c,
                            x = a * h,
                            _ = n.x,
                            b = n.y,
                            w = n.z;
                        return i[0] = (1 - (m + g)) * _, i[1] = (d + x) * _, i[2] = (p - y) * _, i[3] = 0, i[4] = (d - x) * b, i[5] = (1 - (u + g)) * b, i[6] = (f + v) * b, i[7] = 0, i[8] = (p + y) * w, i[9] = (f - v) * w, i[10] = (1 - (u + m)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
                    }
                    decompose(t, e, n) {
                        const i = this.elements;
                        let r = o_.set(i[0], i[1], i[2]).length();
                        const s = o_.set(i[4], i[5], i[6]).length(),
                            o = o_.set(i[8], i[9], i[10]).length();
                        this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], a_.copy(this);
                        const a = 1 / r,
                            l = 1 / s,
                            c = 1 / o;
                        return a_.elements[0] *= a, a_.elements[1] *= a, a_.elements[2] *= a, a_.elements[4] *= l, a_.elements[5] *= l, a_.elements[6] *= l, a_.elements[8] *= c, a_.elements[9] *= c, a_.elements[10] *= c, e.setFromRotationMatrix(a_), n.x = r, n.y = s, n.z = o, this
                    }
                    makePerspective(t, e, n, i, r, s) {
                        void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                        const o = this.elements,
                            a = 2 * r / (e - t),
                            l = 2 * r / (n - i),
                            c = (e + t) / (e - t),
                            h = (n + i) / (n - i),
                            u = -(s + r) / (s - r),
                            d = -2 * s * r / (s - r);
                        return o[0] = a, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = h, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
                    }
                    makeOrthographic(t, e, n, i, r, s) {
                        const o = this.elements,
                            a = 1 / (e - t),
                            l = 1 / (n - i),
                            c = 1 / (s - r),
                            h = (e + t) * a,
                            u = (n + i) * l,
                            d = (s + r) * c;
                        return o[0] = 2 * a, o[4] = 0, o[8] = 0, o[12] = -h, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
                    }
                    equals(t) {
                        const e = this.elements,
                            n = t.elements;
                        for (let t = 0; t < 16; t++)
                            if (e[t] !== n[t]) return !1;
                        return !0
                    }
                    fromArray(t, e = 0) { for (let n = 0; n < 16; n++) this.elements[n] = t[n + e]; return this }
                    toArray(t = [], e = 0) { const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t }
                }
                s_.prototype.isMatrix4 = !0;
                const o_ = new Lx,
                    a_ = new s_,
                    l_ = new Lx(0, 0, 0),
                    c_ = new Lx(1, 1, 1),
                    h_ = new Lx,
                    u_ = new Lx,
                    d_ = new Lx,
                    p_ = new s_,
                    m_ = new Ax;
                class f_ {
                    constructor(t = 0, e = 0, n = 0, i = f_.DefaultOrder) { this._x = t, this._y = e, this._z = n, this._order = i }
                    get x() { return this._x }
                    set x(t) { this._x = t, this._onChangeCallback() }
                    get y() { return this._y }
                    set y(t) { this._y = t, this._onChangeCallback() }
                    get z() { return this._z }
                    set z(t) { this._z = t, this._onChangeCallback() }
                    get order() { return this._order }
                    set order(t) { this._order = t, this._onChangeCallback() }
                    set(t, e, n, i = this._order) { return this._x = t, this._y = e, this._z = n, this._order = i, this._onChangeCallback(), this }
                    clone() { return new this.constructor(this._x, this._y, this._z, this._order) }
                    copy(t) { return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this }
                    setFromRotationMatrix(t, e = this._order, n = !0) {
                        const i = t.elements,
                            r = i[0],
                            s = i[4],
                            o = i[8],
                            a = i[1],
                            l = i[5],
                            c = i[9],
                            h = i[2],
                            u = i[6],
                            d = i[10];
                        switch (e) {
                            case "XYZ":
                                this._y = Math.asin(ux(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                                break;
                            case "YXZ":
                                this._x = Math.asin(-ux(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
                                break;
                            case "ZXY":
                                this._x = Math.asin(ux(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(a, r));
                                break;
                            case "ZYX":
                                this._y = Math.asin(-ux(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(a, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
                                break;
                            case "YZX":
                                this._z = Math.asin(ux(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(o, d));
                                break;
                            case "XZY":
                                this._z = Math.asin(-ux(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
                                break;
                            default:
                                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                        }
                        return this._order = e, !0 === n && this._onChangeCallback(), this
                    }
                    setFromQuaternion(t, e, n) { return p_.makeRotationFromQuaternion(t), this.setFromRotationMatrix(p_, e, n) }
                    setFromVector3(t, e = this._order) { return this.set(t.x, t.y, t.z, e) }
                    reorder(t) { return m_.setFromEuler(this), this.setFromQuaternion(m_, t) }
                    equals(t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order }
                    fromArray(t) { return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this }
                    toArray(t = [], e = 0) { return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t }
                    toVector3(t) { return t ? t.set(this._x, this._y, this._z) : new Lx(this._x, this._y, this._z) }
                    _onChange(t) { return this._onChangeCallback = t, this }
                    _onChangeCallback() {}
                }
                f_.prototype.isEuler = !0, f_.DefaultOrder = "XYZ", f_.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
                class g_ {
                    constructor() { this.mask = 1 }
                    set(t) { this.mask = 1 << t | 0 }
                    enable(t) { this.mask |= 1 << t | 0 }
                    enableAll() { this.mask = -1 }
                    toggle(t) { this.mask ^= 1 << t | 0 }
                    disable(t) { this.mask &= ~(1 << t | 0) }
                    disableAll() { this.mask = 0 }
                    test(t) { return 0 != (this.mask & t.mask) }
                }
                let v_ = 0;
                const y_ = new Lx,
                    x_ = new Ax,
                    __ = new s_,
                    b_ = new Lx,
                    w_ = new Lx,
                    M_ = new Lx,
                    S_ = new Ax,
                    T_ = new Lx(1, 0, 0),
                    E_ = new Lx(0, 1, 0),
                    A_ = new Lx(0, 0, 1),
                    L_ = { type: "added" },
                    R_ = { type: "removed" };
                class C_ extends sx {
                    constructor() {
                        super(), Object.defineProperty(this, "id", { value: v_++ }), this.uuid = hx(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = C_.DefaultUp.clone();
                        const t = new Lx,
                            e = new f_,
                            n = new Ax,
                            i = new Lx(1, 1, 1);
                        e._onChange((function() { n.setFromEuler(e, !1) })), n._onChange((function() { e.setFromQuaternion(n, void 0, !1) })), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: i }, modelViewMatrix: { value: new s_ }, normalMatrix: { value: new yx } }), this.matrix = new s_, this.matrixWorld = new s_, this.matrixAutoUpdate = C_.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new g_, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                    }
                    onBeforeRender() {}
                    onAfterRender() {}
                    applyMatrix4(t) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale) }
                    applyQuaternion(t) { return this.quaternion.premultiply(t), this }
                    setRotationFromAxisAngle(t, e) { this.quaternion.setFromAxisAngle(t, e) }
                    setRotationFromEuler(t) { this.quaternion.setFromEuler(t, !0) }
                    setRotationFromMatrix(t) { this.quaternion.setFromRotationMatrix(t) }
                    setRotationFromQuaternion(t) { this.quaternion.copy(t) }
                    rotateOnAxis(t, e) { return x_.setFromAxisAngle(t, e), this.quaternion.multiply(x_), this }
                    rotateOnWorldAxis(t, e) { return x_.setFromAxisAngle(t, e), this.quaternion.premultiply(x_), this }
                    rotateX(t) { return this.rotateOnAxis(T_, t) }
                    rotateY(t) { return this.rotateOnAxis(E_, t) }
                    rotateZ(t) { return this.rotateOnAxis(A_, t) }
                    translateOnAxis(t, e) { return y_.copy(t).applyQuaternion(this.quaternion), this.position.add(y_.multiplyScalar(e)), this }
                    translateX(t) { return this.translateOnAxis(T_, t) }
                    translateY(t) { return this.translateOnAxis(E_, t) }
                    translateZ(t) { return this.translateOnAxis(A_, t) }
                    localToWorld(t) { return t.applyMatrix4(this.matrixWorld) }
                    worldToLocal(t) { return t.applyMatrix4(__.copy(this.matrixWorld).invert()) }
                    lookAt(t, e, n) {
                        t.isVector3 ? b_.copy(t) : b_.set(t, e, n);
                        const i = this.parent;
                        this.updateWorldMatrix(!0, !1), w_.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? __.lookAt(w_, b_, this.up) : __.lookAt(b_, w_, this.up), this.quaternion.setFromRotationMatrix(__), i && (__.extractRotation(i.matrixWorld), x_.setFromRotationMatrix(__), this.quaternion.premultiply(x_.invert()))
                    }
                    add(t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++) this.add(arguments[t]); return this } return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(L_)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this) }
                    remove(t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]); return this } const e = this.children.indexOf(t); return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(R_)), this }
                    removeFromParent() { const t = this.parent; return null !== t && t.remove(this), this }
                    clear() {
                        for (let t = 0; t < this.children.length; t++) {
                            const e = this.children[t];
                            e.parent = null, e.dispatchEvent(R_)
                        }
                        return this.children.length = 0, this
                    }
                    attach(t) { return this.updateWorldMatrix(!0, !1), __.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), __.multiply(t.parent.matrixWorld)), t.applyMatrix4(__), this.add(t), t.updateWorldMatrix(!1, !0), this }
                    getObjectById(t) { return this.getObjectByProperty("id", t) }
                    getObjectByName(t) { return this.getObjectByProperty("name", t) }
                    getObjectByProperty(t, e) { if (this[t] === e) return this; for (let n = 0, i = this.children.length; n < i; n++) { const i = this.children[n].getObjectByProperty(t, e); if (void 0 !== i) return i } }
                    getWorldPosition(t) { return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld) }
                    getWorldQuaternion(t) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(w_, t, M_), t }
                    getWorldScale(t) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(w_, S_, t), t }
                    getWorldDirection(t) { this.updateWorldMatrix(!0, !1); const e = this.matrixWorld.elements; return t.set(e[8], e[9], e[10]).normalize() }
                    raycast() {}
                    traverse(t) { t(this); const e = this.children; for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t) }
                    traverseVisible(t) {
                        if (!1 === this.visible) return;
                        t(this);
                        const e = this.children;
                        for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
                    }
                    traverseAncestors(t) {
                        const e = this.parent;
                        null !== e && (t(e), e.traverseAncestors(t))
                    }
                    updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 }
                    updateMatrixWorld(t) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0); const e = this.children; for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t) }
                    updateWorldMatrix(t, e) { const n = this.parent; if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) { const t = this.children; for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0) } }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t,
                            n = {};
                        e && (t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
                        const i = {};

                        function r(e, n) { return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid }
                        if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && (i.environment = this.environment.toJSON(t).uuid);
                        else if (this.isMesh || this.isLine || this.isPoints) {
                            i.geometry = r(t.geometries, this.geometry);
                            const e = this.geometry.parameters;
                            if (void 0 !== e && void 0 !== e.shapes) {
                                const n = e.shapes;
                                if (Array.isArray(n))
                                    for (let e = 0, i = n.length; e < i; e++) {
                                        const i = n[e];
                                        r(t.shapes, i)
                                    } else r(t.shapes, n)
                            }
                        }
                        if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                            if (Array.isArray(this.material)) {
                                const e = [];
                                for (let n = 0, i = this.material.length; n < i; n++) e.push(r(t.materials, this.material[n]));
                                i.material = e
                            } else i.material = r(t.materials, this.material);
                        if (this.children.length > 0) { i.children = []; for (let e = 0; e < this.children.length; e++) i.children.push(this.children[e].toJSON(t).object) }
                        if (this.animations.length > 0) {
                            i.animations = [];
                            for (let e = 0; e < this.animations.length; e++) {
                                const n = this.animations[e];
                                i.animations.push(r(t.animations, n))
                            }
                        }
                        if (e) {
                            const e = s(t.geometries),
                                i = s(t.materials),
                                r = s(t.textures),
                                o = s(t.images),
                                a = s(t.shapes),
                                l = s(t.skeletons),
                                c = s(t.animations);
                            e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o), a.length > 0 && (n.shapes = a), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c)
                        }
                        return n.object = i, n;

                        function s(t) {
                            const e = [];
                            for (const n in t) {
                                const i = t[n];
                                delete i.metadata, e.push(i)
                            }
                            return e
                        }
                    }
                    clone(t) { return (new this.constructor).copy(this, t) }
                    copy(t, e = !0) {
                        if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                            for (let e = 0; e < t.children.length; e++) {
                                const n = t.children[e];
                                this.add(n.clone())
                            }
                        return this
                    }
                }
                C_.DefaultUp = new Lx(0, 1, 0), C_.DefaultMatrixAutoUpdate = !0, C_.prototype.isObject3D = !0;
                const P_ = new Lx,
                    I_ = new Lx,
                    D_ = new Lx,
                    N_ = new Lx,
                    B_ = new Lx,
                    O_ = new Lx,
                    F_ = new Lx,
                    z_ = new Lx,
                    U_ = new Lx,
                    H_ = new Lx;
                class k_ {
                    constructor(t = new Lx, e = new Lx, n = new Lx) { this.a = t, this.b = e, this.c = n }
                    static getNormal(t, e, n, i) { i.subVectors(n, e), P_.subVectors(t, e), i.cross(P_); const r = i.lengthSq(); return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0) }
                    static getBarycoord(t, e, n, i, r) {
                        P_.subVectors(i, e), I_.subVectors(n, e), D_.subVectors(t, e);
                        const s = P_.dot(P_),
                            o = P_.dot(I_),
                            a = P_.dot(D_),
                            l = I_.dot(I_),
                            c = I_.dot(D_),
                            h = s * l - o * o;
                        if (0 === h) return r.set(-2, -1, -1);
                        const u = 1 / h,
                            d = (l * a - o * c) * u,
                            p = (s * c - o * a) * u;
                        return r.set(1 - d - p, p, d)
                    }
                    static containsPoint(t, e, n, i) { return this.getBarycoord(t, e, n, i, N_), N_.x >= 0 && N_.y >= 0 && N_.x + N_.y <= 1 }
                    static getUV(t, e, n, i, r, s, o, a) { return this.getBarycoord(t, e, n, i, N_), a.set(0, 0), a.addScaledVector(r, N_.x), a.addScaledVector(s, N_.y), a.addScaledVector(o, N_.z), a }
                    static isFrontFacing(t, e, n, i) { return P_.subVectors(n, e), I_.subVectors(t, e), P_.cross(I_).dot(i) < 0 }
                    set(t, e, n) { return this.a.copy(t), this.b.copy(e), this.c.copy(n), this }
                    setFromPointsAndIndices(t, e, n, i) { return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this }
                    getArea() { return P_.subVectors(this.c, this.b), I_.subVectors(this.a, this.b), .5 * P_.cross(I_).length() }
                    getMidpoint(t) { return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) }
                    getNormal(t) { return k_.getNormal(this.a, this.b, this.c, t) }
                    getPlane(t) { return t.setFromCoplanarPoints(this.a, this.b, this.c) }
                    getBarycoord(t, e) { return k_.getBarycoord(t, this.a, this.b, this.c, e) }
                    getUV(t, e, n, i, r) { return k_.getUV(t, this.a, this.b, this.c, e, n, i, r) }
                    containsPoint(t) { return k_.containsPoint(t, this.a, this.b, this.c) }
                    isFrontFacing(t) { return k_.isFrontFacing(this.a, this.b, this.c, t) }
                    intersectsBox(t) { return t.intersectsTriangle(this) }
                    closestPointToPoint(t, e) {
                        const n = this.a,
                            i = this.b,
                            r = this.c;
                        let s, o;
                        B_.subVectors(i, n), O_.subVectors(r, n), z_.subVectors(t, n);
                        const a = B_.dot(z_),
                            l = O_.dot(z_);
                        if (a <= 0 && l <= 0) return e.copy(n);
                        U_.subVectors(t, i);
                        const c = B_.dot(U_),
                            h = O_.dot(U_);
                        if (c >= 0 && h <= c) return e.copy(i);
                        const u = a * h - c * l;
                        if (u <= 0 && a >= 0 && c <= 0) return s = a / (a - c), e.copy(n).addScaledVector(B_, s);
                        H_.subVectors(t, r);
                        const d = B_.dot(H_),
                            p = O_.dot(H_);
                        if (p >= 0 && d <= p) return e.copy(r);
                        const m = d * l - a * p;
                        if (m <= 0 && l >= 0 && p <= 0) return o = l / (l - p), e.copy(n).addScaledVector(O_, o);
                        const f = c * p - d * h;
                        if (f <= 0 && h - c >= 0 && d - p >= 0) return F_.subVectors(r, i), o = (h - c) / (h - c + (d - p)), e.copy(i).addScaledVector(F_, o);
                        const g = 1 / (f + m + u);
                        return s = m * g, o = u * g, e.copy(n).addScaledVector(B_, s).addScaledVector(O_, o)
                    }
                    equals(t) { return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c) }
                }
                let G_ = 0;
                class V_ extends sx {
                    constructor() { super(), Object.defineProperty(this, "id", { value: G_++ }), this.uuid = hx(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = Py, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = ex, this.stencilZFail = ex, this.stencilZPass = ex, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0 }
                    onBuild() {}
                    onBeforeCompile() {}
                    customProgramCacheKey() { return this.onBeforeCompile.toString() }
                    setValues(t) {
                        if (void 0 !== t)
                            for (const e in t) {
                                const n = t[e];
                                if (void 0 === n) { console.warn("THREE.Material: '" + e + "' parameter is undefined."); continue }
                                if ("shading" === e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n; continue }
                                const i = this[e];
                                void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                            }
                    }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t;
                        e && (t = { textures: {}, images: {} });
                        const n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };

                        function i(t) {
                            const e = [];
                            for (const n in t) {
                                const i = t[n];
                                delete i.metadata, e.push(i)
                            }
                            return e
                        }
                        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                            const e = i(t.textures),
                                r = i(t.images);
                            e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
                        }
                        return n
                    }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) {
                        this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                        const e = t.clippingPlanes;
                        let n = null;
                        if (null !== e) {
                            const t = e.length;
                            n = new Array(t);
                            for (let i = 0; i !== t; ++i) n[i] = e[i].clone()
                        }
                        return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
                    }
                    dispose() { this.dispatchEvent({ type: "dispose" }) }
                    set needsUpdate(t) {!0 === t && this.version++ }
                }
                V_.prototype.isMaterial = !0;
                const W_ = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 },
                    j_ = { h: 0, s: 0, l: 0 },
                    q_ = { h: 0, s: 0, l: 0 };

                function X_(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t }

                function Y_(t) { return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4) }

                function Z_(t) { return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055 }
                class J_ {
                    constructor(t, e, n) { return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n) }
                    set(t) { return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this }
                    setScalar(t) { return this.r = t, this.g = t, this.b = t, this }
                    setHex(t) { return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this }
                    setRGB(t, e, n) { return this.r = t, this.g = e, this.b = n, this }
                    setHSL(t, e, n) {
                        if (t = dx(t, 1), e = ux(e, 0, 1), n = ux(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                        else {
                            const i = n <= .5 ? n * (1 + e) : n + e - n * e,
                                r = 2 * n - i;
                            this.r = X_(r, i, t + 1 / 3), this.g = X_(r, i, t), this.b = X_(r, i, t - 1 / 3)
                        }
                        return this
                    }
                    setStyle(t) {
                        function e(e) { void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.") }
                        let n;
                        if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
                            let t;
                            const i = n[1],
                                r = n[2];
                            switch (i) {
                                case "rgb":
                                case "rgba":
                                    if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[4]), this;
                                    if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[4]), this;
                                    break;
                                case "hsl":
                                case "hsla":
                                    if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                                        const n = parseFloat(t[1]) / 360,
                                            i = parseInt(t[2], 10) / 100,
                                            r = parseInt(t[3], 10) / 100;
                                        return e(t[4]), this.setHSL(n, i, r)
                                    }
                            }
                        } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                            const t = n[1],
                                e = t.length;
                            if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
                            if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
                        }
                        return t && t.length > 0 ? this.setColorName(t) : this
                    }
                    setColorName(t) { const e = W_[t.toLowerCase()]; return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this }
                    clone() { return new this.constructor(this.r, this.g, this.b) }
                    copy(t) { return this.r = t.r, this.g = t.g, this.b = t.b, this }
                    copyGammaToLinear(t, e = 2) { return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this }
                    copyLinearToGamma(t, e = 2) { const n = e > 0 ? 1 / e : 1; return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this }
                    convertGammaToLinear(t) { return this.copyGammaToLinear(this, t), this }
                    convertLinearToGamma(t) { return this.copyLinearToGamma(this, t), this }
                    copySRGBToLinear(t) { return this.r = Y_(t.r), this.g = Y_(t.g), this.b = Y_(t.b), this }
                    copyLinearToSRGB(t) { return this.r = Z_(t.r), this.g = Z_(t.g), this.b = Z_(t.b), this }
                    convertSRGBToLinear() { return this.copySRGBToLinear(this), this }
                    convertLinearToSRGB() { return this.copyLinearToSRGB(this), this }
                    getHex() { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 }
                    getHexString() { return ("000000" + this.getHex().toString(16)).slice(-6) }
                    getHSL(t) {
                        const e = this.r,
                            n = this.g,
                            i = this.b,
                            r = Math.max(e, n, i),
                            s = Math.min(e, n, i);
                        let o, a;
                        const l = (s + r) / 2;
                        if (s === r) o = 0, a = 0;
                        else {
                            const t = r - s;
                            switch (a = l <= .5 ? t / (r + s) : t / (2 - r - s), r) {
                                case e:
                                    o = (n - i) / t + (n < i ? 6 : 0);
                                    break;
                                case n:
                                    o = (i - e) / t + 2;
                                    break;
                                case i:
                                    o = (e - n) / t + 4
                            }
                            o /= 6
                        }
                        return t.h = o, t.s = a, t.l = l, t
                    }
                    getStyle() { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" }
                    offsetHSL(t, e, n) { return this.getHSL(j_), j_.h += t, j_.s += e, j_.l += n, this.setHSL(j_.h, j_.s, j_.l), this }
                    add(t) { return this.r += t.r, this.g += t.g, this.b += t.b, this }
                    addColors(t, e) { return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this }
                    addScalar(t) { return this.r += t, this.g += t, this.b += t, this }
                    sub(t) { return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this }
                    multiply(t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this }
                    multiplyScalar(t) { return this.r *= t, this.g *= t, this.b *= t, this }
                    lerp(t, e) { return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this }
                    lerpColors(t, e, n) { return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this }
                    lerpHSL(t, e) {
                        this.getHSL(j_), t.getHSL(q_);
                        const n = px(j_.h, q_.h, e),
                            i = px(j_.s, q_.s, e),
                            r = px(j_.l, q_.l, e);
                        return this.setHSL(n, i, r), this
                    }
                    equals(t) { return t.r === this.r && t.g === this.g && t.b === this.b }
                    fromArray(t, e = 0) { return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this }
                    toArray(t = [], e = 0) { return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t }
                    fromBufferAttribute(t, e) { return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this }
                    toJSON() { return this.getHex() }
                }
                J_.NAMES = W_, J_.prototype.isColor = !0, J_.prototype.r = 1, J_.prototype.g = 1, J_.prototype.b = 1;
                class K_ extends V_ {
                    constructor(t) { super(), this.type = "MeshBasicMaterial", this.color = new J_(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this }
                }
                K_.prototype.isMeshBasicMaterial = !0;
                const Q_ = new Lx,
                    $_ = new vx;
                class tb {
                    constructor(t, e, n) {
                        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = nx, this.updateRange = { offset: 0, count: -1 }, this.version = 0
                    }
                    onUploadCallback() {}
                    set needsUpdate(t) {!0 === t && this.version++ }
                    setUsage(t) { return this.usage = t, this }
                    copy(t) { return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this }
                    copyAt(t, e, n) { t *= this.itemSize, n *= e.itemSize; for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i]; return this }
                    copyArray(t) { return this.array.set(t), this }
                    copyColorsArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let i = 0, r = t.length; i < r; i++) {
                            let r = t[i];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new J_), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
                        }
                        return this
                    }
                    copyVector2sArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let i = 0, r = t.length; i < r; i++) {
                            let r = t[i];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new vx), e[n++] = r.x, e[n++] = r.y
                        }
                        return this
                    }
                    copyVector3sArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let i = 0, r = t.length; i < r; i++) {
                            let r = t[i];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new Lx), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
                        }
                        return this
                    }
                    copyVector4sArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let i = 0, r = t.length; i < r; i++) {
                            let r = t[i];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new Sx), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
                        }
                        return this
                    }
                    applyMatrix3(t) {
                        if (2 === this.itemSize)
                            for (let e = 0, n = this.count; e < n; e++) $_.fromBufferAttribute(this, e), $_.applyMatrix3(t), this.setXY(e, $_.x, $_.y);
                        else if (3 === this.itemSize)
                            for (let e = 0, n = this.count; e < n; e++) Q_.fromBufferAttribute(this, e), Q_.applyMatrix3(t), this.setXYZ(e, Q_.x, Q_.y, Q_.z);
                        return this
                    }
                    applyMatrix4(t) { for (let e = 0, n = this.count; e < n; e++) Q_.x = this.getX(e), Q_.y = this.getY(e), Q_.z = this.getZ(e), Q_.applyMatrix4(t), this.setXYZ(e, Q_.x, Q_.y, Q_.z); return this }
                    applyNormalMatrix(t) { for (let e = 0, n = this.count; e < n; e++) Q_.x = this.getX(e), Q_.y = this.getY(e), Q_.z = this.getZ(e), Q_.applyNormalMatrix(t), this.setXYZ(e, Q_.x, Q_.y, Q_.z); return this }
                    transformDirection(t) { for (let e = 0, n = this.count; e < n; e++) Q_.x = this.getX(e), Q_.y = this.getY(e), Q_.z = this.getZ(e), Q_.transformDirection(t), this.setXYZ(e, Q_.x, Q_.y, Q_.z); return this }
                    set(t, e = 0) { return this.array.set(t, e), this }
                    getX(t) { return this.array[t * this.itemSize] }
                    setX(t, e) { return this.array[t * this.itemSize] = e, this }
                    getY(t) { return this.array[t * this.itemSize + 1] }
                    setY(t, e) { return this.array[t * this.itemSize + 1] = e, this }
                    getZ(t) { return this.array[t * this.itemSize + 2] }
                    setZ(t, e) { return this.array[t * this.itemSize + 2] = e, this }
                    getW(t) { return this.array[t * this.itemSize + 3] }
                    setW(t, e) { return this.array[t * this.itemSize + 3] = e, this }
                    setXY(t, e, n) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this }
                    setXYZ(t, e, n, i) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this }
                    setXYZW(t, e, n, i, r) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this }
                    onUpload(t) { return this.onUploadCallback = t, this }
                    clone() { return new this.constructor(this.array, this.itemSize).copy(this) }
                    toJSON() { const t = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized }; return "" !== this.name && (t.name = this.name), this.usage !== nx && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t }
                }
                tb.prototype.isBufferAttribute = !0;
                class eb extends tb { constructor(t, e, n) { super(new Uint16Array(t), e, n) } }
                class nb extends tb { constructor(t, e, n) { super(new Uint32Array(t), e, n) } }(class extends tb { constructor(t, e, n) { super(new Uint16Array(t), e, n) } }).prototype.isFloat16BufferAttribute = !0;
                class ib extends tb { constructor(t, e, n) { super(new Float32Array(t), e, n) } }

                function rb(t) { if (0 === t.length) return -1 / 0; let e = t[0]; for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]); return e }
                Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
                let sb = 0;
                const ob = new s_,
                    ab = new C_,
                    lb = new Lx,
                    cb = new Px,
                    hb = new Px,
                    ub = new Lx;
                class db extends sx {
                    constructor() { super(), Object.defineProperty(this, "id", { value: sb++ }), this.uuid = hx(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} }
                    getIndex() { return this.index }
                    setIndex(t) { return Array.isArray(t) ? this.index = new(rb(t) > 65535 ? nb : eb)(t, 1) : this.index = t, this }
                    getAttribute(t) { return this.attributes[t] }
                    setAttribute(t, e) { return this.attributes[t] = e, this }
                    deleteAttribute(t) { return delete this.attributes[t], this }
                    hasAttribute(t) { return void 0 !== this.attributes[t] }
                    addGroup(t, e, n = 0) { this.groups.push({ start: t, count: e, materialIndex: n }) }
                    clearGroups() { this.groups = [] }
                    setDrawRange(t, e) { this.drawRange.start = t, this.drawRange.count = e }
                    applyMatrix4(t) {
                        const e = this.attributes.position;
                        void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                        const n = this.attributes.normal;
                        if (void 0 !== n) {
                            const e = (new yx).getNormalMatrix(t);
                            n.applyNormalMatrix(e), n.needsUpdate = !0
                        }
                        const i = this.attributes.tangent;
                        return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                    }
                    applyQuaternion(t) { return ob.makeRotationFromQuaternion(t), this.applyMatrix4(ob), this }
                    rotateX(t) { return ob.makeRotationX(t), this.applyMatrix4(ob), this }
                    rotateY(t) { return ob.makeRotationY(t), this.applyMatrix4(ob), this }
                    rotateZ(t) { return ob.makeRotationZ(t), this.applyMatrix4(ob), this }
                    translate(t, e, n) { return ob.makeTranslation(t, e, n), this.applyMatrix4(ob), this }
                    scale(t, e, n) { return ob.makeScale(t, e, n), this.applyMatrix4(ob), this }
                    lookAt(t) { return ab.lookAt(t), ab.updateMatrix(), this.applyMatrix4(ab.matrix), this }
                    center() { return this.computeBoundingBox(), this.boundingBox.getCenter(lb).negate(), this.translate(lb.x, lb.y, lb.z), this }
                    setFromPoints(t) {
                        const e = [];
                        for (let n = 0, i = t.length; n < i; n++) {
                            const i = t[n];
                            e.push(i.x, i.y, i.z || 0)
                        }
                        return this.setAttribute("position", new ib(e, 3)), this
                    }
                    computeBoundingBox() {
                        null === this.boundingBox && (this.boundingBox = new Px);
                        const t = this.attributes.position,
                            e = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Lx(-1 / 0, -1 / 0, -1 / 0), new Lx(1 / 0, 1 / 0, 1 / 0));
                        if (void 0 !== t) {
                            if (this.boundingBox.setFromBufferAttribute(t), e)
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t];
                                    cb.setFromBufferAttribute(n), this.morphTargetsRelative ? (ub.addVectors(this.boundingBox.min, cb.min), this.boundingBox.expandByPoint(ub), ub.addVectors(this.boundingBox.max, cb.max), this.boundingBox.expandByPoint(ub)) : (this.boundingBox.expandByPoint(cb.min), this.boundingBox.expandByPoint(cb.max))
                                }
                        } else this.boundingBox.makeEmpty();
                        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                    }
                    computeBoundingSphere() {
                        null === this.boundingSphere && (this.boundingSphere = new Jx);
                        const t = this.attributes.position,
                            e = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Lx, 1 / 0);
                        if (t) {
                            const n = this.boundingSphere.center;
                            if (cb.setFromBufferAttribute(t), e)
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t];
                                    hb.setFromBufferAttribute(n), this.morphTargetsRelative ? (ub.addVectors(cb.min, hb.min), cb.expandByPoint(ub), ub.addVectors(cb.max, hb.max), cb.expandByPoint(ub)) : (cb.expandByPoint(hb.min), cb.expandByPoint(hb.max))
                                }
                            cb.getCenter(n);
                            let i = 0;
                            for (let e = 0, r = t.count; e < r; e++) ub.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(ub));
                            if (e)
                                for (let r = 0, s = e.length; r < s; r++) {
                                    const s = e[r],
                                        o = this.morphTargetsRelative;
                                    for (let e = 0, r = s.count; e < r; e++) ub.fromBufferAttribute(s, e), o && (lb.fromBufferAttribute(t, e), ub.add(lb)), i = Math.max(i, n.distanceToSquared(ub))
                                }
                            this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                    computeFaceNormals() {}
                    computeTangents() {
                        const t = this.index,
                            e = this.attributes;
                        if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                        const n = t.array,
                            i = e.position.array,
                            r = e.normal.array,
                            s = e.uv.array,
                            o = i.length / 3;
                        void 0 === e.tangent && this.setAttribute("tangent", new tb(new Float32Array(4 * o), 4));
                        const a = e.tangent.array,
                            l = [],
                            c = [];
                        for (let t = 0; t < o; t++) l[t] = new Lx, c[t] = new Lx;
                        const h = new Lx,
                            u = new Lx,
                            d = new Lx,
                            p = new vx,
                            m = new vx,
                            f = new vx,
                            g = new Lx,
                            v = new Lx;

                        function y(t, e, n) {
                            h.fromArray(i, 3 * t), u.fromArray(i, 3 * e), d.fromArray(i, 3 * n), p.fromArray(s, 2 * t), m.fromArray(s, 2 * e), f.fromArray(s, 2 * n), u.sub(h), d.sub(h), m.sub(p), f.sub(p);
                            const r = 1 / (m.x * f.y - f.x * m.y);
                            isFinite(r) && (g.copy(u).multiplyScalar(f.y).addScaledVector(d, -m.y).multiplyScalar(r), v.copy(d).multiplyScalar(m.x).addScaledVector(u, -f.x).multiplyScalar(r), l[t].add(g), l[e].add(g), l[n].add(g), c[t].add(v), c[e].add(v), c[n].add(v))
                        }
                        let x = this.groups;
                        0 === x.length && (x = [{ start: 0, count: n.length }]);
                        for (let t = 0, e = x.length; t < e; ++t) {
                            const e = x[t],
                                i = e.start;
                            for (let t = i, r = i + e.count; t < r; t += 3) y(n[t + 0], n[t + 1], n[t + 2])
                        }
                        const _ = new Lx,
                            b = new Lx,
                            w = new Lx,
                            M = new Lx;

                        function S(t) {
                            w.fromArray(r, 3 * t), M.copy(w);
                            const e = l[t];
                            _.copy(e), _.sub(w.multiplyScalar(w.dot(e))).normalize(), b.crossVectors(M, e);
                            const n = b.dot(c[t]) < 0 ? -1 : 1;
                            a[4 * t] = _.x, a[4 * t + 1] = _.y, a[4 * t + 2] = _.z, a[4 * t + 3] = n
                        }
                        for (let t = 0, e = x.length; t < e; ++t) {
                            const e = x[t],
                                i = e.start;
                            for (let t = i, r = i + e.count; t < r; t += 3) S(n[t + 0]), S(n[t + 1]), S(n[t + 2])
                        }
                    }
                    computeVertexNormals() {
                        const t = this.index,
                            e = this.getAttribute("position");
                        if (void 0 !== e) {
                            let n = this.getAttribute("normal");
                            if (void 0 === n) n = new tb(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                            else
                                for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                            const i = new Lx,
                                r = new Lx,
                                s = new Lx,
                                o = new Lx,
                                a = new Lx,
                                l = new Lx,
                                c = new Lx,
                                h = new Lx;
                            if (t)
                                for (let u = 0, d = t.count; u < d; u += 3) {
                                    const d = t.getX(u + 0),
                                        p = t.getX(u + 1),
                                        m = t.getX(u + 2);
                                    i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), s.fromBufferAttribute(e, m), c.subVectors(s, r), h.subVectors(i, r), c.cross(h), o.fromBufferAttribute(n, d), a.fromBufferAttribute(n, p), l.fromBufferAttribute(n, m), o.add(c), a.add(c), l.add(c), n.setXYZ(d, o.x, o.y, o.z), n.setXYZ(p, a.x, a.y, a.z), n.setXYZ(m, l.x, l.y, l.z)
                                } else
                                    for (let t = 0, o = e.count; t < o; t += 3) i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), s.fromBufferAttribute(e, t + 2), c.subVectors(s, r), h.subVectors(i, r), c.cross(h), n.setXYZ(t + 0, c.x, c.y, c.z), n.setXYZ(t + 1, c.x, c.y, c.z), n.setXYZ(t + 2, c.x, c.y, c.z);
                            this.normalizeNormals(), n.needsUpdate = !0
                        }
                    }
                    merge(t, e) {
                        if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                        void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                        const n = this.attributes;
                        for (const i in n) {
                            if (void 0 === t.attributes[i]) continue;
                            const r = n[i].array,
                                s = t.attributes[i],
                                o = s.array,
                                a = s.itemSize * e,
                                l = Math.min(o.length, r.length - a);
                            for (let t = 0, e = a; t < l; t++, e++) r[e] = o[t]
                        }
                        return this
                    }
                    normalizeNormals() { const t = this.attributes.normal; for (let e = 0, n = t.count; e < n; e++) ub.fromBufferAttribute(t, e), ub.normalize(), t.setXYZ(e, ub.x, ub.y, ub.z) }
                    toNonIndexed() {
                        function t(t, e) {
                            const n = t.array,
                                i = t.itemSize,
                                r = t.normalized,
                                s = new n.constructor(e.length * i);
                            let o = 0,
                                a = 0;
                            for (let r = 0, l = e.length; r < l; r++) { o = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i; for (let t = 0; t < i; t++) s[a++] = n[o++] }
                            return new tb(s, i, r)
                        }
                        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                        const e = new db,
                            n = this.index.array,
                            i = this.attributes;
                        for (const r in i) {
                            const s = t(i[r], n);
                            e.setAttribute(r, s)
                        }
                        const r = this.morphAttributes;
                        for (const i in r) {
                            const s = [],
                                o = r[i];
                            for (let e = 0, i = o.length; e < i; e++) {
                                const i = t(o[e], n);
                                s.push(i)
                            }
                            e.morphAttributes[i] = s
                        }
                        e.morphTargetsRelative = this.morphTargetsRelative;
                        const s = this.groups;
                        for (let t = 0, n = s.length; t < n; t++) {
                            const n = s[t];
                            e.addGroup(n.start, n.count, n.materialIndex)
                        }
                        return e
                    }
                    toJSON() {
                        const t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
                        if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) { const e = this.parameters; for (const n in e) void 0 !== e[n] && (t[n] = e[n]); return t }
                        t.data = { attributes: {} };
                        const e = this.index;
                        null !== e && (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) });
                        const n = this.attributes;
                        for (const e in n) {
                            const i = n[e];
                            t.data.attributes[e] = i.toJSON(t.data)
                        }
                        const i = {};
                        let r = !1;
                        for (const e in this.morphAttributes) {
                            const n = this.morphAttributes[e],
                                s = [];
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = n[e];
                                s.push(i.toJSON(t.data))
                            }
                            s.length > 0 && (i[e] = s, r = !0)
                        }
                        r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
                        const s = this.groups;
                        s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                        const o = this.boundingSphere;
                        return null !== o && (t.data.boundingSphere = { center: o.center.toArray(), radius: o.radius }), t
                    }
                    clone() { return (new db).copy(this) }
                    copy(t) {
                        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                        const e = {};
                        this.name = t.name;
                        const n = t.index;
                        null !== n && this.setIndex(n.clone(e));
                        const i = t.attributes;
                        for (const t in i) {
                            const n = i[t];
                            this.setAttribute(t, n.clone(e))
                        }
                        const r = t.morphAttributes;
                        for (const t in r) {
                            const n = [],
                                i = r[t];
                            for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
                            this.morphAttributes[t] = n
                        }
                        this.morphTargetsRelative = t.morphTargetsRelative;
                        const s = t.groups;
                        for (let t = 0, e = s.length; t < e; t++) {
                            const e = s[t];
                            this.addGroup(e.start, e.count, e.materialIndex)
                        }
                        const o = t.boundingBox;
                        null !== o && (this.boundingBox = o.clone());
                        const a = t.boundingSphere;
                        return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
                    }
                    dispose() { this.dispatchEvent({ type: "dispose" }) }
                }
                db.prototype.isBufferGeometry = !0;
                const pb = new s_,
                    mb = new r_,
                    fb = new Jx,
                    gb = new Lx,
                    vb = new Lx,
                    yb = new Lx,
                    xb = new Lx,
                    _b = new Lx,
                    bb = new Lx,
                    wb = new Lx,
                    Mb = new Lx,
                    Sb = new Lx,
                    Tb = new vx,
                    Eb = new vx,
                    Ab = new vx,
                    Lb = new Lx,
                    Rb = new Lx;
                class Cb extends C_ {
                    constructor(t = new db, e = new K_) { super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets() }
                    copy(t) { return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this }
                    updateMorphTargets() {
                        const t = this.geometry;
                        if (t.isBufferGeometry) {
                            const e = t.morphAttributes,
                                n = Object.keys(e);
                            if (n.length > 0) {
                                const t = e[n[0]];
                                if (void 0 !== t) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let e = 0, n = t.length; e < n; e++) {
                                        const n = t[e].name || String(e);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                    }
                                }
                            }
                        } else {
                            const e = t.morphTargets;
                            void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                        }
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            i = this.material,
                            r = this.matrixWorld;
                        if (void 0 === i) return;
                        if (null === n.boundingSphere && n.computeBoundingSphere(), fb.copy(n.boundingSphere), fb.applyMatrix4(r), !1 === t.ray.intersectsSphere(fb)) return;
                        if (pb.copy(r).invert(), mb.copy(t.ray).applyMatrix4(pb), null !== n.boundingBox && !1 === mb.intersectsBox(n.boundingBox)) return;
                        let s;
                        if (n.isBufferGeometry) {
                            const r = n.index,
                                o = n.attributes.position,
                                a = n.morphAttributes.position,
                                l = n.morphTargetsRelative,
                                c = n.attributes.uv,
                                h = n.attributes.uv2,
                                u = n.groups,
                                d = n.drawRange;
                            if (null !== r)
                                if (Array.isArray(i))
                                    for (let n = 0, p = u.length; n < p; n++) {
                                        const p = u[n],
                                            m = i[p.materialIndex];
                                        for (let n = Math.max(p.start, d.start), i = Math.min(p.start + p.count, d.start + d.count); n < i; n += 3) {
                                            const i = r.getX(n),
                                                u = r.getX(n + 1),
                                                d = r.getX(n + 2);
                                            s = Pb(this, m, t, mb, o, a, l, c, h, i, u, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, e.push(s))
                                        }
                                    } else
                                        for (let n = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); n < u; n += 3) {
                                            const u = r.getX(n),
                                                d = r.getX(n + 1),
                                                p = r.getX(n + 2);
                                            s = Pb(this, i, t, mb, o, a, l, c, h, u, d, p), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                                        } else if (void 0 !== o)
                                            if (Array.isArray(i))
                                                for (let n = 0, r = u.length; n < r; n++) {
                                                    const r = u[n],
                                                        p = i[r.materialIndex];
                                                    for (let n = Math.max(r.start, d.start), i = Math.min(r.start + r.count, d.start + d.count); n < i; n += 3) s = Pb(this, p, t, mb, o, a, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, e.push(s))
                                                } else
                                                    for (let n = Math.max(0, d.start), r = Math.min(o.count, d.start + d.count); n < r; n += 3) s = Pb(this, i, t, mb, o, a, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                        } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }

                function Pb(t, e, n, i, r, s, o, a, l, c, h, u) {
                    gb.fromBufferAttribute(r, c), vb.fromBufferAttribute(r, h), yb.fromBufferAttribute(r, u);
                    const d = t.morphTargetInfluences;
                    if (e.morphTargets && s && d) {
                        wb.set(0, 0, 0), Mb.set(0, 0, 0), Sb.set(0, 0, 0);
                        for (let t = 0, e = s.length; t < e; t++) {
                            const e = d[t],
                                n = s[t];
                            0 !== e && (xb.fromBufferAttribute(n, c), _b.fromBufferAttribute(n, h), bb.fromBufferAttribute(n, u), o ? (wb.addScaledVector(xb, e), Mb.addScaledVector(_b, e), Sb.addScaledVector(bb, e)) : (wb.addScaledVector(xb.sub(gb), e), Mb.addScaledVector(_b.sub(vb), e), Sb.addScaledVector(bb.sub(yb), e)))
                        }
                        gb.add(wb), vb.add(Mb), yb.add(Sb)
                    }
                    t.isSkinnedMesh && (t.boneTransform(c, gb), t.boneTransform(h, vb), t.boneTransform(u, yb));
                    const p = function(t, e, n, i, r, s, o, a) {
                        let l;
                        if (l = 1 === e.side ? i.intersectTriangle(o, s, r, !0, a) : i.intersectTriangle(r, s, o, 2 !== e.side, a), null === l) return null;
                        Rb.copy(a), Rb.applyMatrix4(t.matrixWorld);
                        const c = n.ray.origin.distanceTo(Rb);
                        return c < n.near || c > n.far ? null : { distance: c, point: Rb.clone(), object: t }
                    }(t, e, n, i, gb, vb, yb, Lb);
                    if (p) {
                        a && (Tb.fromBufferAttribute(a, c), Eb.fromBufferAttribute(a, h), Ab.fromBufferAttribute(a, u), p.uv = k_.getUV(Lb, gb, vb, yb, Tb, Eb, Ab, new vx)), l && (Tb.fromBufferAttribute(l, c), Eb.fromBufferAttribute(l, h), Ab.fromBufferAttribute(l, u), p.uv2 = k_.getUV(Lb, gb, vb, yb, Tb, Eb, Ab, new vx));
                        const t = { a: c, b: h, c: u, normal: new Lx, materialIndex: 0 };
                        k_.getNormal(gb, vb, yb, t.normal), p.face = t
                    }
                    return p
                }
                Cb.prototype.isMesh = !0;
                class Ib extends db {
                    constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
                        super(), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: n, widthSegments: i, heightSegments: r, depthSegments: s };
                        const o = this;
                        i = Math.floor(i), r = Math.floor(r), s = Math.floor(s);
                        const a = [],
                            l = [],
                            c = [],
                            h = [];
                        let u = 0,
                            d = 0;

                        function p(t, e, n, i, r, s, p, m, f, g, v) {
                            const y = s / f,
                                x = p / g,
                                _ = s / 2,
                                b = p / 2,
                                w = m / 2,
                                M = f + 1,
                                S = g + 1;
                            let T = 0,
                                E = 0;
                            const A = new Lx;
                            for (let s = 0; s < S; s++) {
                                const o = s * x - b;
                                for (let a = 0; a < M; a++) {
                                    const u = a * y - _;
                                    A[t] = u * i, A[e] = o * r, A[n] = w, l.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = m > 0 ? 1 : -1, c.push(A.x, A.y, A.z), h.push(a / f), h.push(1 - s / g), T += 1
                                }
                            }
                            for (let t = 0; t < g; t++)
                                for (let e = 0; e < f; e++) {
                                    const n = u + e + M * t,
                                        i = u + e + M * (t + 1),
                                        r = u + (e + 1) + M * (t + 1),
                                        s = u + (e + 1) + M * t;
                                    a.push(n, i, s), a.push(i, r, s), E += 6
                                }
                            o.addGroup(d, E, v), d += E, u += T
                        }
                        p("z", "y", "x", -1, -1, n, e, t, s, r, 0), p("z", "y", "x", 1, -1, n, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, s, 2), p("x", "z", "y", 1, -1, t, n, -e, i, s, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new ib(l, 3)), this.setAttribute("normal", new ib(c, 3)), this.setAttribute("uv", new ib(h, 2))
                    }
                    static fromJSON(t) { return new Ib(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments) }
                }

                function Db(t) {
                    const e = {};
                    for (const n in t) {
                        e[n] = {};
                        for (const i in t[n]) {
                            const r = t[n][i];
                            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                        }
                    }
                    return e
                }

                function Nb(t) { const e = {}; for (let n = 0; n < t.length; n++) { const i = Db(t[n]); for (const t in i) e[t] = i[t] } return e }
                const Bb = { clone: Db, merge: Nb };
                class Ob extends V_ {
                    constructor(t) { super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t)) }
                    copy(t) { return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Db(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        e.glslVersion = this.glslVersion, e.uniforms = {};
                        for (const n in this.uniforms) {
                            const i = this.uniforms[n].value;
                            i && i.isTexture ? e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid } : i && i.isColor ? e.uniforms[n] = { type: "c", value: i.getHex() } : i && i.isVector2 ? e.uniforms[n] = { type: "v2", value: i.toArray() } : i && i.isVector3 ? e.uniforms[n] = { type: "v3", value: i.toArray() } : i && i.isVector4 ? e.uniforms[n] = { type: "v4", value: i.toArray() } : i && i.isMatrix3 ? e.uniforms[n] = { type: "m3", value: i.toArray() } : i && i.isMatrix4 ? e.uniforms[n] = { type: "m4", value: i.toArray() } : e.uniforms[n] = { value: i }
                        }
                        Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                        const n = {};
                        for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
                        return Object.keys(n).length > 0 && (e.extensions = n), e
                    }
                }
                Ob.prototype.isShaderMaterial = !0;
                class Fb extends C_ {
                    constructor() { super(), this.type = "Camera", this.matrixWorldInverse = new s_, this.projectionMatrix = new s_, this.projectionMatrixInverse = new s_ }
                    copy(t, e) { return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this }
                    getWorldDirection(t) { this.updateWorldMatrix(!0, !1); const e = this.matrixWorld.elements; return t.set(-e[8], -e[9], -e[10]).normalize() }
                    updateMatrixWorld(t) { super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert() }
                    updateWorldMatrix(t, e) { super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert() }
                    clone() { return (new this.constructor).copy(this) }
                }
                Fb.prototype.isCamera = !0;
                class zb extends Fb {
                    constructor(t = 50, e = 1, n = .1, i = 2e3) { super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() }
                    copy(t, e) { return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this }
                    setFocalLength(t) {
                        const e = .5 * this.getFilmHeight() / t;
                        this.fov = 2 * cx * Math.atan(e), this.updateProjectionMatrix()
                    }
                    getFocalLength() { const t = Math.tan(.5 * lx * this.fov); return .5 * this.getFilmHeight() / t }
                    getEffectiveFOV() { return 2 * cx * Math.atan(Math.tan(.5 * lx * this.fov) / this.zoom) }
                    getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) }
                    getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) }
                    setViewOffset(t, e, n, i, r, s) { this.aspect = t / e, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix() }
                    clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }
                    updateProjectionMatrix() {
                        const t = this.near;
                        let e = t * Math.tan(.5 * lx * this.fov) / this.zoom,
                            n = 2 * e,
                            i = this.aspect * n,
                            r = -.5 * i;
                        const s = this.view;
                        if (null !== this.view && this.view.enabled) {
                            const t = s.fullWidth,
                                o = s.fullHeight;
                            r += s.offsetX * i / t, e -= s.offsetY * n / o, i *= s.width / t, n *= s.height / o
                        }
                        const o = this.filmOffset;
                        0 !== o && (r += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(t) { const e = super.toJSON(t); return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e }
                }
                zb.prototype.isPerspectiveCamera = !0;
                const Ub = 90;
                class Hb extends C_ {
                    constructor(t, e, n) {
                        if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                        this.renderTarget = n;
                        const i = new zb(Ub, 1, t, e);
                        i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new Lx(1, 0, 0)), this.add(i);
                        const r = new zb(Ub, 1, t, e);
                        r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Lx(-1, 0, 0)), this.add(r);
                        const s = new zb(Ub, 1, t, e);
                        s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new Lx(0, 1, 0)), this.add(s);
                        const o = new zb(Ub, 1, t, e);
                        o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new Lx(0, -1, 0)), this.add(o);
                        const a = new zb(Ub, 1, t, e);
                        a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new Lx(0, 0, 1)), this.add(a);
                        const l = new zb(Ub, 1, t, e);
                        l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Lx(0, 0, -1)), this.add(l)
                    }
                    update(t, e) {
                        null === this.parent && this.updateMatrixWorld();
                        const n = this.renderTarget,
                            [i, r, s, o, a, l] = this.children,
                            c = t.xr.enabled,
                            h = t.getRenderTarget();
                        t.xr.enabled = !1;
                        const u = n.texture.generateMipmaps;
                        n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, o), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = u, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(h), t.xr.enabled = c
                    }
                }
                class kb extends wx {
                    constructor(t, e, n, i, r, s, o, a, l, c) { super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : 301, n, i, r, s, o = void 0 !== o ? o : Wy, a, l, c), this._needsFlipEnvMap = !0, this.flipY = !1 }
                    get images() { return this.image }
                    set images(t) { this.image = t }
                }
                kb.prototype.isCubeTexture = !0;
                class Gb extends Tx {
                    constructor(t, e, n) { Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new kb(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : Oy, this.texture._needsFlipEnvMap = !1 }
                    fromEquirectangularTexture(t, e) {
                        this.texture.type = e.type, this.texture.format = jy, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                        const n = { tEquirect: { value: null } },
                            i = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                            r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                            s = new Ib(5, 5, 5),
                            o = new Ob({ name: "CubemapFromEquirect", uniforms: Db(n), vertexShader: i, fragmentShader: r, side: 1, blending: 0 });
                        o.uniforms.tEquirect.value = e;
                        const a = new Cb(s, o),
                            l = e.minFilter;
                        return e.minFilter === Fy && (e.minFilter = Oy), new Hb(1, 10, this).update(t, a), e.minFilter = l, a.geometry.dispose(), a.material.dispose(), this
                    }
                    clear(t, e, n, i) {
                        const r = t.getRenderTarget();
                        for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
                        t.setRenderTarget(r)
                    }
                }
                Gb.prototype.isWebGLCubeRenderTarget = !0;
                const Vb = new Lx,
                    Wb = new Lx,
                    jb = new yx;
                class qb {
                    constructor(t = new Lx(1, 0, 0), e = 0) { this.normal = t, this.constant = e }
                    set(t, e) { return this.normal.copy(t), this.constant = e, this }
                    setComponents(t, e, n, i) { return this.normal.set(t, e, n), this.constant = i, this }
                    setFromNormalAndCoplanarPoint(t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this }
                    setFromCoplanarPoints(t, e, n) { const i = Vb.subVectors(n, e).cross(Wb.subVectors(t, e)).normalize(); return this.setFromNormalAndCoplanarPoint(i, t), this }
                    copy(t) { return this.normal.copy(t.normal), this.constant = t.constant, this }
                    normalize() { const t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this }
                    negate() { return this.constant *= -1, this.normal.negate(), this }
                    distanceToPoint(t) { return this.normal.dot(t) + this.constant }
                    distanceToSphere(t) { return this.distanceToPoint(t.center) - t.radius }
                    projectPoint(t, e) { return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t) }
                    intersectLine(t, e) {
                        const n = t.delta(Vb),
                            i = this.normal.dot(n);
                        if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                        const r = -(t.start.dot(this.normal) + this.constant) / i;
                        return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start)
                    }
                    intersectsLine(t) {
                        const e = this.distanceToPoint(t.start),
                            n = this.distanceToPoint(t.end);
                        return e < 0 && n > 0 || n < 0 && e > 0
                    }
                    intersectsBox(t) { return t.intersectsPlane(this) }
                    intersectsSphere(t) { return t.intersectsPlane(this) }
                    coplanarPoint(t) { return t.copy(this.normal).multiplyScalar(-this.constant) }
                    applyMatrix4(t, e) {
                        const n = e || jb.getNormalMatrix(t),
                            i = this.coplanarPoint(Vb).applyMatrix4(t),
                            r = this.normal.applyMatrix3(n).normalize();
                        return this.constant = -i.dot(r), this
                    }
                    translate(t) { return this.constant -= t.dot(this.normal), this }
                    equals(t) { return t.normal.equals(this.normal) && t.constant === this.constant }
                    clone() { return (new this.constructor).copy(this) }
                }
                qb.prototype.isPlane = !0;
                const Xb = new Jx,
                    Yb = new Lx;
                class Zb {
                    constructor(t = new qb, e = new qb, n = new qb, i = new qb, r = new qb, s = new qb) { this.planes = [t, e, n, i, r, s] }
                    set(t, e, n, i, r, s) { const o = this.planes; return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(s), this }
                    copy(t) { const e = this.planes; for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]); return this }
                    setFromProjectionMatrix(t) {
                        const e = this.planes,
                            n = t.elements,
                            i = n[0],
                            r = n[1],
                            s = n[2],
                            o = n[3],
                            a = n[4],
                            l = n[5],
                            c = n[6],
                            h = n[7],
                            u = n[8],
                            d = n[9],
                            p = n[10],
                            m = n[11],
                            f = n[12],
                            g = n[13],
                            v = n[14],
                            y = n[15];
                        return e[0].setComponents(o - i, h - a, m - u, y - f).normalize(), e[1].setComponents(o + i, h + a, m + u, y + f).normalize(), e[2].setComponents(o + r, h + l, m + d, y + g).normalize(), e[3].setComponents(o - r, h - l, m - d, y - g).normalize(), e[4].setComponents(o - s, h - c, m - p, y - v).normalize(), e[5].setComponents(o + s, h + c, m + p, y + v).normalize(), this
                    }
                    intersectsObject(t) { const e = t.geometry; return null === e.boundingSphere && e.computeBoundingSphere(), Xb.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Xb) }
                    intersectsSprite(t) { return Xb.center.set(0, 0, 0), Xb.radius = .7071067811865476, Xb.applyMatrix4(t.matrixWorld), this.intersectsSphere(Xb) }
                    intersectsSphere(t) {
                        const e = this.planes,
                            n = t.center,
                            i = -t.radius;
                        for (let t = 0; t < 6; t++)
                            if (e[t].distanceToPoint(n) < i) return !1;
                        return !0
                    }
                    intersectsBox(t) { const e = this.planes; for (let n = 0; n < 6; n++) { const i = e[n]; if (Yb.x = i.normal.x > 0 ? t.max.x : t.min.x, Yb.y = i.normal.y > 0 ? t.max.y : t.min.y, Yb.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(Yb) < 0) return !1 } return !0 }
                    containsPoint(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++)
                            if (e[n].distanceToPoint(t) < 0) return !1;
                        return !0
                    }
                    clone() { return (new this.constructor).copy(this) }
                }

                function Jb() {
                    let t = null,
                        e = !1,
                        n = null,
                        i = null;

                    function r(e, s) { n(e, s), i = t.requestAnimationFrame(r) }
                    return { start: function() {!0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0) }, stop: function() { t.cancelAnimationFrame(i), e = !1 }, setAnimationLoop: function(t) { n = t }, setContext: function(e) { t = e } }
                }

                function Kb(t, e) {
                    const n = e.isWebGL2,
                        i = new WeakMap;
                    return {
                        get: function(t) { return t.isInterleavedBufferAttribute && (t = t.data), i.get(t) },
                        remove: function(e) {
                            e.isInterleavedBufferAttribute && (e = e.data);
                            const n = i.get(e);
                            n && (t.deleteBuffer(n.buffer), i.delete(e))
                        },
                        update: function(e, r) {
                            if (e.isGLBufferAttribute) { const t = i.get(e); return void((!t || t.version < e.version) && i.set(e, { buffer: e.buffer, type: e.type, bytesPerElement: e.elementSize, version: e.version })) }
                            e.isInterleavedBufferAttribute && (e = e.data);
                            const s = i.get(e);
                            void 0 === s ? i.set(e, function(e, i) {
                                const r = e.array,
                                    s = e.usage,
                                    o = t.createBuffer();
                                t.bindBuffer(i, o), t.bufferData(i, r, s), e.onUploadCallback();
                                let a = 5126;
                                return r instanceof Float32Array ? a = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : (r instanceof Uint8Array || r instanceof Uint8ClampedArray) && (a = 5121), { buffer: o, type: a, bytesPerElement: r.BYTES_PER_ELEMENT, version: e.version }
                            }(e, r)) : s.version < e.version && (function(e, i, r) {
                                const s = i.array,
                                    o = i.updateRange;
                                t.bindBuffer(r, e), -1 === o.count ? t.bufferSubData(r, 0, s) : (n ? t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)), o.count = -1)
                            }(s.buffer, e, r), s.version = e.version)
                        }
                    }
                }
                class Qb extends db {
                    constructor(t = 1, e = 1, n = 1, i = 1) {
                        super(), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i };
                        const r = t / 2,
                            s = e / 2,
                            o = Math.floor(n),
                            a = Math.floor(i),
                            l = o + 1,
                            c = a + 1,
                            h = t / o,
                            u = e / a,
                            d = [],
                            p = [],
                            m = [],
                            f = [];
                        for (let t = 0; t < c; t++) {
                            const e = t * u - s;
                            for (let n = 0; n < l; n++) {
                                const i = n * h - r;
                                p.push(i, -e, 0), m.push(0, 0, 1), f.push(n / o), f.push(1 - t / a)
                            }
                        }
                        for (let t = 0; t < a; t++)
                            for (let e = 0; e < o; e++) {
                                const n = e + l * t,
                                    i = e + l * (t + 1),
                                    r = e + 1 + l * (t + 1),
                                    s = e + 1 + l * t;
                                d.push(n, i, s), d.push(i, r, s)
                            }
                        this.setIndex(d), this.setAttribute("position", new ib(p, 3)), this.setAttribute("normal", new ib(m, 3)), this.setAttribute("uv", new ib(f, 2))
                    }
                    static fromJSON(t) { return new Qb(t.width, t.height, t.widthSegments, t.heightSegments) }
                }
                const $b = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotVH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSNMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n\t\tnormal, v, roughnessFactor, material.diffuseColor, totalSpecular,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform vec3 attenuationColor;\n\tuniform float attenuationDistance;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" },
                    tw = { common: { diffuse: { value: new J_(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new yx }, uv2Transform: { value: new yx }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new vx(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new J_(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new J_(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new yx } }, sprite: { diffuse: { value: new J_(16777215) }, opacity: { value: 1 }, center: { value: new vx(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new yx } } },
                    ew = { basic: { uniforms: Nb([tw.common, tw.specularmap, tw.envmap, tw.aomap, tw.lightmap, tw.fog]), vertexShader: $b.meshbasic_vert, fragmentShader: $b.meshbasic_frag }, lambert: { uniforms: Nb([tw.common, tw.specularmap, tw.envmap, tw.aomap, tw.lightmap, tw.emissivemap, tw.fog, tw.lights, { emissive: { value: new J_(0) } }]), vertexShader: $b.meshlambert_vert, fragmentShader: $b.meshlambert_frag }, phong: { uniforms: Nb([tw.common, tw.specularmap, tw.envmap, tw.aomap, tw.lightmap, tw.emissivemap, tw.bumpmap, tw.normalmap, tw.displacementmap, tw.fog, tw.lights, { emissive: { value: new J_(0) }, specular: { value: new J_(1118481) }, shininess: { value: 30 } }]), vertexShader: $b.meshphong_vert, fragmentShader: $b.meshphong_frag }, standard: { uniforms: Nb([tw.common, tw.envmap, tw.aomap, tw.lightmap, tw.emissivemap, tw.bumpmap, tw.normalmap, tw.displacementmap, tw.roughnessmap, tw.metalnessmap, tw.fog, tw.lights, { emissive: { value: new J_(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: $b.meshphysical_vert, fragmentShader: $b.meshphysical_frag }, toon: { uniforms: Nb([tw.common, tw.aomap, tw.lightmap, tw.emissivemap, tw.bumpmap, tw.normalmap, tw.displacementmap, tw.gradientmap, tw.fog, tw.lights, { emissive: { value: new J_(0) } }]), vertexShader: $b.meshtoon_vert, fragmentShader: $b.meshtoon_frag }, matcap: { uniforms: Nb([tw.common, tw.bumpmap, tw.normalmap, tw.displacementmap, tw.fog, { matcap: { value: null } }]), vertexShader: $b.meshmatcap_vert, fragmentShader: $b.meshmatcap_frag }, points: { uniforms: Nb([tw.points, tw.fog]), vertexShader: $b.points_vert, fragmentShader: $b.points_frag }, dashed: { uniforms: Nb([tw.common, tw.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: $b.linedashed_vert, fragmentShader: $b.linedashed_frag }, depth: { uniforms: Nb([tw.common, tw.displacementmap]), vertexShader: $b.depth_vert, fragmentShader: $b.depth_frag }, normal: { uniforms: Nb([tw.common, tw.bumpmap, tw.normalmap, tw.displacementmap, { opacity: { value: 1 } }]), vertexShader: $b.normal_vert, fragmentShader: $b.normal_frag }, sprite: { uniforms: Nb([tw.sprite, tw.fog]), vertexShader: $b.sprite_vert, fragmentShader: $b.sprite_frag }, background: { uniforms: { uvTransform: { value: new yx }, t2D: { value: null } }, vertexShader: $b.background_vert, fragmentShader: $b.background_frag }, cube: { uniforms: Nb([tw.envmap, { opacity: { value: 1 } }]), vertexShader: $b.cube_vert, fragmentShader: $b.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: $b.equirect_vert, fragmentShader: $b.equirect_frag }, distanceRGBA: { uniforms: Nb([tw.common, tw.displacementmap, { referencePosition: { value: new Lx }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: $b.distanceRGBA_vert, fragmentShader: $b.distanceRGBA_frag }, shadow: { uniforms: Nb([tw.lights, tw.fog, { color: { value: new J_(0) }, opacity: { value: 1 } }]), vertexShader: $b.shadow_vert, fragmentShader: $b.shadow_frag } };

                function nw(t, e, n, i, r) {
                    const s = new J_(0);
                    let o, a, l = 0,
                        c = null,
                        h = 0,
                        u = null;

                    function d(t, e) { n.buffers.color.setClear(t.r, t.g, t.b, e, r) }
                    return {
                        getClearColor: function() { return s },
                        setClearColor: function(t, e = 1) { s.set(t), l = e, d(s, l) },
                        getClearAlpha: function() { return l },
                        setClearAlpha: function(t) { l = t, d(s, l) },
                        render: function(n, r) {
                            let p = !1,
                                m = !0 === r.isScene ? r.background : null;
                            m && m.isTexture && (m = e.get(m));
                            const f = t.xr,
                                g = f.getSession && f.getSession();
                            g && "additive" === g.environmentBlendMode && (m = null), null === m ? d(s, l) : m && m.isColor && (d(m, 1), p = !0), (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), m && (m.isCubeTexture || 306 === m.mapping) ? (void 0 === a && (a = new Cb(new Ib(1, 1, 1), new Ob({ name: "BackgroundCubeMaterial", uniforms: Db(ew.cube.uniforms), vertexShader: ew.cube.vertexShader, fragmentShader: ew.cube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1 })), a.geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function(t, e, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(a.material, "envMap", { get: function() { return this.uniforms.envMap.value } }), i.update(a)), a.material.uniforms.envMap.value = m, a.material.uniforms.flipEnvMap.value = m.isCubeTexture && m._needsFlipEnvMap ? -1 : 1, c === m && h === m.version && u === t.toneMapping || (a.material.needsUpdate = !0, c = m, h = m.version, u = t.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null)) : m && m.isTexture && (void 0 === o && (o = new Cb(new Qb(2, 2), new Ob({ name: "BackgroundMaterial", uniforms: Db(ew.background.uniforms), vertexShader: ew.background.vertexShader, fragmentShader: ew.background.fragmentShader, side: 0, depthTest: !1, depthWrite: !1, fog: !1 })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", { get: function() { return this.uniforms.t2D.value } }), i.update(o)), o.material.uniforms.t2D.value = m, !0 === m.matrixAutoUpdate && m.updateMatrix(), o.material.uniforms.uvTransform.value.copy(m.matrix), c === m && h === m.version && u === t.toneMapping || (o.material.needsUpdate = !0, c = m, h = m.version, u = t.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null))
                        }
                    }
                }

                function iw(t, e, n, i) {
                    const r = t.getParameter(34921),
                        s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                        o = i.isWebGL2 || null !== s,
                        a = {},
                        l = d(null);
                    let c = l;

                    function h(e) { return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e) }

                    function u(e) { return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e) }

                    function d(t) {
                        const e = [],
                            n = [],
                            i = [];
                        for (let t = 0; t < r; t++) e[t] = 0, n[t] = 0, i[t] = 0;
                        return { geometry: null, program: null, wireframe: !1, newAttributes: e, enabledAttributes: n, attributeDivisors: i, object: t, attributes: {}, index: null }
                    }

                    function p() { const t = c.newAttributes; for (let e = 0, n = t.length; e < n; e++) t[e] = 0 }

                    function m(t) { f(t, 0) }

                    function f(n, r) {
                        const s = c.newAttributes,
                            o = c.enabledAttributes,
                            a = c.attributeDivisors;
                        s[n] = 1, 0 === o[n] && (t.enableVertexAttribArray(n), o[n] = 1), a[n] !== r && ((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), a[n] = r)
                    }

                    function g() {
                        const e = c.newAttributes,
                            n = c.enabledAttributes;
                        for (let i = 0, r = n.length; i < r; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0)
                    }

                    function v(e, n, r, s, o, a) {!0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, s, o, a) : t.vertexAttribIPointer(e, n, r, o, a) }

                    function y() { x(), c !== l && (c = l, h(c.object)) }

                    function x() { l.geometry = null, l.program = null, l.wireframe = !1 }
                    return {
                        setup: function(r, l, u, y, x) {
                            let _ = !1;
                            if (o) {
                                const e = function(e, n, r) {
                                    const o = !0 === r.wireframe;
                                    let l = a[e.id];
                                    void 0 === l && (l = {}, a[e.id] = l);
                                    let c = l[n.id];
                                    void 0 === c && (c = {}, l[n.id] = c);
                                    let h = c[o];
                                    return void 0 === h && (h = d(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()), c[o] = h), h
                                }(y, u, l);
                                c !== e && (c = e, h(c.object)), _ = function(t, e) {
                                    const n = c.attributes,
                                        i = t.attributes;
                                    let r = 0;
                                    for (const t in i) {
                                        const e = n[t],
                                            s = i[t];
                                        if (void 0 === e) return !0;
                                        if (e.attribute !== s) return !0;
                                        if (e.data !== s.data) return !0;
                                        r++
                                    }
                                    return c.attributesNum !== r || c.index !== e
                                }(y, x), _ && function(t, e) {
                                    const n = {},
                                        i = t.attributes;
                                    let r = 0;
                                    for (const t in i) {
                                        const e = i[t],
                                            s = {};
                                        s.attribute = e, e.data && (s.data = e.data), n[t] = s, r++
                                    }
                                    c.attributes = n, c.attributesNum = r, c.index = e
                                }(y, x)
                            } else {
                                const t = !0 === l.wireframe;
                                c.geometry === y.id && c.program === u.id && c.wireframe === t || (c.geometry = y.id, c.program = u.id, c.wireframe = t, _ = !0)
                            }!0 === r.isInstancedMesh && (_ = !0), null !== x && n.update(x, 34963), _ && (function(r, s, o, a) {
                                if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                                p();
                                const l = a.attributes,
                                    c = o.getAttributes(),
                                    h = s.defaultAttributeValues;
                                for (const e in c) {
                                    const i = c[e];
                                    if (i >= 0) {
                                        const s = l[e];
                                        if (void 0 !== s) {
                                            const e = s.normalized,
                                                r = s.itemSize,
                                                o = n.get(s);
                                            if (void 0 === o) continue;
                                            const l = o.buffer,
                                                c = o.type,
                                                h = o.bytesPerElement;
                                            if (s.isInterleavedBufferAttribute) {
                                                const n = s.data,
                                                    o = n.stride,
                                                    u = s.offset;
                                                n && n.isInstancedInterleavedBuffer ? (f(i, n.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)) : m(i), t.bindBuffer(34962, l), v(i, r, c, e, o * h, u * h)
                                            } else s.isInstancedBufferAttribute ? (f(i, s.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count)) : m(i), t.bindBuffer(34962, l), v(i, r, c, e, 0, 0)
                                        } else if ("instanceMatrix" === e) {
                                            const e = n.get(r.instanceMatrix);
                                            if (void 0 === e) continue;
                                            const s = e.buffer,
                                                o = e.type;
                                            f(i + 0, 1), f(i + 1, 1), f(i + 2, 1), f(i + 3, 1), t.bindBuffer(34962, s), t.vertexAttribPointer(i + 0, 4, o, !1, 64, 0), t.vertexAttribPointer(i + 1, 4, o, !1, 64, 16), t.vertexAttribPointer(i + 2, 4, o, !1, 64, 32), t.vertexAttribPointer(i + 3, 4, o, !1, 64, 48)
                                        } else if ("instanceColor" === e) {
                                            const e = n.get(r.instanceColor);
                                            if (void 0 === e) continue;
                                            const s = e.buffer,
                                                o = e.type;
                                            f(i, 1), t.bindBuffer(34962, s), t.vertexAttribPointer(i, 3, o, !1, 12, 0)
                                        } else if (void 0 !== h) {
                                            const n = h[e];
                                            if (void 0 !== n) switch (n.length) {
                                                case 2:
                                                    t.vertexAttrib2fv(i, n);
                                                    break;
                                                case 3:
                                                    t.vertexAttrib3fv(i, n);
                                                    break;
                                                case 4:
                                                    t.vertexAttrib4fv(i, n);
                                                    break;
                                                default:
                                                    t.vertexAttrib1fv(i, n)
                                            }
                                        }
                                    }
                                }
                                g()
                            }(r, l, u, y), null !== x && t.bindBuffer(34963, n.get(x).buffer))
                        },
                        reset: y,
                        resetDefaultState: x,
                        dispose: function() {
                            y();
                            for (const t in a) {
                                const e = a[t];
                                for (const t in e) {
                                    const n = e[t];
                                    for (const t in n) u(n[t].object), delete n[t];
                                    delete e[t]
                                }
                                delete a[t]
                            }
                        },
                        releaseStatesOfGeometry: function(t) {
                            if (void 0 === a[t.id]) return;
                            const e = a[t.id];
                            for (const t in e) {
                                const n = e[t];
                                for (const t in n) u(n[t].object), delete n[t];
                                delete e[t]
                            }
                            delete a[t.id]
                        },
                        releaseStatesOfProgram: function(t) {
                            for (const e in a) {
                                const n = a[e];
                                if (void 0 === n[t.id]) continue;
                                const i = n[t.id];
                                for (const t in i) u(i[t].object), delete i[t];
                                delete n[t.id]
                            }
                        },
                        initAttributes: p,
                        enableAttribute: m,
                        disableUnusedAttributes: g
                    }
                }

                function rw(t, e, n, i) {
                    const r = i.isWebGL2;
                    let s;
                    this.setMode = function(t) { s = t }, this.render = function(e, i) { t.drawArrays(s, e, i), n.update(i, s, 1) }, this.renderInstances = function(i, o, a) {
                        if (0 === a) return;
                        let l, c;
                        if (r) l = t, c = "drawArraysInstanced";
                        else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        l[c](s, i, o, a), n.update(o, s, a)
                    }
                }

                function sw(t, e, n) {
                    let i;

                    function r(e) {
                        if ("highp" === e) {
                            if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                            e = "mediump"
                        }
                        return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                    }
                    const s = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
                    let o = void 0 !== n.precision ? n.precision : "highp";
                    const a = r(o);
                    a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a);
                    const l = s || e.has("WEBGL_draw_buffers"),
                        c = !0 === n.logarithmicDepthBuffer,
                        h = t.getParameter(34930),
                        u = t.getParameter(35660),
                        d = t.getParameter(3379),
                        p = t.getParameter(34076),
                        m = t.getParameter(34921),
                        f = t.getParameter(36347),
                        g = t.getParameter(36348),
                        v = t.getParameter(36349),
                        y = u > 0,
                        x = s || e.has("OES_texture_float");
                    return {
                        isWebGL2: s,
                        drawBuffers: l,
                        getMaxAnisotropy: function() {
                            if (void 0 !== i) return i;
                            if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                                const n = e.get("EXT_texture_filter_anisotropic");
                                i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                            } else i = 0;
                            return i
                        },
                        getMaxPrecision: r,
                        precision: o,
                        logarithmicDepthBuffer: c,
                        maxTextures: h,
                        maxVertexTextures: u,
                        maxTextureSize: d,
                        maxCubemapSize: p,
                        maxAttributes: m,
                        maxVertexUniforms: f,
                        maxVaryings: g,
                        maxFragmentUniforms: v,
                        vertexTextures: y,
                        floatFragmentTextures: x,
                        floatVertexTextures: y && x,
                        maxSamples: s ? t.getParameter(36183) : 0
                    }
                }

                function ow(t) {
                    const e = this;
                    let n = null,
                        i = 0,
                        r = !1,
                        s = !1;
                    const o = new qb,
                        a = new yx,
                        l = { value: null, needsUpdate: !1 };

                    function c() { l.value !== n && (l.value = n, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0 }

                    function h(t, n, i, r) {
                        const s = null !== t ? t.length : 0;
                        let c = null;
                        if (0 !== s) {
                            if (c = l.value, !0 !== r || null === c) {
                                const e = i + 4 * s,
                                    r = n.matrixWorldInverse;
                                a.getNormalMatrix(r), (null === c || c.length < e) && (c = new Float32Array(e));
                                for (let e = 0, n = i; e !== s; ++e, n += 4) o.copy(t[e]).applyMatrix4(r, a), o.normal.toArray(c, n), c[n + 3] = o.constant
                            }
                            l.value = c, l.needsUpdate = !0
                        }
                        return e.numPlanes = s, e.numIntersection = 0, c
                    }
                    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e, s) { const o = 0 !== t.length || e || 0 !== i || r; return r = e, n = h(t, s, 0), i = t.length, o }, this.beginShadows = function() { s = !0, h(null) }, this.endShadows = function() { s = !1, c() }, this.setState = function(e, o, a) {
                        const u = e.clippingPlanes,
                            d = e.clipIntersection,
                            p = e.clipShadows,
                            m = t.get(e);
                        if (!r || null === u || 0 === u.length || s && !p) s ? h(null) : c();
                        else {
                            const t = s ? 0 : i,
                                e = 4 * t;
                            let r = m.clippingState || null;
                            l.value = r, r = h(u, o, e, a);
                            for (let t = 0; t !== e; ++t) r[t] = n[t];
                            m.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                        }
                    }
                }

                function aw(t) {
                    let e = new WeakMap;

                    function n(t, e) { return 303 === e ? t.mapping = 301 : 304 === e && (t.mapping = 302), t }

                    function i(t) {
                        const n = t.target;
                        n.removeEventListener("dispose", i);
                        const r = e.get(n);
                        void 0 !== r && (e.delete(n), r.dispose())
                    }
                    return {
                        get: function(r) {
                            if (r && r.isTexture) {
                                const s = r.mapping;
                                if (303 === s || 304 === s) {
                                    if (e.has(r)) return n(e.get(r).texture, r.mapping); {
                                        const s = r.image;
                                        if (s && s.height > 0) {
                                            const o = t.getRenderTarget(),
                                                a = new Gb(s.height / 2);
                                            return a.fromEquirectangularTexture(t, r), e.set(r, a), t.setRenderTarget(o), r.addEventListener("dispose", i), n(a.texture, r.mapping)
                                        }
                                        return null
                                    }
                                }
                            }
                            return r
                        },
                        dispose: function() { e = new WeakMap }
                    }
                }

                function lw(t) {
                    const e = {};

                    function n(n) {
                        if (void 0 !== e[n]) return e[n];
                        let i;
                        switch (n) {
                            case "WEBGL_depth_texture":
                                i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            default:
                                i = t.getExtension(n)
                        }
                        return e[n] = i, i
                    }
                    return { has: function(t) { return null !== n(t) }, init: function(t) { t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float") }, get: function(t) { const e = n(t); return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e } }
                }

                function cw(t, e, n, i) {
                    const r = {},
                        s = new WeakMap;

                    function o(t) {
                        const a = t.target;
                        null !== a.index && e.remove(a.index);
                        for (const t in a.attributes) e.remove(a.attributes[t]);
                        a.removeEventListener("dispose", o), delete r[a.id];
                        const l = s.get(a);
                        l && (e.remove(l), s.delete(a)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
                    }

                    function a(t) {
                        const n = [],
                            i = t.index,
                            r = t.attributes.position;
                        let o = 0;
                        if (null !== i) {
                            const t = i.array;
                            o = i.version;
                            for (let e = 0, i = t.length; e < i; e += 3) {
                                const i = t[e + 0],
                                    r = t[e + 1],
                                    s = t[e + 2];
                                n.push(i, r, r, s, s, i)
                            }
                        } else {
                            const t = r.array;
                            o = r.version;
                            for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                                const t = e + 0,
                                    i = e + 1,
                                    r = e + 2;
                                n.push(t, i, i, r, r, t)
                            }
                        }
                        const a = new(rb(n) > 65535 ? nb : eb)(n, 1);
                        a.version = o;
                        const l = s.get(t);
                        l && e.remove(l), s.set(t, a)
                    }
                    return {
                        get: function(t, e) { return !0 === r[e.id] || (e.addEventListener("dispose", o), r[e.id] = !0, n.memory.geometries++), e },
                        update: function(t) { const n = t.attributes; for (const t in n) e.update(n[t], 34962); const i = t.morphAttributes; for (const t in i) { const n = i[t]; for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962) } },
                        getWireframeAttribute: function(t) {
                            const e = s.get(t);
                            if (e) {
                                const n = t.index;
                                null !== n && e.version < n.version && a(t)
                            } else a(t);
                            return s.get(t)
                        }
                    }
                }

                function hw(t, e, n, i) {
                    const r = i.isWebGL2;
                    let s, o, a;
                    this.setMode = function(t) { s = t }, this.setIndex = function(t) { o = t.type, a = t.bytesPerElement }, this.render = function(e, i) { t.drawElements(s, i, o, e * a), n.update(i, s, 1) }, this.renderInstances = function(i, l, c) {
                        if (0 === c) return;
                        let h, u;
                        if (r) h = t, u = "drawElementsInstanced";
                        else if (h = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        h[u](s, l, o, i * a, c), n.update(l, s, c)
                    }
                }

                function uw(t) {
                    const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
                    return {
                        memory: { geometries: 0, textures: 0 },
                        render: e,
                        programs: null,
                        autoReset: !0,
                        reset: function() { e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0 },
                        update: function(t, n, i) {
                            switch (e.calls++, n) {
                                case 4:
                                    e.triangles += i * (t / 3);
                                    break;
                                case 1:
                                    e.lines += i * (t / 2);
                                    break;
                                case 3:
                                    e.lines += i * (t - 1);
                                    break;
                                case 2:
                                    e.lines += i * t;
                                    break;
                                case 0:
                                    e.points += i * t;
                                    break;
                                default:
                                    console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                            }
                        }
                    }
                }

                function dw(t, e) { return t[0] - e[0] }

                function pw(t, e) { return Math.abs(e[1]) - Math.abs(t[1]) }

                function mw(t) {
                    const e = {},
                        n = new Float32Array(8),
                        i = [];
                    for (let t = 0; t < 8; t++) i[t] = [t, 0];
                    return {
                        update: function(r, s, o, a) {
                            const l = r.morphTargetInfluences,
                                c = void 0 === l ? 0 : l.length;
                            let h = e[s.id];
                            if (void 0 === h || h.length !== c) {
                                h = [];
                                for (let t = 0; t < c; t++) h[t] = [t, 0];
                                e[s.id] = h
                            }
                            for (let t = 0; t < c; t++) {
                                const e = h[t];
                                e[0] = t, e[1] = l[t]
                            }
                            h.sort(pw);
                            for (let t = 0; t < 8; t++) t < c && h[t][1] ? (i[t][0] = h[t][0], i[t][1] = h[t][1]) : (i[t][0] = Number.MAX_SAFE_INTEGER, i[t][1] = 0);
                            i.sort(dw);
                            const u = o.morphTargets && s.morphAttributes.position,
                                d = o.morphNormals && s.morphAttributes.normal;
                            let p = 0;
                            for (let t = 0; t < 8; t++) {
                                const e = i[t],
                                    r = e[0],
                                    o = e[1];
                                r !== Number.MAX_SAFE_INTEGER && o ? (u && s.getAttribute("morphTarget" + t) !== u[r] && s.setAttribute("morphTarget" + t, u[r]), d && s.getAttribute("morphNormal" + t) !== d[r] && s.setAttribute("morphNormal" + t, d[r]), n[t] = o, p += o) : (u && !0 === s.hasAttribute("morphTarget" + t) && s.deleteAttribute("morphTarget" + t), d && !0 === s.hasAttribute("morphNormal" + t) && s.deleteAttribute("morphNormal" + t), n[t] = 0)
                            }
                            const m = s.morphTargetsRelative ? 1 : 1 - p;
                            a.getUniforms().setValue(t, "morphTargetBaseInfluence", m), a.getUniforms().setValue(t, "morphTargetInfluences", n)
                        }
                    }
                }

                function fw(t, e, n, i) {
                    let r = new WeakMap;

                    function s(t) {
                        const e = t.target;
                        e.removeEventListener("dispose", s), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
                    }
                    return {
                        update: function(t) {
                            const o = i.render.frame,
                                a = t.geometry,
                                l = e.get(t, a);
                            return r.get(l) !== o && (e.update(l), r.set(l, o)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s) && t.addEventListener("dispose", s), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), l
                        },
                        dispose: function() { r = new WeakMap }
                    }
                }
                ew.physical = { uniforms: Nb([ew.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new vx(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new J_(0) }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new vx }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new J_(0) } }]), vertexShader: $b.meshphysical_vert, fragmentShader: $b.meshphysical_frag };
                class gw extends wx { constructor(t = null, e = 1, n = 1, i = 1) { super(null), this.image = { data: t, width: e, height: n, depth: i }, this.magFilter = By, this.minFilter = By, this.wrapR = Dy, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } }
                gw.prototype.isDataTexture2DArray = !0;
                class vw extends wx { constructor(t = null, e = 1, n = 1, i = 1) { super(null), this.image = { data: t, width: e, height: n, depth: i }, this.magFilter = By, this.minFilter = By, this.wrapR = Dy, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } }
                vw.prototype.isDataTexture3D = !0;
                const yw = new wx,
                    xw = new gw,
                    _w = new vw,
                    bw = new kb,
                    ww = [],
                    Mw = [],
                    Sw = new Float32Array(16),
                    Tw = new Float32Array(9),
                    Ew = new Float32Array(4);

                function Aw(t, e, n) { const i = t[0]; if (i <= 0 || i > 0) return t; const r = e * n; let s = ww[r]; if (void 0 === s && (s = new Float32Array(r), ww[r] = s), 0 !== e) { i.toArray(s, 0); for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(s, r) } return s }

                function Lw(t, e) {
                    if (t.length !== e.length) return !1;
                    for (let n = 0, i = t.length; n < i; n++)
                        if (t[n] !== e[n]) return !1;
                    return !0
                }

                function Rw(t, e) { for (let n = 0, i = e.length; n < i; n++) t[n] = e[n] }

                function Cw(t, e) {
                    let n = Mw[e];
                    void 0 === n && (n = new Int32Array(e), Mw[e] = n);
                    for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
                    return n
                }

                function Pw(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
                }

                function Iw(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                    else {
                        if (Lw(n, e)) return;
                        t.uniform2fv(this.addr, e), Rw(n, e)
                    }
                }

                function Dw(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                    else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
                    else {
                        if (Lw(n, e)) return;
                        t.uniform3fv(this.addr, e), Rw(n, e)
                    }
                }

                function Nw(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                    else {
                        if (Lw(n, e)) return;
                        t.uniform4fv(this.addr, e), Rw(n, e)
                    }
                }

                function Bw(t, e) {
                    const n = this.cache,
                        i = e.elements;
                    if (void 0 === i) {
                        if (Lw(n, e)) return;
                        t.uniformMatrix2fv(this.addr, !1, e), Rw(n, e)
                    } else {
                        if (Lw(n, i)) return;
                        Ew.set(i), t.uniformMatrix2fv(this.addr, !1, Ew), Rw(n, i)
                    }
                }

                function Ow(t, e) {
                    const n = this.cache,
                        i = e.elements;
                    if (void 0 === i) {
                        if (Lw(n, e)) return;
                        t.uniformMatrix3fv(this.addr, !1, e), Rw(n, e)
                    } else {
                        if (Lw(n, i)) return;
                        Tw.set(i), t.uniformMatrix3fv(this.addr, !1, Tw), Rw(n, i)
                    }
                }

                function Fw(t, e) {
                    const n = this.cache,
                        i = e.elements;
                    if (void 0 === i) {
                        if (Lw(n, e)) return;
                        t.uniformMatrix4fv(this.addr, !1, e), Rw(n, e)
                    } else {
                        if (Lw(n, i)) return;
                        Sw.set(i), t.uniformMatrix4fv(this.addr, !1, Sw), Rw(n, i)
                    }
                }

                function zw(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
                }

                function Uw(t, e) {
                    const n = this.cache;
                    Lw(n, e) || (t.uniform2iv(this.addr, e), Rw(n, e))
                }

                function Hw(t, e) {
                    const n = this.cache;
                    Lw(n, e) || (t.uniform3iv(this.addr, e), Rw(n, e))
                }

                function kw(t, e) {
                    const n = this.cache;
                    Lw(n, e) || (t.uniform4iv(this.addr, e), Rw(n, e))
                }

                function Gw(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
                }

                function Vw(t, e) {
                    const n = this.cache;
                    Lw(n, e) || (t.uniform2uiv(this.addr, e), Rw(n, e))
                }

                function Ww(t, e) {
                    const n = this.cache;
                    Lw(n, e) || (t.uniform3uiv(this.addr, e), Rw(n, e))
                }

                function jw(t, e) {
                    const n = this.cache;
                    Lw(n, e) || (t.uniform4uiv(this.addr, e), Rw(n, e))
                }

                function qw(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || yw, r)
                }

                function Xw(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || _w, r)
                }

                function Yw(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || bw, r)
                }

                function Zw(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || xw, r)
                }

                function Jw(t, e) { t.uniform1fv(this.addr, e) }

                function Kw(t, e) {
                    const n = Aw(e, this.size, 2);
                    t.uniform2fv(this.addr, n)
                }

                function Qw(t, e) {
                    const n = Aw(e, this.size, 3);
                    t.uniform3fv(this.addr, n)
                }

                function $w(t, e) {
                    const n = Aw(e, this.size, 4);
                    t.uniform4fv(this.addr, n)
                }

                function tM(t, e) {
                    const n = Aw(e, this.size, 4);
                    t.uniformMatrix2fv(this.addr, !1, n)
                }

                function eM(t, e) {
                    const n = Aw(e, this.size, 9);
                    t.uniformMatrix3fv(this.addr, !1, n)
                }

                function nM(t, e) {
                    const n = Aw(e, this.size, 16);
                    t.uniformMatrix4fv(this.addr, !1, n)
                }

                function iM(t, e) { t.uniform1iv(this.addr, e) }

                function rM(t, e) { t.uniform2iv(this.addr, e) }

                function sM(t, e) { t.uniform3iv(this.addr, e) }

                function oM(t, e) { t.uniform4iv(this.addr, e) }

                function aM(t, e) { t.uniform1uiv(this.addr, e) }

                function lM(t, e) { t.uniform2uiv(this.addr, e) }

                function cM(t, e) { t.uniform3uiv(this.addr, e) }

                function hM(t, e) { t.uniform4uiv(this.addr, e) }

                function uM(t, e, n) {
                    const i = e.length,
                        r = Cw(n, i);
                    t.uniform1iv(this.addr, r);
                    for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || yw, r[t])
                }

                function dM(t, e, n) {
                    const i = e.length,
                        r = Cw(n, i);
                    t.uniform1iv(this.addr, r);
                    for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || bw, r[t])
                }

                function pM(t, e, n) {
                    this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                        switch (t) {
                            case 5126:
                                return Pw;
                            case 35664:
                                return Iw;
                            case 35665:
                                return Dw;
                            case 35666:
                                return Nw;
                            case 35674:
                                return Bw;
                            case 35675:
                                return Ow;
                            case 35676:
                                return Fw;
                            case 5124:
                            case 35670:
                                return zw;
                            case 35667:
                            case 35671:
                                return Uw;
                            case 35668:
                            case 35672:
                                return Hw;
                            case 35669:
                            case 35673:
                                return kw;
                            case 5125:
                                return Gw;
                            case 36294:
                                return Vw;
                            case 36295:
                                return Ww;
                            case 36296:
                                return jw;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return qw;
                            case 35679:
                            case 36299:
                            case 36307:
                                return Xw;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return Yw;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return Zw
                        }
                    }(e.type)
                }

                function mM(t, e, n) {
                    this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                        switch (t) {
                            case 5126:
                                return Jw;
                            case 35664:
                                return Kw;
                            case 35665:
                                return Qw;
                            case 35666:
                                return $w;
                            case 35674:
                                return tM;
                            case 35675:
                                return eM;
                            case 35676:
                                return nM;
                            case 5124:
                            case 35670:
                                return iM;
                            case 35667:
                            case 35671:
                                return rM;
                            case 35668:
                            case 35672:
                                return sM;
                            case 35669:
                            case 35673:
                                return oM;
                            case 5125:
                                return aM;
                            case 36294:
                                return lM;
                            case 36295:
                                return cM;
                            case 36296:
                                return hM;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return uM;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return dM
                        }
                    }(e.type)
                }

                function fM(t) { this.id = t, this.seq = [], this.map = {} }
                mM.prototype.updateCache = function(t) {
                    const e = this.cache;
                    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Rw(e, t)
                }, fM.prototype.setValue = function(t, e, n) {
                    const i = this.seq;
                    for (let r = 0, s = i.length; r !== s; ++r) {
                        const s = i[r];
                        s.setValue(t, e[s.id], n)
                    }
                };
                const gM = /(\w+)(\])?(\[|\.)?/g;

                function vM(t, e) { t.seq.push(e), t.map[e.id] = e }

                function yM(t, e, n) {
                    const i = t.name,
                        r = i.length;
                    for (gM.lastIndex = 0;;) {
                        const s = gM.exec(i),
                            o = gM.lastIndex;
                        let a = s[1];
                        const l = "]" === s[2],
                            c = s[3];
                        if (l && (a |= 0), void 0 === c || "[" === c && o + 2 === r) { vM(n, void 0 === c ? new pM(a, t, e) : new mM(a, t, e)); break } {
                            let t = n.map[a];
                            void 0 === t && (t = new fM(a), vM(n, t)), n = t
                        }
                    }
                }

                function xM(t, e) {
                    this.seq = [], this.map = {};
                    const n = t.getProgramParameter(e, 35718);
                    for (let i = 0; i < n; ++i) {
                        const n = t.getActiveUniform(e, i);
                        yM(n, t.getUniformLocation(e, n.name), this)
                    }
                }

                function _M(t, e, n) { const i = t.createShader(e); return t.shaderSource(i, n), t.compileShader(i), i }
                xM.prototype.setValue = function(t, e, n, i) {
                    const r = this.map[e];
                    void 0 !== r && r.setValue(t, n, i)
                }, xM.prototype.setOptional = function(t, e, n) {
                    const i = e[n];
                    void 0 !== i && this.setValue(t, n, i)
                }, xM.upload = function(t, e, n, i) {
                    for (let r = 0, s = e.length; r !== s; ++r) {
                        const s = e[r],
                            o = n[s.id];
                        !1 !== o.needsUpdate && s.setValue(t, o.value, i)
                    }
                }, xM.seqWithValue = function(t, e) {
                    const n = [];
                    for (let i = 0, r = t.length; i !== r; ++i) {
                        const r = t[i];
                        r.id in e && n.push(r)
                    }
                    return n
                };
                let bM = 0;

                function wM(t) {
                    switch (t) {
                        case tx:
                            return ["Linear", "( value )"];
                        case 3001:
                            return ["sRGB", "( value )"];
                        case 3002:
                            return ["RGBE", "( value )"];
                        case 3004:
                            return ["RGBM", "( value, 7.0 )"];
                        case 3005:
                            return ["RGBM", "( value, 16.0 )"];
                        case 3006:
                            return ["RGBD", "( value, 256.0 )"];
                        case 3007:
                            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                        case 3003:
                            return ["LogLuv", "( value )"];
                        default:
                            return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
                    }
                }

                function MM(t, e, n) {
                    const i = t.getShaderParameter(e, 35713),
                        r = t.getShaderInfoLog(e).trim();
                    return i && "" === r ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function(t) { const e = t.split("\n"); for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t]; return e.join("\n") }(t.getShaderSource(e))
                }

                function SM(t, e) { const n = wM(e); return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }" }

                function TM(t, e) { const n = wM(e); return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }" }

                function EM(t, e) {
                    let n;
                    switch (e) {
                        case 1:
                            n = "Linear";
                            break;
                        case 2:
                            n = "Reinhard";
                            break;
                        case 3:
                            n = "OptimizedCineon";
                            break;
                        case 4:
                            n = "ACESFilmic";
                            break;
                        case 5:
                            n = "Custom";
                            break;
                        default:
                            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
                    }
                    return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                }

                function AM(t) { return "" !== t }

                function LM(t, e) { return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) }

                function RM(t, e) { return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) }
                const CM = /^[ \t]*#include +<([\w\d./]+)>/gm;

                function PM(t) { return t.replace(CM, IM) }

                function IM(t, e) { const n = $b[e]; if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">"); return PM(n) }
                const DM = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                    NM = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

                function BM(t) { return t.replace(NM, FM).replace(DM, OM) }

                function OM(t, e, n, i) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), FM(0, e, n, i) }

                function FM(t, e, n, i) { let r = ""; for (let t = parseInt(e); t < parseInt(n); t++) r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t); return r }

                function zM(t) { let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;"; return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e }

                function UM(t, e, n, i) {
                    const r = t.getContext(),
                        s = n.defines;
                    let o = n.vertexShader,
                        a = n.fragmentShader;
                    const l = function(t) { let e = "SHADOWMAP_TYPE_BASIC"; return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e }(n),
                        c = function(t) {
                            let e = "ENVMAP_TYPE_CUBE";
                            if (t.envMap) switch (t.envMapMode) {
                                case 301:
                                case 302:
                                    e = "ENVMAP_TYPE_CUBE";
                                    break;
                                case 306:
                                case 307:
                                    e = "ENVMAP_TYPE_CUBE_UV"
                            }
                            return e
                        }(n),
                        h = function(t) {
                            let e = "ENVMAP_MODE_REFLECTION";
                            if (t.envMap) switch (t.envMapMode) {
                                case 302:
                                case 307:
                                    e = "ENVMAP_MODE_REFRACTION"
                            }
                            return e
                        }(n),
                        u = function(t) {
                            let e = "ENVMAP_BLENDING_NONE";
                            if (t.envMap) switch (t.combine) {
                                case 0:
                                    e = "ENVMAP_BLENDING_MULTIPLY";
                                    break;
                                case 1:
                                    e = "ENVMAP_BLENDING_MIX";
                                    break;
                                case 2:
                                    e = "ENVMAP_BLENDING_ADD"
                            }
                            return e
                        }(n),
                        d = t.gammaFactor > 0 ? t.gammaFactor : 1,
                        p = n.isWebGL2 ? "" : function(t) { return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission > 0) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(AM).join("\n") }(n),
                        m = function(t) { const e = []; for (const n in t) { const i = t[n];!1 !== i && e.push("#define " + n + " " + i) } return e.join("\n") }(s),
                        f = r.createProgram();
                    let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                    n.isRawShaderMaterial ? (g = [m].filter(AM).join("\n"), g.length > 0 && (g += "\n"), v = [p, m].filter(AM).join("\n"), v.length > 0 && (v += "\n")) : (g = [zM(n), "#define SHADER_NAME " + n.shaderName, m, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(AM).join("\n"), v = [p, zM(n), "#define SHADER_NAME " + n.shaderName, m, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? $b.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? EM("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", $b.encodings_pars_fragment, n.map ? SM("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? SM("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? SM("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? SM("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? SM("lightMapTexelToLinear", n.lightMapEncoding) : "", TM("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(AM).join("\n")), o = PM(o), o = LM(o, n), o = RM(o, n), a = PM(a), a = LM(a, n), a = RM(a, n), o = BM(o), a = BM(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n", g = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", n.glslVersion === rx ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === rx ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
                    const x = y + v + a,
                        _ = _M(r, 35633, y + g + o),
                        b = _M(r, 35632, x);
                    if (r.attachShader(f, _), r.attachShader(f, b), void 0 !== n.index0AttributeName ? r.bindAttribLocation(f, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(f, 0, "position"), r.linkProgram(f), t.debug.checkShaderErrors) {
                        const t = r.getProgramInfoLog(f).trim(),
                            e = r.getShaderInfoLog(_).trim(),
                            n = r.getShaderInfoLog(b).trim();
                        let i = !0,
                            s = !0;
                        if (!1 === r.getProgramParameter(f, 35714)) {
                            i = !1;
                            const e = MM(r, _, "vertex"),
                                n = MM(r, b, "fragment");
                            console.error("THREE.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(f, 35715), "gl.getProgramInfoLog", t, e, n)
                        } else "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== n || (s = !1);
                        s && (this.diagnostics = { runnable: i, programLog: t, vertexShader: { log: e, prefix: g }, fragmentShader: { log: n, prefix: v } })
                    }
                    let w, M;
                    return r.deleteShader(_), r.deleteShader(b), this.getUniforms = function() { return void 0 === w && (w = new xM(r, f)), w }, this.getAttributes = function() {
                        return void 0 === M && (M = function(t, e) {
                            const n = {},
                                i = t.getProgramParameter(e, 35721);
                            for (let r = 0; r < i; r++) {
                                const i = t.getActiveAttrib(e, r).name;
                                n[i] = t.getAttribLocation(e, i)
                            }
                            return n
                        }(r, f)), M
                    }, this.destroy = function() { i.releaseStatesOfProgram(this), r.deleteProgram(f), this.program = void 0 }, this.name = n.shaderName, this.id = bM++, this.cacheKey = e, this.usedTimes = 1, this.program = f, this.vertexShader = _, this.fragmentShader = b, this
                }

                function HM(t, e, n, i, r, s) {
                    const o = [],
                        a = i.isWebGL2,
                        l = i.logarithmicDepthBuffer,
                        c = i.floatVertexTextures,
                        h = i.maxVertexUniforms,
                        u = i.vertexTextures;
                    let d = i.precision;
                    const p = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" },
                        m = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmission", "transmissionMap", "thicknessMap"];

                    function f(t) { let e; return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = tx, e }
                    return {
                        getParameters: function(r, o, m, g, v) {
                            const y = g.fog,
                                x = r.isMeshStandardMaterial ? g.environment : null,
                                _ = e.get(r.envMap || x),
                                b = p[r.type],
                                w = v.isSkinnedMesh ? function(t) {
                                    const e = t.skeleton.bones;
                                    if (c) return 1024; {
                                        const t = h,
                                            n = Math.floor((t - 20) / 4),
                                            i = Math.min(n, e.length);
                                        return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i
                                    }
                                }(v) : 0;
                            let M, S;
                            if (null !== r.precision && (d = i.getMaxPrecision(r.precision), d !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", d, "instead.")), b) {
                                const t = ew[b];
                                M = t.vertexShader, S = t.fragmentShader
                            } else M = r.vertexShader, S = r.fragmentShader;
                            const T = t.getRenderTarget();
                            return { isWebGL2: a, shaderID: b, shaderName: r.type, vertexShader: M, fragmentShader: S, defines: r.defines, isRawShaderMaterial: !0 === r.isRawShaderMaterial, glslVersion: r.glslVersion, precision: d, instancing: !0 === v.isInstancedMesh, instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor, supportsVertexTextures: u, outputEncoding: null !== T ? f(T.texture) : t.outputEncoding, map: !!r.map, mapEncoding: f(r.map), matcap: !!r.matcap, matcapEncoding: f(r.matcap), envMap: !!_, envMapMode: _ && _.mapping, envMapEncoding: f(_), envMapCubeUV: !!_ && (306 === _.mapping || 307 === _.mapping), lightMap: !!r.lightMap, lightMapEncoding: f(r.lightMap), aoMap: !!r.aoMap, emissiveMap: !!r.emissiveMap, emissiveMapEncoding: f(r.emissiveMap), bumpMap: !!r.bumpMap, normalMap: !!r.normalMap, objectSpaceNormalMap: 1 === r.normalMapType, tangentSpaceNormalMap: 0 === r.normalMapType, clearcoatMap: !!r.clearcoatMap, clearcoatRoughnessMap: !!r.clearcoatRoughnessMap, clearcoatNormalMap: !!r.clearcoatNormalMap, displacementMap: !!r.displacementMap, roughnessMap: !!r.roughnessMap, metalnessMap: !!r.metalnessMap, specularMap: !!r.specularMap, alphaMap: !!r.alphaMap, gradientMap: !!r.gradientMap, sheen: !!r.sheen, transmission: !!r.transmission, transmissionMap: !!r.transmissionMap, thicknessMap: !!r.thicknessMap, combine: r.combine, vertexTangents: r.normalMap && r.vertexTangents, vertexColors: r.vertexColors, vertexAlphas: !0 === r.vertexColors && v.geometry && v.geometry.attributes.color && 4 === v.geometry.attributes.color.itemSize, vertexUvs: !!(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatMap || r.clearcoatRoughnessMap || r.clearcoatNormalMap || r.displacementMap || r.transmissionMap || r.thicknessMap), uvsVertexOnly: !(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatNormalMap || r.transmission || r.transmissionMap || r.thicknessMap || !r.displacementMap), fog: !!y, useFog: r.fog, fogExp2: y && y.isFogExp2, flatShading: !!r.flatShading, sizeAttenuation: r.sizeAttenuation, logarithmicDepthBuffer: l, skinning: !0 === v.isSkinnedMesh && w > 0, maxBones: w, useVertexTexture: c, morphTargets: r.morphTargets, morphNormals: r.morphNormals, numDirLights: o.directional.length, numPointLights: o.point.length, numSpotLights: o.spot.length, numRectAreaLights: o.rectArea.length, numHemiLights: o.hemi.length, numDirLightShadows: o.directionalShadowMap.length, numPointLightShadows: o.pointShadowMap.length, numSpotLightShadows: o.spotShadowMap.length, numClippingPlanes: s.numPlanes, numClipIntersection: s.numIntersection, dithering: r.dithering, shadowMapEnabled: t.shadowMap.enabled && m.length > 0, shadowMapType: t.shadowMap.type, toneMapping: r.toneMapped ? t.toneMapping : 0, physicallyCorrectLights: t.physicallyCorrectLights, premultipliedAlpha: r.premultipliedAlpha, alphaTest: r.alphaTest, doubleSided: 2 === r.side, flipSided: 1 === r.side, depthPacking: void 0 !== r.depthPacking && r.depthPacking, index0AttributeName: r.index0AttributeName, extensionDerivatives: r.extensions && r.extensions.derivatives, extensionFragDepth: r.extensions && r.extensions.fragDepth, extensionDrawBuffers: r.extensions && r.extensions.drawBuffers, extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD, rendererExtensionFragDepth: a || n.has("EXT_frag_depth"), rendererExtensionDrawBuffers: a || n.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: a || n.has("EXT_shader_texture_lod"), customProgramCacheKey: r.customProgramCacheKey() }
                        },
                        getProgramCacheKey: function(e) {
                            const n = [];
                            if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                                for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                            if (!1 === e.isRawShaderMaterial) {
                                for (let t = 0; t < m.length; t++) n.push(e[m[t]]);
                                n.push(t.outputEncoding), n.push(t.gammaFactor)
                            }
                            return n.push(e.customProgramCacheKey), n.join()
                        },
                        getUniforms: function(t) {
                            const e = p[t.type];
                            let n;
                            if (e) {
                                const t = ew[e];
                                n = Bb.clone(t.uniforms)
                            } else n = t.uniforms;
                            return n
                        },
                        acquireProgram: function(e, n) { let i; for (let t = 0, e = o.length; t < e; t++) { const e = o[t]; if (e.cacheKey === n) { i = e, ++i.usedTimes; break } } return void 0 === i && (i = new UM(t, n, e, r), o.push(i)), i },
                        releaseProgram: function(t) {
                            if (0 == --t.usedTimes) {
                                const e = o.indexOf(t);
                                o[e] = o[o.length - 1], o.pop(), t.destroy()
                            }
                        },
                        programs: o
                    }
                }

                function kM() { let t = new WeakMap; return { get: function(e) { let n = t.get(e); return void 0 === n && (n = {}, t.set(e, n)), n }, remove: function(e) { t.delete(e) }, update: function(e, n, i) { t.get(e)[n] = i }, dispose: function() { t = new WeakMap } } }

                function GM(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id }

                function VM(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id }

                function WM(t) {
                    const e = [];
                    let n = 0;
                    const i = [],
                        r = [],
                        s = [],
                        o = { id: -1 };

                    function a(i, r, s, a, l, c) { let h = e[n]; const u = t.get(s); return void 0 === h ? (h = { id: i.id, object: i, geometry: r, material: s, program: u.program || o, groupOrder: a, renderOrder: i.renderOrder, z: l, group: c }, e[n] = h) : (h.id = i.id, h.object = i, h.geometry = r, h.material = s, h.program = u.program || o, h.groupOrder = a, h.renderOrder = i.renderOrder, h.z = l, h.group = c), n++, h }
                    return {
                        opaque: i,
                        transmissive: r,
                        transparent: s,
                        init: function() { n = 0, i.length = 0, r.length = 0, s.length = 0 },
                        push: function(t, e, n, o, l, c) {
                            const h = a(t, e, n, o, l, c);
                            n.transmission > 0 ? r.push(h) : !0 === n.transparent ? s.push(h) : i.push(h)
                        },
                        unshift: function(t, e, n, o, l, c) {
                            const h = a(t, e, n, o, l, c);
                            n.transmission > 0 ? r.unshift(h) : !0 === n.transparent ? s.unshift(h) : i.unshift(h)
                        },
                        finish: function() {
                            for (let t = n, i = e.length; t < i; t++) {
                                const n = e[t];
                                if (null === n.id) break;
                                n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
                            }
                        },
                        sort: function(t, e) { i.length > 1 && i.sort(t || GM), r.length > 1 && r.sort(e || VM), s.length > 1 && s.sort(e || VM) }
                    }
                }

                function jM(t) { let e = new WeakMap; return { get: function(n, i) { let r; return !1 === e.has(n) ? (r = new WM(t), e.set(n, [r])) : i >= e.get(n).length ? (r = new WM(t), e.get(n).push(r)) : r = e.get(n)[i], r }, dispose: function() { e = new WeakMap } } }

                function qM() {
                    const t = {};
                    return {
                        get: function(e) {
                            if (void 0 !== t[e.id]) return t[e.id];
                            let n;
                            switch (e.type) {
                                case "DirectionalLight":
                                    n = { direction: new Lx, color: new J_ };
                                    break;
                                case "SpotLight":
                                    n = { position: new Lx, direction: new Lx, color: new J_, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
                                    break;
                                case "PointLight":
                                    n = { position: new Lx, color: new J_, distance: 0, decay: 0 };
                                    break;
                                case "HemisphereLight":
                                    n = { direction: new Lx, skyColor: new J_, groundColor: new J_ };
                                    break;
                                case "RectAreaLight":
                                    n = { color: new J_, position: new Lx, halfWidth: new Lx, halfHeight: new Lx }
                            }
                            return t[e.id] = n, n
                        }
                    }
                }
                let XM = 0;

                function YM(t, e) { return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0) }

                function ZM(t, e) {
                    const n = new qM,
                        i = function() {
                            const t = {};
                            return {
                                get: function(e) {
                                    if (void 0 !== t[e.id]) return t[e.id];
                                    let n;
                                    switch (e.type) {
                                        case "DirectionalLight":
                                        case "SpotLight":
                                            n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new vx };
                                            break;
                                        case "PointLight":
                                            n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new vx, shadowCameraNear: 1, shadowCameraFar: 1e3 }
                                    }
                                    return t[e.id] = n, n
                                }
                            }
                        }(),
                        r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] };
                    for (let t = 0; t < 9; t++) r.probe.push(new Lx);
                    const s = new Lx,
                        o = new s_,
                        a = new s_;
                    return {
                        setup: function(s) {
                            let o = 0,
                                a = 0,
                                l = 0;
                            for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                            let c = 0,
                                h = 0,
                                u = 0,
                                d = 0,
                                p = 0,
                                m = 0,
                                f = 0,
                                g = 0;
                            s.sort(YM);
                            for (let t = 0, e = s.length; t < e; t++) {
                                const e = s[t],
                                    v = e.color,
                                    y = e.intensity,
                                    x = e.distance,
                                    _ = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                                if (e.isAmbientLight) o += v.r * y, a += v.g * y, l += v.b * y;
                                else if (e.isLightProbe)
                                    for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], y);
                                else if (e.isDirectionalLight) {
                                    const t = n.get(e);
                                    if (t.color.copy(e.color).multiplyScalar(e.intensity), e.castShadow) {
                                        const t = e.shadow,
                                            n = i.get(e);
                                        n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.directionalShadow[c] = n, r.directionalShadowMap[c] = _, r.directionalShadowMatrix[c] = e.shadow.matrix, m++
                                    }
                                    r.directional[c] = t, c++
                                } else if (e.isSpotLight) {
                                    const t = n.get(e);
                                    if (t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(v).multiplyScalar(y), t.distance = x, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) {
                                        const t = e.shadow,
                                            n = i.get(e);
                                        n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.spotShadow[u] = n, r.spotShadowMap[u] = _, r.spotShadowMatrix[u] = e.shadow.matrix, g++
                                    }
                                    r.spot[u] = t, u++
                                } else if (e.isRectAreaLight) {
                                    const t = n.get(e);
                                    t.color.copy(v).multiplyScalar(y), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), r.rectArea[d] = t, d++
                                } else if (e.isPointLight) {
                                    const t = n.get(e);
                                    if (t.color.copy(e.color).multiplyScalar(e.intensity), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                                        const t = e.shadow,
                                            n = i.get(e);
                                        n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, r.pointShadow[h] = n, r.pointShadowMap[h] = _, r.pointShadowMatrix[h] = e.shadow.matrix, f++
                                    }
                                    r.point[h] = t, h++
                                } else if (e.isHemisphereLight) {
                                    const t = n.get(e);
                                    t.skyColor.copy(e.color).multiplyScalar(y), t.groundColor.copy(e.groundColor).multiplyScalar(y), r.hemi[p] = t, p++
                                }
                            }
                            d > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = tw.LTC_FLOAT_1, r.rectAreaLTC2 = tw.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = tw.LTC_HALF_1, r.rectAreaLTC2 = tw.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = a, r.ambient[2] = l;
                            const v = r.hash;
                            v.directionalLength === c && v.pointLength === h && v.spotLength === u && v.rectAreaLength === d && v.hemiLength === p && v.numDirectionalShadows === m && v.numPointShadows === f && v.numSpotShadows === g || (r.directional.length = c, r.spot.length = u, r.rectArea.length = d, r.point.length = h, r.hemi.length = p, r.directionalShadow.length = m, r.directionalShadowMap.length = m, r.pointShadow.length = f, r.pointShadowMap.length = f, r.spotShadow.length = g, r.spotShadowMap.length = g, r.directionalShadowMatrix.length = m, r.pointShadowMatrix.length = f, r.spotShadowMatrix.length = g, v.directionalLength = c, v.pointLength = h, v.spotLength = u, v.rectAreaLength = d, v.hemiLength = p, v.numDirectionalShadows = m, v.numPointShadows = f, v.numSpotShadows = g, r.version = XM++)
                        },
                        setupView: function(t, e) {
                            let n = 0,
                                i = 0,
                                l = 0,
                                c = 0,
                                h = 0;
                            const u = e.matrixWorldInverse;
                            for (let e = 0, d = t.length; e < d; e++) {
                                const d = t[e];
                                if (d.isDirectionalLight) {
                                    const t = r.directional[n];
                                    t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(u), n++
                                } else if (d.isSpotLight) {
                                    const t = r.spot[l];
                                    t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(u), l++
                                } else if (d.isRectAreaLight) {
                                    const t = r.rectArea[c];
                                    t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), a.identity(), o.copy(d.matrixWorld), o.premultiply(u), a.extractRotation(o), t.halfWidth.set(.5 * d.width, 0, 0), t.halfHeight.set(0, .5 * d.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), c++
                                } else if (d.isPointLight) {
                                    const t = r.point[i];
                                    t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), i++
                                } else if (d.isHemisphereLight) {
                                    const t = r.hemi[h];
                                    t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(u), t.direction.normalize(), h++
                                }
                            }
                        },
                        state: r
                    }
                }

                function JM(t, e) {
                    const n = new ZM(t, e),
                        i = [],
                        r = [];
                    return { init: function() { i.length = 0, r.length = 0 }, state: { lightsArray: i, shadowsArray: r, lights: n }, setupLights: function() { n.setup(i) }, setupLightsView: function(t) { n.setupView(i, t) }, pushLight: function(t) { i.push(t) }, pushShadow: function(t) { r.push(t) } }
                }

                function KM(t, e) { let n = new WeakMap; return { get: function(i, r = 0) { let s; return !1 === n.has(i) ? (s = new JM(t, e), n.set(i, [s])) : r >= n.get(i).length ? (s = new JM(t, e), n.get(i).push(s)) : s = n.get(i)[r], s }, dispose: function() { n = new WeakMap } } }
                class QM extends V_ {
                    constructor(t) { super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.depthPacking = t.depthPacking, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this }
                }
                QM.prototype.isMeshDepthMaterial = !0;
                class $M extends V_ {
                    constructor(t) { super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Lx, this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this }
                }

                function tS(t, e, n) {
                    let i = new Zb;
                    const r = new vx,
                        s = new vx,
                        o = new Sx,
                        a = [],
                        l = [],
                        c = {},
                        h = n.maxTextureSize,
                        u = { 0: 1, 1: 0, 2: 2 },
                        d = new Ob({ defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new vx }, radius: { value: 4 } }, vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }),
                        p = d.clone();
                    p.defines.HORIZONTAL_PASS = 1;
                    const m = new db;
                    m.setAttribute("position", new tb(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                    const f = new Cb(m, d),
                        g = this;

                    function v(n, i) {
                        const r = e.update(f);
                        d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, d, f, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, p, f, null)
                    }

                    function y(t) { const e = t << 0; let n = a[e]; return void 0 === n && (n = new QM({ depthPacking: 3201, morphTargets: t }), a[e] = n), n }

                    function x(t) { const e = t << 0; let n = l[e]; return void 0 === n && (n = new $M({ morphTargets: t }), l[e] = n), n }

                    function _(e, n, i, r, s, o, a) {
                        let l = null,
                            h = y,
                            d = e.customDepthMaterial;
                        if (!0 === r.isPointLight && (h = x, d = e.customDistanceMaterial), void 0 === d) { let t = !1;!0 === i.morphTargets && (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0), l = h(t) } else l = d;
                        if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                            const t = l.uuid,
                                e = i.uuid;
                            let n = c[t];
                            void 0 === n && (n = {}, c[t] = n);
                            let r = n[e];
                            void 0 === r && (r = l.clone(), n[e] = r), l = r
                        }
                        return l.visible = i.visible, l.wireframe = i.wireframe, l.side = 3 === a ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : u[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, !0 === r.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(r.matrixWorld), l.nearDistance = s, l.farDistance = o), l
                    }

                    function b(n, r, s, o, a) {
                        if (!1 === n.visible) return;
                        if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === a) && (!n.frustumCulled || i.intersectsObject(n))) {
                            n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                            const i = e.update(n),
                                r = n.material;
                            if (Array.isArray(r)) {
                                const e = i.groups;
                                for (let l = 0, c = e.length; l < c; l++) {
                                    const c = e[l],
                                        h = r[c.materialIndex];
                                    if (h && h.visible) {
                                        const e = _(n, i, h, o, s.near, s.far, a);
                                        t.renderBufferDirect(s, null, i, e, n, c)
                                    }
                                }
                            } else if (r.visible) {
                                const e = _(n, i, r, o, s.near, s.far, a);
                                t.renderBufferDirect(s, null, i, e, n, null)
                            }
                        }
                        const l = n.children;
                        for (let t = 0, e = l.length; t < e; t++) b(l[t], r, s, o, a)
                    }
                    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(e, n, a) {
                        if (!1 === g.enabled) return;
                        if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
                        if (0 === e.length) return;
                        const l = t.getRenderTarget(),
                            c = t.getActiveCubeFace(),
                            u = t.getActiveMipmapLevel(),
                            d = t.state;
                        d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                        for (let l = 0, c = e.length; l < c; l++) {
                            const c = e[l],
                                u = c.shadow;
                            if (void 0 === u) { console.warn("THREE.WebGLShadowMap:", c, "has no shadow."); continue }
                            if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
                            r.copy(u.mapSize);
                            const p = u.getFrameExtents();
                            if (r.multiply(p), s.copy(u.mapSize), (r.x > h || r.y > h) && (r.x > h && (s.x = Math.floor(h / p.x), r.x = s.x * p.x, u.mapSize.x = s.x), r.y > h && (s.y = Math.floor(h / p.y), r.y = s.y * p.y, u.mapSize.y = s.y)), null === u.map && !u.isPointLightShadow && 3 === this.type) {
                                const t = { minFilter: Oy, magFilter: Oy, format: jy };
                                u.map = new Tx(r.x, r.y, t), u.map.texture.name = c.name + ".shadowMap", u.mapPass = new Tx(r.x, r.y, t), u.camera.updateProjectionMatrix()
                            }
                            if (null === u.map) {
                                const t = { minFilter: By, magFilter: By, format: jy };
                                u.map = new Tx(r.x, r.y, t), u.map.texture.name = c.name + ".shadowMap", u.camera.updateProjectionMatrix()
                            }
                            t.setRenderTarget(u.map), t.clear();
                            const m = u.getViewportCount();
                            for (let t = 0; t < m; t++) {
                                const e = u.getViewport(t);
                                o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), d.viewport(o), u.updateMatrices(c, t), i = u.getFrustum(), b(n, a, u.camera, c, this.type)
                            }
                            u.isPointLightShadow || 3 !== this.type || v(u, a), u.needsUpdate = !1
                        }
                        g.needsUpdate = !1, t.setRenderTarget(l, c, u)
                    }
                }

                function eS(t, e, n) {
                    const i = n.isWebGL2,
                        r = new function() { let e = !1; const n = new Sx; let i = null; const r = new Sx(0, 0, 0, 0); return { setMask: function(n) { i === n || e || (t.colorMask(n, n, n, n), i = n) }, setLocked: function(t) { e = t }, setClear: function(e, i, s, o, a) {!0 === a && (e *= o, i *= o, s *= o), n.set(e, i, s, o), !1 === r.equals(n) && (t.clearColor(e, i, s, o), r.copy(n)) }, reset: function() { e = !1, i = null, r.set(-1, 0, 0, 0) } } },
                        s = new function() {
                            let e = !1,
                                n = null,
                                i = null,
                                r = null;
                            return {
                                setTest: function(t) { t ? F(2929) : z(2929) },
                                setMask: function(i) { n === i || e || (t.depthMask(i), n = i) },
                                setFunc: function(e) {
                                    if (i !== e) {
                                        if (e) switch (e) {
                                            case 0:
                                                t.depthFunc(512);
                                                break;
                                            case 1:
                                                t.depthFunc(519);
                                                break;
                                            case 2:
                                                t.depthFunc(513);
                                                break;
                                            case 3:
                                            default:
                                                t.depthFunc(515);
                                                break;
                                            case 4:
                                                t.depthFunc(514);
                                                break;
                                            case 5:
                                                t.depthFunc(518);
                                                break;
                                            case 6:
                                                t.depthFunc(516);
                                                break;
                                            case 7:
                                                t.depthFunc(517)
                                        } else t.depthFunc(515);
                                        i = e
                                    }
                                },
                                setLocked: function(t) { e = t },
                                setClear: function(e) { r !== e && (t.clearDepth(e), r = e) },
                                reset: function() { e = !1, n = null, i = null, r = null }
                            }
                        },
                        o = new function() {
                            let e = !1,
                                n = null,
                                i = null,
                                r = null,
                                s = null,
                                o = null,
                                a = null,
                                l = null,
                                c = null;
                            return { setTest: function(t) { e || (t ? F(2960) : z(2960)) }, setMask: function(i) { n === i || e || (t.stencilMask(i), n = i) }, setFunc: function(e, n, o) { i === e && r === n && s === o || (t.stencilFunc(e, n, o), i = e, r = n, s = o) }, setOp: function(e, n, i) { o === e && a === n && l === i || (t.stencilOp(e, n, i), o = e, a = n, l = i) }, setLocked: function(t) { e = t }, setClear: function(e) { c !== e && (t.clearStencil(e), c = e) }, reset: function() { e = !1, n = null, i = null, r = null, s = null, o = null, a = null, l = null, c = null } }
                        };
                    let a = {},
                        l = null,
                        c = {},
                        h = null,
                        u = !1,
                        d = null,
                        p = null,
                        m = null,
                        f = null,
                        g = null,
                        v = null,
                        y = null,
                        x = !1,
                        _ = null,
                        b = null,
                        w = null,
                        M = null,
                        S = null;
                    const T = t.getParameter(35661);
                    let E = !1,
                        A = 0;
                    const L = t.getParameter(7938); - 1 !== L.indexOf("WebGL") ? (A = parseFloat(/^WebGL (\d)/.exec(L)[1]), E = A >= 1) : -1 !== L.indexOf("OpenGL ES") && (A = parseFloat(/^OpenGL ES (\d)/.exec(L)[1]), E = A >= 2);
                    let R = null,
                        C = {};
                    const P = t.getParameter(3088),
                        I = t.getParameter(2978),
                        D = (new Sx).fromArray(P),
                        N = (new Sx).fromArray(I);

                    function B(e, n, i) {
                        const r = new Uint8Array(4),
                            s = t.createTexture();
                        t.bindTexture(e, s), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                        for (let e = 0; e < i; e++) t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
                        return s
                    }
                    const O = {};

                    function F(e) {!0 !== a[e] && (t.enable(e), a[e] = !0) }

                    function z(e) {!1 !== a[e] && (t.disable(e), a[e] = !1) }
                    O[3553] = B(3553, 3553, 1), O[34067] = B(34067, 34069, 6), r.setClear(0, 0, 0, 1), s.setClear(1), o.setClear(0), F(2929), s.setFunc(3), G(!1), V(1), F(2884), k(0);
                    const U = {
                        [Py]: 32774,
                        101: 32778,
                        102: 32779
                    };
                    if (i) U[103] = 32775, U[104] = 32776;
                    else {
                        const t = e.get("EXT_blend_minmax");
                        null !== t && (U[103] = t.MIN_EXT, U[104] = t.MAX_EXT)
                    }
                    const H = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 };

                    function k(e, n, i, r, s, o, a, l) {
                        if (0 !== e) {
                            if (!1 === u && (F(3042), u = !0), 5 === e) s = s || n, o = o || i, a = a || r, n === p && s === g || (t.blendEquationSeparate(U[n], U[s]), p = n, g = s), i === m && r === f && o === v && a === y || (t.blendFuncSeparate(H[i], H[r], H[o], H[a]), m = i, f = r, v = o, y = a), d = e, x = null;
                            else if (e !== d || l !== x) {
                                if (p === Py && g === Py || (t.blendEquation(32774), p = Py, g = Py), l) switch (e) {
                                    case 1:
                                        t.blendFuncSeparate(1, 771, 1, 771);
                                        break;
                                    case 2:
                                        t.blendFunc(1, 1);
                                        break;
                                    case 3:
                                        t.blendFuncSeparate(0, 0, 769, 771);
                                        break;
                                    case 4:
                                        t.blendFuncSeparate(0, 768, 0, 770);
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", e)
                                } else switch (e) {
                                    case 1:
                                        t.blendFuncSeparate(770, 771, 1, 771);
                                        break;
                                    case 2:
                                        t.blendFunc(770, 1);
                                        break;
                                    case 3:
                                        t.blendFunc(0, 769);
                                        break;
                                    case 4:
                                        t.blendFunc(0, 768);
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", e)
                                }
                                m = null, f = null, v = null, y = null, d = e, x = l
                            }
                        } else !0 === u && (z(3042), u = !1)
                    }

                    function G(e) { _ !== e && (e ? t.frontFace(2304) : t.frontFace(2305), _ = e) }

                    function V(e) { 0 !== e ? (F(2884), e !== b && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : z(2884), b = e }

                    function W(e, n, i) { e ? (F(32823), M === n && S === i || (t.polygonOffset(n, i), M = n, S = i)) : z(32823) }

                    function j(e) { void 0 === e && (e = 33984 + T - 1), R !== e && (t.activeTexture(e), R = e) }
                    return {
                        buffers: { color: r, depth: s, stencil: o },
                        enable: F,
                        disable: z,
                        bindFramebuffer: function(e, n) { return null === n && null !== l && (n = l), c[e] !== n && (t.bindFramebuffer(e, n), c[e] = n, i && (36009 === e && (c[36160] = n), 36160 === e && (c[36009] = n)), !0) },
                        bindXRFramebuffer: function(e) { e !== l && (t.bindFramebuffer(36160, e), l = e) },
                        useProgram: function(e) { return h !== e && (t.useProgram(e), h = e, !0) },
                        setBlending: k,
                        setMaterial: function(t, e) {
                            2 === t.side ? z(2884) : F(2884);
                            let n = 1 === t.side;
                            e && (n = !n), G(n), 1 === t.blending && !1 === t.transparent ? k(0) : k(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), r.setMask(t.colorWrite);
                            const i = t.stencilWrite;
                            o.setTest(i), i && (o.setMask(t.stencilWriteMask), o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), W(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? F(32926) : z(32926)
                        },
                        setFlipSided: G,
                        setCullFace: V,
                        setLineWidth: function(e) { e !== w && (E && t.lineWidth(e), w = e) },
                        setPolygonOffset: W,
                        setScissorTest: function(t) { t ? F(3089) : z(3089) },
                        activeTexture: j,
                        bindTexture: function(e, n) {
                            null === R && j();
                            let i = C[R];
                            void 0 === i && (i = { type: void 0, texture: void 0 }, C[R] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || O[e]), i.type = e, i.texture = n)
                        },
                        unbindTexture: function() {
                            const e = C[R];
                            void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                        },
                        compressedTexImage2D: function() { try { t.compressedTexImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } },
                        texImage2D: function() { try { t.texImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } },
                        texImage3D: function() { try { t.texImage3D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } },
                        scissor: function(e) {!1 === D.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), D.copy(e)) },
                        viewport: function(e) {!1 === N.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), N.copy(e)) },
                        reset: function() { t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === i && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), a = {}, R = null, C = {}, l = null, c = {}, h = null, u = !1, d = null, p = null, m = null, f = null, g = null, v = null, y = null, x = !1, _ = null, b = null, w = null, M = null, S = null, D.set(0, 0, t.canvas.width, t.canvas.height), N.set(0, 0, t.canvas.width, t.canvas.height), r.reset(), s.reset(), o.reset() }
                    }
                }

                function nS(t, e, n, i, r, s, o) {
                    const a = r.isWebGL2,
                        l = r.maxTextures,
                        c = r.maxCubemapSize,
                        h = r.maxTextureSize,
                        u = r.maxSamples,
                        d = new WeakMap;
                    let p, m = !1;
                    try { m = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (t) {}

                    function f(t, e) { return m ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") }

                    function g(t, e, n, i) {
                        let r = 1;
                        if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                            if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                                const i = e ? fx : Math.floor,
                                    s = i(r * t.width),
                                    o = i(r * t.height);
                                void 0 === p && (p = f(s, o));
                                const a = n ? f(s, o) : p;
                                return a.width = s, a.height = o, a.getContext("2d").drawImage(t, 0, 0, s, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + o + ")."), a
                            }
                            return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                        }
                        return t
                    }

                    function v(t) { return mx(t.width) && mx(t.height) }

                    function y(t, e) { return t.generateMipmaps && e && t.minFilter !== By && t.minFilter !== Oy }

                    function x(e, n, r, s, o = 1) { t.generateMipmap(e), i.get(n).__maxMipLevel = Math.log2(Math.max(r, s, o)) }

                    function _(n, i, r) {
                        if (!1 === a) return i;
                        if (null !== n) {
                            if (void 0 !== t[n]) return t[n];
                            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                        }
                        let s = i;
                        return 6403 === i && (5126 === r && (s = 33326), 5131 === r && (s = 33325), 5121 === r && (s = 33321)), 6407 === i && (5126 === r && (s = 34837), 5131 === r && (s = 34843), 5121 === r && (s = 32849)), 6408 === i && (5126 === r && (s = 34836), 5131 === r && (s = 34842), 5121 === r && (s = 32856)), 33325 !== s && 33326 !== s && 34842 !== s && 34836 !== s || e.get("EXT_color_buffer_float"), s
                    }

                    function b(t) { return t === By || 1004 === t || 1005 === t ? 9728 : 9729 }

                    function w(e) {
                        const n = e.target;
                        n.removeEventListener("dispose", w),
                            function(e) {
                                const n = i.get(e);
                                void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture), i.remove(e))
                            }(n), n.isVideoTexture && d.delete(n), o.memory.textures--
                    }

                    function M(e) {
                        const n = e.target;
                        n.removeEventListener("dispose", M),
                            function(e) {
                                const n = e.texture,
                                    r = i.get(e),
                                    s = i.get(n);
                                if (e) {
                                    if (void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture), o.memory.textures--), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)
                                        for (let e = 0; e < 6; e++) t.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                                    else t.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                                    if (e.isWebGLMultipleRenderTargets)
                                        for (let e = 0, r = n.length; e < r; e++) {
                                            const r = i.get(n[e]);
                                            r.__webglTexture && (t.deleteTexture(r.__webglTexture), o.memory.textures--), i.remove(n[e])
                                        }
                                    i.remove(n), i.remove(e)
                                }
                            }(n)
                    }
                    let S = 0;

                    function T(t, e) {
                        const r = i.get(t);
                        if (t.isVideoTexture && function(t) {
                                const e = o.render.frame;
                                d.get(t) !== e && (d.set(t, e), t.update())
                            }(t), t.version > 0 && r.__version !== t.version) {
                            const n = t.image;
                            if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                            else {
                                if (!1 !== n.complete) return void P(r, t, e);
                                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                            }
                        }
                        n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture)
                    }

                    function E(e, r) {
                        const o = i.get(e);
                        e.version > 0 && o.__version !== e.version ? function(e, i, r) {
                            if (6 !== i.image.length) return;
                            C(e, i), n.activeTexture(33984 + r), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
                            const o = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
                                l = i.image[0] && i.image[0].isDataTexture,
                                h = [];
                            for (let t = 0; t < 6; t++) h[t] = o || l ? l ? i.image[t].image : i.image[t] : g(i.image[t], !1, !0, c);
                            const u = h[0],
                                d = v(u) || a,
                                p = s.convert(i.format),
                                m = s.convert(i.type),
                                f = _(i.internalFormat, p, m);
                            let b;
                            if (R(34067, i, d), o) {
                                for (let t = 0; t < 6; t++) {
                                    b = h[t].mipmaps;
                                    for (let e = 0; e < b.length; e++) {
                                        const r = b[e];
                                        i.format !== jy && i.format !== Wy ? null !== p ? n.compressedTexImage2D(34069 + t, e, f, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, e, f, r.width, r.height, 0, p, m, r.data)
                                    }
                                }
                                e.__maxMipLevel = b.length - 1
                            } else {
                                b = i.mipmaps;
                                for (let t = 0; t < 6; t++)
                                    if (l) {
                                        n.texImage2D(34069 + t, 0, f, h[t].width, h[t].height, 0, p, m, h[t].data);
                                        for (let e = 0; e < b.length; e++) {
                                            const i = b[e].image[t].image;
                                            n.texImage2D(34069 + t, e + 1, f, i.width, i.height, 0, p, m, i.data)
                                        }
                                    } else {
                                        n.texImage2D(34069 + t, 0, f, p, m, h[t]);
                                        for (let e = 0; e < b.length; e++) {
                                            const i = b[e];
                                            n.texImage2D(34069 + t, e + 1, f, p, m, i.image[t])
                                        }
                                    }
                                e.__maxMipLevel = b.length
                            }
                            y(i, d) && x(34067, i, u.width, u.height), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                        }(o, e, r) : (n.activeTexture(33984 + r), n.bindTexture(34067, o.__webglTexture))
                    }
                    const A = {
                            [Iy]: 10497,
                            [Dy]: 33071,
                            [Ny]: 33648
                        },
                        L = {
                            [By]: 9728,
                            1004: 9984,
                            1005: 9986,
                            [Oy]: 9729,
                            1007: 9985,
                            [Fy]: 9987
                        };

                    function R(n, s, o) {
                        if (o ? (t.texParameteri(n, 10242, A[s.wrapS]), t.texParameteri(n, 10243, A[s.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, A[s.wrapR]), t.texParameteri(n, 10240, L[s.magFilter]), t.texParameteri(n, 10241, L[s.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), s.wrapS === Dy && s.wrapT === Dy || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, b(s.magFilter)), t.texParameteri(n, 10241, b(s.minFilter)), s.minFilter !== By && s.minFilter !== Oy && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
                            const o = e.get("EXT_texture_filter_anisotropic");
                            if (s.type === ky && !1 === e.has("OES_texture_float_linear")) return;
                            if (!1 === a && s.type === Gy && !1 === e.has("OES_texture_half_float_linear")) return;
                            (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy)
                        }
                    }

                    function C(e, n) { void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", w), e.__webglTexture = t.createTexture(), o.memory.textures++) }

                    function P(e, i, r) {
                        let o = 3553;
                        i.isDataTexture2DArray && (o = 35866), i.isDataTexture3D && (o = 32879), C(e, i), n.activeTexture(33984 + r), n.bindTexture(o, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
                        const l = function(t) { return !a && (t.wrapS !== Dy || t.wrapT !== Dy || t.minFilter !== By && t.minFilter !== Oy) }(i) && !1 === v(i.image),
                            c = g(i.image, l, !1, h),
                            u = v(c) || a,
                            d = s.convert(i.format);
                        let p, m = s.convert(i.type),
                            f = _(i.internalFormat, d, m);
                        R(o, i, u);
                        const b = i.mipmaps;
                        if (i.isDepthTexture) f = 6402, a ? f = i.type === ky ? 36012 : i.type === Hy ? 33190 : i.type === Vy ? 35056 : 33189 : i.type === ky && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === qy && 6402 === f && i.type !== Uy && i.type !== Hy && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = Uy, m = s.convert(i.type)), i.format === Xy && 6402 === f && (f = 34041, i.type !== Vy && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = Vy, m = s.convert(i.type))), n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, null);
                        else if (i.isDataTexture)
                            if (b.length > 0 && u) {
                                for (let t = 0, e = b.length; t < e; t++) p = b[t], n.texImage2D(3553, t, f, p.width, p.height, 0, d, m, p.data);
                                i.generateMipmaps = !1, e.__maxMipLevel = b.length - 1
                            } else n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, c.data), e.__maxMipLevel = 0;
                        else if (i.isCompressedTexture) {
                            for (let t = 0, e = b.length; t < e; t++) p = b[t], i.format !== jy && i.format !== Wy ? null !== d ? n.compressedTexImage2D(3553, t, f, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, f, p.width, p.height, 0, d, m, p.data);
                            e.__maxMipLevel = b.length - 1
                        } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, f, c.width, c.height, c.depth, 0, d, m, c.data), e.__maxMipLevel = 0;
                        else if (i.isDataTexture3D) n.texImage3D(32879, 0, f, c.width, c.height, c.depth, 0, d, m, c.data), e.__maxMipLevel = 0;
                        else if (b.length > 0 && u) {
                            for (let t = 0, e = b.length; t < e; t++) p = b[t], n.texImage2D(3553, t, f, d, m, p);
                            i.generateMipmaps = !1, e.__maxMipLevel = b.length - 1
                        } else n.texImage2D(3553, 0, f, d, m, c), e.__maxMipLevel = 0;
                        y(i, u) && x(o, i, c.width, c.height), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                    }

                    function I(e, r, o, a, l) {
                        const c = s.convert(o.format),
                            h = s.convert(o.type),
                            u = _(o.internalFormat, c, h);
                        32879 === l || 35866 === l ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null), n.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, a, l, i.get(o).__webglTexture, 0), n.bindFramebuffer(36160, null)
                    }

                    function D(e, n, i) {
                        if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                            let r = 33189;
                            if (i) {
                                const e = n.depthTexture;
                                e && e.isDepthTexture && (e.type === ky ? r = 36012 : e.type === Hy && (r = 33190));
                                const i = N(n);
                                t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                            } else t.renderbufferStorage(36161, r, n.width, n.height);
                            t.framebufferRenderbuffer(36160, 36096, 36161, e)
                        } else if (n.depthBuffer && n.stencilBuffer) {
                            if (i) {
                                const e = N(n);
                                t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height)
                            } else t.renderbufferStorage(36161, 34041, n.width, n.height);
                            t.framebufferRenderbuffer(36160, 33306, 36161, e)
                        } else {
                            const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
                                r = s.convert(e.format),
                                o = s.convert(e.type),
                                a = _(e.internalFormat, r, o);
                            if (i) {
                                const e = N(n);
                                t.renderbufferStorageMultisample(36161, e, a, n.width, n.height)
                            } else t.renderbufferStorage(36161, a, n.width, n.height)
                        }
                        t.bindRenderbuffer(36161, null)
                    }

                    function N(t) { return a && t.isWebGLMultisampleRenderTarget ? Math.min(u, t.samples) : 0 }
                    let B = !1,
                        O = !1;
                    this.allocateTextureUnit = function() { const t = S; return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), S += 1, t }, this.resetTextureUnits = function() { S = 0 }, this.setTexture2D = T, this.setTexture2DArray = function(t, e) {
                        const r = i.get(t);
                        t.version > 0 && r.__version !== t.version ? P(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture))
                    }, this.setTexture3D = function(t, e) {
                        const r = i.get(t);
                        t.version > 0 && r.__version !== t.version ? P(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture))
                    }, this.setTextureCube = E, this.setupRenderTarget = function(e) {
                        const l = e.texture,
                            c = i.get(e),
                            h = i.get(l);
                        e.addEventListener("dispose", M), !0 !== e.isWebGLMultipleRenderTargets && (h.__webglTexture = t.createTexture(), h.__version = l.version, o.memory.textures++);
                        const u = !0 === e.isWebGLCubeRenderTarget,
                            d = !0 === e.isWebGLMultipleRenderTargets,
                            p = !0 === e.isWebGLMultisampleRenderTarget,
                            m = l.isDataTexture3D || l.isDataTexture2DArray,
                            f = v(e) || a;
                        if (!a || l.format !== Wy || l.type !== ky && l.type !== Gy || (l.format = jy, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), u) { c.__webglFramebuffer = []; for (let e = 0; e < 6; e++) c.__webglFramebuffer[e] = t.createFramebuffer() } else if (c.__webglFramebuffer = t.createFramebuffer(), d)
                            if (r.drawBuffers) {
                                const n = e.texture;
                                for (let e = 0, r = n.length; e < r; e++) {
                                    const r = i.get(n[e]);
                                    void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(), o.memory.textures++)
                                }
                            } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                        else if (p)
                            if (a) {
                                c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
                                const i = s.convert(l.format),
                                    r = s.convert(l.type),
                                    o = _(l.internalFormat, i, r),
                                    a = N(e);
                                t.renderbufferStorageMultisample(36161, a, o, e.width, e.height), n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), D(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null)
                            } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                        if (u) {
                            n.bindTexture(34067, h.__webglTexture), R(34067, l, f);
                            for (let t = 0; t < 6; t++) I(c.__webglFramebuffer[t], e, l, 36064, 34069 + t);
                            y(l, f) && x(34067, l, e.width, e.height), n.bindTexture(34067, null)
                        } else if (d) {
                            const t = e.texture;
                            for (let r = 0, s = t.length; r < s; r++) {
                                const s = t[r],
                                    o = i.get(s);
                                n.bindTexture(3553, o.__webglTexture), R(3553, s, f), I(c.__webglFramebuffer, e, s, 36064 + r, 3553), y(s, f) && x(3553, s, e.width, e.height)
                            }
                            n.bindTexture(3553, null)
                        } else {
                            let t = 3553;
                            m && (a ? t = l.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), n.bindTexture(t, h.__webglTexture), R(t, l, f), I(c.__webglFramebuffer, e, l, 36064, t), y(l, f) && x(t, l, e.width, e.height, e.depth), n.bindTexture(t, null)
                        }
                        e.depthBuffer && function(e) {
                            const r = i.get(e),
                                s = !0 === e.isWebGLCubeRenderTarget;
                            if (e.depthTexture) {
                                if (s) throw new Error("target.depthTexture not supported in Cube render targets");
                                ! function(e, r) {
                                    if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                                    if (n.bindFramebuffer(36160, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                                    i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), T(r.depthTexture, 0);
                                    const s = i.get(r.depthTexture).__webglTexture;
                                    if (r.depthTexture.format === qy) t.framebufferTexture2D(36160, 36096, 3553, s, 0);
                                    else {
                                        if (r.depthTexture.format !== Xy) throw new Error("Unknown depthTexture format");
                                        t.framebufferTexture2D(36160, 33306, 3553, s, 0)
                                    }
                                }(r.__webglFramebuffer, e)
                            } else if (s) { r.__webglDepthbuffer = []; for (let i = 0; i < 6; i++) n.bindFramebuffer(36160, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = t.createRenderbuffer(), D(r.__webglDepthbuffer[i], e, !1) } else n.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), D(r.__webglDepthbuffer, e, !1);
                            n.bindFramebuffer(36160, null)
                        }(e)
                    }, this.updateRenderTargetMipmap = function(t) {
                        const e = v(t) || a,
                            r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                        for (let s = 0, o = r.length; s < o; s++) {
                            const o = r[s];
                            if (y(o, e)) {
                                const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                                    r = i.get(o).__webglTexture;
                                n.bindTexture(e, r), x(e, o, t.width, t.height), n.bindTexture(e, null)
                            }
                        }
                    }, this.updateMultisampleRenderTarget = function(e) {
                        if (e.isWebGLMultisampleRenderTarget)
                            if (a) {
                                const r = e.width,
                                    s = e.height;
                                let o = 16384;
                                e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024);
                                const a = i.get(e);
                                n.bindFramebuffer(36008, a.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, a.__webglFramebuffer), t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, o, 9728), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, a.__webglMultisampledFramebuffer)
                            } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                    }, this.safeSetTexture2D = function(t, e) { t && t.isWebGLRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), B = !0), t = t.texture), T(t, e) }, this.safeSetTextureCube = function(t, e) { t && t.isWebGLCubeRenderTarget && (!1 === O && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), O = !0), t = t.texture), E(t, e) }
                }

                function iS(t, e, n) { const i = n.isWebGL2; return { convert: function(t) { let n; if (t === zy) return 5121; if (1017 === t) return 32819; if (1018 === t) return 32820; if (1019 === t) return 33635; if (1010 === t) return 5120; if (1011 === t) return 5122; if (t === Uy) return 5123; if (1013 === t) return 5124; if (t === Hy) return 5125; if (t === ky) return 5126; if (t === Gy) return i ? 5131 : (n = e.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null); if (1021 === t) return 6406; if (t === Wy) return 6407; if (t === jy) return 6408; if (1024 === t) return 6409; if (1025 === t) return 6410; if (t === qy) return 6402; if (t === Xy) return 34041; if (1028 === t) return 6403; if (1029 === t) return 36244; if (1030 === t) return 33319; if (1031 === t) return 33320; if (1032 === t) return 36248; if (1033 === t) return 36249; if (33776 === t || 33777 === t || 33778 === t || 33779 === t) { if (n = e.get("WEBGL_compressed_texture_s3tc"), null === n) return null; if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT; if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (35840 === t || 35841 === t || 35842 === t || 35843 === t) { if (n = e.get("WEBGL_compressed_texture_pvrtc"), null === n) return null; if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (36196 === t) return n = e.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null; if ((37492 === t || 37496 === t) && (n = e.get("WEBGL_compressed_texture_etc"), null !== n)) { if (37492 === t) return n.COMPRESSED_RGB8_ETC2; if (37496 === t) return n.COMPRESSED_RGBA8_ETC2_EAC } return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? (n = e.get("WEBGL_compressed_texture_astc"), null !== n ? t : null) : 36492 === t ? (n = e.get("EXT_texture_compression_bptc"), null !== n ? t : null) : t === Vy ? i ? 34042 : (n = e.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0 } } }
                $M.prototype.isMeshDistanceMaterial = !0;
                class rS extends zb { constructor(t = []) { super(), this.cameras = t } }
                rS.prototype.isArrayCamera = !0;
                class sS extends C_ { constructor() { super(), this.type = "Group" } }
                sS.prototype.isGroup = !0;
                const oS = { type: "move" };
                class aS {
                    constructor() { this._targetRay = null, this._grip = null, this._hand = null }
                    getHandSpace() { return null === this._hand && (this._hand = new sS, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand }
                    getTargetRaySpace() { return null === this._targetRay && (this._targetRay = new sS, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Lx, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Lx), this._targetRay }
                    getGripSpace() { return null === this._grip && (this._grip = new sS, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Lx, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Lx), this._grip }
                    dispatchEvent(t) { return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this }
                    disconnect(t) { return this.dispatchEvent({ type: "disconnected", data: t }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this }
                    update(t, e, n) {
                        let i = null,
                            r = null,
                            s = null;
                        const o = this._targetRay,
                            a = this._grip,
                            l = this._hand;
                        if (t && "visible-blurred" !== e.session.visibilityState)
                            if (null !== o && (i = e.getPose(t.targetRaySpace, n), null !== i && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(oS))), l && t.hand) {
                                s = !0;
                                for (const i of t.hand.values()) {
                                    const t = e.getJointPose(i, n);
                                    if (void 0 === l.joints[i.jointName]) {
                                        const t = new sS;
                                        t.matrixAutoUpdate = !1, t.visible = !1, l.joints[i.jointName] = t, l.add(t)
                                    }
                                    const r = l.joints[i.jointName];
                                    null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = t.radius), r.visible = null !== t
                                }
                                const i = l.joints["index-finger-tip"],
                                    r = l.joints["thumb-tip"],
                                    o = i.position.distanceTo(r.position),
                                    a = .02,
                                    c = .005;
                                l.inputState.pinching && o > a + c ? (l.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this })) : !l.inputState.pinching && o <= a - c && (l.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this }))
                            } else null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1));
                        return null !== o && (o.visible = null !== i), null !== a && (a.visible = null !== r), null !== l && (l.visible = null !== s), this
                    }
                }
                class lS extends sx {
                    constructor(t, e) {
                        super();
                        const n = this,
                            i = t.state;
                        let r = null,
                            s = 1,
                            o = null,
                            a = "local-floor",
                            l = null,
                            c = null,
                            h = null,
                            u = null;
                        const d = [],
                            p = new Map,
                            m = new zb;
                        m.layers.enable(1), m.viewport = new Sx;
                        const f = new zb;
                        f.layers.enable(2), f.viewport = new Sx;
                        const g = [m, f],
                            v = new rS;
                        v.layers.enable(1), v.layers.enable(2);
                        let y = null,
                            x = null;

                        function _(t) {
                            const e = p.get(t.inputSource);
                            e && e.dispatchEvent({ type: t.type, data: t.inputSource })
                        }

                        function b() { p.forEach((function(t, e) { t.disconnect(e) })), p.clear(), y = null, x = null, i.bindXRFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), A.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" }) }

                        function w(t) {
                            const e = r.inputSources;
                            for (let t = 0; t < d.length; t++) p.set(e[t], d[t]);
                            for (let e = 0; e < t.removed.length; e++) {
                                const n = t.removed[e],
                                    i = p.get(n);
                                i && (i.dispatchEvent({ type: "disconnected", data: n }), p.delete(n))
                            }
                            for (let e = 0; e < t.added.length; e++) {
                                const n = t.added[e],
                                    i = p.get(n);
                                i && i.dispatchEvent({ type: "connected", data: n })
                            }
                        }
                        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(t) { let e = d[t]; return void 0 === e && (e = new aS, d[t] = e), e.getTargetRaySpace() }, this.getControllerGrip = function(t) { let e = d[t]; return void 0 === e && (e = new aS, d[t] = e), e.getGripSpace() }, this.getHand = function(t) { let e = d[t]; return void 0 === e && (e = new aS, d[t] = e), e.getHandSpace() }, this.setFramebufferScaleFactor = function(t) { s = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function(t) { a = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function() { return o }, this.getSession = function() { return r }, this.setSession = async function(t) {
                            if (r = t, null !== r) {
                                r.addEventListener("select", _), r.addEventListener("selectstart", _), r.addEventListener("selectend", _), r.addEventListener("squeeze", _), r.addEventListener("squeezestart", _), r.addEventListener("squeezeend", _), r.addEventListener("end", b), r.addEventListener("inputsourceschange", w);
                                const t = e.getContextAttributes();
                                if (!0 !== t.xrCompatible && await e.makeXRCompatible(), void 0 === r.renderState.layers) {
                                    const n = { antialias: t.antialias, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: s },
                                        i = new XRWebGLLayer(r, e, n);
                                    r.updateRenderState({ baseLayer: i })
                                } else {
                                    let n = 0;
                                    t.depth && (n = t.stencil ? 34041 : 6402);
                                    const i = { colorFormat: t.alpha ? 6408 : 6407, depthFormat: n, scaleFactor: s };
                                    c = new XRWebGLBinding(r, e), u = c.createProjectionLayer(i), h = e.createFramebuffer(), r.updateRenderState({ layers: [u] })
                                }
                                o = await r.requestReferenceSpace(a), A.setContext(r), A.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" })
                            }
                        };
                        const M = new Lx,
                            S = new Lx;

                        function T(t, e) { null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert() }
                        this.updateCamera = function(t) {
                            if (null === r) return;
                            v.near = f.near = m.near = t.near, v.far = f.far = m.far = t.far, y === v.near && x === v.far || (r.updateRenderState({ depthNear: v.near, depthFar: v.far }), y = v.near, x = v.far);
                            const e = t.parent,
                                n = v.cameras;
                            T(v, e);
                            for (let t = 0; t < n.length; t++) T(n[t], e);
                            v.matrixWorld.decompose(v.position, v.quaternion, v.scale), t.position.copy(v.position), t.quaternion.copy(v.quaternion), t.scale.copy(v.scale), t.matrix.copy(v.matrix), t.matrixWorld.copy(v.matrixWorld);
                            const i = t.children;
                            for (let t = 0, e = i.length; t < e; t++) i[t].updateMatrixWorld(!0);
                            2 === n.length ? function(t, e, n) {
                                M.setFromMatrixPosition(e.matrixWorld), S.setFromMatrixPosition(n.matrixWorld);
                                const i = M.distanceTo(S),
                                    r = e.projectionMatrix.elements,
                                    s = n.projectionMatrix.elements,
                                    o = r[14] / (r[10] - 1),
                                    a = r[14] / (r[10] + 1),
                                    l = (r[9] + 1) / r[5],
                                    c = (r[9] - 1) / r[5],
                                    h = (r[8] - 1) / r[0],
                                    u = (s[8] + 1) / s[0],
                                    d = o * h,
                                    p = o * u,
                                    m = i / (-h + u),
                                    f = m * -h;
                                e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(f), t.translateZ(m), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                                const g = o + m,
                                    v = a + m,
                                    y = d - f,
                                    x = p + (i - f),
                                    _ = l * a / v * g,
                                    b = c * a / v * g;
                                t.projectionMatrix.makePerspective(y, x, _, b, g, v)
                            }(v, m, f) : v.projectionMatrix.copy(m.projectionMatrix)
                        }, this.getCamera = function() { return v };
                        let E = null;
                        const A = new Jb;
                        A.setAnimationLoop((function(t, n) {
                            if (l = n.getViewerPose(o), null !== l) {
                                const t = l.views,
                                    n = r.renderState.baseLayer;
                                void 0 === r.renderState.layers && i.bindXRFramebuffer(n.framebuffer);
                                let s = !1;
                                t.length !== v.cameras.length && (v.cameras.length = 0, s = !0);
                                for (let o = 0; o < t.length; o++) {
                                    const a = t[o];
                                    let l = null;
                                    if (void 0 === r.renderState.layers) l = n.getViewport(a);
                                    else {
                                        const t = c.getViewSubImage(u, a);
                                        i.bindXRFramebuffer(h), e.framebufferTexture2D(36160, 36064, 3553, t.colorTexture, 0), void 0 !== t.depthStencilTexture && e.framebufferTexture2D(36160, 36096, 3553, t.depthStencilTexture, 0), l = t.viewport
                                    }
                                    const d = g[o];
                                    d.matrix.fromArray(a.transform.matrix), d.projectionMatrix.fromArray(a.projectionMatrix), d.viewport.set(l.x, l.y, l.width, l.height), 0 === o && v.matrix.copy(d.matrix), !0 === s && v.cameras.push(d)
                                }
                            }
                            const s = r.inputSources;
                            for (let t = 0; t < d.length; t++) {
                                const e = d[t],
                                    i = s[t];
                                e.update(i, n, o)
                            }
                            E && E(t, n)
                        })), this.setAnimationLoop = function(t) { E = t }, this.dispose = function() {}
                    }
                }

                function cS(t) {
                    function e(e, n) {
                        e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap);
                        const i = t.get(n).envMap;
                        if (i) {
                            e.envMap.value = i, e.flipEnvMap.value = i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio;
                            const r = t.get(i).__maxMipLevel;
                            void 0 !== r && (e.maxMipLevel.value = r)
                        }
                        let r, s;
                        n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uv2Transform.value.copy(s.matrix))
                    }

                    function n(e, n) { e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, 1 === n.side && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), 1 === n.side && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity) }
                    return {
                        refreshFogUniforms: function(t, e) { t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density) },
                        refreshMaterialUniforms: function(t, i, r, s, o) {
                            i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i), function(t, e) { e.emissiveMap && (t.emissiveMap.value = e.emissiveMap) }(t, i)) : i.isMeshToonMaterial ? (e(t, i), function(t, e) { e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshPhongMaterial ? (e(t, i), function(t, e) { t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshStandardMaterial ? (e(t, i), i.isMeshPhysicalMaterial ? function(t, e, i) { n(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen), e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate()), t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), e.transmission > 0 && (t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height)), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor) }(t, i, o) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i), function(t, e) { e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshDepthMaterial ? (e(t, i), function(t, e) { e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i), function(t, e) { e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance }(t, i)) : i.isMeshNormalMaterial ? (e(t, i), function(t, e) { e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isLineBasicMaterial ? (function(t, e) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity }(t, i), i.isLineDashedMaterial && function(t, e) { t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale }(t, i)) : i.isPointsMaterial ? function(t, e, n, i) {
                                let r;
                                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.map ? r = e.map : e.alphaMap && (r = e.alphaMap), void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
                            }(t, i, r, s) : i.isSpriteMaterial ? function(t, e) {
                                let n;
                                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.map ? n = e.map : e.alphaMap && (n = e.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                            }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                        }
                    }
                }

                function hS(t = {}) {
                    const e = void 0 !== t.canvas ? t.canvas : function() { const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); return t.style.display = "block", t }(),
                        n = void 0 !== t.context ? t.context : null,
                        i = void 0 !== t.alpha && t.alpha,
                        r = void 0 === t.depth || t.depth,
                        s = void 0 === t.stencil || t.stencil,
                        o = void 0 !== t.antialias && t.antialias,
                        a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                        l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                        c = void 0 !== t.powerPreference ? t.powerPreference : "default",
                        h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
                    let u = null,
                        d = null;
                    const p = [],
                        m = [];
                    this.domElement = e, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = tx, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
                    const f = this;
                    let g = !1,
                        v = 0,
                        y = 0,
                        x = null,
                        _ = -1,
                        b = null;
                    const w = new Sx,
                        M = new Sx;
                    let S = null,
                        T = e.width,
                        E = e.height,
                        A = 1,
                        L = null,
                        R = null;
                    const C = new Sx(0, 0, T, E),
                        P = new Sx(0, 0, T, E);
                    let I = !1;
                    const D = [],
                        N = new Zb;
                    let B = !1,
                        O = !1,
                        F = null;
                    const z = new s_,
                        U = new Lx,
                        H = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };

                    function k() { return null === x ? A : 1 }
                    let G, V, W, j, q, X, Y, Z, J, K, Q, $, tt, et, nt, it, rt, st, ot, at, lt, ct, ht = n;

                    function ut(t, n) {
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i],
                                s = e.getContext(r, n);
                            if (null !== s) return s
                        }
                        return null
                    }
                    try {
                        const t = { alpha: i, depth: r, stencil: s, antialias: o, premultipliedAlpha: a, preserveDrawingBuffer: l, powerPreference: c, failIfMajorPerformanceCaveat: h };
                        if (e.addEventListener("webglcontextlost", mt, !1), e.addEventListener("webglcontextrestored", ft, !1), null === ht) { const e = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === f.isWebGL1Renderer && e.shift(), ht = ut(e, t), null === ht) throw ut(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") }
                        void 0 === ht.getShaderPrecisionFormat && (ht.getShaderPrecisionFormat = function() { return { rangeMin: 1, rangeMax: 1, precision: 1 } })
                    } catch (t) { throw console.error("THREE.WebGLRenderer: " + t.message), t }

                    function dt() { G = new lw(ht), V = new sw(ht, G, t), G.init(V), lt = new iS(ht, G, V), W = new eS(ht, G, V), D[0] = 1029, j = new uw(ht), q = new kM, X = new nS(ht, G, W, q, V, lt, j), Y = new aw(f), Z = new Kb(ht, V), ct = new iw(ht, G, Z, V), J = new cw(ht, Z, j, ct), K = new fw(ht, J, Z, j), st = new mw(ht), nt = new ow(q), Q = new HM(f, Y, G, V, ct, nt), $ = new cS(q), tt = new jM(q), et = new KM(G, V), rt = new nw(f, Y, W, K, a), it = new tS(f, K, V), ot = new rw(ht, G, j, V), at = new hw(ht, G, j, V), j.programs = Q.programs, f.capabilities = V, f.extensions = G, f.properties = q, f.renderLists = tt, f.shadowMap = it, f.state = W, f.info = j }
                    dt();
                    const pt = new lS(f, ht);

                    function mt(t) { t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0 }

                    function ft() {
                        console.log("THREE.WebGLRenderer: Context Restored."), g = !1;
                        const t = j.autoReset,
                            e = it.enabled,
                            n = it.autoUpdate,
                            i = it.needsUpdate,
                            r = it.type;
                        dt(), j.autoReset = t, it.enabled = e, it.autoUpdate = n, it.needsUpdate = i, it.type = r
                    }

                    function gt(t) {
                        const e = t.target;
                        e.removeEventListener("dispose", gt),
                            function(t) {
                                (function(t) {
                                    const e = q.get(t).programs;
                                    void 0 !== e && e.forEach((function(t) { Q.releaseProgram(t) }))
                                })(t), q.remove(t)
                            }(e)
                    }
                    this.xr = pt, this.getContext = function() { return ht }, this.getContextAttributes = function() { return ht.getContextAttributes() }, this.forceContextLoss = function() {
                        const t = G.get("WEBGL_lose_context");
                        t && t.loseContext()
                    }, this.forceContextRestore = function() {
                        const t = G.get("WEBGL_lose_context");
                        t && t.restoreContext()
                    }, this.getPixelRatio = function() { return A }, this.setPixelRatio = function(t) { void 0 !== t && (A = t, this.setSize(T, E, !1)) }, this.getSize = function(t) { return t.set(T, E) }, this.setSize = function(t, n, i) { pt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T = t, E = n, e.width = Math.floor(t * A), e.height = Math.floor(n * A), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n)) }, this.getDrawingBufferSize = function(t) { return t.set(T * A, E * A).floor() }, this.setDrawingBufferSize = function(t, n, i) { T = t, E = n, A = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n) }, this.getCurrentViewport = function(t) { return t.copy(w) }, this.getViewport = function(t) { return t.copy(C) }, this.setViewport = function(t, e, n, i) { t.isVector4 ? C.set(t.x, t.y, t.z, t.w) : C.set(t, e, n, i), W.viewport(w.copy(C).multiplyScalar(A).floor()) }, this.getScissor = function(t) { return t.copy(P) }, this.setScissor = function(t, e, n, i) { t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, n, i), W.scissor(M.copy(P).multiplyScalar(A).floor()) }, this.getScissorTest = function() { return I }, this.setScissorTest = function(t) { W.setScissorTest(I = t) }, this.setOpaqueSort = function(t) { L = t }, this.setTransparentSort = function(t) { R = t }, this.getClearColor = function(t) { return t.copy(rt.getClearColor()) }, this.setClearColor = function() { rt.setClearColor.apply(rt, arguments) }, this.getClearAlpha = function() { return rt.getClearAlpha() }, this.setClearAlpha = function() { rt.setClearAlpha.apply(rt, arguments) }, this.clear = function(t, e, n) {
                        let i = 0;
                        (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), ht.clear(i)
                    }, this.clearColor = function() { this.clear(!0, !1, !1) }, this.clearDepth = function() { this.clear(!1, !0, !1) }, this.clearStencil = function() { this.clear(!1, !1, !0) }, this.dispose = function() { e.removeEventListener("webglcontextlost", mt, !1), e.removeEventListener("webglcontextrestored", ft, !1), tt.dispose(), et.dispose(), q.dispose(), Y.dispose(), K.dispose(), ct.dispose(), pt.dispose(), pt.removeEventListener("sessionstart", yt), pt.removeEventListener("sessionend", xt), F && (F.dispose(), F = null), _t.stop() }, this.renderBufferImmediate = function(t, e) {
                        ct.initAttributes();
                        const n = q.get(t);
                        t.hasPositions && !n.position && (n.position = ht.createBuffer()), t.hasNormals && !n.normal && (n.normal = ht.createBuffer()), t.hasUvs && !n.uv && (n.uv = ht.createBuffer()), t.hasColors && !n.color && (n.color = ht.createBuffer());
                        const i = e.getAttributes();
                        t.hasPositions && (ht.bindBuffer(34962, n.position), ht.bufferData(34962, t.positionArray, 35048), ct.enableAttribute(i.position), ht.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), t.hasNormals && (ht.bindBuffer(34962, n.normal), ht.bufferData(34962, t.normalArray, 35048), ct.enableAttribute(i.normal), ht.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (ht.bindBuffer(34962, n.uv), ht.bufferData(34962, t.uvArray, 35048), ct.enableAttribute(i.uv), ht.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), t.hasColors && (ht.bindBuffer(34962, n.color), ht.bufferData(34962, t.colorArray, 35048), ct.enableAttribute(i.color), ht.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), ct.disableUnusedAttributes(), ht.drawArrays(4, 0, t.count), t.count = 0
                    }, this.renderBufferDirect = function(t, e, n, i, r, s) {
                        null === e && (e = H);
                        const o = r.isMesh && r.matrixWorld.determinant() < 0,
                            a = Et(t, e, i, r);
                        W.setMaterial(i, o);
                        let l = n.index;
                        const c = n.attributes.position;
                        if (null === l) { if (void 0 === c || 0 === c.count) return } else if (0 === l.count) return;
                        let h, u = 1;
                        !0 === i.wireframe && (l = J.getWireframeAttribute(n), u = 2), (i.morphTargets || i.morphNormals) && st.update(r, n, i, a), ct.setup(r, i, a, n, l);
                        let d = ot;
                        null !== l && (h = Z.get(l), d = at, d.setIndex(h));
                        const p = null !== l ? l.count : c.count,
                            m = n.drawRange.start * u,
                            f = n.drawRange.count * u,
                            g = null !== s ? s.start * u : 0,
                            v = null !== s ? s.count * u : 1 / 0,
                            y = Math.max(m, g),
                            x = Math.min(p, m + f, g + v) - 1,
                            _ = Math.max(0, x - y + 1);
                        if (0 !== _) {
                            if (r.isMesh) !0 === i.wireframe ? (W.setLineWidth(i.wireframeLinewidth * k()), d.setMode(1)) : d.setMode(4);
                            else if (r.isLine) {
                                let t = i.linewidth;
                                void 0 === t && (t = 1), W.setLineWidth(t * k()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                            } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                            if (r.isInstancedMesh) d.renderInstances(y, _, r.count);
                            else if (n.isInstancedBufferGeometry) {
                                const t = Math.min(n.instanceCount, n._maxInstanceCount);
                                d.renderInstances(y, _, t)
                            } else d.render(y, _)
                        }
                    }, this.compile = function(t, e) {
                        d = et.get(t), d.init(), t.traverseVisible((function(t) { t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t)) })), d.setupLights(), t.traverse((function(e) {
                            const n = e.material;
                            if (n)
                                if (Array.isArray(n))
                                    for (let i = 0; i < n.length; i++) St(n[i], t, e);
                                else St(n, t, e)
                        }))
                    };
                    let vt = null;

                    function yt() { _t.stop() }

                    function xt() { _t.start() }
                    const _t = new Jb;

                    function bt(t, e, n, i) {
                        if (!1 === t.visible) return;
                        if (t.layers.test(e.layers))
                            if (t.isGroup) n = t.renderOrder;
                            else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                        else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
                        else if (t.isSprite) {
                            if (!t.frustumCulled || N.intersectsSprite(t)) {
                                i && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z);
                                const e = K.update(t),
                                    r = t.material;
                                r.visible && u.push(t, e, r, n, U.z, null)
                            }
                        } else if (t.isImmediateRenderObject) i && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z), u.push(t, null, t.material, n, U.z, null);
                        else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== j.render.frame && (t.skeleton.update(), t.skeleton.frame = j.render.frame), !t.frustumCulled || N.intersectsObject(t))) {
                            i && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z);
                            const e = K.update(t),
                                r = t.material;
                            if (Array.isArray(r)) {
                                const i = e.groups;
                                for (let s = 0, o = i.length; s < o; s++) {
                                    const o = i[s],
                                        a = r[o.materialIndex];
                                    a && a.visible && u.push(t, e, a, n, U.z, o)
                                }
                            } else r.visible && u.push(t, e, r, n, U.z, null)
                        }
                        const r = t.children;
                        for (let t = 0, s = r.length; t < s; t++) bt(r[t], e, n, i)
                    }

                    function wt(t, e, n) {
                        const i = !0 === e.isScene ? e.overrideMaterial : null;
                        for (let r = 0, s = t.length; r < s; r++) {
                            const s = t[r],
                                o = s.object,
                                a = s.geometry,
                                l = null === i ? s.material : i,
                                c = s.group;
                            if (n.isArrayCamera) {
                                const t = n.cameras;
                                for (let n = 0, i = t.length; n < i; n++) {
                                    const i = t[n];
                                    o.layers.test(i.layers) && (W.viewport(w.copy(i.viewport)), d.setupLightsView(i), Mt(o, e, i, a, l, c))
                                }
                            } else Mt(o, e, n, a, l, c)
                        }
                    }

                    function Mt(t, e, n, i, r, s) {
                        if (t.onBeforeRender(f, e, n, i, r, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                            const i = Et(n, e, r, t);
                            W.setMaterial(r), ct.reset(),
                                function(t, e) { t.render((function(t) { f.renderBufferImmediate(t, e) })) }(t, i)
                        } else !0 === r.transparent && 2 === r.side ? (r.side = 1, r.needsUpdate = !0, f.renderBufferDirect(n, e, i, r, t, s), r.side = 0, r.needsUpdate = !0, f.renderBufferDirect(n, e, i, r, t, s), r.side = 2) : f.renderBufferDirect(n, e, i, r, t, s);
                        t.onAfterRender(f, e, n, i, r, s)
                    }

                    function St(t, e, n) {
                        !0 !== e.isScene && (e = H);
                        const i = q.get(t),
                            r = d.state.lights,
                            s = d.state.shadowsArray,
                            o = r.state.version,
                            a = Q.getParameters(t, r.state, s, e, n),
                            l = Q.getProgramCacheKey(a);
                        let c = i.programs;
                        i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = Y.get(t.envMap || i.environment), void 0 === c && (t.addEventListener("dispose", gt), c = new Map, i.programs = c);
                        let h = c.get(l);
                        if (void 0 !== h) { if (i.currentProgram === h && i.lightsStateVersion === o) return Tt(t, a), h } else a.uniforms = Q.getUniforms(t), t.onBuild(a, f), t.onBeforeCompile(a, f), h = Q.acquireProgram(a, l), c.set(l, h), i.uniforms = a.uniforms;
                        const u = i.uniforms;
                        (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = nt.uniform), Tt(t, a), i.needsLights = function(t) { return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights }(t), i.lightsStateVersion = o, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
                        const p = h.getUniforms(),
                            m = xM.seqWithValue(p.seq, u);
                        return i.currentProgram = h, i.uniformsList = m, h
                    }

                    function Tt(t, e) {
                        const n = q.get(t);
                        n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.skinning = e.skinning, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas
                    }

                    function Et(t, e, n, i) {
                        !0 !== e.isScene && (e = H), X.resetTextureUnits();
                        const r = e.fog,
                            s = n.isMeshStandardMaterial ? e.environment : null,
                            o = null === x ? f.outputEncoding : x.texture.encoding,
                            a = Y.get(n.envMap || s),
                            l = !0 === n.vertexColors && i.geometry && i.geometry.attributes.color && 4 === i.geometry.attributes.color.itemSize,
                            c = q.get(n),
                            h = d.state.lights;
                        if (!0 === B && (!0 === O || t !== b)) {
                            const e = t === b && n.id === _;
                            nt.setState(n, t, e)
                        }
                        let u = !1;
                        n.version === c.__version ? c.needsLights && c.lightsStateVersion !== h.state.version || c.outputEncoding !== o || i.isInstancedMesh && !1 === c.instancing ? u = !0 : i.isInstancedMesh || !0 !== c.instancing ? i.isSkinnedMesh && !1 === c.skinning ? u = !0 : i.isSkinnedMesh || !0 !== c.skinning ? c.envMap !== a || n.fog && c.fog !== r ? u = !0 : void 0 === c.numClippingPlanes || c.numClippingPlanes === nt.numPlanes && c.numIntersection === nt.numIntersection ? c.vertexAlphas !== l && (u = !0) : u = !0 : u = !0 : u = !0 : (u = !0, c.__version = n.version);
                        let p = c.currentProgram;
                        !0 === u && (p = St(n, e, i));
                        let m = !1,
                            g = !1,
                            v = !1;
                        const y = p.getUniforms(),
                            w = c.uniforms;
                        if (W.useProgram(p.program) && (m = !0, g = !0, v = !0), n.id !== _ && (_ = n.id, g = !0), m || b !== t) {
                            if (y.setValue(ht, "projectionMatrix", t.projectionMatrix), V.logarithmicDepthBuffer && y.setValue(ht, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), b !== t && (b = t, g = !0, v = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                                const e = y.map.cameraPosition;
                                void 0 !== e && e.setValue(ht, U.setFromMatrixPosition(t.matrixWorld))
                            }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && y.setValue(ht, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || i.isSkinnedMesh) && y.setValue(ht, "viewMatrix", t.matrixWorldInverse)
                        }
                        if (i.isSkinnedMesh) {
                            y.setOptional(ht, i, "bindMatrix"), y.setOptional(ht, i, "bindMatrixInverse");
                            const t = i.skeleton;
                            t && (V.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), y.setValue(ht, "boneTexture", t.boneTexture, X), y.setValue(ht, "boneTextureSize", t.boneTextureSize)) : y.setOptional(ht, t, "boneMatrices"))
                        }
                        var M, S;
                        return (g || c.receiveShadow !== i.receiveShadow) && (c.receiveShadow = i.receiveShadow, y.setValue(ht, "receiveShadow", i.receiveShadow)), g && (y.setValue(ht, "toneMappingExposure", f.toneMappingExposure), c.needsLights && (S = v, (M = w).ambientLightColor.needsUpdate = S, M.lightProbe.needsUpdate = S, M.directionalLights.needsUpdate = S, M.directionalLightShadows.needsUpdate = S, M.pointLights.needsUpdate = S, M.pointLightShadows.needsUpdate = S, M.spotLights.needsUpdate = S, M.spotLightShadows.needsUpdate = S, M.rectAreaLights.needsUpdate = S, M.hemisphereLights.needsUpdate = S), r && n.fog && $.refreshFogUniforms(w, r), $.refreshMaterialUniforms(w, n, A, E, F), xM.upload(ht, c.uniformsList, w, X)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (xM.upload(ht, c.uniformsList, w, X), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && y.setValue(ht, "center", i.center), y.setValue(ht, "modelViewMatrix", i.modelViewMatrix), y.setValue(ht, "normalMatrix", i.normalMatrix), y.setValue(ht, "modelMatrix", i.matrixWorld), p
                    }
                    _t.setAnimationLoop((function(t) { vt && vt(t) })), "undefined" != typeof window && _t.setContext(window), this.setAnimationLoop = function(t) { vt = t, pt.setAnimationLoop(t), null === t ? _t.stop() : _t.start() }, pt.addEventListener("sessionstart", yt), pt.addEventListener("sessionend", xt), this.render = function(t, e) {
                        if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                        if (!0 === g) return;
                        !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === pt.enabled && !0 === pt.isPresenting && (!0 === pt.cameraAutoUpdate && pt.updateCamera(e), e = pt.getCamera()), !0 === t.isScene && t.onBeforeRender(f, t, e, x), d = et.get(t, m.length), d.init(), m.push(d), z.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), N.setFromProjectionMatrix(z), O = this.localClippingEnabled, B = nt.init(this.clippingPlanes, O, e), u = tt.get(t, p.length), u.init(), p.push(u), bt(t, e, 0, f.sortObjects), u.finish(), !0 === f.sortObjects && u.sort(L, R), !0 === B && nt.beginShadows();
                        const n = d.state.shadowsArray;
                        it.render(n, t, e), d.setupLights(), d.setupLightsView(e), !0 === B && nt.endShadows(), !0 === this.info.autoReset && this.info.reset(), rt.render(u, t);
                        const i = u.opaque,
                            r = u.transmissive,
                            s = u.transparent;
                        i.length > 0 && wt(i, t, e), r.length > 0 && function(t, e, n, i) {
                            if (null === F) {
                                const t = !0 === o && !0 === V.isWebGL2;
                                F = new(t ? Ex : Tx)(1024, 1024, { generateMipmaps: !0, type: null !== lt.convert(Gy) ? Gy : zy, minFilter: Fy, magFilter: By, wrapS: Dy, wrapT: Dy })
                            }
                            const r = f.getRenderTarget();
                            f.setRenderTarget(F), f.clear();
                            const s = f.toneMapping;
                            f.toneMapping = 0, wt(t, n, i), f.toneMapping = s, X.updateMultisampleRenderTarget(F), X.updateRenderTargetMipmap(F), f.setRenderTarget(r), wt(e, n, i)
                        }(i, r, t, e), s.length > 0 && wt(s, t, e), null !== x && (X.updateMultisampleRenderTarget(x), X.updateRenderTargetMipmap(x)), !0 === t.isScene && t.onAfterRender(f, t, e), W.buffers.depth.setTest(!0), W.buffers.depth.setMask(!0), W.buffers.color.setMask(!0), W.setPolygonOffset(!1), ct.resetDefaultState(), _ = -1, b = null, m.pop(), d = m.length > 0 ? m[m.length - 1] : null, p.pop(), u = p.length > 0 ? p[p.length - 1] : null
                    }, this.getActiveCubeFace = function() { return v }, this.getActiveMipmapLevel = function() { return y }, this.getRenderTarget = function() { return x }, this.setRenderTarget = function(t, e = 0, n = 0) {
                        x = t, v = e, y = n, t && void 0 === q.get(t).__webglFramebuffer && X.setupRenderTarget(t);
                        let i = null,
                            r = !1,
                            s = !1;
                        if (t) {
                            const n = t.texture;
                            (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);
                            const o = q.get(t).__webglFramebuffer;
                            t.isWebGLCubeRenderTarget ? (i = o[e], r = !0) : i = t.isWebGLMultisampleRenderTarget ? q.get(t).__webglMultisampledFramebuffer : o, w.copy(t.viewport), M.copy(t.scissor), S = t.scissorTest
                        } else w.copy(C).multiplyScalar(A).floor(), M.copy(P).multiplyScalar(A).floor(), S = I;
                        if (W.bindFramebuffer(36160, i) && V.drawBuffers) {
                            let e = !1;
                            if (t)
                                if (t.isWebGLMultipleRenderTargets) {
                                    const n = t.texture;
                                    if (D.length !== n.length || 36064 !== D[0]) {
                                        for (let t = 0, e = n.length; t < e; t++) D[t] = 36064 + t;
                                        D.length = n.length, e = !0
                                    }
                                } else 1 === D.length && 36064 === D[0] || (D[0] = 36064, D.length = 1, e = !0);
                            else 1 === D.length && 1029 === D[0] || (D[0] = 1029, D.length = 1, e = !0);
                            e && (V.isWebGL2 ? ht.drawBuffers(D) : G.get("WEBGL_draw_buffers").drawBuffersWEBGL(D))
                        }
                        if (W.viewport(w), W.scissor(M), W.setScissorTest(S), r) {
                            const i = q.get(t.texture);
                            ht.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
                        } else if (s) {
                            const i = q.get(t.texture),
                                r = e || 0;
                            ht.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
                        }
                    }, this.readRenderTargetPixels = function(t, e, n, i, r, s, o) {
                        if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                        let a = q.get(t).__webglFramebuffer;
                        if (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) {
                            W.bindFramebuffer(36160, a);
                            try {
                                const o = t.texture,
                                    a = o.format,
                                    l = o.type;
                                if (a !== jy && lt.convert(a) !== ht.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                const c = l === Gy && (G.has("EXT_color_buffer_half_float") || V.isWebGL2 && G.has("EXT_color_buffer_float"));
                                if (!(l === zy || lt.convert(l) === ht.getParameter(35738) || l === ky && (V.isWebGL2 || G.has("OES_texture_float") || G.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                36053 === ht.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && ht.readPixels(e, n, i, r, lt.convert(a), lt.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            } finally {
                                const t = null !== x ? q.get(x).__webglFramebuffer : null;
                                W.bindFramebuffer(36160, t)
                            }
                        }
                    }, this.copyFramebufferToTexture = function(t, e, n = 0) {
                        const i = Math.pow(2, -n),
                            r = Math.floor(e.image.width * i),
                            s = Math.floor(e.image.height * i);
                        let o = lt.convert(e.format);
                        V.isWebGL2 && (6407 === o && (o = 32849), 6408 === o && (o = 32856)), X.setTexture2D(e, 0), ht.copyTexImage2D(3553, n, o, t.x, t.y, r, s, 0), W.unbindTexture()
                    }, this.copyTextureToTexture = function(t, e, n, i = 0) {
                        const r = e.image.width,
                            s = e.image.height,
                            o = lt.convert(n.format),
                            a = lt.convert(n.type);
                        X.setTexture2D(n, 0), ht.pixelStorei(37440, n.flipY), ht.pixelStorei(37441, n.premultiplyAlpha), ht.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? ht.texSubImage2D(3553, i, t.x, t.y, r, s, o, a, e.image.data) : e.isCompressedTexture ? ht.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : ht.texSubImage2D(3553, i, t.x, t.y, o, a, e.image), 0 === i && n.generateMipmaps && ht.generateMipmap(3553), W.unbindTexture()
                    }, this.copyTextureToTexture3D = function(t, e, n, i, r = 0) {
                        if (f.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                        const s = t.max.x - t.min.x + 1,
                            o = t.max.y - t.min.y + 1,
                            a = t.max.z - t.min.z + 1,
                            l = lt.convert(i.format),
                            c = lt.convert(i.type);
                        let h;
                        if (i.isDataTexture3D) X.setTexture3D(i, 0), h = 32879;
                        else {
                            if (!i.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                            X.setTexture2DArray(i, 0), h = 35866
                        }
                        ht.pixelStorei(37440, i.flipY), ht.pixelStorei(37441, i.premultiplyAlpha), ht.pixelStorei(3317, i.unpackAlignment);
                        const u = ht.getParameter(3314),
                            d = ht.getParameter(32878),
                            p = ht.getParameter(3316),
                            m = ht.getParameter(3315),
                            g = ht.getParameter(32877),
                            v = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                        ht.pixelStorei(3314, v.width), ht.pixelStorei(32878, v.height), ht.pixelStorei(3316, t.min.x), ht.pixelStorei(3315, t.min.y), ht.pixelStorei(32877, t.min.z), n.isDataTexture || n.isDataTexture3D ? ht.texSubImage3D(h, r, e.x, e.y, e.z, s, o, a, l, c, v.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ht.compressedTexSubImage3D(h, r, e.x, e.y, e.z, s, o, a, l, v.data)) : ht.texSubImage3D(h, r, e.x, e.y, e.z, s, o, a, l, c, v), ht.pixelStorei(3314, u), ht.pixelStorei(32878, d), ht.pixelStorei(3316, p), ht.pixelStorei(3315, m), ht.pixelStorei(32877, g), 0 === r && i.generateMipmaps && ht.generateMipmap(h), W.unbindTexture()
                    }, this.initTexture = function(t) { X.setTexture2D(t, 0), W.unbindTexture() }, this.resetState = function() { v = 0, y = 0, x = null, W.reset(), ct.reset() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }))
                }(class extends hS {}).prototype.isWebGL1Renderer = !0;
                class uS {
                    constructor(t, e = 25e-5) { this.name = "", this.color = new J_(t), this.density = e }
                    clone() { return new uS(this.color, this.density) }
                    toJSON() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } }
                }
                uS.prototype.isFogExp2 = !0;
                class dS {
                    constructor(t, e = 1, n = 1e3) { this.name = "", this.color = new J_(t), this.near = e, this.far = n }
                    clone() { return new dS(this.color, this.near, this.far) }
                    toJSON() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } }
                }
                dS.prototype.isFog = !0;
                class pS extends C_ {
                    constructor() { super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) }
                    copy(t, e) { return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this }
                    toJSON(t) { const e = super.toJSON(t); return null !== this.fog && (e.object.fog = this.fog.toJSON()), e }
                }
                pS.prototype.isScene = !0;
                class mS {
                    constructor(t, e) { this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = nx, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = hx() }
                    onUploadCallback() {}
                    set needsUpdate(t) {!0 === t && this.version++ }
                    setUsage(t) { return this.usage = t, this }
                    copy(t) { return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this }
                    copyAt(t, e, n) { t *= this.stride, n *= e.stride; for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i]; return this }
                    set(t, e = 0) { return this.array.set(t, e), this }
                    clone(t) {
                        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = hx()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                        const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                            n = new this.constructor(e, this.stride);
                        return n.setUsage(this.usage), n
                    }
                    onUpload(t) { return this.onUploadCallback = t, this }
                    toJSON(t) { return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = hx()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } }
                }
                mS.prototype.isInterleavedBuffer = !0;
                const fS = new Lx;
                class gS {
                    constructor(t, e, n, i = !1) { this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i }
                    get count() { return this.data.count }
                    get array() { return this.data.array }
                    set needsUpdate(t) { this.data.needsUpdate = t }
                    applyMatrix4(t) { for (let e = 0, n = this.data.count; e < n; e++) fS.x = this.getX(e), fS.y = this.getY(e), fS.z = this.getZ(e), fS.applyMatrix4(t), this.setXYZ(e, fS.x, fS.y, fS.z); return this }
                    applyNormalMatrix(t) { for (let e = 0, n = this.count; e < n; e++) fS.x = this.getX(e), fS.y = this.getY(e), fS.z = this.getZ(e), fS.applyNormalMatrix(t), this.setXYZ(e, fS.x, fS.y, fS.z); return this }
                    transformDirection(t) { for (let e = 0, n = this.count; e < n; e++) fS.x = this.getX(e), fS.y = this.getY(e), fS.z = this.getZ(e), fS.transformDirection(t), this.setXYZ(e, fS.x, fS.y, fS.z); return this }
                    setX(t, e) { return this.data.array[t * this.data.stride + this.offset] = e, this }
                    setY(t, e) { return this.data.array[t * this.data.stride + this.offset + 1] = e, this }
                    setZ(t, e) { return this.data.array[t * this.data.stride + this.offset + 2] = e, this }
                    setW(t, e) { return this.data.array[t * this.data.stride + this.offset + 3] = e, this }
                    getX(t) { return this.data.array[t * this.data.stride + this.offset] }
                    getY(t) { return this.data.array[t * this.data.stride + this.offset + 1] }
                    getZ(t) { return this.data.array[t * this.data.stride + this.offset + 2] }
                    getW(t) { return this.data.array[t * this.data.stride + this.offset + 3] }
                    setXY(t, e, n) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this }
                    setXYZ(t, e, n, i) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this }
                    setXYZW(t, e, n, i, r) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this }
                    clone(t) { if (void 0 === t) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { const n = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e]) } return new tb(new this.array.constructor(t), this.itemSize, this.normalized) } return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new gS(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) }
                    toJSON(t) { if (void 0 === t) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { const n = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized } } return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } }
                }
                gS.prototype.isInterleavedBufferAttribute = !0;
                class vS extends V_ {
                    constructor(t) { super(), this.type = "SpriteMaterial", this.color = new J_(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this }
                }
                let yS;
                vS.prototype.isSpriteMaterial = !0;
                const xS = new Lx,
                    _S = new Lx,
                    bS = new Lx,
                    wS = new vx,
                    MS = new vx,
                    SS = new s_,
                    TS = new Lx,
                    ES = new Lx,
                    AS = new Lx,
                    LS = new vx,
                    RS = new vx,
                    CS = new vx;

                function PS(t, e, n, i, r, s) { wS.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (MS.x = s * wS.x - r * wS.y, MS.y = r * wS.x + s * wS.y) : MS.copy(wS), t.copy(e), t.x += MS.x, t.y += MS.y, t.applyMatrix4(SS) }(class extends C_ {
                    constructor(t) {
                        if (super(), this.type = "Sprite", void 0 === yS) {
                            yS = new db;
                            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                                e = new mS(t, 5);
                            yS.setIndex([0, 1, 2, 0, 2, 3]), yS.setAttribute("position", new gS(e, 3, 0, !1)), yS.setAttribute("uv", new gS(e, 2, 3, !1))
                        }
                        this.geometry = yS, this.material = void 0 !== t ? t : new vS, this.center = new vx(.5, .5)
                    }
                    raycast(t, e) {
                        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), _S.setFromMatrixScale(this.matrixWorld), SS.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), bS.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && _S.multiplyScalar(-bS.z);
                        const n = this.material.rotation;
                        let i, r;
                        0 !== n && (r = Math.cos(n), i = Math.sin(n));
                        const s = this.center;
                        PS(TS.set(-.5, -.5, 0), bS, s, _S, i, r), PS(ES.set(.5, -.5, 0), bS, s, _S, i, r), PS(AS.set(.5, .5, 0), bS, s, _S, i, r), LS.set(0, 0), RS.set(1, 0), CS.set(1, 1);
                        let o = t.ray.intersectTriangle(TS, ES, AS, !1, xS);
                        if (null === o && (PS(ES.set(-.5, .5, 0), bS, s, _S, i, r), RS.set(0, 1), o = t.ray.intersectTriangle(TS, AS, ES, !1, xS), null === o)) return;
                        const a = t.ray.origin.distanceTo(xS);
                        a < t.near || a > t.far || e.push({ distance: a, point: xS.clone(), uv: k_.getUV(xS, TS, ES, AS, LS, RS, CS, new vx), face: null, object: this })
                    }
                    copy(t) { return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this }
                }).prototype.isSprite = !0;
                const IS = new Lx,
                    DS = new Sx,
                    NS = new Sx,
                    BS = new Lx,
                    OS = new s_;
                class FS extends Cb {
                    constructor(t, e) { super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new s_, this.bindMatrixInverse = new s_ }
                    copy(t) { return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this }
                    bind(t, e) { this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert() }
                    pose() { this.skeleton.pose() }
                    normalizeSkinWeights() {
                        const t = new Sx,
                            e = this.geometry.attributes.skinWeight;
                        for (let n = 0, i = e.count; n < i; n++) {
                            t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                            const i = 1 / t.manhattanLength();
                            i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                        }
                    }
                    updateMatrixWorld(t) { super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) }
                    boneTransform(t, e) {
                        const n = this.skeleton,
                            i = this.geometry;
                        DS.fromBufferAttribute(i.attributes.skinIndex, t), NS.fromBufferAttribute(i.attributes.skinWeight, t), IS.fromBufferAttribute(i.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                        for (let t = 0; t < 4; t++) {
                            const i = NS.getComponent(t);
                            if (0 !== i) {
                                const r = DS.getComponent(t);
                                OS.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(BS.copy(IS).applyMatrix4(OS), i)
                            }
                        }
                        return e.applyMatrix4(this.bindMatrixInverse)
                    }
                }
                FS.prototype.isSkinnedMesh = !0;
                (class extends C_ { constructor() { super(), this.type = "Bone" } }).prototype.isBone = !0;
                (class extends wx { constructor(t = null, e = 1, n = 1, i, r, s, o, a, l = 1003, c = 1003, h, u) { super(null, s, o, a, l, c, i, r, h, u), this.image = { data: t, width: e, height: n }, this.magFilter = l, this.minFilter = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } }).prototype.isDataTexture = !0;
                const zS = new s_,
                    US = new s_,
                    HS = [],
                    kS = new Cb;
                (class extends Cb {
                    constructor(t, e, n) { super(t, e), this.instanceMatrix = new tb(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1 }
                    copy(t) { return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this }
                    getColorAt(t, e) { e.fromArray(this.instanceColor.array, 3 * t) }
                    getMatrixAt(t, e) { e.fromArray(this.instanceMatrix.array, 16 * t) }
                    raycast(t, e) {
                        const n = this.matrixWorld,
                            i = this.count;
                        if (kS.geometry = this.geometry, kS.material = this.material, void 0 !== kS.material)
                            for (let r = 0; r < i; r++) {
                                this.getMatrixAt(r, zS), US.multiplyMatrices(n, zS), kS.matrixWorld = US, kS.raycast(t, HS);
                                for (let t = 0, n = HS.length; t < n; t++) {
                                    const n = HS[t];
                                    n.instanceId = r, n.object = this, e.push(n)
                                }
                                HS.length = 0
                            }
                    }
                    setColorAt(t, e) { null === this.instanceColor && (this.instanceColor = new tb(new Float32Array(3 * this.count), 3)), e.toArray(this.instanceColor.array, 3 * t) }
                    setMatrixAt(t, e) { e.toArray(this.instanceMatrix.array, 16 * t) }
                    updateMorphTargets() {}
                    dispose() { this.dispatchEvent({ type: "dispose" }) }
                }).prototype.isInstancedMesh = !0;
                class GS extends V_ {
                    constructor(t) { super(), this.type = "LineBasicMaterial", this.color = new J_(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this }
                }
                GS.prototype.isLineBasicMaterial = !0;
                const VS = new Lx,
                    WS = new Lx,
                    jS = new s_,
                    qS = new r_,
                    XS = new Jx;
                class YS extends C_ {
                    constructor(t = new db, e = new GS) { super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets() }
                    copy(t) { return super.copy(t), this.material = t.material, this.geometry = t.geometry, this }
                    computeLineDistances() {
                        const t = this.geometry;
                        if (t.isBufferGeometry)
                            if (null === t.index) {
                                const e = t.attributes.position,
                                    n = [0];
                                for (let t = 1, i = e.count; t < i; t++) VS.fromBufferAttribute(e, t - 1), WS.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += VS.distanceTo(WS);
                                t.setAttribute("lineDistance", new ib(n, 1))
                            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                        return this
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            i = this.matrixWorld,
                            r = t.params.Line.threshold,
                            s = n.drawRange;
                        if (null === n.boundingSphere && n.computeBoundingSphere(), XS.copy(n.boundingSphere), XS.applyMatrix4(i), XS.radius += r, !1 === t.ray.intersectsSphere(XS)) return;
                        jS.copy(i).invert(), qS.copy(t.ray).applyMatrix4(jS);
                        const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            a = o * o,
                            l = new Lx,
                            c = new Lx,
                            h = new Lx,
                            u = new Lx,
                            d = this.isLineSegments ? 2 : 1;
                        if (n.isBufferGeometry) {
                            const i = n.index,
                                r = n.attributes.position;
                            if (null !== i)
                                for (let n = Math.max(0, s.start), o = Math.min(i.count, s.start + s.count) - 1; n < o; n += d) {
                                    const s = i.getX(n),
                                        o = i.getX(n + 1);
                                    if (l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, o), qS.distanceSqToSegment(l, c, u, h) > a) continue;
                                    u.applyMatrix4(this.matrixWorld);
                                    const d = t.ray.origin.distanceTo(u);
                                    d < t.near || d > t.far || e.push({ distance: d, point: h.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this })
                                } else
                                    for (let n = Math.max(0, s.start), i = Math.min(r.count, s.start + s.count) - 1; n < i; n += d) {
                                        if (l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1), qS.distanceSqToSegment(l, c, u, h) > a) continue;
                                        u.applyMatrix4(this.matrixWorld);
                                        const i = t.ray.origin.distanceTo(u);
                                        i < t.near || i > t.far || e.push({ distance: i, point: h.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this })
                                    }
                        } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                    updateMorphTargets() {
                        const t = this.geometry;
                        if (t.isBufferGeometry) {
                            const e = t.morphAttributes,
                                n = Object.keys(e);
                            if (n.length > 0) {
                                const t = e[n[0]];
                                if (void 0 !== t) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let e = 0, n = t.length; e < n; e++) {
                                        const n = t[e].name || String(e);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                    }
                                }
                            }
                        } else {
                            const e = t.morphTargets;
                            void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                        }
                    }
                }
                YS.prototype.isLine = !0;
                const ZS = new Lx,
                    JS = new Lx;
                class KS extends YS {
                    constructor(t, e) { super(t, e), this.type = "LineSegments" }
                    computeLineDistances() {
                        const t = this.geometry;
                        if (t.isBufferGeometry)
                            if (null === t.index) {
                                const e = t.attributes.position,
                                    n = [];
                                for (let t = 0, i = e.count; t < i; t += 2) ZS.fromBufferAttribute(e, t), JS.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + ZS.distanceTo(JS);
                                t.setAttribute("lineDistance", new ib(n, 1))
                            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                        return this
                    }
                }
                KS.prototype.isLineSegments = !0;
                (class extends YS { constructor(t, e) { super(t, e), this.type = "LineLoop" } }).prototype.isLineLoop = !0;
                class QS extends V_ {
                    constructor(t) { super(), this.type = "PointsMaterial", this.color = new J_(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this }
                }
                QS.prototype.isPointsMaterial = !0;
                const $S = new s_,
                    tT = new r_,
                    eT = new Jx,
                    nT = new Lx;
                class iT extends C_ {
                    constructor(t = new db, e = new QS) { super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets() }
                    copy(t) { return super.copy(t), this.material = t.material, this.geometry = t.geometry, this }
                    raycast(t, e) {
                        const n = this.geometry,
                            i = this.matrixWorld,
                            r = t.params.Points.threshold,
                            s = n.drawRange;
                        if (null === n.boundingSphere && n.computeBoundingSphere(), eT.copy(n.boundingSphere), eT.applyMatrix4(i), eT.radius += r, !1 === t.ray.intersectsSphere(eT)) return;
                        $S.copy(i).invert(), tT.copy(t.ray).applyMatrix4($S);
                        const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            a = o * o;
                        if (n.isBufferGeometry) {
                            const r = n.index,
                                o = n.attributes.position;
                            if (null !== r)
                                for (let n = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); n < l; n++) {
                                    const s = r.getX(n);
                                    nT.fromBufferAttribute(o, s), rT(nT, s, a, i, t, e, this)
                                } else
                                    for (let n = Math.max(0, s.start), r = Math.min(o.count, s.start + s.count); n < r; n++) nT.fromBufferAttribute(o, n), rT(nT, n, a, i, t, e, this)
                        } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                    updateMorphTargets() {
                        const t = this.geometry;
                        if (t.isBufferGeometry) {
                            const e = t.morphAttributes,
                                n = Object.keys(e);
                            if (n.length > 0) {
                                const t = e[n[0]];
                                if (void 0 !== t) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let e = 0, n = t.length; e < n; e++) {
                                        const n = t[e].name || String(e);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                    }
                                }
                            }
                        } else {
                            const e = t.morphTargets;
                            void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                        }
                    }
                }

                function rT(t, e, n, i, r, s, o) {
                    const a = tT.distanceSqToPoint(t);
                    if (a < n) {
                        const n = new Lx;
                        tT.closestPointToPoint(t, n), n.applyMatrix4(i);
                        const l = r.ray.origin.distanceTo(n);
                        if (l < r.near || l > r.far) return;
                        s.push({ distance: l, distanceToRay: Math.sqrt(a), point: n, index: e, face: null, object: o })
                    }
                }
                iT.prototype.isPoints = !0, class extends wx {
                    constructor(t, e, n, i, r, s, o, a, l) { super(t, e, n, i, r, s, o, a, l), this.format = void 0 !== o ? o : Wy, this.minFilter = void 0 !== s ? s : Oy, this.magFilter = void 0 !== r ? r : Oy, this.generateMipmaps = !1; const c = this; "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() { c.needsUpdate = !0, t.requestVideoFrameCallback(e) })) }
                    clone() { return new this.constructor(this.image).copy(this) }
                    update() { const t = this.image;!1 == "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0) }
                }.prototype.isVideoTexture = !0;
                (class extends wx { constructor(t, e, n, i, r, s, o, a, l, c, h, u) { super(null, s, o, a, l, c, i, r, h, u), this.image = { width: e, height: n }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1 } }).prototype.isCompressedTexture = !0, class extends wx { constructor(t, e, n, i, r, s, o, a, l) { super(t, e, n, i, r, s, o, a, l), this.needsUpdate = !0 } }.prototype.isCanvasTexture = !0, class extends wx {
                    constructor(t, e, n, i, r, s, o, a, l, c) {
                        if ((c = void 0 !== c ? c : qy) !== qy && c !== Xy) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                        void 0 === n && c === qy && (n = Uy), void 0 === n && c === Xy && (n = Vy), super(null, i, r, s, o, a, c, n, l), this.image = { width: t, height: e }, this.magFilter = void 0 !== o ? o : By, this.minFilter = void 0 !== a ? a : By, this.flipY = !1, this.generateMipmaps = !1
                    }
                }.prototype.isDepthTexture = !0;
                class sT extends db {
                    constructor(t = 1, e = 1, n = 1, i = 8, r = 1, s = !1, o = 0, a = 2 * Math.PI) {
                        super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: n, radialSegments: i, heightSegments: r, openEnded: s, thetaStart: o, thetaLength: a };
                        const l = this;
                        i = Math.floor(i), r = Math.floor(r);
                        const c = [],
                            h = [],
                            u = [],
                            d = [];
                        let p = 0;
                        const m = [],
                            f = n / 2;
                        let g = 0;

                        function v(n) {
                            const r = p,
                                s = new vx,
                                m = new Lx;
                            let v = 0;
                            const y = !0 === n ? t : e,
                                x = !0 === n ? 1 : -1;
                            for (let t = 1; t <= i; t++) h.push(0, f * x, 0), u.push(0, x, 0), d.push(.5, .5), p++;
                            const _ = p;
                            for (let t = 0; t <= i; t++) {
                                const e = t / i * a + o,
                                    n = Math.cos(e),
                                    r = Math.sin(e);
                                m.x = y * r, m.y = f * x, m.z = y * n, h.push(m.x, m.y, m.z), u.push(0, x, 0), s.x = .5 * n + .5, s.y = .5 * r * x + .5, d.push(s.x, s.y), p++
                            }
                            for (let t = 0; t < i; t++) {
                                const e = r + t,
                                    i = _ + t;
                                !0 === n ? c.push(i, i + 1, e) : c.push(i + 1, i, e), v += 3
                            }
                            l.addGroup(g, v, !0 === n ? 1 : 2), g += v
                        }! function() {
                            const s = new Lx,
                                v = new Lx;
                            let y = 0;
                            const x = (e - t) / n;
                            for (let l = 0; l <= r; l++) {
                                const c = [],
                                    g = l / r,
                                    y = g * (e - t) + t;
                                for (let t = 0; t <= i; t++) {
                                    const e = t / i,
                                        r = e * a + o,
                                        l = Math.sin(r),
                                        m = Math.cos(r);
                                    v.x = y * l, v.y = -g * n + f, v.z = y * m, h.push(v.x, v.y, v.z), s.set(l, x, m).normalize(), u.push(s.x, s.y, s.z), d.push(e, 1 - g), c.push(p++)
                                }
                                m.push(c)
                            }
                            for (let t = 0; t < i; t++)
                                for (let e = 0; e < r; e++) {
                                    const n = m[e][t],
                                        i = m[e + 1][t],
                                        r = m[e + 1][t + 1],
                                        s = m[e][t + 1];
                                    c.push(n, i, s), c.push(i, r, s), y += 6
                                }
                            l.addGroup(g, y, 0), g += y
                        }(), !1 === s && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(c), this.setAttribute("position", new ib(h, 3)), this.setAttribute("normal", new ib(u, 3)), this.setAttribute("uv", new ib(d, 2))
                    }
                    static fromJSON(t) { return new sT(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength) }
                }
                class oT extends sT {
                    constructor(t = 1, e = 1, n = 8, i = 1, r = !1, s = 0, o = 2 * Math.PI) { super(0, t, e, n, i, r, s, o), this.type = "ConeGeometry", this.parameters = { radius: t, height: e, radialSegments: n, heightSegments: i, openEnded: r, thetaStart: s, thetaLength: o } }
                    static fromJSON(t) { return new oT(t.radius, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength) }
                }
                new Lx, new Lx, new Lx, new k_;
                class aT {
                    constructor() { this.type = "Curve", this.arcLengthDivisions = 200 }
                    getPoint() { return console.warn("THREE.Curve: .getPoint() not implemented."), null }
                    getPointAt(t, e) { const n = this.getUtoTmapping(t); return this.getPoint(n, e) }
                    getPoints(t = 5) { const e = []; for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t)); return e }
                    getSpacedPoints(t = 5) { const e = []; for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t)); return e }
                    getLength() { const t = this.getLengths(); return t[t.length - 1] }
                    getLengths(t = this.arcLengthDivisions) {
                        if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                        this.needsUpdate = !1;
                        const e = [];
                        let n, i = this.getPoint(0),
                            r = 0;
                        e.push(0);
                        for (let s = 1; s <= t; s++) n = this.getPoint(s / t), r += n.distanceTo(i), e.push(r), i = n;
                        return this.cacheArcLengths = e, e
                    }
                    updateArcLengths() { this.needsUpdate = !0, this.getLengths() }
                    getUtoTmapping(t, e) {
                        const n = this.getLengths();
                        let i = 0;
                        const r = n.length;
                        let s;
                        s = e || t * n[r - 1];
                        let o, a = 0,
                            l = r - 1;
                        for (; a <= l;)
                            if (i = Math.floor(a + (l - a) / 2), o = n[i] - s, o < 0) a = i + 1;
                            else {
                                if (!(o > 0)) { l = i; break }
                                l = i - 1
                            }
                        if (i = l, n[i] === s) return i / (r - 1);
                        const c = n[i];
                        return (i + (s - c) / (n[i + 1] - c)) / (r - 1)
                    }
                    getTangent(t, e) {
                        const n = 1e-4;
                        let i = t - n,
                            r = t + n;
                        i < 0 && (i = 0), r > 1 && (r = 1);
                        const s = this.getPoint(i),
                            o = this.getPoint(r),
                            a = e || (s.isVector2 ? new vx : new Lx);
                        return a.copy(o).sub(s).normalize(), a
                    }
                    getTangentAt(t, e) { const n = this.getUtoTmapping(t); return this.getTangent(n, e) }
                    computeFrenetFrames(t, e) {
                        const n = new Lx,
                            i = [],
                            r = [],
                            s = [],
                            o = new Lx,
                            a = new s_;
                        for (let e = 0; e <= t; e++) {
                            const n = e / t;
                            i[e] = this.getTangentAt(n, new Lx), i[e].normalize()
                        }
                        r[0] = new Lx, s[0] = new Lx;
                        let l = Number.MAX_VALUE;
                        const c = Math.abs(i[0].x),
                            h = Math.abs(i[0].y),
                            u = Math.abs(i[0].z);
                        c <= l && (l = c, n.set(1, 0, 0)), h <= l && (l = h, n.set(0, 1, 0)), u <= l && n.set(0, 0, 1), o.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], o), s[0].crossVectors(i[0], r[0]);
                        for (let e = 1; e <= t; e++) {
                            if (r[e] = r[e - 1].clone(), s[e] = s[e - 1].clone(), o.crossVectors(i[e - 1], i[e]), o.length() > Number.EPSILON) {
                                o.normalize();
                                const t = Math.acos(ux(i[e - 1].dot(i[e]), -1, 1));
                                r[e].applyMatrix4(a.makeRotationAxis(o, t))
                            }
                            s[e].crossVectors(i[e], r[e])
                        }
                        if (!0 === e) {
                            let e = Math.acos(ux(r[0].dot(r[t]), -1, 1));
                            e /= t, i[0].dot(o.crossVectors(r[0], r[t])) > 0 && (e = -e);
                            for (let n = 1; n <= t; n++) r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)), s[n].crossVectors(i[n], r[n])
                        }
                        return { tangents: i, normals: r, binormals: s }
                    }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { return this.arcLengthDivisions = t.arcLengthDivisions, this }
                    toJSON() { const t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t }
                    fromJSON(t) { return this.arcLengthDivisions = t.arcLengthDivisions, this }
                }
                class lT extends aT {
                    constructor(t = 0, e = 0, n = 1, i = 1, r = 0, s = 2 * Math.PI, o = !1, a = 0) { super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = o, this.aRotation = a }
                    getPoint(t, e) {
                        const n = e || new vx,
                            i = 2 * Math.PI;
                        let r = this.aEndAngle - this.aStartAngle;
                        const s = Math.abs(r) < Number.EPSILON;
                        for (; r < 0;) r += i;
                        for (; r > i;) r -= i;
                        r < Number.EPSILON && (r = s ? 0 : i), !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i);
                        const o = this.aStartAngle + t * r;
                        let a = this.aX + this.xRadius * Math.cos(o),
                            l = this.aY + this.yRadius * Math.sin(o);
                        if (0 !== this.aRotation) {
                            const t = Math.cos(this.aRotation),
                                e = Math.sin(this.aRotation),
                                n = a - this.aX,
                                i = l - this.aY;
                            a = n * t - i * e + this.aX, l = n * e + i * t + this.aY
                        }
                        return n.set(a, l)
                    }
                    copy(t) { return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }
                    toJSON() { const t = super.toJSON(); return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t }
                    fromJSON(t) { return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }
                }
                lT.prototype.isEllipseCurve = !0;
                class cT extends lT { constructor(t, e, n, i, r, s) { super(t, e, n, n, i, r, s), this.type = "ArcCurve" } }

                function hT() {
                    let t = 0,
                        e = 0,
                        n = 0,
                        i = 0;

                    function r(r, s, o, a) { t = r, e = o, n = -3 * r + 3 * s - 2 * o - a, i = 2 * r - 2 * s + o + a }
                    return {
                        initCatmullRom: function(t, e, n, i, s) { r(e, n, s * (n - t), s * (i - e)) },
                        initNonuniformCatmullRom: function(t, e, n, i, s, o, a) {
                            let l = (e - t) / s - (n - t) / (s + o) + (n - e) / o,
                                c = (n - e) / o - (i - e) / (o + a) + (i - n) / a;
                            l *= o, c *= o, r(e, n, l, c)
                        },
                        calc: function(r) { const s = r * r; return t + e * r + n * s + i * (s * r) }
                    }
                }
                cT.prototype.isArcCurve = !0;
                const uT = new Lx,
                    dT = new hT,
                    pT = new hT,
                    mT = new hT;
                class fT extends aT {
                    constructor(t = [], e = !1, n = "centripetal", i = .5) { super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = i }
                    getPoint(t, e = new Lx) {
                        const n = e,
                            i = this.points,
                            r = i.length,
                            s = (r - (this.closed ? 0 : 1)) * t;
                        let o, a, l = Math.floor(s),
                            c = s - l;
                        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? o = i[(l - 1) % r] : (uT.subVectors(i[0], i[1]).add(i[0]), o = uT);
                        const h = i[l % r],
                            u = i[(l + 1) % r];
                        if (this.closed || l + 2 < r ? a = i[(l + 2) % r] : (uT.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), a = uT), "centripetal" === this.curveType || "chordal" === this.curveType) {
                            const t = "chordal" === this.curveType ? .5 : .25;
                            let e = Math.pow(o.distanceToSquared(h), t),
                                n = Math.pow(h.distanceToSquared(u), t),
                                i = Math.pow(u.distanceToSquared(a), t);
                            n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), dT.initNonuniformCatmullRom(o.x, h.x, u.x, a.x, e, n, i), pT.initNonuniformCatmullRom(o.y, h.y, u.y, a.y, e, n, i), mT.initNonuniformCatmullRom(o.z, h.z, u.z, a.z, e, n, i)
                        } else "catmullrom" === this.curveType && (dT.initCatmullRom(o.x, h.x, u.x, a.x, this.tension), pT.initCatmullRom(o.y, h.y, u.y, a.y, this.tension), mT.initCatmullRom(o.z, h.z, u.z, a.z, this.tension));
                        return n.set(dT.calc(c), pT.calc(c), mT.calc(c)), n
                    }
                    copy(t) {
                        super.copy(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push(n.clone())
                        }
                        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.points = [];
                        for (let e = 0, n = this.points.length; e < n; e++) {
                            const n = this.points[e];
                            t.points.push(n.toArray())
                        }
                        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push((new Lx).fromArray(n))
                        }
                        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                    }
                }

                function gT(t, e, n, i, r) {
                    const s = .5 * (i - e),
                        o = .5 * (r - n),
                        a = t * t;
                    return (2 * n - 2 * i + s + o) * (t * a) + (-3 * n + 3 * i - 2 * s - o) * a + s * t + n
                }

                function vT(t, e, n, i) { return function(t, e) { const n = 1 - t; return n * n * e }(t, e) + function(t, e) { return 2 * (1 - t) * t * e }(t, n) + function(t, e) { return t * t * e }(t, i) }

                function yT(t, e, n, i, r) { return function(t, e) { const n = 1 - t; return n * n * n * e }(t, e) + function(t, e) { const n = 1 - t; return 3 * n * n * t * e }(t, n) + function(t, e) { return 3 * (1 - t) * t * t * e }(t, i) + function(t, e) { return t * t * t * e }(t, r) }
                fT.prototype.isCatmullRomCurve3 = !0;
                class xT extends aT {
                    constructor(t = new vx, e = new vx, n = new vx, i = new vx) { super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i }
                    getPoint(t, e = new vx) {
                        const n = e,
                            i = this.v0,
                            r = this.v1,
                            s = this.v2,
                            o = this.v3;
                        return n.set(yT(t, i.x, r.x, s.x, o.x), yT(t, i.y, r.y, s.y, o.y)), n
                    }
                    copy(t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }
                    toJSON() { const t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }
                }
                xT.prototype.isCubicBezierCurve = !0;
                class _T extends aT {
                    constructor(t = new Lx, e = new Lx, n = new Lx, i = new Lx) { super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i }
                    getPoint(t, e = new Lx) {
                        const n = e,
                            i = this.v0,
                            r = this.v1,
                            s = this.v2,
                            o = this.v3;
                        return n.set(yT(t, i.x, r.x, s.x, o.x), yT(t, i.y, r.y, s.y, o.y), yT(t, i.z, r.z, s.z, o.z)), n
                    }
                    copy(t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }
                    toJSON() { const t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }
                }
                _T.prototype.isCubicBezierCurve3 = !0;
                class bT extends aT {
                    constructor(t = new vx, e = new vx) { super(), this.type = "LineCurve", this.v1 = t, this.v2 = e }
                    getPoint(t, e = new vx) { const n = e; return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n }
                    getPointAt(t, e) { return this.getPoint(t, e) }
                    getTangent(t, e) { const n = e || new vx; return n.copy(this.v2).sub(this.v1).normalize(), n }
                    copy(t) { return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }
                    toJSON() { const t = super.toJSON(); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }
                }
                bT.prototype.isLineCurve = !0;
                class wT extends aT {
                    constructor(t = new vx, e = new vx, n = new vx) { super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n }
                    getPoint(t, e = new vx) {
                        const n = e,
                            i = this.v0,
                            r = this.v1,
                            s = this.v2;
                        return n.set(vT(t, i.x, r.x, s.x), vT(t, i.y, r.y, s.y)), n
                    }
                    copy(t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }
                    toJSON() { const t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }
                }
                wT.prototype.isQuadraticBezierCurve = !0;
                class MT extends aT {
                    constructor(t = new Lx, e = new Lx, n = new Lx) { super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n }
                    getPoint(t, e = new Lx) {
                        const n = e,
                            i = this.v0,
                            r = this.v1,
                            s = this.v2;
                        return n.set(vT(t, i.x, r.x, s.x), vT(t, i.y, r.y, s.y), vT(t, i.z, r.z, s.z)), n
                    }
                    copy(t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }
                    toJSON() { const t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }
                }
                MT.prototype.isQuadraticBezierCurve3 = !0;
                class ST extends aT {
                    constructor(t = []) { super(), this.type = "SplineCurve", this.points = t }
                    getPoint(t, e = new vx) {
                        const n = e,
                            i = this.points,
                            r = (i.length - 1) * t,
                            s = Math.floor(r),
                            o = r - s,
                            a = i[0 === s ? s : s - 1],
                            l = i[s],
                            c = i[s > i.length - 2 ? i.length - 1 : s + 1],
                            h = i[s > i.length - 3 ? i.length - 1 : s + 2];
                        return n.set(gT(o, a.x, l.x, c.x, h.x), gT(o, a.y, l.y, c.y, h.y)), n
                    }
                    copy(t) {
                        super.copy(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push(n.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.points = [];
                        for (let e = 0, n = this.points.length; e < n; e++) {
                            const n = this.points[e];
                            t.points.push(n.toArray())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push((new vx).fromArray(n))
                        }
                        return this
                    }
                }
                ST.prototype.isSplineCurve = !0;
                var TT = Object.freeze({
                    __proto__: null,
                    ArcCurve: cT,
                    CatmullRomCurve3: fT,
                    CubicBezierCurve: xT,
                    CubicBezierCurve3: _T,
                    EllipseCurve: lT,
                    LineCurve: bT,
                    LineCurve3: class extends aT {
                        constructor(t = new Lx, e = new Lx) { super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e }
                        getPoint(t, e = new Lx) { const n = e; return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n }
                        getPointAt(t, e) { return this.getPoint(t, e) }
                        copy(t) { return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }
                        toJSON() { const t = super.toJSON(); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }
                        fromJSON(t) { return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }
                    },
                    QuadraticBezierCurve: wT,
                    QuadraticBezierCurve3: MT,
                    SplineCurve: ST
                });

                function ET(t, e, n, i, r) {
                    let s, o;
                    if (r === function(t, e, n, i) { let r = 0; for (let s = e, o = n - i; s < n; s += i) r += (t[o] - t[s]) * (t[s + 1] + t[o + 1]), o = s; return r }(t, e, n, i) > 0)
                        for (s = e; s < n; s += i) o = XT(s, t[s], t[s + 1], o);
                    else
                        for (s = n - i; s >= e; s -= i) o = XT(s, t[s], t[s + 1], o);
                    return o && kT(o, o.next) && (YT(o), o = o.next), o
                }

                function AT(t, e) {
                    if (!t) return t;
                    e || (e = t);
                    let n, i = t;
                    do {
                        if (n = !1, i.steiner || !kT(i, i.next) && 0 !== HT(i.prev, i, i.next)) i = i.next;
                        else {
                            if (YT(i), i = e = i.prev, i === i.next) break;
                            n = !0
                        }
                    } while (n || i !== e);
                    return e
                }

                function LT(t, e, n, i, r, s, o) {
                    if (!t) return;
                    !o && s && function(t, e, n, i) {
                        let r = t;
                        do { null === r.z && (r.z = OT(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next } while (r !== t);
                        r.prevZ.nextZ = null, r.prevZ = null,
                            function(t) {
                                let e, n, i, r, s, o, a, l, c = 1;
                                do {
                                    for (n = t, t = null, s = null, o = 0; n;) {
                                        for (o++, i = n, a = 0, e = 0; e < c && (a++, i = i.nextZ, i); e++);
                                        for (l = c; a > 0 || l > 0 && i;) 0 !== a && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, a--) : (r = i, i = i.nextZ, l--), s ? s.nextZ = r : t = r, r.prevZ = s, s = r;
                                        n = i
                                    }
                                    s.nextZ = null, c *= 2
                                } while (o > 1)
                            }(r)
                    }(t, i, r, s);
                    let a, l, c = t;
                    for (; t.prev !== t.next;)
                        if (a = t.prev, l = t.next, s ? CT(t, i, r, s) : RT(t)) e.push(a.i / n), e.push(t.i / n), e.push(l.i / n), YT(t), t = l.next, c = l.next;
                        else if ((t = l) === c) { o ? 1 === o ? LT(t = PT(AT(t), e, n), e, n, i, r, s, 2) : 2 === o && IT(t, e, n, i, r, s) : LT(AT(t), e, n, i, r, s, 1); break }
                }

                function RT(t) {
                    const e = t.prev,
                        n = t,
                        i = t.next;
                    if (HT(e, n, i) >= 0) return !1;
                    let r = t.next.next;
                    for (; r !== t.prev;) {
                        if (zT(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && HT(r.prev, r, r.next) >= 0) return !1;
                        r = r.next
                    }
                    return !0
                }

                function CT(t, e, n, i) {
                    const r = t.prev,
                        s = t,
                        o = t.next;
                    if (HT(r, s, o) >= 0) return !1;
                    const a = r.x < s.x ? r.x < o.x ? r.x : o.x : s.x < o.x ? s.x : o.x,
                        l = r.y < s.y ? r.y < o.y ? r.y : o.y : s.y < o.y ? s.y : o.y,
                        c = r.x > s.x ? r.x > o.x ? r.x : o.x : s.x > o.x ? s.x : o.x,
                        h = r.y > s.y ? r.y > o.y ? r.y : o.y : s.y > o.y ? s.y : o.y,
                        u = OT(a, l, e, n, i),
                        d = OT(c, h, e, n, i);
                    let p = t.prevZ,
                        m = t.nextZ;
                    for (; p && p.z >= u && m && m.z <= d;) {
                        if (p !== t.prev && p !== t.next && zT(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) && HT(p.prev, p, p.next) >= 0) return !1;
                        if (p = p.prevZ, m !== t.prev && m !== t.next && zT(r.x, r.y, s.x, s.y, o.x, o.y, m.x, m.y) && HT(m.prev, m, m.next) >= 0) return !1;
                        m = m.nextZ
                    }
                    for (; p && p.z >= u;) {
                        if (p !== t.prev && p !== t.next && zT(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) && HT(p.prev, p, p.next) >= 0) return !1;
                        p = p.prevZ
                    }
                    for (; m && m.z <= d;) {
                        if (m !== t.prev && m !== t.next && zT(r.x, r.y, s.x, s.y, o.x, o.y, m.x, m.y) && HT(m.prev, m, m.next) >= 0) return !1;
                        m = m.nextZ
                    }
                    return !0
                }

                function PT(t, e, n) {
                    let i = t;
                    do {
                        const r = i.prev,
                            s = i.next.next;
                        !kT(r, s) && GT(r, i, i.next, s) && jT(r, s) && jT(s, r) && (e.push(r.i / n), e.push(i.i / n), e.push(s.i / n), YT(i), YT(i.next), i = t = s), i = i.next
                    } while (i !== t);
                    return AT(i)
                }

                function IT(t, e, n, i, r, s) {
                    let o = t;
                    do {
                        let t = o.next.next;
                        for (; t !== o.prev;) {
                            if (o.i !== t.i && UT(o, t)) { let a = qT(o, t); return o = AT(o, o.next), a = AT(a, a.next), LT(o, e, n, i, r, s), void LT(a, e, n, i, r, s) }
                            t = t.next
                        }
                        o = o.next
                    } while (o !== t)
                }

                function DT(t, e) { return t.x - e.x }

                function NT(t, e) {
                    if (e = function(t, e) {
                            let n = e;
                            const i = t.x,
                                r = t.y;
                            let s, o = -1 / 0;
                            do {
                                if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                                    const t = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                    if (t <= i && t > o) {
                                        if (o = t, t === i) { if (r === n.y) return n; if (r === n.next.y) return n.next }
                                        s = n.x < n.next.x ? n : n.next
                                    }
                                }
                                n = n.next
                            } while (n !== e);
                            if (!s) return null;
                            if (i === o) return s;
                            const a = s,
                                l = s.x,
                                c = s.y;
                            let h, u = 1 / 0;
                            n = s;
                            do { i >= n.x && n.x >= l && i !== n.x && zT(r < c ? i : o, r, l, c, r < c ? o : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x), jT(n, t) && (h < u || h === u && (n.x > s.x || n.x === s.x && BT(s, n))) && (s = n, u = h)), n = n.next } while (n !== a);
                            return s
                        }(t, e), e) {
                        const n = qT(e, t);
                        AT(e, e.next), AT(n, n.next)
                    }
                }

                function BT(t, e) { return HT(t.prev, t, e.prev) < 0 && HT(e.next, t, t.next) < 0 }

                function OT(t, e, n, i, r) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 }

                function FT(t) {
                    let e = t,
                        n = t;
                    do {
                        (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
                    } while (e !== t);
                    return n
                }

                function zT(t, e, n, i, r, s, o, a) { return (r - o) * (e - a) - (t - o) * (s - a) >= 0 && (t - o) * (i - a) - (n - o) * (e - a) >= 0 && (n - o) * (s - a) - (r - o) * (i - a) >= 0 }

                function UT(t, e) {
                    return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                        let n = t;
                        do {
                            if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && GT(n, n.next, t, e)) return !0;
                            n = n.next
                        } while (n !== t);
                        return !1
                    }(t, e) && (jT(t, e) && jT(e, t) && function(t, e) {
                        let n = t,
                            i = !1;
                        const r = (t.x + e.x) / 2,
                            s = (t.y + e.y) / 2;
                        do { n.y > s != n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next } while (n !== t);
                        return i
                    }(t, e) && (HT(t.prev, t, e.prev) || HT(t, e.prev, e)) || kT(t, e) && HT(t.prev, t, t.next) > 0 && HT(e.prev, e, e.next) > 0)
                }

                function HT(t, e, n) { return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y) }

                function kT(t, e) { return t.x === e.x && t.y === e.y }

                function GT(t, e, n, i) {
                    const r = WT(HT(t, e, n)),
                        s = WT(HT(t, e, i)),
                        o = WT(HT(n, i, t)),
                        a = WT(HT(n, i, e));
                    return r !== s && o !== a || !(0 !== r || !VT(t, n, e)) || !(0 !== s || !VT(t, i, e)) || !(0 !== o || !VT(n, t, i)) || !(0 !== a || !VT(n, e, i))
                }

                function VT(t, e, n) { return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y) }

                function WT(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 }

                function jT(t, e) { return HT(t.prev, t, t.next) < 0 ? HT(t, e, t.next) >= 0 && HT(t, t.prev, e) >= 0 : HT(t, e, t.prev) < 0 || HT(t, t.next, e) < 0 }

                function qT(t, e) {
                    const n = new ZT(t.i, t.x, t.y),
                        i = new ZT(e.i, e.x, e.y),
                        r = t.next,
                        s = e.prev;
                    return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, s.next = i, i.prev = s, i
                }

                function XT(t, e, n, i) { const r = new ZT(t, e, n); return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r }

                function YT(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) }

                function ZT(t, e, n) { this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 }
                class JT {
                    static area(t) { const e = t.length; let n = 0; for (let i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y; return .5 * n }
                    static isClockWise(t) { return JT.area(t) < 0 }
                    static triangulateShape(t, e) {
                        const n = [],
                            i = [],
                            r = [];
                        KT(t), QT(n, t);
                        let s = t.length;
                        e.forEach(KT);
                        for (let t = 0; t < e.length; t++) i.push(s), s += e[t].length, QT(n, e[t]);
                        const o = function(t, e, n = 2) {
                            const i = e && e.length,
                                r = i ? e[0] * n : t.length;
                            let s = ET(t, 0, r, n, !0);
                            const o = [];
                            if (!s || s.next === s.prev) return o;
                            let a, l, c, h, u, d, p;
                            if (i && (s = function(t, e, n, i) { const r = []; let s, o, a, l, c; for (s = 0, o = e.length; s < o; s++) a = e[s] * i, l = s < o - 1 ? e[s + 1] * i : t.length, c = ET(t, a, l, i, !1), c === c.next && (c.steiner = !0), r.push(FT(c)); for (r.sort(DT), s = 0; s < r.length; s++) NT(r[s], n), n = AT(n, n.next); return n }(t, e, s, n)), t.length > 80 * n) {
                                a = c = t[0], l = h = t[1];
                                for (let e = n; e < r; e += n) u = t[e], d = t[e + 1], u < a && (a = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
                                p = Math.max(c - a, h - l), p = 0 !== p ? 1 / p : 0
                            }
                            return LT(s, o, n, a, l, p), o
                        }(n, i);
                        for (let t = 0; t < o.length; t += 3) r.push(o.slice(t, t + 3));
                        return r
                    }
                }

                function KT(t) {
                    const e = t.length;
                    e > 2 && t[e - 1].equals(t[0]) && t.pop()
                }

                function QT(t, e) { for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y) }
                class $T extends db {
                    constructor(t, e) {
                        super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: t, options: e }, t = Array.isArray(t) ? t : [t];
                        const n = this,
                            i = [],
                            r = [];
                        for (let e = 0, n = t.length; e < n; e++) s(t[e]);

                        function s(t) {
                            const s = [],
                                o = void 0 !== e.curveSegments ? e.curveSegments : 12,
                                a = void 0 !== e.steps ? e.steps : 1;
                            let l = void 0 !== e.depth ? e.depth : 100,
                                c = void 0 === e.bevelEnabled || e.bevelEnabled,
                                h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                                u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
                                d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                                p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                            const m = e.extrudePath,
                                f = void 0 !== e.UVGenerator ? e.UVGenerator : tE;
                            void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);
                            let g, v, y, x, _, b = !1;
                            m && (g = m.getSpacedPoints(a), b = !0, c = !1, v = m.computeFrenetFrames(a, !1), y = new Lx, x = new Lx, _ = new Lx), c || (p = 0, h = 0, u = 0, d = 0);
                            const w = t.extractPoints(o);
                            let M = w.shape;
                            const S = w.holes;
                            if (!JT.isClockWise(M)) {
                                M = M.reverse();
                                for (let t = 0, e = S.length; t < e; t++) {
                                    const e = S[t];
                                    JT.isClockWise(e) && (S[t] = e.reverse())
                                }
                            }
                            const T = JT.triangulateShape(M, S),
                                E = M;
                            for (let t = 0, e = S.length; t < e; t++) {
                                const e = S[t];
                                M = M.concat(e)
                            }

                            function A(t, e, n) { return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t) }
                            const L = M.length,
                                R = T.length;

                            function C(t, e, n) {
                                let i, r, s;
                                const o = t.x - e.x,
                                    a = t.y - e.y,
                                    l = n.x - t.x,
                                    c = n.y - t.y,
                                    h = o * o + a * a,
                                    u = o * c - a * l;
                                if (Math.abs(u) > Number.EPSILON) {
                                    const u = Math.sqrt(h),
                                        d = Math.sqrt(l * l + c * c),
                                        p = e.x - a / u,
                                        m = e.y + o / u,
                                        f = ((n.x - c / d - p) * c - (n.y + l / d - m) * l) / (o * c - a * l);
                                    i = p + o * f - t.x, r = m + a * f - t.y;
                                    const g = i * i + r * r;
                                    if (g <= 2) return new vx(i, r);
                                    s = Math.sqrt(g / 2)
                                } else {
                                    let t = !1;
                                    o > Number.EPSILON ? l > Number.EPSILON && (t = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(c) && (t = !0), t ? (i = -a, r = o, s = Math.sqrt(h)) : (i = o, r = a, s = Math.sqrt(h / 2))
                                }
                                return new vx(i / s, r / s)
                            }
                            const P = [];
                            for (let t = 0, e = E.length, n = e - 1, i = t + 1; t < e; t++, n++, i++) n === e && (n = 0), i === e && (i = 0), P[t] = C(E[t], E[n], E[i]);
                            const I = [];
                            let D, N = P.concat();
                            for (let t = 0, e = S.length; t < e; t++) {
                                const e = S[t];
                                D = [];
                                for (let t = 0, n = e.length, i = n - 1, r = t + 1; t < n; t++, i++, r++) i === n && (i = 0), r === n && (r = 0), D[t] = C(e[t], e[i], e[r]);
                                I.push(D), N = N.concat(D)
                            }
                            for (let t = 0; t < p; t++) {
                                const e = t / p,
                                    n = h * Math.cos(e * Math.PI / 2),
                                    i = u * Math.sin(e * Math.PI / 2) + d;
                                for (let t = 0, e = E.length; t < e; t++) {
                                    const e = A(E[t], P[t], i);
                                    F(e.x, e.y, -n)
                                }
                                for (let t = 0, e = S.length; t < e; t++) {
                                    const e = S[t];
                                    D = I[t];
                                    for (let t = 0, r = e.length; t < r; t++) {
                                        const r = A(e[t], D[t], i);
                                        F(r.x, r.y, -n)
                                    }
                                }
                            }
                            const B = u + d;
                            for (let t = 0; t < L; t++) {
                                const e = c ? A(M[t], N[t], B) : M[t];
                                b ? (x.copy(v.normals[0]).multiplyScalar(e.x), y.copy(v.binormals[0]).multiplyScalar(e.y), _.copy(g[0]).add(x).add(y), F(_.x, _.y, _.z)) : F(e.x, e.y, 0)
                            }
                            for (let t = 1; t <= a; t++)
                                for (let e = 0; e < L; e++) {
                                    const n = c ? A(M[e], N[e], B) : M[e];
                                    b ? (x.copy(v.normals[t]).multiplyScalar(n.x), y.copy(v.binormals[t]).multiplyScalar(n.y), _.copy(g[t]).add(x).add(y), F(_.x, _.y, _.z)) : F(n.x, n.y, l / a * t)
                                }
                            for (let t = p - 1; t >= 0; t--) {
                                const e = t / p,
                                    n = h * Math.cos(e * Math.PI / 2),
                                    i = u * Math.sin(e * Math.PI / 2) + d;
                                for (let t = 0, e = E.length; t < e; t++) {
                                    const e = A(E[t], P[t], i);
                                    F(e.x, e.y, l + n)
                                }
                                for (let t = 0, e = S.length; t < e; t++) {
                                    const e = S[t];
                                    D = I[t];
                                    for (let t = 0, r = e.length; t < r; t++) {
                                        const r = A(e[t], D[t], i);
                                        b ? F(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : F(r.x, r.y, l + n)
                                    }
                                }
                            }

                            function O(t, e) {
                                let n = t.length;
                                for (; --n >= 0;) {
                                    const i = n;
                                    let r = n - 1;
                                    r < 0 && (r = t.length - 1);
                                    for (let t = 0, n = a + 2 * p; t < n; t++) {
                                        const n = L * t,
                                            s = L * (t + 1);
                                        U(e + i + n, e + r + n, e + r + s, e + i + s)
                                    }
                                }
                            }

                            function F(t, e, n) { s.push(t), s.push(e), s.push(n) }

                            function z(t, e, r) {
                                H(t), H(e), H(r);
                                const s = i.length / 3,
                                    o = f.generateTopUV(n, i, s - 3, s - 2, s - 1);
                                k(o[0]), k(o[1]), k(o[2])
                            }

                            function U(t, e, r, s) {
                                H(t), H(e), H(s), H(e), H(r), H(s);
                                const o = i.length / 3,
                                    a = f.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1);
                                k(a[0]), k(a[1]), k(a[3]), k(a[1]), k(a[2]), k(a[3])
                            }

                            function H(t) { i.push(s[3 * t + 0]), i.push(s[3 * t + 1]), i.push(s[3 * t + 2]) }

                            function k(t) { r.push(t.x), r.push(t.y) }! function() {
                                const t = i.length / 3;
                                if (c) {
                                    let t = 0,
                                        e = L * t;
                                    for (let t = 0; t < R; t++) {
                                        const n = T[t];
                                        z(n[2] + e, n[1] + e, n[0] + e)
                                    }
                                    t = a + 2 * p, e = L * t;
                                    for (let t = 0; t < R; t++) {
                                        const n = T[t];
                                        z(n[0] + e, n[1] + e, n[2] + e)
                                    }
                                } else {
                                    for (let t = 0; t < R; t++) {
                                        const e = T[t];
                                        z(e[2], e[1], e[0])
                                    }
                                    for (let t = 0; t < R; t++) {
                                        const e = T[t];
                                        z(e[0] + L * a, e[1] + L * a, e[2] + L * a)
                                    }
                                }
                                n.addGroup(t, i.length / 3 - t, 0)
                            }(),
                            function() {
                                const t = i.length / 3;
                                let e = 0;
                                O(E, e), e += E.length;
                                for (let t = 0, n = S.length; t < n; t++) {
                                    const n = S[t];
                                    O(n, e), e += n.length
                                }
                                n.addGroup(t, i.length / 3 - t, 1)
                            }()
                        }
                        this.setAttribute("position", new ib(i, 3)), this.setAttribute("uv", new ib(r, 2)), this.computeVertexNormals()
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return function(t, e, n) {
                            if (n.shapes = [], Array.isArray(t))
                                for (let e = 0, i = t.length; e < i; e++) {
                                    const i = t[e];
                                    n.shapes.push(i.uuid)
                                } else n.shapes.push(t.uuid);
                            return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
                        }(this.parameters.shapes, this.parameters.options, t)
                    }
                    static fromJSON(t, e) {
                        const n = [];
                        for (let i = 0, r = t.shapes.length; i < r; i++) {
                            const r = e[t.shapes[i]];
                            n.push(r)
                        }
                        const i = t.options.extrudePath;
                        return void 0 !== i && (t.options.extrudePath = (new TT[i.type]).fromJSON(i)), new $T(n, t.options)
                    }
                }
                const tE = {
                    generateTopUV: function(t, e, n, i, r) {
                        const s = e[3 * n],
                            o = e[3 * n + 1],
                            a = e[3 * i],
                            l = e[3 * i + 1],
                            c = e[3 * r],
                            h = e[3 * r + 1];
                        return [new vx(s, o), new vx(a, l), new vx(c, h)]
                    },
                    generateSideWallUV: function(t, e, n, i, r, s) {
                        const o = e[3 * n],
                            a = e[3 * n + 1],
                            l = e[3 * n + 2],
                            c = e[3 * i],
                            h = e[3 * i + 1],
                            u = e[3 * i + 2],
                            d = e[3 * r],
                            p = e[3 * r + 1],
                            m = e[3 * r + 2],
                            f = e[3 * s],
                            g = e[3 * s + 1],
                            v = e[3 * s + 2];
                        return Math.abs(a - h) < Math.abs(o - c) ? [new vx(o, 1 - l), new vx(c, 1 - u), new vx(d, 1 - m), new vx(f, 1 - v)] : [new vx(a, 1 - l), new vx(h, 1 - u), new vx(p, 1 - m), new vx(g, 1 - v)]
                    }
                };
                class eE extends db {
                    constructor(t, e = 12) {
                        super(), this.type = "ShapeGeometry", this.parameters = { shapes: t, curveSegments: e };
                        const n = [],
                            i = [],
                            r = [],
                            s = [];
                        let o = 0,
                            a = 0;
                        if (!1 === Array.isArray(t)) l(t);
                        else
                            for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(o, a, e), o += a, a = 0;

                        function l(t) {
                            const o = i.length / 3,
                                l = t.extractPoints(e);
                            let c = l.shape;
                            const h = l.holes;
                            !1 === JT.isClockWise(c) && (c = c.reverse());
                            for (let t = 0, e = h.length; t < e; t++) { const e = h[t];!0 === JT.isClockWise(e) && (h[t] = e.reverse()) }
                            const u = JT.triangulateShape(c, h);
                            for (let t = 0, e = h.length; t < e; t++) {
                                const e = h[t];
                                c = c.concat(e)
                            }
                            for (let t = 0, e = c.length; t < e; t++) {
                                const e = c[t];
                                i.push(e.x, e.y, 0), r.push(0, 0, 1), s.push(e.x, e.y)
                            }
                            for (let t = 0, e = u.length; t < e; t++) {
                                const e = u[t],
                                    i = e[0] + o,
                                    r = e[1] + o,
                                    s = e[2] + o;
                                n.push(i, r, s), a += 3
                            }
                        }
                        this.setIndex(n), this.setAttribute("position", new ib(i, 3)), this.setAttribute("normal", new ib(r, 3)), this.setAttribute("uv", new ib(s, 2))
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return function(t, e) {
                            if (e.shapes = [], Array.isArray(t))
                                for (let n = 0, i = t.length; n < i; n++) {
                                    const i = t[n];
                                    e.shapes.push(i.uuid)
                                } else e.shapes.push(t.uuid);
                            return e
                        }(this.parameters.shapes, t)
                    }
                    static fromJSON(t, e) {
                        const n = [];
                        for (let i = 0, r = t.shapes.length; i < r; i++) {
                            const r = e[t.shapes[i]];
                            n.push(r)
                        }
                        return new eE(n, t.curveSegments)
                    }
                }
                class nE extends db {
                    constructor(t = 1, e = 8, n = 6, i = 0, r = 2 * Math.PI, s = 0, o = Math.PI) {
                        super(), this.type = "SphereGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: i, phiLength: r, thetaStart: s, thetaLength: o }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n));
                        const a = Math.min(s + o, Math.PI);
                        let l = 0;
                        const c = [],
                            h = new Lx,
                            u = new Lx,
                            d = [],
                            p = [],
                            m = [],
                            f = [];
                        for (let d = 0; d <= n; d++) {
                            const g = [],
                                v = d / n;
                            let y = 0;
                            0 == d && 0 == s ? y = .5 / e : d == n && a == Math.PI && (y = -.5 / e);
                            for (let n = 0; n <= e; n++) {
                                const a = n / e;
                                h.x = -t * Math.cos(i + a * r) * Math.sin(s + v * o), h.y = t * Math.cos(s + v * o), h.z = t * Math.sin(i + a * r) * Math.sin(s + v * o), p.push(h.x, h.y, h.z), u.copy(h).normalize(), m.push(u.x, u.y, u.z), f.push(a + y, 1 - v), g.push(l++)
                            }
                            c.push(g)
                        }
                        for (let t = 0; t < n; t++)
                            for (let i = 0; i < e; i++) {
                                const e = c[t][i + 1],
                                    r = c[t][i],
                                    o = c[t + 1][i],
                                    l = c[t + 1][i + 1];
                                (0 !== t || s > 0) && d.push(e, r, l), (t !== n - 1 || a < Math.PI) && d.push(r, o, l)
                            }
                        this.setIndex(d), this.setAttribute("position", new ib(p, 3)), this.setAttribute("normal", new ib(m, 3)), this.setAttribute("uv", new ib(f, 2))
                    }
                    static fromJSON(t) { return new nE(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength) }
                }
                class iE extends db {
                    constructor(t = 1, e = .4, n = 8, i = 6, r = 2 * Math.PI) {
                        super(), this.type = "TorusGeometry", this.parameters = { radius: t, tube: e, radialSegments: n, tubularSegments: i, arc: r }, n = Math.floor(n), i = Math.floor(i);
                        const s = [],
                            o = [],
                            a = [],
                            l = [],
                            c = new Lx,
                            h = new Lx,
                            u = new Lx;
                        for (let s = 0; s <= n; s++)
                            for (let d = 0; d <= i; d++) {
                                const p = d / i * r,
                                    m = s / n * Math.PI * 2;
                                h.x = (t + e * Math.cos(m)) * Math.cos(p), h.y = (t + e * Math.cos(m)) * Math.sin(p), h.z = e * Math.sin(m), o.push(h.x, h.y, h.z), c.x = t * Math.cos(p), c.y = t * Math.sin(p), u.subVectors(h, c).normalize(), a.push(u.x, u.y, u.z), l.push(d / i), l.push(s / n)
                            }
                        for (let t = 1; t <= n; t++)
                            for (let e = 1; e <= i; e++) {
                                const n = (i + 1) * t + e - 1,
                                    r = (i + 1) * (t - 1) + e - 1,
                                    o = (i + 1) * (t - 1) + e,
                                    a = (i + 1) * t + e;
                                s.push(n, r, a), s.push(r, o, a)
                            }
                        this.setIndex(s), this.setAttribute("position", new ib(o, 3)), this.setAttribute("normal", new ib(a, 3)), this.setAttribute("uv", new ib(l, 2))
                    }
                    static fromJSON(t) { return new iE(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc) }
                }(class extends V_ {
                    constructor(t) { super(), this.type = "ShadowMaterial", this.color = new J_(0), this.transparent = !0, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this }
                }).prototype.isShadowMaterial = !0;
                (class extends Ob { constructor(t) { super(t), this.type = "RawShaderMaterial" } }).prototype.isRawShaderMaterial = !0;
                class rE extends V_ {
                    constructor(t) { super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new J_(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new J_(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new vx(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.vertexTangents = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this.vertexTangents = t.vertexTangents, this }
                }
                rE.prototype.isMeshStandardMaterial = !0;
                class sE extends rE {
                    constructor(t) { super(), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new vx(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", { get: function() { return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity) }, set: function(t) { this.reflectivity = ux(2.5 * (t - 1) / (t + 1), 0, 1) } }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.thickness = .01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new J_(1, 1, 1), this.setValues(t) }
                    copy(t) { return super.copy(t), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new J_).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this }
                }
                sE.prototype.isMeshPhysicalMaterial = !0;
                class oE extends V_ {
                    constructor(t) { super(), this.type = "MeshPhongMaterial", this.color = new J_(16777215), this.specular = new J_(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new J_(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new vx(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this }
                }
                oE.prototype.isMeshPhongMaterial = !0;
                class aE extends V_ {
                    constructor(t) { super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new J_(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new J_(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new vx(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }
                }
                aE.prototype.isMeshToonMaterial = !0;
                class lE extends V_ {
                    constructor(t) { super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new vx(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this }
                }
                lE.prototype.isMeshNormalMaterial = !0;
                class cE extends V_ {
                    constructor(t) { super(), this.type = "MeshLambertMaterial", this.color = new J_(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new J_(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }
                }
                cE.prototype.isMeshLambertMaterial = !0;
                (class extends V_ {
                    constructor(t) { super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new J_(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new vx(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this }
                }).prototype.isMeshMatcapMaterial = !0;
                (class extends GS {
                    constructor(t) { super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this }
                }).prototype.isLineDashedMaterial = !0;
                const hE = {
                    arraySlice: function(t, e, n) { return hE.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n) },
                    convertArray: function(t, e, n) { return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t) },
                    isTypedArray: function(t) { return ArrayBuffer.isView(t) && !(t instanceof DataView) },
                    getKeyframeOrder: function(t) {
                        const e = t.length,
                            n = new Array(e);
                        for (let t = 0; t !== e; ++t) n[t] = t;
                        return n.sort((function(e, n) { return t[e] - t[n] })), n
                    },
                    sortedArray: function(t, e, n) {
                        const i = t.length,
                            r = new t.constructor(i);
                        for (let s = 0, o = 0; o !== i; ++s) { const i = n[s] * e; for (let n = 0; n !== e; ++n) r[o++] = t[i + n] }
                        return r
                    },
                    flattenJSON: function(t, e, n, i) {
                        let r = 1,
                            s = t[0];
                        for (; void 0 !== s && void 0 === s[i];) s = t[r++];
                        if (void 0 === s) return;
                        let o = s[i];
                        if (void 0 !== o)
                            if (Array.isArray(o))
                                do { o = s[i], void 0 !== o && (e.push(s.time), n.push.apply(n, o)), s = t[r++] } while (void 0 !== s);
                            else if (void 0 !== o.toArray)
                            do { o = s[i], void 0 !== o && (e.push(s.time), o.toArray(n, n.length)), s = t[r++] } while (void 0 !== s);
                        else
                            do { o = s[i], void 0 !== o && (e.push(s.time), n.push(o)), s = t[r++] } while (void 0 !== s)
                    },
                    subclip: function(t, e, n, i, r = 30) {
                        const s = t.clone();
                        s.name = e;
                        const o = [];
                        for (let t = 0; t < s.tracks.length; ++t) {
                            const e = s.tracks[t],
                                a = e.getValueSize(),
                                l = [],
                                c = [];
                            for (let t = 0; t < e.times.length; ++t) { const s = e.times[t] * r; if (!(s < n || s >= i)) { l.push(e.times[t]); for (let n = 0; n < a; ++n) c.push(e.values[t * a + n]) } }
                            0 !== l.length && (e.times = hE.convertArray(l, e.times.constructor), e.values = hE.convertArray(c, e.values.constructor), o.push(e))
                        }
                        s.tracks = o;
                        let a = 1 / 0;
                        for (let t = 0; t < s.tracks.length; ++t) a > s.tracks[t].times[0] && (a = s.tracks[t].times[0]);
                        for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * a);
                        return s.resetDuration(), s
                    },
                    makeClipAdditive: function(t, e = 0, n = t, i = 30) {
                        i <= 0 && (i = 30);
                        const r = n.tracks.length,
                            s = e / i;
                        for (let e = 0; e < r; ++e) {
                            const i = n.tracks[e],
                                r = i.ValueTypeName;
                            if ("bool" === r || "string" === r) continue;
                            const o = t.tracks.find((function(t) { return t.name === i.name && t.ValueTypeName === r }));
                            if (void 0 === o) continue;
                            let a = 0;
                            const l = i.getValueSize();
                            i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
                            let c = 0;
                            const h = o.getValueSize();
                            o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
                            const u = i.times.length - 1;
                            let d;
                            if (s <= i.times[0]) {
                                const t = a,
                                    e = l - a;
                                d = hE.arraySlice(i.values, t, e)
                            } else if (s >= i.times[u]) {
                                const t = u * l + a,
                                    e = t + l - a;
                                d = hE.arraySlice(i.values, t, e)
                            } else {
                                const t = i.createInterpolant(),
                                    e = a,
                                    n = l - a;
                                t.evaluate(s), d = hE.arraySlice(t.resultBuffer, e, n)
                            }
                            "quaternion" === r && (new Ax).fromArray(d).normalize().conjugate().toArray(d);
                            const p = o.times.length;
                            for (let t = 0; t < p; ++t) {
                                const e = t * h + c;
                                if ("quaternion" === r) Ax.multiplyQuaternionsFlat(o.values, e, d, 0, o.values, e);
                                else { const t = h - 2 * c; for (let n = 0; n < t; ++n) o.values[e + n] -= d[n] }
                            }
                        }
                        return t.blendMode = 2501, t
                    }
                };
                class uE {
                    constructor(t, e, n, i) { this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {} }
                    evaluate(t) {
                        const e = this.parameterPositions;
                        let n = this._cachedIndex,
                            i = e[n],
                            r = e[n - 1];
                        t: {
                            e: {
                                let s;n: {
                                    i: if (!(t < i)) {
                                        for (let s = n + 2;;) { if (void 0 === i) { if (t < r) break i; return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r) } if (n === s) break; if (r = i, i = e[++n], t < i) break e }
                                        s = e.length;
                                        break n
                                    }if (t >= r) break t; {
                                        const o = e[1];
                                        t < o && (n = 2, r = o);
                                        for (let s = n - 2;;) { if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i); if (n === s) break; if (i = r, r = e[--n - 1], t >= r) break e }
                                        s = n, n = 0
                                    }
                                }
                                for (; n < s;) {
                                    const i = n + s >>> 1;
                                    t < e[i] ? s = i : n = i + 1
                                }
                                if (i = e[n], r = e[n - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                                if (void 0 === i) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, t)
                            }
                            this._cachedIndex = n,
                            this.intervalChanged_(n, r, i)
                        }
                        return this.interpolate_(n, r, t, i)
                    }
                    getSettings_() { return this.settings || this.DefaultSettings_ }
                    copySampleValue_(t) {
                        const e = this.resultBuffer,
                            n = this.sampleValues,
                            i = this.valueSize,
                            r = t * i;
                        for (let t = 0; t !== i; ++t) e[t] = n[r + t];
                        return e
                    }
                    interpolate_() { throw new Error("call to abstract method") }
                    intervalChanged_() {}
                }
                uE.prototype.beforeStart_ = uE.prototype.copySampleValue_, uE.prototype.afterEnd_ = uE.prototype.copySampleValue_;
                class dE extends uE {
                    constructor(t, e, n, i) { super(t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: Ky, endingEnd: Ky } }
                    intervalChanged_(t, e, n) {
                        const i = this.parameterPositions;
                        let r = t - 2,
                            s = t + 1,
                            o = i[r],
                            a = i[s];
                        if (void 0 === o) switch (this.getSettings_().endingStart) {
                            case Qy:
                                r = t, o = 2 * e - n;
                                break;
                            case $y:
                                r = i.length - 2, o = e + i[r] - i[r + 1];
                                break;
                            default:
                                r = t, o = n
                        }
                        if (void 0 === a) switch (this.getSettings_().endingEnd) {
                            case Qy:
                                s = t, a = 2 * n - e;
                                break;
                            case $y:
                                s = 1, a = n + i[1] - i[0];
                                break;
                            default:
                                s = t - 1, a = e
                        }
                        const l = .5 * (n - e),
                            c = this.valueSize;
                        this._weightPrev = l / (e - o), this._weightNext = l / (a - n), this._offsetPrev = r * c, this._offsetNext = s * c
                    }
                    interpolate_(t, e, n, i) {
                        const r = this.resultBuffer,
                            s = this.sampleValues,
                            o = this.valueSize,
                            a = t * o,
                            l = a - o,
                            c = this._offsetPrev,
                            h = this._offsetNext,
                            u = this._weightPrev,
                            d = this._weightNext,
                            p = (n - e) / (i - e),
                            m = p * p,
                            f = m * p,
                            g = -u * f + 2 * u * m - u * p,
                            v = (1 + u) * f + (-1.5 - 2 * u) * m + (-.5 + u) * p + 1,
                            y = (-1 - d) * f + (1.5 + d) * m + .5 * p,
                            x = d * f - d * m;
                        for (let t = 0; t !== o; ++t) r[t] = g * s[c + t] + v * s[l + t] + y * s[a + t] + x * s[h + t];
                        return r
                    }
                }
                class pE extends uE {
                    constructor(t, e, n, i) { super(t, e, n, i) }
                    interpolate_(t, e, n, i) {
                        const r = this.resultBuffer,
                            s = this.sampleValues,
                            o = this.valueSize,
                            a = t * o,
                            l = a - o,
                            c = (n - e) / (i - e),
                            h = 1 - c;
                        for (let t = 0; t !== o; ++t) r[t] = s[l + t] * h + s[a + t] * c;
                        return r
                    }
                }
                class mE extends uE {
                    constructor(t, e, n, i) { super(t, e, n, i) }
                    interpolate_(t) { return this.copySampleValue_(t - 1) }
                }
                class fE {
                    constructor(t, e, n, i) {
                        if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                        if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                        this.name = t, this.times = hE.convertArray(e, this.TimeBufferType), this.values = hE.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
                    }
                    static toJSON(t) {
                        const e = t.constructor;
                        let n;
                        if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                        else {
                            n = { name: t.name, times: hE.convertArray(t.times, Array), values: hE.convertArray(t.values, Array) };
                            const e = t.getInterpolation();
                            e !== t.DefaultInterpolation && (n.interpolation = e)
                        }
                        return n.type = t.ValueTypeName, n
                    }
                    InterpolantFactoryMethodDiscrete(t) { return new mE(this.times, this.values, this.getValueSize(), t) }
                    InterpolantFactoryMethodLinear(t) { return new pE(this.times, this.values, this.getValueSize(), t) }
                    InterpolantFactoryMethodSmooth(t) { return new dE(this.times, this.values, this.getValueSize(), t) }
                    setInterpolation(t) {
                        let e;
                        switch (t) {
                            case Yy:
                                e = this.InterpolantFactoryMethodDiscrete;
                                break;
                            case Zy:
                                e = this.InterpolantFactoryMethodLinear;
                                break;
                            case Jy:
                                e = this.InterpolantFactoryMethodSmooth
                        }
                        if (void 0 === e) {
                            const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                            if (void 0 === this.createInterpolant) {
                                if (t === this.DefaultInterpolation) throw new Error(e);
                                this.setInterpolation(this.DefaultInterpolation)
                            }
                            return console.warn("THREE.KeyframeTrack:", e), this
                        }
                        return this.createInterpolant = e, this
                    }
                    getInterpolation() {
                        switch (this.createInterpolant) {
                            case this.InterpolantFactoryMethodDiscrete:
                                return Yy;
                            case this.InterpolantFactoryMethodLinear:
                                return Zy;
                            case this.InterpolantFactoryMethodSmooth:
                                return Jy
                        }
                    }
                    getValueSize() { return this.values.length / this.times.length }
                    shift(t) { if (0 !== t) { const e = this.times; for (let n = 0, i = e.length; n !== i; ++n) e[n] += t } return this }
                    scale(t) { if (1 !== t) { const e = this.times; for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t } return this }
                    trim(t, e) {
                        const n = this.times,
                            i = n.length;
                        let r = 0,
                            s = i - 1;
                        for (; r !== i && n[r] < t;) ++r;
                        for (; - 1 !== s && n[s] > e;) --s;
                        if (++s, 0 !== r || s !== i) {
                            r >= s && (s = Math.max(s, 1), r = s - 1);
                            const t = this.getValueSize();
                            this.times = hE.arraySlice(n, r, s), this.values = hE.arraySlice(this.values, r * t, s * t)
                        }
                        return this
                    }
                    validate() {
                        let t = !0;
                        const e = this.getValueSize();
                        e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                        const n = this.times,
                            i = this.values,
                            r = n.length;
                        0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                        let s = null;
                        for (let e = 0; e !== r; e++) {
                            const i = n[e];
                            if ("number" == typeof i && isNaN(i)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i), t = !1; break }
                            if (null !== s && s > i) { console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, s), t = !1; break }
                            s = i
                        }
                        if (void 0 !== i && hE.isTypedArray(i))
                            for (let e = 0, n = i.length; e !== n; ++e) { const n = i[e]; if (isNaN(n)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1; break } }
                        return t
                    }
                    optimize() {
                        const t = hE.arraySlice(this.times),
                            e = hE.arraySlice(this.values),
                            n = this.getValueSize(),
                            i = this.getInterpolation() === Jy,
                            r = t.length - 1;
                        let s = 1;
                        for (let o = 1; o < r; ++o) {
                            let r = !1;
                            const a = t[o];
                            if (a !== t[o + 1] && (1 !== o || a !== t[0]))
                                if (i) r = !0;
                                else {
                                    const t = o * n,
                                        i = t - n,
                                        s = t + n;
                                    for (let o = 0; o !== n; ++o) { const n = e[t + o]; if (n !== e[i + o] || n !== e[s + o]) { r = !0; break } }
                                }
                            if (r) {
                                if (o !== s) {
                                    t[s] = t[o];
                                    const i = o * n,
                                        r = s * n;
                                    for (let t = 0; t !== n; ++t) e[r + t] = e[i + t]
                                }++s
                            }
                        }
                        if (r > 0) { t[s] = t[r]; for (let t = r * n, i = s * n, o = 0; o !== n; ++o) e[i + o] = e[t + o];++s }
                        return s !== t.length ? (this.times = hE.arraySlice(t, 0, s), this.values = hE.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this
                    }
                    clone() {
                        const t = hE.arraySlice(this.times, 0),
                            e = hE.arraySlice(this.values, 0),
                            n = new(0, this.constructor)(this.name, t, e);
                        return n.createInterpolant = this.createInterpolant, n
                    }
                }
                fE.prototype.TimeBufferType = Float32Array, fE.prototype.ValueBufferType = Float32Array, fE.prototype.DefaultInterpolation = Zy;
                class gE extends fE {}
                gE.prototype.ValueTypeName = "bool", gE.prototype.ValueBufferType = Array, gE.prototype.DefaultInterpolation = Yy, gE.prototype.InterpolantFactoryMethodLinear = void 0, gE.prototype.InterpolantFactoryMethodSmooth = void 0;
                class vE extends fE {}
                vE.prototype.ValueTypeName = "color";
                class yE extends fE {}
                yE.prototype.ValueTypeName = "number";
                class xE extends uE {
                    constructor(t, e, n, i) { super(t, e, n, i) }
                    interpolate_(t, e, n, i) {
                        const r = this.resultBuffer,
                            s = this.sampleValues,
                            o = this.valueSize,
                            a = (n - e) / (i - e);
                        let l = t * o;
                        for (let t = l + o; l !== t; l += 4) Ax.slerpFlat(r, 0, s, l - o, s, l, a);
                        return r
                    }
                }
                class _E extends fE { InterpolantFactoryMethodLinear(t) { return new xE(this.times, this.values, this.getValueSize(), t) } }
                _E.prototype.ValueTypeName = "quaternion", _E.prototype.DefaultInterpolation = Zy, _E.prototype.InterpolantFactoryMethodSmooth = void 0;
                class bE extends fE {}
                bE.prototype.ValueTypeName = "string", bE.prototype.ValueBufferType = Array, bE.prototype.DefaultInterpolation = Yy, bE.prototype.InterpolantFactoryMethodLinear = void 0, bE.prototype.InterpolantFactoryMethodSmooth = void 0;
                class wE extends fE {}
                wE.prototype.ValueTypeName = "vector";
                class ME {
                    constructor(t, e = -1, n, i = 2500) { this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = hx(), this.duration < 0 && this.resetDuration() }
                    static parse(t) {
                        const e = [],
                            n = t.tracks,
                            i = 1 / (t.fps || 1);
                        for (let t = 0, r = n.length; t !== r; ++t) e.push(SE(n[t]).scale(i));
                        const r = new this(t.name, t.duration, e, t.blendMode);
                        return r.uuid = t.uuid, r
                    }
                    static toJSON(t) {
                        const e = [],
                            n = t.tracks,
                            i = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode };
                        for (let t = 0, i = n.length; t !== i; ++t) e.push(fE.toJSON(n[t]));
                        return i
                    }
                    static CreateFromMorphTargetSequence(t, e, n, i) {
                        const r = e.length,
                            s = [];
                        for (let t = 0; t < r; t++) {
                            let o = [],
                                a = [];
                            o.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0);
                            const l = hE.getKeyframeOrder(o);
                            o = hE.sortedArray(o, 1, l), a = hE.sortedArray(a, 1, l), i || 0 !== o[0] || (o.push(r), a.push(a[0])), s.push(new yE(".morphTargetInfluences[" + e[t].name + "]", o, a).scale(1 / n))
                        }
                        return new this(t, -1, s)
                    }
                    static findByName(t, e) {
                        let n = t;
                        if (!Array.isArray(t)) {
                            const e = t;
                            n = e.geometry && e.geometry.animations || e.animations
                        }
                        for (let t = 0; t < n.length; t++)
                            if (n[t].name === e) return n[t];
                        return null
                    }
                    static CreateClipsFromMorphTargetSequences(t, e, n) {
                        const i = {},
                            r = /^([\w-]*?)([\d]+)$/;
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e],
                                s = n.name.match(r);
                            if (s && s.length > 1) {
                                const t = s[1];
                                let e = i[t];
                                e || (i[t] = e = []), e.push(n)
                            }
                        }
                        const s = [];
                        for (const t in i) s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
                        return s
                    }
                    static parseAnimation(t, e) {
                        if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                        const n = function(t, e, n, i, r) {
                                if (0 !== n.length) {
                                    const s = [],
                                        o = [];
                                    hE.flattenJSON(n, s, o, i), 0 !== s.length && r.push(new t(e, s, o))
                                }
                            },
                            i = [],
                            r = t.name || "default",
                            s = t.fps || 30,
                            o = t.blendMode;
                        let a = t.length || -1;
                        const l = t.hierarchy || [];
                        for (let t = 0; t < l.length; t++) {
                            const r = l[t].keys;
                            if (r && 0 !== r.length)
                                if (r[0].morphTargets) {
                                    const t = {};
                                    let e;
                                    for (e = 0; e < r.length; e++)
                                        if (r[e].morphTargets)
                                            for (let n = 0; n < r[e].morphTargets.length; n++) t[r[e].morphTargets[n]] = -1;
                                    for (const n in t) {
                                        const t = [],
                                            s = [];
                                        for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                            const i = r[e];
                                            t.push(i.time), s.push(i.morphTarget === n ? 1 : 0)
                                        }
                                        i.push(new yE(".morphTargetInfluence[" + n + "]", t, s))
                                    }
                                    a = t.length * (s || 1)
                                } else {
                                    const s = ".bones[" + e[t].name + "]";
                                    n(wE, s + ".position", r, "pos", i), n(_E, s + ".quaternion", r, "rot", i), n(wE, s + ".scale", r, "scl", i)
                                }
                        }
                        return 0 === i.length ? null : new this(r, a, i, o)
                    }
                    resetDuration() {
                        let t = 0;
                        for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                            const n = this.tracks[e];
                            t = Math.max(t, n.times[n.times.length - 1])
                        }
                        return this.duration = t, this
                    }
                    trim() { for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration); return this }
                    validate() { let t = !0; for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate(); return t }
                    optimize() { for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize(); return this }
                    clone() { const t = []; for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone()); return new this.constructor(this.name, this.duration, t, this.blendMode) }
                    toJSON() { return this.constructor.toJSON(this) }
                }

                function SE(t) {
                    if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                    const e = function(t) {
                        switch (t.toLowerCase()) {
                            case "scalar":
                            case "double":
                            case "float":
                            case "number":
                            case "integer":
                                return yE;
                            case "vector":
                            case "vector2":
                            case "vector3":
                            case "vector4":
                                return wE;
                            case "color":
                                return vE;
                            case "quaternion":
                                return _E;
                            case "bool":
                            case "boolean":
                                return gE;
                            case "string":
                                return bE
                        }
                        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                    }(t.type);
                    if (void 0 === t.times) {
                        const e = [],
                            n = [];
                        hE.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
                    }
                    return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
                }
                const TE = { enabled: !1, files: {}, add: function(t, e) {!1 !== this.enabled && (this.files[t] = e) }, get: function(t) { if (!1 !== this.enabled) return this.files[t] }, remove: function(t) { delete this.files[t] }, clear: function() { this.files = {} } };
                const EE = new class {
                    constructor(t, e, n) {
                        const i = this;
                        let r, s = !1,
                            o = 0,
                            a = 0;
                        const l = [];
                        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) { a++, !1 === s && void 0 !== i.onStart && i.onStart(t, o, a), s = !0 }, this.itemEnd = function(t) { o++, void 0 !== i.onProgress && i.onProgress(t, o, a), o === a && (s = !1, void 0 !== i.onLoad && i.onLoad()) }, this.itemError = function(t) { void 0 !== i.onError && i.onError(t) }, this.resolveURL = function(t) { return r ? r(t) : t }, this.setURLModifier = function(t) { return r = t, this }, this.addHandler = function(t, e) { return l.push(t, e), this }, this.removeHandler = function(t) { const e = l.indexOf(t); return -1 !== e && l.splice(e, 2), this }, this.getHandler = function(t) {
                            for (let e = 0, n = l.length; e < n; e += 2) {
                                const n = l[e],
                                    i = l[e + 1];
                                if (n.global && (n.lastIndex = 0), n.test(t)) return i
                            }
                            return null
                        }
                    }
                };
                class AE {
                    constructor(t) { this.manager = void 0 !== t ? t : EE, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} }
                    load() {}
                    loadAsync(t, e) { const n = this; return new Promise((function(i, r) { n.load(t, i, e, r) })) }
                    parse() {}
                    setCrossOrigin(t) { return this.crossOrigin = t, this }
                    setWithCredentials(t) { return this.withCredentials = t, this }
                    setPath(t) { return this.path = t, this }
                    setResourcePath(t) { return this.resourcePath = t, this }
                    setRequestHeader(t) { return this.requestHeader = t, this }
                }
                const LE = {};
                class RE extends AE {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                        const r = this,
                            s = TE.get(t);
                        if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() { e && e(s), r.manager.itemEnd(t) }), 0), s;
                        if (void 0 !== LE[t]) return void LE[t].push({ onLoad: e, onProgress: n, onError: i });
                        const o = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                        let a;
                        if (o) {
                            const n = o[1],
                                s = !!o[2];
                            let a = o[3];
                            a = decodeURIComponent(a), s && (a = atob(a));
                            try {
                                let i;
                                const s = (this.responseType || "").toLowerCase();
                                switch (s) {
                                    case "arraybuffer":
                                    case "blob":
                                        const t = new Uint8Array(a.length);
                                        for (let e = 0; e < a.length; e++) t[e] = a.charCodeAt(e);
                                        i = "blob" === s ? new Blob([t.buffer], { type: n }) : t.buffer;
                                        break;
                                    case "document":
                                        const e = new DOMParser;
                                        i = e.parseFromString(a, n);
                                        break;
                                    case "json":
                                        i = JSON.parse(a);
                                        break;
                                    default:
                                        i = a
                                }
                                setTimeout((function() { e && e(i), r.manager.itemEnd(t) }), 0)
                            } catch (e) { setTimeout((function() { i && i(e), r.manager.itemError(t), r.manager.itemEnd(t) }), 0) }
                        } else {
                            LE[t] = [], LE[t].push({ onLoad: e, onProgress: n, onError: i }), a = new XMLHttpRequest, a.open("GET", t, !0), a.addEventListener("load", (function(e) {
                                const n = this.response,
                                    i = LE[t];
                                if (delete LE[t], 200 === this.status || 0 === this.status) {
                                    0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), TE.add(t, n);
                                    for (let t = 0, e = i.length; t < e; t++) {
                                        const e = i[t];
                                        e.onLoad && e.onLoad(n)
                                    }
                                    r.manager.itemEnd(t)
                                } else {
                                    for (let t = 0, n = i.length; t < n; t++) {
                                        const n = i[t];
                                        n.onError && n.onError(e)
                                    }
                                    r.manager.itemError(t), r.manager.itemEnd(t)
                                }
                            }), !1), a.addEventListener("progress", (function(e) {
                                const n = LE[t];
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    i.onProgress && i.onProgress(e)
                                }
                            }), !1), a.addEventListener("error", (function(e) {
                                const n = LE[t];
                                delete LE[t];
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    i.onError && i.onError(e)
                                }
                                r.manager.itemError(t), r.manager.itemEnd(t)
                            }), !1), a.addEventListener("abort", (function(e) {
                                const n = LE[t];
                                delete LE[t];
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    i.onError && i.onError(e)
                                }
                                r.manager.itemError(t), r.manager.itemEnd(t)
                            }), !1), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                            for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t]);
                            a.send(null)
                        }
                        return r.manager.itemStart(t), a
                    }
                    setResponseType(t) { return this.responseType = t, this }
                    setMimeType(t) { return this.mimeType = t, this }
                }
                class CE extends AE {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                        const r = this,
                            s = TE.get(t);
                        if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() { e && e(s), r.manager.itemEnd(t) }), 0), s;
                        const o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                        function a() { o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1), TE.add(t, this), e && e(this), r.manager.itemEnd(t) }

                        function l(e) { o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t) }
                        return o.addEventListener("load", a, !1), o.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(t), o.src = t, o
                    }
                }
                class PE extends AE {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = new kb,
                            s = new CE(this.manager);
                        s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                        let o = 0;

                        function a(n) { s.load(t[n], (function(t) { r.images[n] = t, o++, 6 === o && (r.needsUpdate = !0, e && e(r)) }), void 0, i) }
                        for (let e = 0; e < t.length; ++e) a(e);
                        return r
                    }
                }
                class IE extends AE {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = new wx,
                            s = new CE(this.manager);
                        return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function(n) {
                            r.image = n;
                            const i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                            r.format = i ? Wy : jy, r.needsUpdate = !0, void 0 !== e && e(r)
                        }), n, i), r
                    }
                }
                class DE extends aT {
                    constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 }
                    add(t) { this.curves.push(t) }
                    closePath() {
                        const t = this.curves[0].getPoint(0),
                            e = this.curves[this.curves.length - 1].getPoint(1);
                        t.equals(e) || this.curves.push(new bT(e, t))
                    }
                    getPoint(t) {
                        const e = t * this.getLength(),
                            n = this.getCurveLengths();
                        let i = 0;
                        for (; i < n.length;) {
                            if (n[i] >= e) {
                                const t = n[i] - e,
                                    r = this.curves[i],
                                    s = r.getLength(),
                                    o = 0 === s ? 0 : 1 - t / s;
                                return r.getPointAt(o)
                            }
                            i++
                        }
                        return null
                    }
                    getLength() { const t = this.getCurveLengths(); return t[t.length - 1] }
                    updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() }
                    getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const t = []; let e = 0; for (let n = 0, i = this.curves.length; n < i; n++) e += this.curves[n].getLength(), t.push(e); return this.cacheLengths = t, t }
                    getSpacedPoints(t = 40) { const e = []; for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t)); return this.autoClose && e.push(e[0]), e }
                    getPoints(t = 12) {
                        const e = [];
                        let n;
                        for (let i = 0, r = this.curves; i < r.length; i++) {
                            const s = r[i],
                                o = s && s.isEllipseCurve ? 2 * t : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t,
                                a = s.getPoints(o);
                            for (let t = 0; t < a.length; t++) {
                                const i = a[t];
                                n && n.equals(i) || (e.push(i), n = i)
                            }
                        }
                        return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
                    }
                    copy(t) {
                        super.copy(t), this.curves = [];
                        for (let e = 0, n = t.curves.length; e < n; e++) {
                            const n = t.curves[e];
                            this.curves.push(n.clone())
                        }
                        return this.autoClose = t.autoClose, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.autoClose = this.autoClose, t.curves = [];
                        for (let e = 0, n = this.curves.length; e < n; e++) {
                            const n = this.curves[e];
                            t.curves.push(n.toJSON())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                        for (let e = 0, n = t.curves.length; e < n; e++) {
                            const n = t.curves[e];
                            this.curves.push((new TT[n.type]).fromJSON(n))
                        }
                        return this
                    }
                }
                class NE extends DE {
                    constructor(t) { super(), this.type = "Path", this.currentPoint = new vx, t && this.setFromPoints(t) }
                    setFromPoints(t) { this.moveTo(t[0].x, t[0].y); for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y); return this }
                    moveTo(t, e) { return this.currentPoint.set(t, e), this }
                    lineTo(t, e) { const n = new bT(this.currentPoint.clone(), new vx(t, e)); return this.curves.push(n), this.currentPoint.set(t, e), this }
                    quadraticCurveTo(t, e, n, i) { const r = new wT(this.currentPoint.clone(), new vx(t, e), new vx(n, i)); return this.curves.push(r), this.currentPoint.set(n, i), this }
                    bezierCurveTo(t, e, n, i, r, s) { const o = new xT(this.currentPoint.clone(), new vx(t, e), new vx(n, i), new vx(r, s)); return this.curves.push(o), this.currentPoint.set(r, s), this }
                    splineThru(t) {
                        const e = [this.currentPoint.clone()].concat(t),
                            n = new ST(e);
                        return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
                    }
                    arc(t, e, n, i, r, s) {
                        const o = this.currentPoint.x,
                            a = this.currentPoint.y;
                        return this.absarc(t + o, e + a, n, i, r, s), this
                    }
                    absarc(t, e, n, i, r, s) { return this.absellipse(t, e, n, n, i, r, s), this }
                    ellipse(t, e, n, i, r, s, o, a) {
                        const l = this.currentPoint.x,
                            c = this.currentPoint.y;
                        return this.absellipse(t + l, e + c, n, i, r, s, o, a), this
                    }
                    absellipse(t, e, n, i, r, s, o, a) {
                        const l = new lT(t, e, n, i, r, s, o, a);
                        if (this.curves.length > 0) {
                            const t = l.getPoint(0);
                            t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                        }
                        this.curves.push(l);
                        const c = l.getPoint(1);
                        return this.currentPoint.copy(c), this
                    }
                    copy(t) { return super.copy(t), this.currentPoint.copy(t.currentPoint), this }
                    toJSON() { const t = super.toJSON(); return t.currentPoint = this.currentPoint.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this }
                }
                class BE extends NE {
                    constructor(t) { super(t), this.uuid = hx(), this.type = "Shape", this.holes = [] }
                    getPointsHoles(t) { const e = []; for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t); return e }
                    extractPoints(t) { return { shape: this.getPoints(t), holes: this.getPointsHoles(t) } }
                    copy(t) {
                        super.copy(t), this.holes = [];
                        for (let e = 0, n = t.holes.length; e < n; e++) {
                            const n = t.holes[e];
                            this.holes.push(n.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.uuid = this.uuid, t.holes = [];
                        for (let e = 0, n = this.holes.length; e < n; e++) {
                            const n = this.holes[e];
                            t.holes.push(n.toJSON())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
                        for (let e = 0, n = t.holes.length; e < n; e++) {
                            const n = t.holes[e];
                            this.holes.push((new NE).fromJSON(n))
                        }
                        return this
                    }
                }
                class OE extends C_ {
                    constructor(t, e = 1) { super(), this.type = "Light", this.color = new J_(t), this.intensity = e }
                    dispose() {}
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this }
                    toJSON(t) { const e = super.toJSON(t); return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e }
                }
                OE.prototype.isLight = !0;
                (class extends OE {
                    constructor(t, e, n) { super(t, n), this.type = "HemisphereLight", this.position.copy(C_.DefaultUp), this.updateMatrix(), this.groundColor = new J_(e) }
                    copy(t) { return OE.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this }
                }).prototype.isHemisphereLight = !0;
                const FE = new s_,
                    zE = new Lx,
                    UE = new Lx;
                class HE {
                    constructor(t) { this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new vx(512, 512), this.map = null, this.mapPass = null, this.matrix = new s_, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Zb, this._frameExtents = new vx(1, 1), this._viewportCount = 1, this._viewports = [new Sx(0, 0, 1, 1)] }
                    getViewportCount() { return this._viewportCount }
                    getFrustum() { return this._frustum }
                    updateMatrices(t) {
                        const e = this.camera,
                            n = this.matrix;
                        zE.setFromMatrixPosition(t.matrixWorld), e.position.copy(zE), UE.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(UE), e.updateMatrixWorld(), FE.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(FE), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
                    }
                    getViewport(t) { return this._viewports[t] }
                    getFrameExtents() { return this._frameExtents }
                    dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() }
                    copy(t) { return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this }
                    clone() { return (new this.constructor).copy(this) }
                    toJSON() { const t = {}; return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t }
                }
                class kE extends HE {
                    constructor() { super(new zb(50, 1, .5, 500)), this.focus = 1 }
                    updateMatrices(t) {
                        const e = this.camera,
                            n = 2 * cx * t.angle * this.focus,
                            i = this.mapSize.width / this.mapSize.height,
                            r = t.distance || e.far;
                        n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t)
                    }
                    copy(t) { return super.copy(t), this.focus = t.focus, this }
                }
                kE.prototype.isSpotLightShadow = !0;
                (class extends OE {
                    constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 1) { super(t, e), this.type = "SpotLight", this.position.copy(C_.DefaultUp), this.updateMatrix(), this.target = new C_, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.shadow = new kE }
                    get power() { return this.intensity * Math.PI }
                    set power(t) { this.intensity = t / Math.PI }
                    dispose() { this.shadow.dispose() }
                    copy(t) { return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this }
                }).prototype.isSpotLight = !0;
                const GE = new s_,
                    VE = new Lx,
                    WE = new Lx;
                class jE extends HE {
                    constructor() { super(new zb(90, 1, .5, 500)), this._frameExtents = new vx(4, 2), this._viewportCount = 6, this._viewports = [new Sx(2, 1, 1, 1), new Sx(0, 1, 1, 1), new Sx(3, 1, 1, 1), new Sx(1, 1, 1, 1), new Sx(3, 0, 1, 1), new Sx(1, 0, 1, 1)], this._cubeDirections = [new Lx(1, 0, 0), new Lx(-1, 0, 0), new Lx(0, 0, 1), new Lx(0, 0, -1), new Lx(0, 1, 0), new Lx(0, -1, 0)], this._cubeUps = [new Lx(0, 1, 0), new Lx(0, 1, 0), new Lx(0, 1, 0), new Lx(0, 1, 0), new Lx(0, 0, 1), new Lx(0, 0, -1)] }
                    updateMatrices(t, e = 0) {
                        const n = this.camera,
                            i = this.matrix,
                            r = t.distance || n.far;
                        r !== n.far && (n.far = r, n.updateProjectionMatrix()), VE.setFromMatrixPosition(t.matrixWorld), n.position.copy(VE), WE.copy(n.position), WE.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(WE), n.updateMatrixWorld(), i.makeTranslation(-VE.x, -VE.y, -VE.z), GE.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(GE)
                    }
                }
                jE.prototype.isPointLightShadow = !0;
                (class extends OE {
                    constructor(t, e, n = 0, i = 1) { super(t, e), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new jE }
                    get power() { return 4 * this.intensity * Math.PI }
                    set power(t) { this.intensity = t / (4 * Math.PI) }
                    dispose() { this.shadow.dispose() }
                    copy(t) { return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this }
                }).prototype.isPointLight = !0;
                class qE extends Fb {
                    constructor(t = -1, e = 1, n = 1, i = -1, r = .1, s = 2e3) { super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix() }
                    copy(t, e) { return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this }
                    setViewOffset(t, e, n, i, r, s) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix() }
                    clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }
                    updateProjectionMatrix() {
                        const t = (this.right - this.left) / (2 * this.zoom),
                            e = (this.top - this.bottom) / (2 * this.zoom),
                            n = (this.right + this.left) / 2,
                            i = (this.top + this.bottom) / 2;
                        let r = n - t,
                            s = n + t,
                            o = i + e,
                            a = i - e;
                        if (null !== this.view && this.view.enabled) {
                            const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                                e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                            r += t * this.view.offsetX, s = r + t * this.view.width, o -= e * this.view.offsetY, a = o - e * this.view.height
                        }
                        this.projectionMatrix.makeOrthographic(r, s, o, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(t) { const e = super.toJSON(t); return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e }
                }
                qE.prototype.isOrthographicCamera = !0;
                class XE extends HE { constructor() { super(new qE(-5, 5, 5, -5, .5, 500)) } }
                XE.prototype.isDirectionalLightShadow = !0;
                (class extends OE {
                    constructor(t, e) { super(t, e), this.type = "DirectionalLight", this.position.copy(C_.DefaultUp), this.updateMatrix(), this.target = new C_, this.shadow = new XE }
                    dispose() { this.shadow.dispose() }
                    copy(t) { return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this }
                }).prototype.isDirectionalLight = !0;
                (class extends OE { constructor(t, e) { super(t, e), this.type = "AmbientLight" } }).prototype.isAmbientLight = !0;
                (class extends OE {
                    constructor(t, e, n = 10, i = 10) { super(t, e), this.type = "RectAreaLight", this.width = n, this.height = i }
                    copy(t) { return super.copy(t), this.width = t.width, this.height = t.height, this }
                    toJSON(t) { const e = super.toJSON(t); return e.object.width = this.width, e.object.height = this.height, e }
                }).prototype.isRectAreaLight = !0;
                class YE {
                    constructor() { this.coefficients = []; for (let t = 0; t < 9; t++) this.coefficients.push(new Lx) }
                    set(t) { for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]); return this }
                    zero() { for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0); return this }
                    getAt(t, e) {
                        const n = t.x,
                            i = t.y,
                            r = t.z,
                            s = this.coefficients;
                        return e.copy(s[0]).multiplyScalar(.282095), e.addScaledVector(s[1], .488603 * i), e.addScaledVector(s[2], .488603 * r), e.addScaledVector(s[3], .488603 * n), e.addScaledVector(s[4], n * i * 1.092548), e.addScaledVector(s[5], i * r * 1.092548), e.addScaledVector(s[6], .315392 * (3 * r * r - 1)), e.addScaledVector(s[7], n * r * 1.092548), e.addScaledVector(s[8], .546274 * (n * n - i * i)), e
                    }
                    getIrradianceAt(t, e) {
                        const n = t.x,
                            i = t.y,
                            r = t.z,
                            s = this.coefficients;
                        return e.copy(s[0]).multiplyScalar(.886227), e.addScaledVector(s[1], 1.023328 * i), e.addScaledVector(s[2], 1.023328 * r), e.addScaledVector(s[3], 1.023328 * n), e.addScaledVector(s[4], .858086 * n * i), e.addScaledVector(s[5], .858086 * i * r), e.addScaledVector(s[6], .743125 * r * r - .247708), e.addScaledVector(s[7], .858086 * n * r), e.addScaledVector(s[8], .429043 * (n * n - i * i)), e
                    }
                    add(t) { for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]); return this }
                    addScaledSH(t, e) { for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e); return this }
                    scale(t) { for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t); return this }
                    lerp(t, e) { for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e); return this }
                    equals(t) {
                        for (let e = 0; e < 9; e++)
                            if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                        return !0
                    }
                    copy(t) { return this.set(t.coefficients) }
                    clone() { return (new this.constructor).copy(this) }
                    fromArray(t, e = 0) { const n = this.coefficients; for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i); return this }
                    toArray(t = [], e = 0) { const n = this.coefficients; for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i); return t }
                    static getBasisAt(t, e) {
                        const n = t.x,
                            i = t.y,
                            r = t.z;
                        e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i)
                    }
                }
                YE.prototype.isSphericalHarmonics3 = !0;
                class ZE extends OE {
                    constructor(t = new YE, e = 1) { super(void 0, e), this.sh = t }
                    copy(t) { return super.copy(t), this.sh.copy(t.sh), this }
                    fromJSON(t) { return this.intensity = t.intensity, this.sh.fromArray(t.sh), this }
                    toJSON(t) { const e = super.toJSON(t); return e.object.sh = this.sh.toArray(), e }
                }
                ZE.prototype.isLightProbe = !0;
                (class extends db {
                    constructor() { super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 }
                    copy(t) { return super.copy(t), this.instanceCount = t.instanceCount, this }
                    clone() { return (new this.constructor).copy(this) }
                    toJSON() { const t = super.toJSON(this); return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t }
                }).prototype.isInstancedBufferGeometry = !0;
                (class extends tb {
                    constructor(t, e, n, i = 1) { "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, n), this.meshPerAttribute = i }
                    copy(t) { return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this }
                    toJSON() { const t = super.toJSON(); return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t }
                }).prototype.isInstancedBufferAttribute = !0, class extends AE {
                    constructor(t) { super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } }
                    setOptions(t) { return this.options = t, this }
                    load(t, e, n, i) {
                        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                        const r = this,
                            s = TE.get(t);
                        if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() { e && e(s), r.manager.itemEnd(t) }), 0), s;
                        const o = {};
                        o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader, fetch(t, o).then((function(t) { return t.blob() })).then((function(t) { return createImageBitmap(t, Object.assign(r.options, { colorSpaceConversion: "none" })) })).then((function(n) { TE.add(t, n), e && e(n), r.manager.itemEnd(t) })).catch((function(e) { i && i(e), r.manager.itemError(t), r.manager.itemEnd(t) })), r.manager.itemStart(t)
                    }
                }.prototype.isImageBitmapLoader = !0;
                let JE;
                class KE extends AE {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = this,
                            s = new RE(this.manager);
                        s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, (function(n) {
                            try {
                                const t = n.slice(0);
                                (void 0 === JE && (JE = new(window.AudioContext || window.webkitAudioContext)), JE).decodeAudioData(t, (function(t) { e(t) }))
                            } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) }
                        }), n, i)
                    }
                }(class extends ZE {
                    constructor(t, e, n = 1) {
                        super(void 0, n);
                        const i = (new J_).set(t),
                            r = (new J_).set(e),
                            s = new Lx(i.r, i.g, i.b),
                            o = new Lx(r.r, r.g, r.b),
                            a = Math.sqrt(Math.PI),
                            l = a * Math.sqrt(.75);
                        this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a), this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l)
                    }
                }).prototype.isHemisphereLightProbe = !0, class extends ZE {
                    constructor(t, e = 1) {
                        super(void 0, e);
                        const n = (new J_).set(t);
                        this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
                    }
                }.prototype.isAmbientLightProbe = !0;
                class QE {
                    constructor(t, e, n) {
                        let i, r, s;
                        switch (this.binding = t, this.valueSize = n, e) {
                            case "quaternion":
                                i = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                                break;
                            case "string":
                            case "bool":
                                i = this._select, r = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                                break;
                            default:
                                i = this._lerp, r = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                        }
                        this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                    }
                    accumulate(t, e) {
                        const n = this.buffer,
                            i = this.valueSize,
                            r = t * i + i;
                        let s = this.cumulativeWeight;
                        if (0 === s) {
                            for (let t = 0; t !== i; ++t) n[r + t] = n[t];
                            s = e
                        } else {
                            s += e;
                            const t = e / s;
                            this._mixBufferRegion(n, r, 0, t, i)
                        }
                        this.cumulativeWeight = s
                    }
                    accumulateAdditive(t) {
                        const e = this.buffer,
                            n = this.valueSize,
                            i = n * this._addIndex;
                        0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, i, 0, t, n), this.cumulativeWeightAdditive += t
                    }
                    apply(t) {
                        const e = this.valueSize,
                            n = this.buffer,
                            i = t * e + e,
                            r = this.cumulativeWeight,
                            s = this.cumulativeWeightAdditive,
                            o = this.binding;
                        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                            const t = e * this._origIndex;
                            this._mixBufferRegion(n, i, t, 1 - r, e)
                        }
                        s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
                        for (let t = e, r = e + e; t !== r; ++t)
                            if (n[t] !== n[t + e]) { o.setValue(n, i); break }
                    }
                    saveOriginalState() {
                        const t = this.binding,
                            e = this.buffer,
                            n = this.valueSize,
                            i = n * this._origIndex;
                        t.getValue(e, i);
                        for (let t = n, r = i; t !== r; ++t) e[t] = e[i + t % n];
                        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                    }
                    restoreOriginalState() {
                        const t = 3 * this.valueSize;
                        this.binding.setValue(this.buffer, t)
                    }
                    _setAdditiveIdentityNumeric() {
                        const t = this._addIndex * this.valueSize,
                            e = t + this.valueSize;
                        for (let n = t; n < e; n++) this.buffer[n] = 0
                    }
                    _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 }
                    _setAdditiveIdentityOther() {
                        const t = this._origIndex * this.valueSize,
                            e = this._addIndex * this.valueSize;
                        for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
                    }
                    _select(t, e, n, i, r) {
                        if (i >= .5)
                            for (let i = 0; i !== r; ++i) t[e + i] = t[n + i]
                    }
                    _slerp(t, e, n, i) { Ax.slerpFlat(t, e, t, e, t, n, i) }
                    _slerpAdditive(t, e, n, i, r) {
                        const s = this._workIndex * r;
                        Ax.multiplyQuaternionsFlat(t, s, t, e, t, n), Ax.slerpFlat(t, e, t, e, t, s, i)
                    }
                    _lerp(t, e, n, i, r) {
                        const s = 1 - i;
                        for (let o = 0; o !== r; ++o) {
                            const r = e + o;
                            t[r] = t[r] * s + t[n + o] * i
                        }
                    }
                    _lerpAdditive(t, e, n, i, r) {
                        for (let s = 0; s !== r; ++s) {
                            const r = e + s;
                            t[r] = t[r] + t[n + s] * i
                        }
                    }
                }
                const $E = new RegExp("[\\[\\]\\.:\\/]", "g"),
                    tA = "[^\\[\\]\\.:\\/]",
                    eA = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                    nA = /((?:WC+[\/:])*)/.source.replace("WC", tA),
                    iA = /(WCOD+)?/.source.replace("WCOD", eA),
                    rA = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", tA),
                    sA = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", tA),
                    oA = new RegExp("^" + nA + iA + rA + sA + "$"),
                    aA = ["material", "materials", "bones"];
                class lA {
                    constructor(t, e, n) { this.path = e, this.parsedPath = n || lA.parseTrackName(e), this.node = lA.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound }
                    static create(t, e, n) { return t && t.isAnimationObjectGroup ? new lA.Composite(t, e, n) : new lA(t, e, n) }
                    static sanitizeNodeName(t) { return t.replace(/\s/g, "_").replace($E, "") }
                    static parseTrackName(t) {
                        const e = oA.exec(t);
                        if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                        const n = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] },
                            i = n.nodeName && n.nodeName.lastIndexOf(".");
                        if (void 0 !== i && -1 !== i) { const t = n.nodeName.substring(i + 1); - 1 !== aA.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t) }
                        if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                        return n
                    }
                    static findNode(t, e) {
                        if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                        if (t.skeleton) { const n = t.skeleton.getBoneByName(e); if (void 0 !== n) return n }
                        if (t.children) {
                            const n = function(t) { for (let i = 0; i < t.length; i++) { const r = t[i]; if (r.name === e || r.uuid === e) return r; const s = n(r.children); if (s) return s } return null },
                                i = n(t.children);
                            if (i) return i
                        }
                        return null
                    }
                    _getValue_unavailable() {}
                    _setValue_unavailable() {}
                    _getValue_direct(t, e) { t[e] = this.node[this.propertyName] }
                    _getValue_array(t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i] }
                    _getValue_arrayElement(t, e) { t[e] = this.resolvedProperty[this.propertyIndex] }
                    _getValue_toArray(t, e) { this.resolvedProperty.toArray(t, e) }
                    _setValue_direct(t, e) { this.targetObject[this.propertyName] = t[e] }
                    _setValue_direct_setNeedsUpdate(t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0 }
                    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }
                    _setValue_array(t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++] }
                    _setValue_array_setNeedsUpdate(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_arrayElement(t, e) { this.resolvedProperty[this.propertyIndex] = t[e] }
                    _setValue_arrayElement_setNeedsUpdate(t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0 }
                    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }
                    _setValue_fromArray(t, e) { this.resolvedProperty.fromArray(t, e) }
                    _setValue_fromArray_setNeedsUpdate(t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0 }
                    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0 }
                    _getValue_unbound(t, e) { this.bind(), this.getValue(t, e) }
                    _setValue_unbound(t, e) { this.bind(), this.setValue(t, e) }
                    bind() {
                        let t = this.node;
                        const e = this.parsedPath,
                            n = e.objectName,
                            i = e.propertyName;
                        let r = e.propertyIndex;
                        if (t || (t = lA.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                        if (n) {
                            let i = e.objectIndex;
                            switch (n) {
                                case "materials":
                                    if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    t = t.material.materials;
                                    break;
                                case "bones":
                                    if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    t = t.skeleton.bones;
                                    for (let e = 0; e < t.length; e++)
                                        if (t[e].name === i) { i = e; break }
                                    break;
                                default:
                                    if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    t = t[n]
                            }
                            if (void 0 !== i) {
                                if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                t = t[i]
                            }
                        }
                        const s = t[i];
                        if (void 0 === s) { const n = e.nodeName; return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t) }
                        let o = this.Versioning.None;
                        this.targetObject = t, void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
                        let a = this.BindingType.Direct;
                        if (void 0 !== r) {
                            if ("morphTargetInfluences" === i) {
                                if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                                if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                            }
                            a = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                        } else void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                        this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o]
                    }
                    unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound }
                }
                lA.Composite = class {
                    constructor(t, e, n) {
                        const i = n || lA.parseTrackName(e);
                        this._targetGroup = t, this._bindings = t.subscribe_(e, i)
                    }
                    getValue(t, e) {
                        this.bind();
                        const n = this._targetGroup.nCachedObjects_,
                            i = this._bindings[n];
                        void 0 !== i && i.getValue(t, e)
                    }
                    setValue(t, e) { const n = this._bindings; for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e) }
                    bind() { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind() }
                    unbind() { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind() }
                }, lA.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, lA.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, lA.prototype.GetterByBindingType = [lA.prototype._getValue_direct, lA.prototype._getValue_array, lA.prototype._getValue_arrayElement, lA.prototype._getValue_toArray], lA.prototype.SetterByBindingTypeAndVersioning = [
                    [lA.prototype._setValue_direct, lA.prototype._setValue_direct_setNeedsUpdate, lA.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                    [lA.prototype._setValue_array, lA.prototype._setValue_array_setNeedsUpdate, lA.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                    [lA.prototype._setValue_arrayElement, lA.prototype._setValue_arrayElement_setNeedsUpdate, lA.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                    [lA.prototype._setValue_fromArray, lA.prototype._setValue_fromArray_setNeedsUpdate, lA.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
                ];
                class cA {
                    constructor(t, e, n = null, i = e.blendMode) {
                        this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = i;
                        const r = e.tracks,
                            s = r.length,
                            o = new Array(s),
                            a = { endingStart: Ky, endingEnd: Ky };
                        for (let t = 0; t !== s; ++t) {
                            const e = r[t].createInterpolant(null);
                            o[t] = e, e.settings = a
                        }
                        this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                    }
                    play() { return this._mixer._activateAction(this), this }
                    stop() { return this._mixer._deactivateAction(this), this.reset() }
                    reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() }
                    isRunning() { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) }
                    isScheduled() { return this._mixer._isActiveAction(this) }
                    startAt(t) { return this._startTime = t, this }
                    setLoop(t, e) { return this.loop = t, this.repetitions = e, this }
                    setEffectiveWeight(t) { return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading() }
                    getEffectiveWeight() { return this._effectiveWeight }
                    fadeIn(t) { return this._scheduleFading(t, 0, 1) }
                    fadeOut(t) { return this._scheduleFading(t, 1, 0) }
                    crossFadeFrom(t, e, n) {
                        if (t.fadeOut(e), this.fadeIn(e), n) {
                            const n = this._clip.duration,
                                i = t._clip.duration,
                                r = i / n,
                                s = n / i;
                            t.warp(1, r, e), this.warp(s, 1, e)
                        }
                        return this
                    }
                    crossFadeTo(t, e, n) { return t.crossFadeFrom(this, e, n) }
                    stopFading() { const t = this._weightInterpolant; return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }
                    setEffectiveTimeScale(t) { return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping() }
                    getEffectiveTimeScale() { return this._effectiveTimeScale }
                    setDuration(t) { return this.timeScale = this._clip.duration / t, this.stopWarping() }
                    syncWith(t) { return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping() }
                    halt(t) { return this.warp(this._effectiveTimeScale, 0, t) }
                    warp(t, e, n) {
                        const i = this._mixer,
                            r = i.time,
                            s = this.timeScale;
                        let o = this._timeScaleInterpolant;
                        null === o && (o = i._lendControlInterpolant(), this._timeScaleInterpolant = o);
                        const a = o.parameterPositions,
                            l = o.sampleValues;
                        return a[0] = r, a[1] = r + n, l[0] = t / s, l[1] = e / s, this
                    }
                    stopWarping() { const t = this._timeScaleInterpolant; return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }
                    getMixer() { return this._mixer }
                    getClip() { return this._clip }
                    getRoot() { return this._localRoot || this._mixer._root }
                    _update(t, e, n, i) {
                        if (!this.enabled) return void this._updateWeight(t);
                        const r = this._startTime;
                        if (null !== r) {
                            const i = (t - r) * n;
                            if (i < 0 || 0 === n) return;
                            this._startTime = null, e = n * i
                        }
                        e *= this._updateTimeScale(t);
                        const s = this._updateTime(e),
                            o = this._updateWeight(t);
                        if (o > 0) {
                            const t = this._interpolants,
                                e = this._propertyBindings;
                            if (2501 === this.blendMode)
                                for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(s), e[n].accumulateAdditive(o);
                            else
                                for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(s), e[n].accumulate(i, o)
                        }
                    }
                    _updateWeight(t) {
                        let e = 0;
                        if (this.enabled) {
                            e = this.weight;
                            const n = this._weightInterpolant;
                            if (null !== n) {
                                const i = n.evaluate(t)[0];
                                e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = e, e
                    }
                    _updateTimeScale(t) {
                        let e = 0;
                        if (!this.paused) {
                            e = this.timeScale;
                            const n = this._timeScaleInterpolant;
                            null !== n && (e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e))
                        }
                        return this._effectiveTimeScale = e, e
                    }
                    _updateTime(t) {
                        const e = this._clip.duration,
                            n = this.loop;
                        let i = this.time + t,
                            r = this._loopCount;
                        const s = 2202 === n;
                        if (0 === t) return -1 === r ? i : s && 1 == (1 & r) ? e - i : i;
                        if (2200 === n) {
                            -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                            t: {
                                if (i >= e) i = e;
                                else {
                                    if (!(i < 0)) { this.time = i; break t }
                                    i = 0
                                }
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                this.time = i,
                                this._mixer.dispatchEvent({ type: "finished", action: this, direction: t < 0 ? -1 : 1 })
                            }
                        } else {
                            if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), i >= e || i < 0) {
                                const n = Math.floor(i / e);
                                i -= e * n, r += Math.abs(n);
                                const o = this.repetitions - r;
                                if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = t > 0 ? e : 0, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t > 0 ? 1 : -1 });
                                else {
                                    if (1 === o) {
                                        const e = t < 0;
                                        this._setEndings(e, !e, s)
                                    } else this._setEndings(!1, !1, s);
                                    this._loopCount = r, this.time = i, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n })
                                }
                            } else this.time = i;
                            if (s && 1 == (1 & r)) return e - i
                        }
                        return i
                    }
                    _setEndings(t, e, n) {
                        const i = this._interpolantSettings;
                        n ? (i.endingStart = Qy, i.endingEnd = Qy) : (i.endingStart = t ? this.zeroSlopeAtStart ? Qy : Ky : $y, i.endingEnd = e ? this.zeroSlopeAtEnd ? Qy : Ky : $y)
                    }
                    _scheduleFading(t, e, n) {
                        const i = this._mixer,
                            r = i.time;
                        let s = this._weightInterpolant;
                        null === s && (s = i._lendControlInterpolant(), this._weightInterpolant = s);
                        const o = s.parameterPositions,
                            a = s.sampleValues;
                        return o[0] = r, a[0] = e, o[1] = r + t, a[1] = n, this
                    }
                }
                class hA extends sx {
                    constructor(t) { super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 }
                    _bindAction(t, e) {
                        const n = t._localRoot || this._root,
                            i = t._clip.tracks,
                            r = i.length,
                            s = t._propertyBindings,
                            o = t._interpolants,
                            a = n.uuid,
                            l = this._bindingsByRootAndName;
                        let c = l[a];
                        void 0 === c && (c = {}, l[a] = c);
                        for (let t = 0; t !== r; ++t) {
                            const r = i[t],
                                l = r.name;
                            let h = c[l];
                            if (void 0 !== h) s[t] = h;
                            else {
                                if (h = s[t], void 0 !== h) { null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, a, l)); continue }
                                const i = e && e._propertyBindings[t].binding.parsedPath;
                                h = new QE(lA.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, a, l), s[t] = h
                            }
                            o[t].resultBuffer = h.buffer
                        }
                    }
                    _activateAction(t) {
                        if (!this._isActiveAction(t)) {
                            if (null === t._cacheIndex) {
                                const e = (t._localRoot || this._root).uuid,
                                    n = t._clip.uuid,
                                    i = this._actionsByClip[n];
                                this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e)
                            }
                            const e = t._propertyBindings;
                            for (let t = 0, n = e.length; t !== n; ++t) {
                                const n = e[t];
                                0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                            }
                            this._lendAction(t)
                        }
                    }
                    _deactivateAction(t) {
                        if (this._isActiveAction(t)) {
                            const e = t._propertyBindings;
                            for (let t = 0, n = e.length; t !== n; ++t) {
                                const n = e[t];
                                0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                            }
                            this._takeBackAction(t)
                        }
                    }
                    _initMemoryManager() {
                        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                        const t = this;
                        this.stats = { actions: {get total() { return t._actions.length }, get inUse() { return t._nActiveActions } }, bindings: {get total() { return t._bindings.length }, get inUse() { return t._nActiveBindings } }, controlInterpolants: {get total() { return t._controlInterpolants.length }, get inUse() { return t._nActiveControlInterpolants } } }
                    }
                    _isActiveAction(t) { const e = t._cacheIndex; return null !== e && e < this._nActiveActions }
                    _addInactiveAction(t, e, n) {
                        const i = this._actions,
                            r = this._actionsByClip;
                        let s = r[e];
                        if (void 0 === s) s = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, r[e] = s;
                        else {
                            const e = s.knownActions;
                            t._byClipCacheIndex = e.length, e.push(t)
                        }
                        t._cacheIndex = i.length, i.push(t), s.actionByRoot[n] = t
                    }
                    _removeInactiveAction(t) {
                        const e = this._actions,
                            n = e[e.length - 1],
                            i = t._cacheIndex;
                        n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null;
                        const r = t._clip.uuid,
                            s = this._actionsByClip,
                            o = s[r],
                            a = o.knownActions,
                            l = a[a.length - 1],
                            c = t._byClipCacheIndex;
                        l._byClipCacheIndex = c, a[c] = l, a.pop(), t._byClipCacheIndex = null, delete o.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete s[r], this._removeInactiveBindingsForAction(t)
                    }
                    _removeInactiveBindingsForAction(t) {
                        const e = t._propertyBindings;
                        for (let t = 0, n = e.length; t !== n; ++t) {
                            const n = e[t];
                            0 == --n.referenceCount && this._removeInactiveBinding(n)
                        }
                    }
                    _lendAction(t) {
                        const e = this._actions,
                            n = t._cacheIndex,
                            i = this._nActiveActions++,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    }
                    _takeBackAction(t) {
                        const e = this._actions,
                            n = t._cacheIndex,
                            i = --this._nActiveActions,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    }
                    _addInactiveBinding(t, e, n) {
                        const i = this._bindingsByRootAndName,
                            r = this._bindings;
                        let s = i[e];
                        void 0 === s && (s = {}, i[e] = s), s[n] = t, t._cacheIndex = r.length, r.push(t)
                    }
                    _removeInactiveBinding(t) {
                        const e = this._bindings,
                            n = t.binding,
                            i = n.rootNode.uuid,
                            r = n.path,
                            s = this._bindingsByRootAndName,
                            o = s[i],
                            a = e[e.length - 1],
                            l = t._cacheIndex;
                        a._cacheIndex = l, e[l] = a, e.pop(), delete o[r], 0 === Object.keys(o).length && delete s[i]
                    }
                    _lendBinding(t) {
                        const e = this._bindings,
                            n = t._cacheIndex,
                            i = this._nActiveBindings++,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    }
                    _takeBackBinding(t) {
                        const e = this._bindings,
                            n = t._cacheIndex,
                            i = --this._nActiveBindings,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    }
                    _lendControlInterpolant() {
                        const t = this._controlInterpolants,
                            e = this._nActiveControlInterpolants++;
                        let n = t[e];
                        return void 0 === n && (n = new pE(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
                    }
                    _takeBackControlInterpolant(t) {
                        const e = this._controlInterpolants,
                            n = t.__cacheIndex,
                            i = --this._nActiveControlInterpolants,
                            r = e[i];
                        t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
                    }
                    clipAction(t, e, n) {
                        const i = e || this._root,
                            r = i.uuid;
                        let s = "string" == typeof t ? ME.findByName(i, t) : t;
                        const o = null !== s ? s.uuid : t,
                            a = this._actionsByClip[o];
                        let l = null;
                        if (void 0 === n && (n = null !== s ? s.blendMode : 2500), void 0 !== a) {
                            const t = a.actionByRoot[r];
                            if (void 0 !== t && t.blendMode === n) return t;
                            l = a.knownActions[0], null === s && (s = l._clip)
                        }
                        if (null === s) return null;
                        const c = new cA(this, s, e, n);
                        return this._bindAction(c, l), this._addInactiveAction(c, o, r), c
                    }
                    existingAction(t, e) {
                        const n = e || this._root,
                            i = n.uuid,
                            r = "string" == typeof t ? ME.findByName(n, t) : t,
                            s = r ? r.uuid : t,
                            o = this._actionsByClip[s];
                        return void 0 !== o && o.actionByRoot[i] || null
                    }
                    stopAllAction() { const t = this._actions; for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop(); return this }
                    update(t) {
                        t *= this.timeScale;
                        const e = this._actions,
                            n = this._nActiveActions,
                            i = this.time += t,
                            r = Math.sign(t),
                            s = this._accuIndex ^= 1;
                        for (let o = 0; o !== n; ++o) e[o]._update(i, t, r, s);
                        const o = this._bindings,
                            a = this._nActiveBindings;
                        for (let t = 0; t !== a; ++t) o[t].apply(s);
                        return this
                    }
                    setTime(t) { this.time = 0; for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0; return this.update(t) }
                    getRoot() { return this._root }
                    uncacheClip(t) {
                        const e = this._actions,
                            n = t.uuid,
                            i = this._actionsByClip,
                            r = i[n];
                        if (void 0 !== r) {
                            const t = r.knownActions;
                            for (let n = 0, i = t.length; n !== i; ++n) {
                                const i = t[n];
                                this._deactivateAction(i);
                                const r = i._cacheIndex,
                                    s = e[e.length - 1];
                                i._cacheIndex = null, i._byClipCacheIndex = null, s._cacheIndex = r, e[r] = s, e.pop(), this._removeInactiveBindingsForAction(i)
                            }
                            delete i[n]
                        }
                    }
                    uncacheRoot(t) {
                        const e = t.uuid,
                            n = this._actionsByClip;
                        for (const t in n) {
                            const i = n[t].actionByRoot[e];
                            void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                        }
                        const i = this._bindingsByRootAndName[e];
                        if (void 0 !== i)
                            for (const t in i) {
                                const e = i[t];
                                e.restoreOriginalState(), this._removeInactiveBinding(e)
                            }
                    }
                    uncacheAction(t, e) {
                        const n = this.existingAction(t, e);
                        null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                    }
                }
                hA.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
                class uA {
                    constructor(t) { "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t }
                    clone() { return new uA(void 0 === this.value.clone ? this.value : this.value.clone()) }
                }(class extends mS {
                    constructor(t, e, n = 1) { super(t, e), this.meshPerAttribute = n }
                    copy(t) { return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this }
                    clone(t) { const e = super.clone(t); return e.meshPerAttribute = this.meshPerAttribute, e }
                    toJSON(t) { const e = super.toJSON(t); return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e }
                }).prototype.isInstancedInterleavedBuffer = !0;
                const dA = new vx;
                class pA {
                    constructor(t = new vx(1 / 0, 1 / 0), e = new vx(-1 / 0, -1 / 0)) { this.min = t, this.max = e }
                    set(t, e) { return this.min.copy(t), this.max.copy(e), this }
                    setFromPoints(t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]); return this }
                    setFromCenterAndSize(t, e) { const n = dA.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { return this.min.copy(t.min), this.max.copy(t.max), this }
                    makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this }
                    isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y }
                    getCenter(t) { return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) }
                    getSize(t) { return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min) }
                    expandByPoint(t) { return this.min.min(t), this.max.max(t), this }
                    expandByVector(t) { return this.min.sub(t), this.max.add(t), this }
                    expandByScalar(t) { return this.min.addScalar(-t), this.max.addScalar(t), this }
                    containsPoint(t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y) }
                    containsBox(t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y }
                    getParameter(t, e) { return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y)) }
                    intersectsBox(t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y) }
                    clampPoint(t, e) { return e.copy(t).clamp(this.min, this.max) }
                    distanceToPoint(t) { return dA.copy(t).clamp(this.min, this.max).sub(t).length() }
                    intersect(t) { return this.min.max(t.min), this.max.min(t.max), this }
                    union(t) { return this.min.min(t.min), this.max.max(t.max), this }
                    translate(t) { return this.min.add(t), this.max.add(t), this }
                    equals(t) { return t.min.equals(this.min) && t.max.equals(this.max) }
                }
                pA.prototype.isBox2 = !0, class extends C_ { constructor(t) { super(), this.material = t, this.render = function() {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0 } }.prototype.isImmediateRenderObject = !0;
                const mA = new Lx,
                    fA = new s_,
                    gA = new s_;

                function vA(t) {
                    const e = [];
                    t && t.isBone && e.push(t);
                    for (let n = 0; n < t.children.length; n++) e.push.apply(e, vA(t.children[n]));
                    return e
                }
                const yA = new Float32Array(1);
                new Int32Array(yA.buffer), Math.pow(2, 8);
                const xA = [.125, .215, .35, .446, .526, .582],
                    _A = 5 + xA.length,
                    bA = new K_({ side: 1, depthWrite: !1, depthTest: !1 }),
                    { _lodPlanes: wA, _sizeLods: MA, _sigmas: SA } = (new Cb(new Ib, bA), TA());

                function TA() {
                    const t = [],
                        e = [],
                        n = [];
                    let i = 8;
                    for (let r = 0; r < _A; r++) {
                        const s = Math.pow(2, i);
                        e.push(s);
                        let o = 1 / s;
                        r > 4 ? o = xA[r - 8 + 4 - 1] : 0 == r && (o = 0), n.push(o);
                        const a = 1 / (s - 1),
                            l = -a / 2,
                            c = 1 + a / 2,
                            h = [l, l, c, l, c, c, l, l, c, c, l, c],
                            u = 6,
                            d = 6,
                            p = 3,
                            m = 2,
                            f = 1,
                            g = new Float32Array(p * d * u),
                            v = new Float32Array(m * d * u),
                            y = new Float32Array(f * d * u);
                        for (let t = 0; t < u; t++) {
                            const e = t % 3 * 2 / 3 - 1,
                                n = t > 2 ? 0 : -1,
                                i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                            g.set(i, p * d * t), v.set(h, m * d * t);
                            const r = [t, t, t, t, t, t];
                            y.set(r, f * d * t)
                        }
                        const x = new db;
                        x.setAttribute("position", new tb(g, p)), x.setAttribute("uv", new tb(v, m)), x.setAttribute("faceIndex", new tb(y, f)), t.push(x), i > 4 && i--
                    }
                    return { _lodPlanes: t, _sizeLods: e, _sigmas: n }
                }
                Math.sqrt(5), aT.create = function(t, e) { return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(aT.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t }, NE.prototype.fromPoints = function(t) { return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t) }, class extends KS {
                    constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
                        n = new J_(n), i = new J_(i);
                        const r = e / 2,
                            s = t / e,
                            o = t / 2,
                            a = [],
                            l = [];
                        for (let t = 0, c = 0, h = -o; t <= e; t++, h += s) {
                            a.push(-o, 0, h, o, 0, h), a.push(h, 0, -o, h, 0, o);
                            const e = t === r ? n : i;
                            e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3
                        }
                        const c = new db;
                        c.setAttribute("position", new ib(a, 3)), c.setAttribute("color", new ib(l, 3)), super(c, new GS({ vertexColors: !0, toneMapped: !1 })), this.type = "GridHelper"
                    }
                }.prototype.setColors = function() { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, class extends KS {
                    constructor(t) {
                        const e = vA(t),
                            n = new db,
                            i = [],
                            r = [],
                            s = new J_(0, 0, 1),
                            o = new J_(0, 1, 0);
                        for (let t = 0; t < e.length; t++) {
                            const n = e[t];
                            n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(o.r, o.g, o.b))
                        }
                        n.setAttribute("position", new ib(i, 3)), n.setAttribute("color", new ib(r, 3)), super(n, new GS({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
                    }
                    updateMatrixWorld(t) {
                        const e = this.bones,
                            n = this.geometry,
                            i = n.getAttribute("position");
                        gA.copy(this.root.matrixWorld).invert();
                        for (let t = 0, n = 0; t < e.length; t++) {
                            const r = e[t];
                            r.parent && r.parent.isBone && (fA.multiplyMatrices(gA, r.matrixWorld), mA.setFromMatrixPosition(fA), i.setXYZ(n, mA.x, mA.y, mA.z), fA.multiplyMatrices(gA, r.parent.matrixWorld), mA.setFromMatrixPosition(fA), i.setXYZ(n + 1, mA.x, mA.y, mA.z), n += 2)
                        }
                        n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
                    }
                }.prototype.update = function() { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, AE.prototype.extractUrlBase = function(t) {
                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), class {
                        static decodeText(t) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t); let e = ""; for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]); try { return decodeURIComponent(escape(e)) } catch (t) { return e } }
                        static extractUrlBase(t) { const e = t.lastIndexOf("/"); return -1 === e ? "./" : t.substr(0, e + 1) }
                    }.extractUrlBase(t)
                }, AE.Handlers = { add: function() { console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.") }, get: function() { console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.") } }, pA.prototype.center = function(t) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t) }, pA.prototype.empty = function() { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, pA.prototype.isIntersectionBox = function(t) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, pA.prototype.size = function(t) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t) }, Px.prototype.center = function(t) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, Px.prototype.empty = function() { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, Px.prototype.isIntersectionBox = function(t) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, Px.prototype.isIntersectionSphere = function(t) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) }, Px.prototype.size = function(t) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t) }, Jx.prototype.empty = function() { return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, Zb.prototype.setFromMatrix = function(t) { return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t) }, yx.prototype.flattenToArrayOffset = function(t, e) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, yx.prototype.multiplyVector3 = function(t) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, yx.prototype.multiplyVector3Array = function() { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, yx.prototype.applyToBufferAttribute = function(t) { return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, yx.prototype.applyToVector3Array = function() { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") }, yx.prototype.getInverse = function(t) { return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert() }, s_.prototype.extractPosition = function(t) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t) }, s_.prototype.flattenToArrayOffset = function(t, e) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, s_.prototype.getPosition = function() { return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Lx).setFromMatrixColumn(this, 3) }, s_.prototype.setRotationFromQuaternion = function(t) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t) }, s_.prototype.multiplyToArray = function() { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, s_.prototype.multiplyVector3 = function(t) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, s_.prototype.multiplyVector4 = function(t) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, s_.prototype.multiplyVector3Array = function() { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, s_.prototype.rotateAxis = function(t) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this) }, s_.prototype.crossVector = function(t) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, s_.prototype.translate = function() { console.error("THREE.Matrix4: .translate() has been removed.") }, s_.prototype.rotateX = function() { console.error("THREE.Matrix4: .rotateX() has been removed.") }, s_.prototype.rotateY = function() { console.error("THREE.Matrix4: .rotateY() has been removed.") }, s_.prototype.rotateZ = function() { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, s_.prototype.rotateByAxis = function() { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, s_.prototype.applyToBufferAttribute = function(t) { return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, s_.prototype.applyToVector3Array = function() { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, s_.prototype.makeFrustum = function(t, e, n, i, r, s) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, s) }, s_.prototype.getInverse = function(t) { return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert() }, qb.prototype.isIntersectionLine = function(t) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t) }, Ax.prototype.multiplyVector3 = function(t) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this) }, Ax.prototype.inverse = function() { return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert() }, r_.prototype.isIntersectionBox = function(t) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, r_.prototype.isIntersectionPlane = function(t) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t) }, r_.prototype.isIntersectionSphere = function(t) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) }, k_.prototype.area = function() { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, k_.prototype.barycoordFromPoint = function(t, e) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e) }, k_.prototype.midpoint = function(t) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t) }, k_.prototypenormal = function(t) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t) }, k_.prototype.plane = function(t) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t) }, k_.barycoordFromPoint = function(t, e, n, i, r) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), k_.getBarycoord(t, e, n, i, r) }, k_.normal = function(t, e, n, i) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), k_.getNormal(t, e, n, i) }, BE.prototype.extractAllPoints = function(t) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t) }, BE.prototype.extrude = function(t) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new $T(this, t) }, BE.prototype.makeGeometry = function(t) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new eE(this, t) }, vx.prototype.fromAttribute = function(t, e, n) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, vx.prototype.distanceToManhattan = function(t) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, vx.prototype.lengthManhattan = function() { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, Lx.prototype.setEulerFromRotationMatrix = function() { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, Lx.prototype.setEulerFromQuaternion = function() { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, Lx.prototype.getPositionFromMatrix = function(t) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t) }, Lx.prototype.getScaleFromMatrix = function(t) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t) }, Lx.prototype.getColumnFromMatrix = function(t, e) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t) }, Lx.prototype.applyProjection = function(t) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t) }, Lx.prototype.fromAttribute = function(t, e, n) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, Lx.prototype.distanceToManhattan = function(t) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, Lx.prototype.lengthManhattan = function() { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, Sx.prototype.fromAttribute = function(t, e, n) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, Sx.prototype.lengthManhattan = function() { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, C_.prototype.getChildByName = function(t) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t) }, C_.prototype.renderDepth = function() { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, C_.prototype.translate = function(t, e) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t) }, C_.prototype.getWorldRotation = function() { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") }, C_.prototype.applyMatrix = function(t) { return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) }, Object.defineProperties(C_.prototype, { eulerOrder: { get: function() { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function(t) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t } }, useQuaternion: { get: function() { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function() { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), Cb.prototype.setDrawMode = function() { console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") }, Object.defineProperties(Cb.prototype, { drawMode: { get: function() { return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0 }, set: function() { console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } } }), FS.prototype.initBones = function() { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, zb.prototype.setLens = function(t, e) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t) }, Object.defineProperties(OE.prototype, { onlyShadow: { set: function() { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function(t) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t } }, shadowCameraLeft: { set: function(t) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t } }, shadowCameraRight: { set: function(t) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t } }, shadowCameraTop: { set: function(t) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t } }, shadowCameraBottom: { set: function(t) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t } }, shadowCameraNear: { set: function(t) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t } }, shadowCameraFar: { set: function(t) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t } }, shadowCameraVisible: { set: function() { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function(t) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t } }, shadowDarkness: { set: function() { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function(t) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t } }, shadowMapHeight: { set: function(t) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t } } }), Object.defineProperties(tb.prototype, { length: { get: function() { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, dynamic: { get: function() { return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === ix }, set: function() { console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(ix) } } }), tb.prototype.setDynamic = function(t) { return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? ix : nx), this }, tb.prototype.copyIndicesArray = function() { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") }, tb.prototype.setArray = function() { console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, db.prototype.addIndex = function(t) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t) }, db.prototype.addAttribute = function(t, e) { return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new tb(arguments[1], arguments[2]))) }, db.prototype.addDrawCall = function(t, e, n) { void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e) }, db.prototype.clearDrawCalls = function() { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, db.prototype.computeOffsets = function() { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") }, db.prototype.removeAttribute = function(t) { return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t) }, db.prototype.applyMatrix = function(t) { return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) }, Object.defineProperties(db.prototype, { drawcalls: { get: function() { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function() { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), mS.prototype.setDynamic = function(t) { return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? ix : nx), this }, mS.prototype.setArray = function() { console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, $T.prototype.getArrays = function() { console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.") }, $T.prototype.addShapeList = function() { console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.") }, $T.prototype.addShape = function() { console.error("THREE.ExtrudeGeometry: .addShape() has been removed.") }, pS.prototype.dispose = function() { console.error("THREE.Scene: .dispose() has been removed.") }, uA.prototype.onUpdate = function() { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this }, Object.defineProperties(V_.prototype, { wrapAround: { get: function() { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function() { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function() { console.warn("THREE.Material: .overdraw has been removed.") }, set: function() { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function() { return console.warn("THREE.Material: .wrapRGB has been removed."), new J_ } }, shading: { get: function() { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function(t) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t } }, stencilMask: { get: function() { return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask }, set: function(t) { console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t } } }), Object.defineProperties(Ob.prototype, { derivatives: { get: function() { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function(t) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t } } }), hS.prototype.clearTarget = function(t, e, n, i) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i) }, hS.prototype.animate = function(t) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t) }, hS.prototype.getCurrentRenderTarget = function() { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, hS.prototype.getMaxAnisotropy = function() { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, hS.prototype.getPrecision = function() { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, hS.prototype.resetGLState = function() { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, hS.prototype.supportsFloatTextures = function() { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, hS.prototype.supportsHalfFloatTextures = function() { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, hS.prototype.supportsStandardDerivatives = function() { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, hS.prototype.supportsCompressedTextureS3TC = function() { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, hS.prototype.supportsCompressedTexturePVRTC = function() { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, hS.prototype.supportsBlendMinMax = function() { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, hS.prototype.supportsVertexTextures = function() { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, hS.prototype.supportsInstancedArrays = function() { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, hS.prototype.enableScissorTest = function(t) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t) }, hS.prototype.initMaterial = function() { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, hS.prototype.addPrePlugin = function() { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, hS.prototype.addPostPlugin = function() { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, hS.prototype.updateShadowMap = function() { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, hS.prototype.setFaceCulling = function() { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, hS.prototype.allocTextureUnit = function() { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, hS.prototype.setTexture = function() { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, hS.prototype.setTexture2D = function() { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, hS.prototype.setTextureCube = function() { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") }, hS.prototype.getActiveMipMapLevel = function() { return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel() }, Object.defineProperties(hS.prototype, { shadowMapEnabled: { get: function() { return this.shadowMap.enabled }, set: function(t) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t } }, shadowMapType: { get: function() { return this.shadowMap.type }, set: function(t) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t } }, shadowMapCullFace: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } }, context: { get: function() { return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext() } }, vr: { get: function() { return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr } }, gammaInput: { get: function() { return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1 }, set: function() { console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.") } }, gammaOutput: { get: function() { return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1 }, set: function(t) { console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? 3001 : tx } }, toneMappingWhitePoint: { get: function() { return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1 }, set: function() { console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.") } } }), Object.defineProperties(tS.prototype, { cullFace: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(Tx.prototype, { wrapS: { get: function() { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t } }, wrapT: { get: function() { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t } }, magFilter: { get: function() { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t } }, minFilter: { get: function() { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t } }, anisotropy: { get: function() { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t } }, offset: { get: function() { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t } }, repeat: { get: function() { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t } }, format: { get: function() { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t } }, type: { get: function() { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t } }, generateMipmaps: { get: function() { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t } } }), class extends C_ {
                    constructor(t) { super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] }
                    getOutput() { return this.gain }
                    setNodeSource(t) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this }
                    setMediaElementSource(t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this }
                    setMediaStreamSource(t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this }
                    setBuffer(t) { return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this }
                    play(t = 0) {
                        if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                        if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                        this._startedAt = this.context.currentTime + t;
                        const e = this.context.createBufferSource();
                        return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                    }
                    pause() {
                        if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    stop() {
                        if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    connect() {
                        if (this.filters.length > 0) {
                            this.source.connect(this.filters[0]);
                            for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                            this.filters[this.filters.length - 1].connect(this.getOutput())
                        } else this.source.connect(this.getOutput());
                        return this._connected = !0, this
                    }
                    disconnect() {
                        if (this.filters.length > 0) {
                            this.source.disconnect(this.filters[0]);
                            for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                            this.filters[this.filters.length - 1].disconnect(this.getOutput())
                        } else this.source.disconnect(this.getOutput());
                        return this._connected = !1, this
                    }
                    getFilters() { return this.filters }
                    setFilters(t) { return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this }
                    setDetune(t) { if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this }
                    getDetune() { return this.detune }
                    getFilter() { return this.getFilters()[0] }
                    setFilter(t) { return this.setFilters(t ? [t] : []) }
                    setPlaybackRate(t) {
                        if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    getPlaybackRate() { return this.playbackRate }
                    onEnded() { this.isPlaying = !1 }
                    getLoop() { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop }
                    setLoop(t) {
                        if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    setLoopStart(t) { return this.loopStart = t, this }
                    setLoopEnd(t) { return this.loopEnd = t, this }
                    getVolume() { return this.gain.gain.value }
                    setVolume(t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this }
                }.prototype.load = function(t) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); const e = this; return (new KE).load(t, (function(t) { e.setBuffer(t) })), this }, Hb.prototype.updateCubeMap = function(t, e) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e) }, Hb.prototype.clear = function(t, e, n, i) { return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, i) }, _x.crossOrigin = void 0, _x.loadTexture = function(t, e, n, i) {
                    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                    const r = new IE;
                    r.setCrossOrigin(this.crossOrigin);
                    const s = r.load(t, n, void 0, i);
                    return e && (s.mapping = e), s
                }, _x.loadTextureCube = function(t, e, n, i) {
                    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                    const r = new PE;
                    r.setCrossOrigin(this.crossOrigin);
                    const s = r.load(t, n, void 0, i);
                    return e && (s.mapping = e), s
                }, _x.loadCompressedTexture = function() { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, _x.loadCompressedTextureCube = function() { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "130" } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "130");
                class EA extends Cb {
                    constructor(t, e) { super(t, e), this.isExtendedMesh = !0, this.isGroup = !1, this.vector3 = new Lx, this.hasBody = !1, this.fragmentDepth = 0, this.breakable = !1, this.fractureImpulse = 1, this.name = `object-${this.id}` }
                    get world() { return { theta: this.worldTheta, phi: this.worldPhi } }
                    get worldTheta() { return this.getWorldDirection(this.vector3), Math.atan2(this.vector3.x, this.vector3.z) }
                    get worldPhi() { return this.getWorldDirection(this.vector3), Math.acos(this.vector3.y) }
                }
                const AA = new Map,
                    LA = (t, e = !1) => {
                        if (AA.has(t)) {
                            const e = AA.get(t);
                            if (void 0 === e) return;
                            if (e >= 5) return;
                            AA.set(t, e + 1)
                        } else AA.set(t, 1);
                        e ? console.error(`%c [enable3d] ${t} `, "background: #222; color: #bada55") : console.warn(`%c [enable3d] ${t} `, "background: #222; color: #bada55")
                    },
                    RA = class {
                        constructor() { this._defaultMaterial = new cE({ color: 13421772 }) }
                        get() { return this._defaultMaterial }
                    };
                var CA = function(t, e) { var n = {}; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (n[i] = t[i]); if (null != t && "function" == typeof Object.getOwnPropertySymbols) { var r = 0; for (i = Object.getOwnPropertySymbols(t); r < i.length; r++) e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[r]) && (n[i[r]] = t[i[r]]) } return n };
                class PA {
                    constructor(t) { this.scene = t, this.isHeadless = "headless" === t, this.defaultMaterial = new RA }
                    get make() { return { plane: (t = {}, e = {}) => this.makePlane(t, e), box: (t = {}, e = {}) => this.makeBox(t, e), sphere: (t = {}, e = {}) => this.makeSphere(t, e), cylinder: (t = {}, e = {}) => this.makeCylinder(t, e), cone: (t = {}, e = {}) => this.makeCone(t, e), torus: (t = {}, e = {}) => this.makeTorus(t, e), extrude: (t, e = {}) => this.makeExtrude(t, e) } }
                    get add() { return { mesh: t => this.addMesh(t), existing: t => this.addExisting(t), plane: (t = {}, e = {}) => this.addPlane(t, e), box: (t = {}, e = {}) => this.addBox(t, e), ground: (t, e = {}) => this.addGround(t, e), sphere: (t = {}, e = {}) => this.addSphere(t, e), cylinder: (t = {}, e = {}) => this.addCylinder(t, e), cone: (t = {}, e = {}) => this.addCone(t, e), torus: (t = {}, e = {}) => this.addTorus(t, e), extrude: (t, e = {}) => this.addExtrude(t, e), material: (t = {}) => this.addMaterial(t) } }
                    addExisting(...t) { "headless" !== this.scene && this.scene.add(...t) }
                    addMesh(t) {
                        if (Array.isArray(t))
                            for (let e = 0; e < t.length; e++) this.addExisting(t[e]);
                        else this.addExisting(t);
                        return this
                    }
                    createMesh(t, e, n) {
                        const { x: i = 0, y: r = 0, z: s = 0 } = n;
                        let o;
                        switch (!Array.isArray(e) && e.type) {
                            case "LineBasicMaterial":
                                o = new YS(t, e);
                                break;
                            case "PointsMaterial":
                                o = new iT(t, e);
                                break;
                            default:
                                o = new EA(t, e)
                        }
                        return o.position.set(i, r, s), o.castShadow = o.receiveShadow = !0, o
                    }
                    makeExtrude(t, e) { const { x: n, y: i, z: r, name: s, shape: o, autoCenter: a = !0, breakable: l = !1 } = t, c = CA(t, ["x", "y", "z", "name", "shape", "autoCenter", "breakable"]), { depth: h = 1, bevelEnabled: u = !1 } = c, d = new $T(o, Object.assign({ depth: h, bevelEnabled: u }, c)), p = this.addMaterial(e), m = this.createMesh(d, p, { x: n, y: i, z: r }); return a && m.geometry.center(), m.name = s || `body_id_${m.id}`, m.shape = "extrude", m }
                    addExtrude(t, e = {}) { const n = this.makeExtrude(t, e); return this.addExisting(n), n }
                    makePlane(t, e) {
                        const { x: n, y: i, z: r, name: s, breakable: o = !1 } = t, a = CA(t, ["x", "y", "z", "name", "breakable"]), l = new Qb(a.width || 1, a.height || 1, a.widthSegments || 1, a.heightSegments || 1), c = this.addMaterial(e);
                        c.side = 2;
                        const h = this.createMesh(l, c, { x: n, y: i, z: r });
                        return h.name = s || `body_id_${h.id}`, h.shape = "plane", h
                    }
                    addPlane(t, e) { const n = this.makePlane(t, e); return this.addExisting(n), n }
                    makeSphere(t, e) { const { x: n, y: i, z: r, name: s, breakable: o = !1 } = t, a = CA(t, ["x", "y", "z", "name", "breakable"]), l = new nE(a.radius || 1, a.widthSegments || 16, a.heightSegments || 12, a.phiStart || void 0, a.phiLength || void 0, a.thetaStart || void 0, a.thetaLength || void 0), c = this.addMaterial(e), h = this.createMesh(l, c, { x: n, y: i, z: r }); return h.name = s || `body_id_${h.id}`, h.shape = "sphere", h }
                    addSphere(t = {}, e = {}) { const n = this.makeSphere(t, e); return this.addExisting(n), n }
                    makeBox(t, e) { const { x: n, y: i, z: r, name: s, breakable: o = !1 } = t, a = CA(t, ["x", "y", "z", "name", "breakable"]), l = new Ib(a.width || 1, a.height || 1, a.depth || 1, a.widthSegments || void 0, a.heightSegments || void 0, a.depthSegments || void 0), c = this.addMaterial(e), h = this.createMesh(l, c, { x: n, y: i, z: r }); return h.name = s || `body_id_${h.id}`, h.shape = "box", h }
                    addBox(t = {}, e = {}) { const n = this.makeBox(t, e); return this.addExisting(n), n }
                    addGround(t, e = {}) { const n = this.makeBox(t, e); return n.rotateX(gx.degToRad(90)), this.addExisting(n), n }
                    makeCylinder(t = {}, e = {}) { const { x: n, y: i, z: r, name: s, breakable: o = !1 } = t, a = CA(t, ["x", "y", "z", "name", "breakable"]), l = new sT(a.radiusTop || 1, a.radiusBottom || 1, a.height || 1, a.radiusSegments || void 0, a.heightSegments || void 0, a.openEnded || void 0, a.thetaStart || void 0, a.thetaLength || void 0), c = this.addMaterial(e), h = this.createMesh(l, c, { x: n, y: i, z: r }); return h.name = s || `body_id_${h.id}`, h.shape = "cylinder", h }
                    addCylinder(t = {}, e = {}) { const n = this.makeCylinder(t, e); return this.addExisting(n), n }
                    makeCone(t = {}, e = {}) { const { x: n, y: i, z: r, name: s, breakable: o = !1 } = t, a = CA(t, ["x", "y", "z", "name", "breakable"]), l = new oT(a.radius || 1, a.height || 1, a.radiusSegments || 8, a.heightSegments || 1, a.openEnded || !1, a.thetaStart || 0, a.thetaLength || 2 * Math.PI), c = this.addMaterial(e), h = this.createMesh(l, c, { x: n, y: i, z: r }); return h.name = s || `body_id_${h.id}`, h.shape = "cone", h }
                    addCone(t = {}, e = {}) { const n = this.makeCone(t, e); return this.addExisting(n), n }
                    makeTorus(t = {}, e = {}) { const { x: n, y: i, z: r, name: s, breakable: o = !1 } = t, a = CA(t, ["x", "y", "z", "name", "breakable"]), l = new iE(a.radius || void 0, a.tube || void 0, a.radialSegments || void 0, a.tubularSegments || void 0, a.arc || void 0), c = this.addMaterial(e), h = this.createMesh(l, c, { x: n, y: i, z: r }); return h.name = s || `body_id_${h.id}`, h.shape = "torus", h }
                    addTorus(t = {}, e = {}) { const n = this.makeTorus(t, e); return this.addExisting(n), n }
                    addMaterial(t = {}) {
                        const e = Object.keys(t)[0];
                        let n;
                        if ("headless" === this.scene) return this.defaultMaterial.get();
                        switch (e) {
                            case "basic":
                                n = new K_(t.basic);
                                break;
                            case "normal":
                                n = new lE(t.normal);
                                break;
                            case "standard":
                                n = new rE(t.standard);
                                break;
                            case "lambert":
                                n = new cE(t.lambert);
                                break;
                            case "phong":
                                n = new oE(t.phong);
                                break;
                            case "physical":
                                void 0 !== t.physical ? n = new sE(t.physical) : (LA("You need to pass parameters to the physical material. (Fallback to default material)"), n = this.defaultMaterial.get());
                                break;
                            case "toon":
                                n = new aE(t.toon);
                                break;
                            case "line":
                                n = new GS(t.line);
                                break;
                            case "points":
                                n = new QS(t.points);
                                break;
                            case "custom":
                                n = t.custom || this.defaultMaterial.get();
                                break;
                            default:
                                n = this.defaultMaterial.get()
                        }
                        return n
                    }
                }
                class IA {
                    constructor(t) { this.scene = t }
                    add(t, e = {}) { const n = this.make(t, e); return n ? this.scene.add(n) : console.warn("Could not make heightmap"), n }
                    make(t, e = {}) {
                        const { image: n } = t, { width: i, height: r } = n, { colorScale: s } = e, o = document.createElement("canvas");
                        o.width = i, o.height = r;
                        const a = o.getContext("2d");
                        if (!a) return;
                        a.drawImage(t.image, 0, 0);
                        const l = a.getImageData(0, 0, i, r),
                            c = (new Fm).fromBufferGeometry(new Ws(10, 10, i - 1, r - 1));
                        let h = { color: 13421772, side: _ };
                        s && (h = Object.assign(Object.assign({}, h), { vertexColors: !0 }));
                        const u = new Fh(h),
                            d = new EA(c, u);
                        d.receiveShadow = d.castShadow = !0, d.shape = "concave";
                        const p = d.geometry;
                        for (let t = 0; t < p.vertices.length; t++) p.vertices[t].z = l.data[4 * t] / 120;
                        return s && p.faces.forEach((t => t.color = new Dr(s(((t, e) => {
                            var n = t.vertices[e.a].z,
                                i = t.vertices[e.b].z,
                                r = t.vertices[e.c].z;
                            return Math.max(n, i, r)
                        })(p, t)).hex()))), d.rotateX(-Math.PI / 2), d.updateMatrix(), c.computeFaceNormals(), c.computeVertexNormals(), d.name = "heightmap", d.geometry = Vm(new rs, d.geometry), d
                    }
                }
                const DA = { type: "change" },
                    NA = { type: "start" },
                    BA = { type: "end" };
                class OA extends Hn {
                    constructor(t, e) {
                        super(), void 0 === e && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), e === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = t, this.domElement = e, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new ui, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: l.ROTATE, MIDDLE: l.DOLLY, RIGHT: l.PAN }, this.touches = { ONE: c.ROTATE, TWO: c.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function() { return o.phi }, this.getAzimuthalAngle = function() { return o.theta }, this.listenToKeyEvents = function(t) { t.addEventListener("keydown", j), this._domElementKeyEvents = t }, this.saveState = function() { n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom }, this.reset = function() { n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(DA), n.update(), r = i.NONE }, this.update = function() {
                            const e = new ui,
                                l = (new hi).setFromUnitVectors(t.up, new ui(0, 1, 0)),
                                c = l.clone().invert(),
                                p = new ui,
                                m = new hi,
                                f = 2 * Math.PI;
                            return function() {
                                const t = n.object.position;
                                e.copy(t).sub(n.target), e.applyQuaternion(l), o.setFromVector3(e), n.autoRotate && r === i.NONE && T(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), n.enableDamping ? (o.theta += a.theta * n.dampingFactor, o.phi += a.phi * n.dampingFactor) : (o.theta += a.theta, o.phi += a.phi);
                                let g = n.minAzimuthAngle,
                                    v = n.maxAzimuthAngle;
                                return isFinite(g) && isFinite(v) && (g < -Math.PI ? g += f : g > Math.PI && (g -= f), v < -Math.PI ? v += f : v > Math.PI && (v -= f), o.theta = g <= v ? Math.max(g, Math.min(v, o.theta)) : o.theta > (g + v) / 2 ? Math.max(g, o.theta) : Math.min(v, o.theta)), o.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, o.phi)), o.makeSafe(), o.radius *= h, o.radius = Math.max(n.minDistance, Math.min(n.maxDistance, o.radius)), !0 === n.enableDamping ? n.target.addScaledVector(u, n.dampingFactor) : n.target.add(u), e.setFromSpherical(o), e.applyQuaternion(c), t.copy(n.target).add(e), n.object.lookAt(n.target), !0 === n.enableDamping ? (a.theta *= 1 - n.dampingFactor, a.phi *= 1 - n.dampingFactor, u.multiplyScalar(1 - n.dampingFactor)) : (a.set(0, 0, 0), u.set(0, 0, 0)), h = 1, !!(d || p.distanceToSquared(n.object.position) > s || 8 * (1 - m.dot(n.object.quaternion)) > s) && (n.dispatchEvent(DA), p.copy(n.object.position), m.copy(n.object.quaternion), d = !1, !0)
                            }
                        }(), this.dispose = function() { n.domElement.removeEventListener("contextmenu", q), n.domElement.removeEventListener("pointerdown", H), n.domElement.removeEventListener("pointercancel", V), n.domElement.removeEventListener("wheel", W), n.domElement.ownerDocument.removeEventListener("pointermove", k), n.domElement.ownerDocument.removeEventListener("pointerup", G), null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", j) };
                        const n = this,
                            i = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 };
                        let r = i.NONE;
                        const s = 1e-6,
                            o = new Gd,
                            a = new Gd;
                        let h = 1;
                        const u = new ui;
                        let d = !1;
                        const p = new $n,
                            m = new $n,
                            f = new $n,
                            g = new $n,
                            v = new $n,
                            y = new $n,
                            x = new $n,
                            _ = new $n,
                            b = new $n,
                            w = [],
                            M = {};

                        function S() { return Math.pow(.95, n.zoomSpeed) }

                        function T(t) { a.theta -= t }

                        function E(t) { a.phi -= t }
                        const A = function() { const t = new ui; return function(e, n) { t.setFromMatrixColumn(n, 0), t.multiplyScalar(-e), u.add(t) } }(),
                            L = function() { const t = new ui; return function(e, i) {!0 === n.screenSpacePanning ? t.setFromMatrixColumn(i, 1) : (t.setFromMatrixColumn(i, 0), t.crossVectors(n.object.up, t)), t.multiplyScalar(e), u.add(t) } }(),
                            R = function() {
                                const t = new ui;
                                return function(e, i) {
                                    const r = n.domElement;
                                    if (n.object.isPerspectiveCamera) {
                                        const s = n.object.position;
                                        t.copy(s).sub(n.target);
                                        let o = t.length();
                                        o *= Math.tan(n.object.fov / 2 * Math.PI / 180), A(2 * e * o / r.clientHeight, n.object.matrix), L(2 * i * o / r.clientHeight, n.object.matrix)
                                    } else n.object.isOrthographicCamera ? (A(e * (n.object.right - n.object.left) / n.object.zoom / r.clientWidth, n.object.matrix), L(i * (n.object.top - n.object.bottom) / n.object.zoom / r.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1)
                                }
                            }();

                        function C(t) { n.object.isPerspectiveCamera ? h /= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * t)), n.object.updateProjectionMatrix(), d = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1) }

                        function P(t) { n.object.isPerspectiveCamera ? h *= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / t)), n.object.updateProjectionMatrix(), d = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1) }

                        function I(t) { p.set(t.clientX, t.clientY) }

                        function D(t) { g.set(t.clientX, t.clientY) }

                        function N() {
                            if (1 === w.length) p.set(w[0].pageX, w[0].pageY);
                            else {
                                const t = .5 * (w[0].pageX + w[1].pageX),
                                    e = .5 * (w[0].pageY + w[1].pageY);
                                p.set(t, e)
                            }
                        }

                        function B() {
                            if (1 === w.length) g.set(w[0].pageX, w[0].pageY);
                            else {
                                const t = .5 * (w[0].pageX + w[1].pageX),
                                    e = .5 * (w[0].pageY + w[1].pageY);
                                g.set(t, e)
                            }
                        }

                        function O() {
                            const t = w[0].pageX - w[1].pageX,
                                e = w[0].pageY - w[1].pageY,
                                n = Math.sqrt(t * t + e * e);
                            x.set(0, n)
                        }

                        function F(t) {
                            if (1 == w.length) m.set(t.pageX, t.pageY);
                            else {
                                const e = Z(t),
                                    n = .5 * (t.pageX + e.x),
                                    i = .5 * (t.pageY + e.y);
                                m.set(n, i)
                            }
                            f.subVectors(m, p).multiplyScalar(n.rotateSpeed);
                            const e = n.domElement;
                            T(2 * Math.PI * f.x / e.clientHeight), E(2 * Math.PI * f.y / e.clientHeight), p.copy(m)
                        }

                        function z(t) {
                            if (1 === w.length) v.set(t.pageX, t.pageY);
                            else {
                                const e = Z(t),
                                    n = .5 * (t.pageX + e.x),
                                    i = .5 * (t.pageY + e.y);
                                v.set(n, i)
                            }
                            y.subVectors(v, g).multiplyScalar(n.panSpeed), R(y.x, y.y), g.copy(v)
                        }

                        function U(t) {
                            const e = Z(t),
                                i = t.pageX - e.x,
                                r = t.pageY - e.y,
                                s = Math.sqrt(i * i + r * r);
                            _.set(0, s), b.set(0, Math.pow(_.y / x.y, n.zoomSpeed)), C(b.y), x.copy(_)
                        }

                        function H(t) {
                            !1 !== n.enabled && (0 === w.length && (n.domElement.ownerDocument.addEventListener("pointermove", k), n.domElement.ownerDocument.addEventListener("pointerup", G)), function(t) { w.push(t) }(t), "touch" === t.pointerType ? function(t) {
                                switch (Y(t), w.length) {
                                    case 1:
                                        switch (n.touches.ONE) {
                                            case c.ROTATE:
                                                if (!1 === n.enableRotate) return;
                                                N(), r = i.TOUCH_ROTATE;
                                                break;
                                            case c.PAN:
                                                if (!1 === n.enablePan) return;
                                                B(), r = i.TOUCH_PAN;
                                                break;
                                            default:
                                                r = i.NONE
                                        }
                                        break;
                                    case 2:
                                        switch (n.touches.TWO) {
                                            case c.DOLLY_PAN:
                                                if (!1 === n.enableZoom && !1 === n.enablePan) return;
                                                n.enableZoom && O(), n.enablePan && B(), r = i.TOUCH_DOLLY_PAN;
                                                break;
                                            case c.DOLLY_ROTATE:
                                                if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                                                n.enableZoom && O(), n.enableRotate && N(), r = i.TOUCH_DOLLY_ROTATE;
                                                break;
                                            default:
                                                r = i.NONE
                                        }
                                        break;
                                    default:
                                        r = i.NONE
                                }
                                r !== i.NONE && n.dispatchEvent(NA)
                            }(t) : function(t) {
                                let e;
                                switch (t.button) {
                                    case 0:
                                        e = n.mouseButtons.LEFT;
                                        break;
                                    case 1:
                                        e = n.mouseButtons.MIDDLE;
                                        break;
                                    case 2:
                                        e = n.mouseButtons.RIGHT;
                                        break;
                                    default:
                                        e = -1
                                }
                                switch (e) {
                                    case l.DOLLY:
                                        if (!1 === n.enableZoom) return;
                                        ! function(t) { x.set(t.clientX, t.clientY) }(t), r = i.DOLLY;
                                        break;
                                    case l.ROTATE:
                                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                                            if (!1 === n.enablePan) return;
                                            D(t), r = i.PAN
                                        } else {
                                            if (!1 === n.enableRotate) return;
                                            I(t), r = i.ROTATE
                                        }
                                        break;
                                    case l.PAN:
                                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                                            if (!1 === n.enableRotate) return;
                                            I(t), r = i.ROTATE
                                        } else {
                                            if (!1 === n.enablePan) return;
                                            D(t), r = i.PAN
                                        }
                                        break;
                                    default:
                                        r = i.NONE
                                }
                                r !== i.NONE && n.dispatchEvent(NA)
                            }(t))
                        }

                        function k(t) {
                            !1 !== n.enabled && ("touch" === t.pointerType ? function(t) {
                                switch (Y(t), r) {
                                    case i.TOUCH_ROTATE:
                                        if (!1 === n.enableRotate) return;
                                        F(t), n.update();
                                        break;
                                    case i.TOUCH_PAN:
                                        if (!1 === n.enablePan) return;
                                        z(t), n.update();
                                        break;
                                    case i.TOUCH_DOLLY_PAN:
                                        if (!1 === n.enableZoom && !1 === n.enablePan) return;
                                        ! function(t) { n.enableZoom && U(t), n.enablePan && z(t) }(t), n.update();
                                        break;
                                    case i.TOUCH_DOLLY_ROTATE:
                                        if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                                        ! function(t) { n.enableZoom && U(t), n.enableRotate && F(t) }(t), n.update();
                                        break;
                                    default:
                                        r = i.NONE
                                }
                            }(t) : function(t) {
                                if (!1 !== n.enabled) switch (r) {
                                    case i.ROTATE:
                                        if (!1 === n.enableRotate) return;
                                        ! function(t) {
                                            m.set(t.clientX, t.clientY), f.subVectors(m, p).multiplyScalar(n.rotateSpeed);
                                            const e = n.domElement;
                                            T(2 * Math.PI * f.x / e.clientHeight), E(2 * Math.PI * f.y / e.clientHeight), p.copy(m), n.update()
                                        }(t);
                                        break;
                                    case i.DOLLY:
                                        if (!1 === n.enableZoom) return;
                                        ! function(t) { _.set(t.clientX, t.clientY), b.subVectors(_, x), b.y > 0 ? C(S()) : b.y < 0 && P(S()), x.copy(_), n.update() }(t);
                                        break;
                                    case i.PAN:
                                        if (!1 === n.enablePan) return;
                                        ! function(t) { v.set(t.clientX, t.clientY), y.subVectors(v, g).multiplyScalar(n.panSpeed), R(y.x, y.y), g.copy(v), n.update() }(t)
                                }
                            }(t))
                        }

                        function G(t) {!1 !== n.enabled && (t.pointerType, n.dispatchEvent(BA), r = i.NONE, X(t), 0 === w.length && (n.domElement.ownerDocument.removeEventListener("pointermove", k), n.domElement.ownerDocument.removeEventListener("pointerup", G))) }

                        function V(t) { X(t) }

                        function W(t) {!1 === n.enabled || !1 === n.enableZoom || r !== i.NONE && r !== i.ROTATE || (t.preventDefault(), n.dispatchEvent(NA), function(t) { t.deltaY < 0 ? P(S()) : t.deltaY > 0 && C(S()), n.update() }(t), n.dispatchEvent(BA)) }

                        function j(t) {
                            !1 !== n.enabled && !1 !== n.enablePan && function(t) {
                                let e = !1;
                                switch (t.code) {
                                    case n.keys.UP:
                                        R(0, n.keyPanSpeed), e = !0;
                                        break;
                                    case n.keys.BOTTOM:
                                        R(0, -n.keyPanSpeed), e = !0;
                                        break;
                                    case n.keys.LEFT:
                                        R(n.keyPanSpeed, 0), e = !0;
                                        break;
                                    case n.keys.RIGHT:
                                        R(-n.keyPanSpeed, 0), e = !0
                                }
                                e && (t.preventDefault(), n.update())
                            }(t)
                        }

                        function q(t) {!1 !== n.enabled && t.preventDefault() }

                        function X(t) {
                            delete M[t.pointerId];
                            for (let e = 0; e < w.length; e++)
                                if (w[e].pointerId == t.pointerId) return void w.splice(e, 1)
                        }

                        function Y(t) {
                            let e = M[t.pointerId];
                            void 0 === e && (e = new $n, M[t.pointerId] = e), e.set(t.pageX, t.pageY)
                        }

                        function Z(t) { const e = t.pointerId === w[0].pointerId ? w[1] : w[0]; return M[e.pointerId] }
                        n.domElement.addEventListener("contextmenu", q), n.domElement.addEventListener("pointerdown", H), n.domElement.addEventListener("pointercancel", V), n.domElement.addEventListener("wheel", W, { passive: !1 }), this.update()
                    }
                }
                class FA {
                    constructor(t, e, n, i, r, s, o) { this.scene = t, this.renderer = e, this.camera = n, this.lights = i, this.physics = r, this.load = s, this.factories = o }
                    warpSpeed(...t) {
                        return e = this, n = void 0, r = function*() {
                            let e = {};
                            const n = t.filter((t => /^-\w+/.test(t))),
                                i = n.length > 0;
                            if ((0 === t.length || i) && (t = ["light", "camera", "lookAtCenter", "ground", "grid", "orbitControls", "fog", "sky"]), i && n.map((t => t.substr(1))).forEach((e => {
                                    const n = t.indexOf(e);
                                    t.splice(n, 1)
                                })), t.includes("sky")) {
                                const t = ["varying vec3 vWorldPosition;", "", "void main() {", "", "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "vWorldPosition = worldPosition.xyz;", "", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "", "}"].join("\n"),
                                    e = ["uniform vec3 topColor;", "uniform vec3 bottomColor;", "uniform float offset;", "uniform float exponent;", "", "varying vec3 vWorldPosition;", "", "void main() {", "", "float h = normalize( vWorldPosition + offset ).y;", "gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );", "", "}"].join("\n"),
                                    n = { topColor: { value: new Dr(30719) }, bottomColor: { value: new Dr(15595007) }, offset: { value: 33 }, exponent: { value: .6 } };
                                var r = new Th(500, 32, 15),
                                    s = new Ls({ uniforms: n, vertexShader: t, fragmentShader: e, side: x }),
                                    o = new ws(r, s);
                                this.scene.add(o)
                            }
                            if (t.includes("camera") && (this.camera.position.set(0, 6, 12), e = Object.assign({ camera: this.camera }, e)), t.includes("light")) {
                                const t = .4,
                                    n = this.lights.hemisphereLight({ skyColor: 16777215, groundColor: 0, intensity: t }),
                                    i = this.lights.ambientLight({ color: 16777215, intensity: t }),
                                    r = this.lights.directionalLight({ color: 16777215, intensity: t });
                                r.position.set(100, 200, 50);
                                const s = 20;
                                r.shadow.camera.top = s, r.shadow.camera.bottom = -s, r.shadow.camera.left = -s, r.shadow.camera.right = s, r.shadow.mapSize.set(1024, 1024);
                                const o = { ambientLight: i, directionalLight: r, hemisphereLight: n };
                                e = Object.assign({ lights: o }, e)
                            }
                            if (t.includes("lookAtCenter") && this.camera.lookAt(this.scene.position), t.includes("ground")) {
                                const n = t.includes("grid"),
                                    i = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOnAAADusBZ+q87AAAAJtJREFUeJzt0EENwDAAxLDbNP6UOxh+NEYQ5dl2drFv286598GrA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAu37AD8eaBH5JQdVbAAAAAElFTkSuQmCC",
                                    r = yield this.load.texture(i);
                                r.wrapS = r.wrapT = ft, r.repeat.set(21, 21);
                                const s = { name: "ground", width: 21, height: 21, depth: 1, y: -.5 },
                                    o = { phong: { map: n ? r : null, color: 16777215 } };
                                let a;
                                window.__loadPhysics ? (a = this.physics.add.ground(s, o), a.body.setRestitution(1)) : a = this.factories.add.ground(s, o), a.receiveShadow = !0, e = Object.assign({ ground: a }, e)
                            }
                            if (t.includes("orbitControls")) {
                                const t = new OA(this.camera, document.getElementById("enable3d-phaser-canvas") || this.renderer.domElement);
                                e = Object.assign({ orbitControls: t }, e)
                            }
                            return e
                        }, new((i = void 0) || (i = Promise))((function(t, s) {
                            function o(t) { try { l(r.next(t)) } catch (t) { s(t) } }

                            function a(t) { try { l(r.throw(t)) } catch (t) { s(t) } }

                            function l(e) {
                                var n;
                                e.done ? t(e.value) : (n = e.value, n instanceof i ? n : new i((function(t) { t(n) }))).then(o, a)
                            }
                            l((r = r.apply(e, n || [])).next())
                        }));
                        var e, n, i, r
                    }
                }
                class zA extends ws {
                    constructor(t, e = {}) {
                        super(t), this.type = "Reflector";
                        const n = this,
                            i = void 0 !== e.color ? new Dr(e.color) : new Dr(8355711),
                            r = e.textureWidth || 512,
                            s = e.textureHeight || 512,
                            o = e.clipBias || 0,
                            a = e.shader || zA.ReflectorShader,
                            l = new zs,
                            c = new ui,
                            h = new ui,
                            u = new ui,
                            d = new Gi,
                            p = new ui(0, 0, -1),
                            m = new oi,
                            f = new ui,
                            g = new ui,
                            v = new oi,
                            y = new Gi,
                            x = new Cs,
                            _ = new ai(r, s, { minFilter: Mt, magFilter: Mt, format: kt });
                        Qn.isPowerOfTwo(r) && Qn.isPowerOfTwo(s) || (_.texture.generateMipmaps = !1);
                        const b = new Ls({ uniforms: As.clone(a.uniforms), fragmentShader: a.fragmentShader, vertexShader: a.vertexShader });
                        b.uniforms.tDiffuse.value = _.texture, b.uniforms.color.value = i, b.uniforms.textureMatrix.value = y, this.material = b, this.onBeforeRender = function(t, e, i) {
                            if (h.setFromMatrixPosition(n.matrixWorld), u.setFromMatrixPosition(i.matrixWorld), d.extractRotation(n.matrixWorld), c.set(0, 0, 1), c.applyMatrix4(d), f.subVectors(h, u), f.dot(c) > 0) return;
                            f.reflect(c).negate(), f.add(h), d.extractRotation(i.matrixWorld), p.set(0, 0, -1), p.applyMatrix4(d), p.add(u), g.subVectors(h, p), g.reflect(c).negate(), g.add(h), x.position.copy(f), x.up.set(0, 1, 0), x.up.applyMatrix4(d), x.up.reflect(c), x.lookAt(g), x.far = i.far, x.updateMatrixWorld(), x.projectionMatrix.copy(i.projectionMatrix), y.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), y.multiply(x.projectionMatrix), y.multiply(x.matrixWorldInverse), y.multiply(n.matrixWorld), l.setFromNormalAndCoplanarPoint(c, h), l.applyMatrix4(x.matrixWorldInverse), m.set(l.normal.x, l.normal.y, l.normal.z, l.constant);
                            const r = x.projectionMatrix;
                            v.x = (Math.sign(m.x) + r.elements[8]) / r.elements[0], v.y = (Math.sign(m.y) + r.elements[9]) / r.elements[5], v.z = -1, v.w = (1 + r.elements[10]) / r.elements[14], m.multiplyScalar(2 / m.dot(v)), r.elements[2] = m.x, r.elements[6] = m.y, r.elements[10] = m.z + 1 - o, r.elements[14] = m.w, _.texture.encoding = t.outputEncoding, n.visible = !1;
                            const s = t.getRenderTarget(),
                                a = t.xr.enabled,
                                b = t.shadowMap.autoUpdate;
                            t.xr.enabled = !1, t.shadowMap.autoUpdate = !1, t.setRenderTarget(_), t.state.buffers.depth.setMask(!0), !1 === t.autoClear && t.clear(), t.render(e, x), t.xr.enabled = a, t.shadowMap.autoUpdate = b, t.setRenderTarget(s);
                            const w = i.viewport;
                            void 0 !== w && t.state.viewport(w), n.visible = !0
                        }, this.getRenderTarget = function() { return _ }
                    }
                }
                zA.prototype.isReflector = !0, zA.ReflectorShader = { uniforms: { color: { value: null }, tDiffuse: { value: null }, textureMatrix: { value: null } }, vertexShader: "\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}", fragmentShader: "\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}" };
                class UA extends ws {
                    constructor(t, e = {}) {
                        super(t), this.type = "Refractor";
                        const n = this,
                            i = void 0 !== e.color ? new Dr(e.color) : new Dr(8355711),
                            r = e.textureWidth || 512,
                            s = e.textureHeight || 512,
                            o = e.clipBias || 0,
                            a = e.shader || UA.RefractorShader,
                            l = new Cs;
                        l.matrixAutoUpdate = !1, l.userData.refractor = !0;
                        const c = new zs,
                            h = new Gi,
                            u = new ai(r, s, { minFilter: Mt, magFilter: Mt, format: kt });
                        Qn.isPowerOfTwo(r) && Qn.isPowerOfTwo(s) || (u.texture.generateMipmaps = !1), this.material = new Ls({ uniforms: As.clone(a.uniforms), vertexShader: a.vertexShader, fragmentShader: a.fragmentShader, transparent: !0 }), this.material.uniforms.color.value = i, this.material.uniforms.tDiffuse.value = u.texture, this.material.uniforms.textureMatrix.value = h;
                        const d = function() {
                                const t = new ui,
                                    e = new ui,
                                    i = new Gi,
                                    r = new ui,
                                    s = new ui;
                                return function(o) { return t.setFromMatrixPosition(n.matrixWorld), e.setFromMatrixPosition(o.matrixWorld), r.subVectors(t, e), i.extractRotation(n.matrixWorld), s.set(0, 0, 1), s.applyMatrix4(i), r.dot(s) < 0 }
                            }(),
                            p = function() {
                                const t = new ui,
                                    e = new ui,
                                    i = new hi,
                                    r = new ui;
                                return function() { n.matrixWorld.decompose(e, i, r), t.set(0, 0, 1).applyQuaternion(i).normalize(), t.negate(), c.setFromNormalAndCoplanarPoint(t, e) }
                            }(),
                            m = function() {
                                const t = new zs,
                                    e = new oi,
                                    n = new oi;
                                return function(i) {
                                    l.matrixWorld.copy(i.matrixWorld), l.matrixWorldInverse.copy(l.matrixWorld).invert(), l.projectionMatrix.copy(i.projectionMatrix), l.far = i.far, t.copy(c), t.applyMatrix4(l.matrixWorldInverse), e.set(t.normal.x, t.normal.y, t.normal.z, t.constant);
                                    const r = l.projectionMatrix;
                                    n.x = (Math.sign(e.x) + r.elements[8]) / r.elements[0], n.y = (Math.sign(e.y) + r.elements[9]) / r.elements[5], n.z = -1, n.w = (1 + r.elements[10]) / r.elements[14], e.multiplyScalar(2 / e.dot(n)), r.elements[2] = e.x, r.elements[6] = e.y, r.elements[10] = e.z + 1 - o, r.elements[14] = e.w
                                }
                            }();
                        this.onBeforeRender = function(t, e, i) {
                            u.texture.encoding = t.outputEncoding, !0 !== i.userData.refractor && 1 != !d(i) && (p(), function(t) { h.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), h.multiply(t.projectionMatrix), h.multiply(t.matrixWorldInverse), h.multiply(n.matrixWorld) }(i), m(i), function(t, e, i) {
                                n.visible = !1;
                                const r = t.getRenderTarget(),
                                    s = t.xr.enabled,
                                    o = t.shadowMap.autoUpdate;
                                t.xr.enabled = !1, t.shadowMap.autoUpdate = !1, t.setRenderTarget(u), !1 === t.autoClear && t.clear(), t.render(e, l), t.xr.enabled = s, t.shadowMap.autoUpdate = o, t.setRenderTarget(r);
                                const a = i.viewport;
                                void 0 !== a && t.state.viewport(a), n.visible = !0
                            }(t, e, i))
                        }, this.getRenderTarget = function() { return u }
                    }
                }
                UA.prototype.isRefractor = !0, UA.RefractorShader = { uniforms: { color: { value: null }, tDiffuse: { value: null }, textureMatrix: { value: null } }, vertexShader: "\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}", fragmentShader: "\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}" };
                class HA extends ws {
                    constructor(t, e = {}) {
                        super(t), this.type = "Water";
                        const n = this,
                            i = void 0 !== e.color ? new Dr(e.color) : new Dr(16777215),
                            r = e.textureWidth || 512,
                            s = e.textureHeight || 512,
                            o = e.clipBias || 0,
                            a = e.flowDirection || new $n(1, 0),
                            l = e.flowSpeed || .03,
                            c = e.reflectivity || .02,
                            h = e.scale || 1,
                            u = e.shader || HA.WaterShader,
                            d = void 0 !== e.encoding ? e.encoding : tn,
                            p = new gu,
                            m = e.flowMap || void 0,
                            f = e.normalMap0 || p.load("textures/water/Water_1_M_Normal.jpg"),
                            g = e.normalMap1 || p.load("textures/water/Water_2_M_Normal.jpg"),
                            v = .15,
                            y = .075,
                            x = new Gi,
                            _ = new ld;
                        if (void 0 === zA) return void console.error("THREE.Water: Required component Reflector not found.");
                        if (void 0 === UA) return void console.error("THREE.Water: Required component Refractor not found.");
                        const b = new zA(t, { textureWidth: r, textureHeight: s, clipBias: o, encoding: d }),
                            w = new UA(t, { textureWidth: r, textureHeight: s, clipBias: o, encoding: d });
                        b.matrixAutoUpdate = !1, w.matrixAutoUpdate = !1, this.material = new Ls({ uniforms: As.merge([qs.fog, u.uniforms]), vertexShader: u.vertexShader, fragmentShader: u.fragmentShader, transparent: !0, fog: !0 }), void 0 !== m ? (this.material.defines.USE_FLOWMAP = "", this.material.uniforms.tFlowMap = { type: "t", value: m }) : this.material.uniforms.flowDirection = { type: "v2", value: a }, f.wrapS = f.wrapT = ft, g.wrapS = g.wrapT = ft, this.material.uniforms.tReflectionMap.value = b.getRenderTarget().texture, this.material.uniforms.tRefractionMap.value = w.getRenderTarget().texture, this.material.uniforms.tNormalMap0.value = f, this.material.uniforms.tNormalMap1.value = g, this.material.uniforms.color.value = i, this.material.uniforms.reflectivity.value = c, this.material.uniforms.textureMatrix.value = x, this.material.uniforms.config.value.x = 0, this.material.uniforms.config.value.y = y, this.material.uniforms.config.value.z = y, this.material.uniforms.config.value.w = h, this.onBeforeRender = function(t, e, i) {
                            ! function(t) { x.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), x.multiply(t.projectionMatrix), x.multiply(t.matrixWorldInverse), x.multiply(n.matrixWorld) }(i),
                            function() {
                                const t = _.getDelta(),
                                    e = n.material.uniforms.config;
                                e.value.x += l * t, e.value.y = e.value.x + y, e.value.x >= v ? (e.value.x = 0, e.value.y = y) : e.value.y >= v && (e.value.y = e.value.y - v)
                            }(), n.visible = !1, b.matrixWorld.copy(n.matrixWorld), w.matrixWorld.copy(n.matrixWorld), b.onBeforeRender(t, e, i), w.onBeforeRender(t, e, i), n.visible = !0
                        }
                    }
                }
                HA.prototype.isWater = !0, HA.WaterShader = { uniforms: { color: { type: "c", value: null }, reflectivity: { type: "f", value: 0 }, tReflectionMap: { type: "t", value: null }, tRefractionMap: { type: "t", value: null }, tNormalMap0: { type: "t", value: null }, tNormalMap1: { type: "t", value: null }, textureMatrix: { type: "m4", value: null }, config: { type: "v4", value: new oi } }, vertexShader: "\n\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\n\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}", fragmentShader: "\n\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\n\t\t\tuniform sampler2D tFlowMap;\n\t\t#else\n\t\t\tuniform vec2 flowDirection;\n\t\t#endif\n\n\t\tuniform vec3 color;\n\t\tuniform float reflectivity;\n\t\tuniform vec4 config;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tfloat flowMapOffset0 = config.x;\n\t\t\tfloat flowMapOffset1 = config.y;\n\t\t\tfloat halfCycle = config.z;\n\t\t\tfloat scale = config.w;\n\n\t\t\tvec3 toEye = normalize( vToEye );\n\n\t\t\t// determine flow direction\n\t\t\tvec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t\t#else\n\t\t\t\tflow = flowDirection;\n\t\t\t#endif\n\t\t\tflow.x *= - 1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n\t\t\t// calculate final uv coords\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}" };
                class kA {
                    constructor(t, e, n) { this.scene = t, this.renderer = e, this.factories = n }
                    water(t = {}) {
                        ((t, e, n = {}) => {
                            const { width: i = 20, height: r = 20, x: s = 0, y: o = 0, z: a = 0, color: l = "#ffffff", scale: c = 4, flowX: h = 1, flowY: u = 1, normalMap0: d, normalMap1: p } = n, m = new Ws(i, r), f = new Bh({ color: 30654, transparent: !0, opacity: .8 }), g = new ws(m, f);
                            g.position.set(s, o, a), g.rotation.x = -.5 * Math.PI, t.add(g);
                            const v = new Ws(i, r),
                                y = new HA(v, { color: l, scale: c, flowDirection: new $n(h, u), textureWidth: 1024, textureHeight: 1024, normalMap0: d, normalMap1: p, encoding: e.outputEncoding });
                            y.position.set(s, o + .1, a), y.rotation.x = -.5 * Math.PI, t.add(y)
                        })(this.scene, this.renderer, t)
                    }
                    textureCube(t) {
                        6 !== t.length && LA("You need to pass 6 urls to textureCube()");
                        const e = new GA;
                        return t.forEach(((t, n) => {
                            t.wrapS = t.wrapT = ft;
                            const i = this.factories.add.material({ phong: { map: t } });
                            e.materials[n] = i
                        })), e
                    }
                }
                class GA {
                    constructor() { this.materials = new Array(6) }
                    get texture() { return { left: this.getTexture(0), right: this.getTexture(1), up: this.getTexture(2), down: this.getTexture(3), front: this.getTexture(4), back: this.getTexture(5) } }
                    getTexture(t) { return this.materials[t].map }
                }
                const VA = { Handedness: Object.freeze({ NONE: "none", LEFT: "left", RIGHT: "right" }), ComponentState: Object.freeze({ DEFAULT: "default", TOUCHED: "touched", PRESSED: "pressed" }), ComponentProperty: Object.freeze({ BUTTON: "button", X_AXIS: "xAxis", Y_AXIS: "yAxis", STATE: "state" }), ComponentType: Object.freeze({ TRIGGER: "trigger", SQUEEZE: "squeeze", TOUCHPAD: "touchpad", THUMBSTICK: "thumbstick", BUTTON: "button" }), ButtonTouchThreshold: .05, AxisTouchThreshold: .1, VisualResponseProperty: Object.freeze({ TRANSFORM: "transform", VISIBILITY: "visibility" }) };
                async function WA(t) { const e = await fetch(t); if (e.ok) return e.json(); throw new Error(e.statusText) }
                const jA = { xAxis: 0, yAxis: 0, button: 0, state: VA.ComponentState.DEFAULT };
                class qA {
                    constructor(t) { this.componentProperty = t.componentProperty, this.states = t.states, this.valueNodeName = t.valueNodeName, this.valueNodeProperty = t.valueNodeProperty, this.valueNodeProperty === VA.VisualResponseProperty.TRANSFORM && (this.minNodeName = t.minNodeName, this.maxNodeName = t.maxNodeName), this.value = 0, this.updateFromComponent(jA) }
                    updateFromComponent({ xAxis: t, yAxis: e, button: n, state: i }) {
                        const { normalizedXAxis: r, normalizedYAxis: s } = function(t = 0, e = 0) {
                            let n = t,
                                i = e;
                            if (Math.sqrt(t * t + e * e) > 1) {
                                const r = Math.atan2(e, t);
                                n = Math.cos(r), i = Math.sin(r)
                            }
                            return { normalizedXAxis: .5 * n + .5, normalizedYAxis: .5 * i + .5 }
                        }(t, e);
                        switch (this.componentProperty) {
                            case VA.ComponentProperty.X_AXIS:
                                this.value = this.states.includes(i) ? r : .5;
                                break;
                            case VA.ComponentProperty.Y_AXIS:
                                this.value = this.states.includes(i) ? s : .5;
                                break;
                            case VA.ComponentProperty.BUTTON:
                                this.value = this.states.includes(i) ? n : 0;
                                break;
                            case VA.ComponentProperty.STATE:
                                this.valueNodeProperty === VA.VisualResponseProperty.VISIBILITY ? this.value = this.states.includes(i) : this.value = this.states.includes(i) ? 1 : 0;
                                break;
                            default:
                                throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`)
                        }
                    }
                }
                class XA {
                    constructor(t, e) {
                        if (!(t && e && e.visualResponses && e.gamepadIndices && 0 !== Object.keys(e.gamepadIndices).length)) throw new Error("Invalid arguments supplied");
                        this.id = t, this.type = e.type, this.rootNodeName = e.rootNodeName, this.touchPointNodeName = e.touchPointNodeName, this.visualResponses = {}, Object.keys(e.visualResponses).forEach((t => {
                            const n = new qA(e.visualResponses[t]);
                            this.visualResponses[t] = n
                        })), this.gamepadIndices = Object.assign({}, e.gamepadIndices), this.values = { state: VA.ComponentState.DEFAULT, button: void 0 !== this.gamepadIndices.button ? 0 : void 0, xAxis: void 0 !== this.gamepadIndices.xAxis ? 0 : void 0, yAxis: void 0 !== this.gamepadIndices.yAxis ? 0 : void 0 }
                    }
                    get data() { return { id: this.id, ...this.values } }
                    updateFromGamepad(t) {
                        if (this.values.state = VA.ComponentState.DEFAULT, void 0 !== this.gamepadIndices.button && t.buttons.length > this.gamepadIndices.button) {
                            const e = t.buttons[this.gamepadIndices.button];
                            this.values.button = e.value, this.values.button = this.values.button < 0 ? 0 : this.values.button, this.values.button = this.values.button > 1 ? 1 : this.values.button, e.pressed || 1 === this.values.button ? this.values.state = VA.ComponentState.PRESSED : (e.touched || this.values.button > VA.ButtonTouchThreshold) && (this.values.state = VA.ComponentState.TOUCHED)
                        }
                        void 0 !== this.gamepadIndices.xAxis && t.axes.length > this.gamepadIndices.xAxis && (this.values.xAxis = t.axes[this.gamepadIndices.xAxis], this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis, this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis, this.values.state === VA.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > VA.AxisTouchThreshold && (this.values.state = VA.ComponentState.TOUCHED)), void 0 !== this.gamepadIndices.yAxis && t.axes.length > this.gamepadIndices.yAxis && (this.values.yAxis = t.axes[this.gamepadIndices.yAxis], this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis, this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis, this.values.state === VA.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > VA.AxisTouchThreshold && (this.values.state = VA.ComponentState.TOUCHED)), Object.values(this.visualResponses).forEach((t => { t.updateFromComponent(this.values) }))
                    }
                }
                class YA {
                    constructor(t, e, n) {
                        if (!t) throw new Error("No xrInputSource supplied");
                        if (!e) throw new Error("No profile supplied");
                        this.xrInputSource = t, this.assetUrl = n, this.id = e.profileId, this.layoutDescription = e.layouts[t.handedness], this.components = {}, Object.keys(this.layoutDescription.components).forEach((t => {
                            const e = this.layoutDescription.components[t];
                            this.components[t] = new XA(t, e)
                        })), this.updateFromGamepad()
                    }
                    get gripSpace() { return this.xrInputSource.gripSpace }
                    get targetRaySpace() { return this.xrInputSource.targetRaySpace }
                    get data() { const t = []; return Object.values(this.components).forEach((e => { t.push(e.data) })), t }
                    updateFromGamepad() { Object.values(this.components).forEach((t => { t.updateFromGamepad(this.xrInputSource.gamepad) })) }
                }
                class ZA extends pr {
                    constructor() { super(), this.motionController = null, this.envMap = null }
                    setEnvironmentMap(t) { return this.envMap == t || (this.envMap = t, this.traverse((t => { t.isMesh && (t.material.envMap = this.envMap, t.material.needsUpdate = !0) }))), this }
                    updateMatrixWorld(t) {
                        super.updateMatrixWorld(t), this.motionController && (this.motionController.updateFromGamepad(), Object.values(this.motionController.components).forEach((t => {
                            Object.values(t.visualResponses).forEach((t => {
                                const { valueNode: e, minNode: n, maxNode: i, value: r, valueNodeProperty: s } = t;
                                e && (s === VA.VisualResponseProperty.VISIBILITY ? e.visible = r : s === VA.VisualResponseProperty.TRANSFORM && (e.quaternion.slerpQuaternions(n.quaternion, i.quaternion, r), e.position.lerpVectors(n.position, i.position, r)))
                            }))
                        })))
                    }
                }

                function JA(t, e) {
                    ! function(t, e) {
                        Object.values(t.components).forEach((t => {
                            const { type: n, touchPointNodeName: i, visualResponses: r } = t;
                            if (n === VA.ComponentType.TOUCHPAD)
                                if (t.touchPointNode = e.getObjectByName(i), t.touchPointNode) {
                                    const e = new Th(.001),
                                        n = new Nr({ color: 255 }),
                                        i = new ws(e, n);
                                    t.touchPointNode.add(i)
                                } else console.warn(`Could not find touch dot, ${t.touchPointNodeName}, in touchpad component ${t.id}`);
                            Object.values(r).forEach((t => {
                                const { valueNodeName: n, minNodeName: i, maxNodeName: r, valueNodeProperty: s } = t;
                                if (s === VA.VisualResponseProperty.TRANSFORM) { if (t.minNode = e.getObjectByName(i), t.maxNode = e.getObjectByName(r), !t.minNode) return void console.warn(`Could not find ${i} in the model`); if (!t.maxNode) return void console.warn(`Could not find ${r} in the model`) }
                                t.valueNode = e.getObjectByName(n), t.valueNode || console.warn(`Could not find ${n} in the model`)
                            }))
                        }))
                    }(t.motionController, e), t.envMap && e.traverse((e => { e.isMesh && (e.material.envMap = t.envMap, e.material.needsUpdate = !0) })), t.add(e)
                }
                class KA {
                    constructor(t = null) { this.gltfLoader = t, this.path = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles", this._assetCache = {}, this.gltfLoader || (this.gltfLoader = new jv) }
                    createControllerModel(t) {
                        const e = new ZA;
                        let n = null;
                        return t.addEventListener("connected", (t => {
                            const i = t.data;
                            "tracked-pointer" === i.targetRayMode && i.gamepad && async function(t, e, n = null, i = !0) {
                                if (!t) throw new Error("No xrInputSource supplied");
                                if (!e) throw new Error("No basePath supplied");
                                const r = await async function(t) { if (!t) throw new Error("No basePath supplied"); return await WA(`${t}/profilesList.json`) }(e);
                                let s;
                                if (t.profiles.some((t => { const n = r[t]; return n && (s = { profileId: t, profilePath: `${e}/${n.path}`, deprecated: !!n.deprecated }), !!s })), !s) {
                                    if (!n) throw new Error("No matching profile name found");
                                    const t = r[n];
                                    if (!t) throw new Error(`No matching profile name found and default profile "${n}" missing.`);
                                    s = { profileId: n, profilePath: `${e}/${t.path}`, deprecated: !!t.deprecated }
                                }
                                const o = await WA(s.profilePath);
                                let a;
                                if (i) {
                                    let e;
                                    if (e = "any" === t.handedness ? o.layouts[Object.keys(o.layouts)[0]] : o.layouts[t.handedness], !e) throw new Error(`No matching handedness, ${t.handedness}, in profile ${s.profileId}`);
                                    e.assetPath && (a = s.profilePath.replace("profile.json", e.assetPath))
                                }
                                return { profile: o, assetPath: a }
                            }(i, this.path, "generic-trigger").then((({ profile: t, assetPath: r }) => {
                                e.motionController = new YA(i, t, r);
                                const s = this._assetCache[e.motionController.assetUrl];
                                if (s) n = s.scene.clone(), JA(e, n);
                                else {
                                    if (!this.gltfLoader) throw new Error("GLTFLoader not set.");
                                    this.gltfLoader.setPath(""), this.gltfLoader.load(e.motionController.assetUrl, (t => { this._assetCache[e.motionController.assetUrl] = t, n = t.scene.clone(), JA(e, n) }), null, (() => { throw new Error(`Asset ${e.motionController.assetUrl} missing or malformed.`) }))
                                }
                            })).catch((t => { console.warn(t) }))
                        })), t.addEventListener("disconnected", (() => { e.motionController = null, e.remove(n), n = null })), e
                    }
                }
                class QA {
                    constructor(t, e, n) {
                        this._renderer = t, this._scene = e, this._camera = n, this.controllerModelFactory = new KA, this.cameraGroup = new Qa, this.cameraGroup.add(n), e.add(this.cameraGroup), t.xr.enabled = !0;
                        const i = class {
                            static createButton(t, e) {
                                e && console.error('THREE.VRButton: The "options" parameter has been removed. Please set the reference space type via renderer.xr.setReferenceSpaceType() instead.');
                                const n = document.createElement("button");

                                function i(t) { t.style.position = "absolute", t.style.bottom = "20px", t.style.padding = "12px 6px", t.style.border = "1px solid #fff", t.style.borderRadius = "4px", t.style.background = "rgba(0,0,0,0.1)", t.style.color = "#fff", t.style.font = "normal 13px sans-serif", t.style.textAlign = "center", t.style.opacity = "0.5", t.style.outline = "none", t.style.zIndex = "999" }
                                if ("xr" in navigator) return n.id = "VRButton", n.style.display = "none", i(n), navigator.xr.isSessionSupported("immersive-vr").then((function(e) {
                                    e ? function() {
                                        let e = null;
                                        async function i(i) { i.addEventListener("end", r), await t.xr.setSession(i), n.textContent = "EXIT VR", e = i }

                                        function r() { e.removeEventListener("end", r), n.textContent = "ENTER VR", e = null }
                                        n.style.display = "", n.style.cursor = "pointer", n.style.left = "calc(50% - 50px)", n.style.width = "100px", n.textContent = "ENTER VR", n.onmouseenter = function() { n.style.opacity = "1.0" }, n.onmouseleave = function() { n.style.opacity = "0.5" }, n.onclick = function() {
                                            if (null === e) {
                                                const t = { optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "layers"] };
                                                navigator.xr.requestSession("immersive-vr", t).then(i)
                                            } else e.end()
                                        }
                                    }() : (n.style.display = "", n.style.cursor = "auto", n.style.left = "calc(50% - 75px)", n.style.width = "150px", n.onmouseenter = null, n.onmouseleave = null, n.onclick = null, n.textContent = "VR NOT SUPPORTED")
                                })), n; { const t = document.createElement("a"); return !1 === window.isSecureContext ? (t.href = document.location.href.replace(/^http:/, "https:"), t.innerHTML = "WEBXR NEEDS HTTPS") : (t.href = "https://immersiveweb.dev/", t.innerHTML = "WEBXR NOT AVAILABLE"), t.style.left = "calc(50% - 90px)", t.style.width = "180px", t.style.textDecoration = "none", i(t), t }
                            }
                        }.createButton(t);
                        i.style.cssText += "background: rgba(0, 0, 0, 0.8); ", document.body.appendChild(i)
                    }
                    get isPresenting() { var t, e; return !!(null === (e = null === (t = this._renderer) || void 0 === t ? void 0 : t.xr) || void 0 === e ? void 0 : e.isPresenting) }
                    getController(t) { const e = this._renderer.xr.getController(t); return this.cameraGroup.add(e), e }
                    getControllerGrip(t) {
                        const e = this._renderer.xr.getControllerGrip(t),
                            n = this.controllerModelFactory.createControllerModel(e);
                        return e.add(n), this.cameraGroup.add(e), e
                    }
                    getControllerRay(t) {
                        const { targetRayMode: e } = t;
                        if ("tracked-pointer" === e) {
                            const t = new rs;
                            t.setAttribute("position", new qr([0, 0, 0, 0, 0, -1], 3)), t.setAttribute("color", new qr([1, 0, 0, 1, 1, 1], 3));
                            const e = new ql({ vertexColors: !0 });
                            return new Ql(t, e)
                        }
                        if ("gaze" === e) {
                            const t = new Mh(.02, .04, 32).translate(0, 0, -1),
                                e = new Nr({ color: "red", opacity: .5, transparent: !0 });
                            return new ws(t, e)
                        }
                    }
                    get camera() { return this.WebXRCamera }
                    get WebXRCamera() { var t; return { group: this.cameraGroup, position: null === (t = this.cameraGroup) || void 0 === t ? void 0 : t.position, rotation: this.isPresenting ? this._renderer.xr.getCamera(this._camera).rotation : void 0, getWorldDirection: t => this.isPresenting ? this._renderer.xr.getCamera(this._camera).getWorldDirection(t) : void 0 } }
                }
                class $A {
                    perspectiveCamera(t = {}) { return $A.Perspective(t) }
                    orthographicCamera(t = {}) { return $A.Orthographic(t) }
                    static Perspective(t = {}) { const { fov: e = 50, aspect: n = window.innerWidth / window.innerHeight, near: i = .1, far: r = 2e3, x: s = 0, y: o = 5, z: a = 25 } = t, l = new Cs(e, n, i, r); return l.position.set(s, o, a), l }
                    static Orthographic(t = {}) {
                        const e = window.innerWidth,
                            n = window.innerHeight,
                            { left: i = e / -2, right: r = e / 2, top: s = n / 2, bottom: o = n / -2, near: a = 1, far: l = 1e3, x: c = 0, y: h = 0, z: u = 10 } = t,
                            d = new Du(i, r, s, o, a, l);
                        return d.position.set(c, h, u), d
                    }
                }
                var tL = function(t, e, n, i) {
                    return new(n || (n = Promise))((function(r, s) {
                        function o(t) { try { l(i.next(t)) } catch (t) { s(t) } }

                        function a(t) { try { l(i.throw(t)) } catch (t) { s(t) } }

                        function l(t) {
                            var e;
                            t.done ? r(t.value) : (e = t.value, e instanceof n ? e : new n((function(t) { t(e) }))).then(o, a)
                        }
                        l((i = i.apply(t, e || [])).next())
                    }))
                };
                class eL {
                    constructor(t = {}) {
                        this.sceneConfig = t, this.scenes = new Map, this.__config = {}, this._isRunning = !1, this._deconstructor = [];
                        const { key: e = Math.random().toString(), enableXR: n = !1 } = t;
                        this.__config.sceneKey = e, this.__config.enableXR = n
                    }
                    get deconstructor() { return { add: (...t) => { t.forEach((t => { this._deconstructor.push(t) })) } } }
                    initializeScene(t) {
                        const { renderer: e, parent: n, canvas: i, scene: r, scenes: s, camera: o, cache: a, physics: l, sceneConfig: c } = t;
                        this.scene = r, this.scenes = s, this.camera = o, this.cache = a, this.physics = l, this.renderer = e, this.parent = n, this.canvas = i;
                        const { autoStart: h, textureAnisotropy: u } = c;
                        this.load = new Ly(this.cache, u), this.lights = new Cy(this.scene), this.transform = new jm(this.camera, this.renderer), this.csg = qm, this.heightMap = new IA(this.scene), this.factories = new PA(this.scene), this.misc = new kA(this.scene, this.renderer, this.factories), this.ws = new FA(r, e, o, this.lights, this.physics, this.load, this.factories), this.mixers = new class {
                            constructor() { this._mixers = [] }
                            animationMixer(t) { const e = new Bd(t); return this.mixers.add(e), e }
                            get mixers() { return { create: t => this.animationMixer(t), add: t => this._mixers.push(t), get: () => this._mixers, update: t => { var e; return null === (e = this._mixers) || void 0 === e ? void 0 : e.forEach((e => e.update(t / 1e3))) } } }
                        }, this.cameras = new $A, this.clock = new ld, this.__config.enableXR && (this.webXR = new QA(this.renderer, this.scene, this.camera)), h && this.start(this.__config.sceneKey)
                    }
                    get sceneKey() { return this.__config.sceneKey }
                    destroy(t) {
                        var e;
                        null === (e = this.physics) || void 0 === e || e.destroy(t.body), this.scene.remove(t), t = null
                    }
                    warpSpeed(...t) { return tL(this, void 0, void 0, (function*() { return yield this.ws.warpSpeed(...t) })) }
                    get animationMixers() { return this.mixers.mixers }
                    get make() { return this.factories.make }
                    get add() { return this.factories.add }
                    haveSomeFun(t = 20) {
                        ((t = 20, e) => {
                            if (window.__loadPhysics)
                                for (let n = 0; n < t; n++) {
                                    const t = ["standard", "basic", "normal", "phong", "line", "points"],
                                        n = (t, e) => Math.floor(Math.random() * (e - t + 1) + t),
                                        i = t => t[Math.floor(Math.random() * t.length)];
                                    Math.random() > .5 ? e.add.box({ x: n(-10, 10), y: n(10, 20), z: n(-10, 10), width: n(1, 2) / 10, height: n(1, 2) / 10, depth: n(1, 2) / 10, mass: 1 }, {
                                        [i(t)]: { color: Math.floor(16777215 * Math.random()) }
                                    }).body.setRestitution(Math.floor(10 * Math.random()) / 20) : e.add.sphere({ x: n(-10, 10), y: n(10, 20), z: n(-10, 10), radius: n(1, 2) / 10, mass: 1 }, {
                                        [i(t)]: { color: Math.floor(16777215 * Math.random()) }
                                    }).body.setRestitution(Math.floor(10 * Math.random()) / 20)
                                } else console.log("There is not much fun without physics enabled!")
                        })(t, this.physics)
                    }
                    isRunning() { return this._isRunning }
                    start(t, e) { var n; return tL(this, void 0, void 0, (function*() { t && t !== this.__config.sceneKey ? (this.stop(), null === (n = this.scenes.get(t)) || void 0 === n || n._start(e)) : this._start(e) })) }
                    _start(t) { var e; return tL(this, void 0, void 0, (function*() { yield null === (e = this.init) || void 0 === e ? void 0 : e.call(this, t), yield this._preload(), yield this._create(), this.renderer.setAnimationLoop((() => { this._update() })), this._isRunning = !0 })) }
                    restart(t) { return tL(this, void 0, void 0, (function*() { yield this.stop(), yield this.start(this.__config.sceneKey, t) })) }
                    stop() {
                        var t, e, n;
                        return tL(this, void 0, void 0, (function*() {
                            this._isRunning = !1, this.renderer.setAnimationLoop(null), this.clock.start();
                            for (let n of this._deconstructor) yield null === (t = n.dispose) || void 0 === t ? void 0 : t.call(n), yield null === (e = n.destroy) || void 0 === e ? void 0 : e.call(n), "function" == typeof n && (yield null == n ? void 0 : n()), n = null;
                            if (this._deconstructor = [], null === (n = this.physics) || void 0 === n ? void 0 : n.rigidBodies)
                                for (let t = this.physics.rigidBodies.length - 1; t >= 0; t--) this.physics.destroy(this.physics.rigidBodies[t]);
                            for (let t = this.scene.children.length - 1; t >= 0; t--) this.scene.remove(this.scene.children[t])
                        }))
                    }
                    setSize(t, e) { this.renderer.setSize(t, e), void 0 !== this.camera.aspect && (this.camera.aspect = t / e), this.camera.updateProjectionMatrix() }
                    setPixelRatio(t) { this.renderer.setPixelRatio(t) }
                    init(t = {}) {}
                    preload() {}
                    create() {}
                    update(t, e) {}
                    preRender() {}
                    postRender() {}
                    _preload() { var t; return tL(this, void 0, void 0, (function*() { yield null === (t = this.preload) || void 0 === t ? void 0 : t.call(this) })) }
                    _create() { var t; return tL(this, void 0, void 0, (function*() { yield null === (t = this.create) || void 0 === t ? void 0 : t.call(this) })) }
                    _update() {
                        var t, e, n;
                        const i = 1e3 * this.clock.getDelta(),
                            r = this.clock.getElapsedTime();
                        null === (t = this.update) || void 0 === t || t.call(this, parseFloat(r.toFixed(3)), parseInt(i.toString())), null === (e = this.physics) || void 0 === e || e.update(i), null === (n = this.physics) || void 0 === n || n.updateDebugger(), this.animationMixers.update(i), this.preRender(), this.composer ? this.composer.render() : this.renderer.render(this.scene, this.camera), this.postRender()
                    }
                }
                var nL = n(70);
                class iL extends C_ {
                    constructor() { super(), this.isExtendedObject3D = !0, this.isGroup = !1, this.vector3 = new Lx, this.hasBody = !1, this.fragmentDepth = 0, this.breakable = !1, this.fractureImpulse = 1, this._currentAnimation = "", this._animationActions = new Map, this.name = `object-${this.id}` }
                    get world() { return { theta: this.worldTheta, phi: this.worldPhi } }
                    get worldTheta() { return this.getWorldDirection(this.vector3), Math.atan2(this.vector3.x, this.vector3.z) }
                    get worldPhi() { return this.getWorldDirection(this.vector3), Math.acos(this.vector3.y) }
                    set animationMixer(t) { this._animationMixer = t }
                    get animationMixer() { return this._animationMixer || (this._animationMixer = new hA(this)), this._animationMixer }
                    get anims() { return { current: this._currentAnimation, add: (t, e) => this._animsAdd(t, e), get: t => this._animsGet(t), play: (t, e = 500, n = !0) => this._animsPlay(t, e, n), mixer: this.animationMixer } }
                    get animation() { return LA('Please use "anims" instead of "animation"'), this.anims }
                    _animsAdd(t, e) { this._animationActions.set(t, this.animationMixer.clipAction(e)) }
                    _animsGet(t) { const e = this._animationActions.get(t); return e || LA(`Animation(${t}) not found!`), e }
                    _animsPlay(t, e = 500, n = !0) {
                        const i = this._animationActions.get(t),
                            r = this._animationActions.get(this._currentAnimation);
                        i && (i.reset(), r && (i.crossFadeFrom(r, e / 1e3, !0), i.clampWhenFinished = !0), n || i.setLoop(2200, 0), i.play()), this._currentAnimation = t
                    }
                    setAction(t) { LA(`setAction(${t}) is deprecated. Use animation.play(${t}) instead!`) }
                    traverse(t) { super.traverse(t) }
                    traverseVisible(t) { super.traverseVisible(t) }
                    traverseAncestors(t) { super.traverseAncestors(t) }
                }
                class rL {
                    constructor(t, e) { this.worldTransform = t, this.physicsWorld = e, this.tmpBtVector3 = new Ammo.btVector3 }
                    toAmmoV3(t, e = 0) { return new Ammo.btVector3(void 0 !== (null == t ? void 0 : t.x) ? t.x : e, void 0 !== (null == t ? void 0 : t.y) ? t.y : e, void 0 !== (null == t ? void 0 : t.z) ? t.z : e) }
                    get addConstraints() { return { lock: (t, e, n) => this.lock(t, e, n), fixed: (t, e, n) => this.fixed(t, e, n), pointToPoint: (t, e, n, i) => this.pointToPoint(t, e, n, i), hinge: (t, e, n, i) => this.hinge(t, e, n, i), slider: (t, e, n = {}, i) => this.slider(t, e, n, i), spring: (t, e, n = {}, i) => this.spring(t, e, n, i), coneTwist: (t, e, n = { frameA: {}, frameB: {} }, i) => this.coneTwist(t, e, n, i), dof: (t, e, n, i) => this.dof(t, e, n, i) } }
                    getTransform(t, e, n = { x: 0, y: 0, z: 0 }, i = !1) {
                        n = Object.assign({ x: 0, y: 0, z: 0 }, n);
                        const r = new Ammo.btTransform;
                        if (r.setIdentity(), i) {
                            const i = (s = t.getWorldTransform().getOrigin(), o = e.getWorldTransform().getOrigin(), a = (s.x() - o.x()) / 2 + n.x, l = (s.y() - o.y()) / 2 + n.y, c = (s.z() - o.z()) / 2 + n.z, new Ammo.btVector3(a, l, c)),
                                r = new Ammo.btTransform;
                            r.setIdentity(), r.setOrigin(i);
                            const h = t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform());
                            return h.op_mul(r), { transformA: h, transformB: r }
                        }
                        return r.setOrigin(new Ammo.btVector3(n.x, n.y, n.z)), { transformA: t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform()).op_mul(r), transformB: r };
                        var s, o, a, l, c
                    }
                    lock(t, e, n = !0) { const i = { x: 0, y: 0, z: 0 }; return this.dof(t, e, { angularLowerLimit: i, angularUpperLimit: i }, n) }
                    fixed(t, e, n = !0) {
                        const i = this.getTransform(t.ammo, e.ammo);
                        i.transformA.setRotation(t.ammo.getWorldTransform().getRotation()), i.transformB.setRotation(e.ammo.getWorldTransform().getRotation());
                        const r = new Ammo.btFixedConstraint(t.ammo, e.ammo, i.transformA, i.transformB);
                        return this.physicsWorld.addConstraint(r, n), r
                    }
                    pointToPoint(t, e, n = {}, i = !0) { const { pivotA: r, pivotB: s } = n, o = new Ammo.btVector3((null == r ? void 0 : r.x) || 0, (null == r ? void 0 : r.y) || 0, (null == r ? void 0 : r.z) || 0), a = new Ammo.btVector3((null == s ? void 0 : s.x) || 0, (null == s ? void 0 : s.y) || 0, (null == s ? void 0 : s.z) || 0), l = new Ammo.btPoint2PointConstraint(t.ammo, e.ammo, o, a); return this.physicsWorld.addConstraint(l, i), l }
                    hinge(t, e, n = {}, i = !0) { const { pivotA: r, pivotB: s, axisA: o, axisB: a } = n, l = new Ammo.btVector3((null == r ? void 0 : r.x) || 0, (null == r ? void 0 : r.y) || 0, (null == r ? void 0 : r.z) || 0), c = new Ammo.btVector3((null == s ? void 0 : s.x) || 0, (null == s ? void 0 : s.y) || 0, (null == s ? void 0 : s.z) || 0), h = new Ammo.btVector3((null == o ? void 0 : o.x) || 0, (null == o ? void 0 : o.y) || 0, (null == o ? void 0 : o.z) || 0), u = new Ammo.btVector3((null == a ? void 0 : a.x) || 0, (null == a ? void 0 : a.y) || 0, (null == a ? void 0 : a.z) || 0), d = new Ammo.btHingeConstraint(t.ammo, e.ammo, l, c, h, u, !0); return this.physicsWorld.addConstraint(d, i), d }
                    slider(t, e, n = {}, i = !0) {
                        const r = this.getTransform(t.ammo, e.ammo),
                            { frameA: s = {}, frameB: o = {}, linearLowerLimit: a = 0, linearUpperLimit: l = 0, angularLowerLimit: c = 0, angularUpperLimit: h = 0 } = n,
                            u = r.transformA.getRotation();
                        u.setEulerZYX(s.x || 0, s.y || 0, s.z || 0), r.transformA.setRotation(u);
                        const d = r.transformB.getRotation();
                        d.setEulerZYX(o.x || 0, o.y || 0, o.z || 0), r.transformB.setRotation(d);
                        const p = new Ammo.btSliderConstraint(t.ammo, e.ammo, r.transformA, r.transformB, !0);
                        return p.setLowerLinLimit(a), p.setUpperLinLimit(l), p.setLowerAngLimit(c), p.setUpperAngLimit(h), this.physicsWorld.addConstraint(p, i), p
                    }
                    spring(t, e, n = {}, i = !0) {
                        const { stiffness: r = 50, damping: s = .01, angularLock: o = !1, linearLowerLimit: a = {}, linearUpperLimit: l = {}, angularLowerLimit: c = {}, angularUpperLimit: h = {}, offset: u = {}, center: d = !1, enableSpring: p = !0 } = n, m = Object.assign({ x: 0, y: 0, z: 0 }, u), f = this.getTransform(t.ammo, e.ammo, m, d), g = new Ammo.btGeneric6DofSpringConstraint(t.ammo, e.ammo, f.transformA, f.transformB, !0);
                        this.tmpBtVector3.setValue(a.x || 0, a.y || 0, a.z || 0), g.setLinearLowerLimit(this.tmpBtVector3), this.tmpBtVector3.setValue(l.x || 0, l.y || 0, l.z || 0), g.setLinearUpperLimit(this.tmpBtVector3), o ? (this.tmpBtVector3.setValue(0, 0, 0), g.setAngularLowerLimit(this.tmpBtVector3), g.setAngularUpperLimit(this.tmpBtVector3)) : (console.log(c, h), g.setAngularLowerLimit(this.toAmmoV3(c, -Math.PI)), g.setAngularUpperLimit(this.toAmmoV3(h, Math.PI)));
                        for (let t = 0; t < 3; t++) g.enableSpring(t, p), g.setStiffness(t, r), g.setDamping(t, s);
                        return this.physicsWorld.addConstraint(g, i), g
                    }
                    coneTwist(t, e, n, i = !0) {
                        const { frameA: r, frameB: s } = n, o = new Ammo.btTransform;
                        o.setIdentity(), o.getOrigin().setValue((null == r ? void 0 : r.x) || 0, (null == r ? void 0 : r.y) || 0, (null == r ? void 0 : r.z) || 0);
                        const a = new Ammo.btTransform;
                        a.setIdentity(), a.getOrigin().setValue((null == s ? void 0 : s.x) || 0, (null == s ? void 0 : s.y) || 0, (null == s ? void 0 : s.z) || 0), this.getTransform(t.ammo, e.ammo);
                        const l = new Ammo.btConeTwistConstraint(e.ammo, t.ammo, o, a);
                        return l.setAngularOnly(!0), this.physicsWorld.addConstraint(l, i), l
                    }
                    dof(t, e, n = {}, i = !0) { const { offset: r, center: s = !1 } = n, o = Object.assign({ x: 0, y: 0, z: 0 }, r), a = this.getTransform(t.ammo, e.ammo, o, s), l = new Ammo.btGeneric6DofConstraint(t.ammo, e.ammo, a.transformA, a.transformB, !0), { linearLowerLimit: c, linearUpperLimit: h, angularLowerLimit: u, angularUpperLimit: d } = n, p = this.toAmmoV3(c), m = this.toAmmoV3(h), f = this.toAmmoV3(u, -Math.PI), g = this.toAmmoV3(d, Math.PI); return l.setLinearLowerLimit(p), l.setLinearUpperLimit(m), l.setAngularLowerLimit(f), l.setAngularUpperLimit(g), Ammo.destroy(p), Ammo.destroy(m), Ammo.destroy(f), Ammo.destroy(g), this.physicsWorld.addConstraint(l, i), l }
                }
                const sL = "hull",
                    oL = "manual",
                    aL = function() {
                        const t = new ui,
                            e = new ui,
                            n = new Gi;
                        return function(i, r, s, o = {}) {
                            if (o.type = sL, uL(o), o.fit === oL) return console.warn("cannot use fit: manual with type: hull"), null;
                            const a = fL(i, r),
                                l = new Ammo.btVector3,
                                c = new Ammo.btConvexHullShape;
                            c.setMargin(o.margin), e.addVectors(a.max, a.min).multiplyScalar(.5);
                            let h = 0;
                            for (let t = 0; t < i.length; t++) h += i[t].length / 3;
                            const u = o.hullMaxVertices || 1e5;
                            h > u && console.warn(`too many vertices for hull shape; sampling ~${u} from ~${h} vertices`);
                            const d = Math.min(1, u / h);
                            for (let s = 0; s < i.length; s++) {
                                const o = i[s];
                                n.fromArray(r[s]);
                                for (let r = 0; r < o.length; r += 3) {
                                    const a = s === i.length - 1 && r === o.length - 3;
                                    (Math.random() <= d || a) && (t.set(o[r], o[r + 1], o[r + 2]).applyMatrix4(n).sub(e), l.setValue(t.x, t.y, t.z), c.addPoint(l, a))
                                }
                            }
                            let p = c;
                            if (c.getNumVertices() >= 100) {
                                const t = new Ammo.btShapeHull(c);
                                t.buildHull(o.margin), Ammo.destroy(c), p = new Ammo.btConvexHullShape(Ammo.getPointer(t.getVertexPointer()), t.numVertices()), Ammo.destroy(t)
                            }
                            return Ammo.destroy(l), dL(p, o, mL(s, o)), p
                        }
                    }(),
                    lL = function() {
                        const t = new ui,
                            e = new ui,
                            n = new Gi;
                        return function(i, r, s, o, a = {}) {
                            if (a.type = "hacd", uL(a), a.fit === oL) return console.warn("cannot use fit: manual with type: hacd"), [];
                            if (!Ammo.hasOwnProperty("HACD")) return console.warn("HACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."), [];
                            const l = fL(i, r),
                                c = mL(o, a);
                            let h = 0,
                                u = 0;
                            e.addVectors(l.max, l.min).multiplyScalar(.5);
                            for (let t = 0; t < i.length; t++) h += i[t].length / 3, s && s[t] ? u += s[t].length / 3 : u += i[t].length / 9;
                            const d = new Ammo.HACD;
                            a.hasOwnProperty("compacityWeight") && d.SetCompacityWeight(a.compacityWeight), a.hasOwnProperty("volumeWeight") && d.SetVolumeWeight(a.volumeWeight), a.hasOwnProperty("nClusters") && d.SetNClusters(a.nClusters), a.hasOwnProperty("nVerticesPerCH") && d.SetNVerticesPerCH(a.nVerticesPerCH), a.hasOwnProperty("concavity") && d.SetConcavity(a.concavity);
                            const p = Ammo._malloc(3 * h * 8),
                                m = Ammo._malloc(3 * u * 4);
                            d.SetPoints(p), d.SetTriangles(m), d.SetNPoints(h), d.SetNTriangles(u);
                            let f = p / 8,
                                g = m / 4;
                            for (let o = 0; o < i.length; o++) {
                                const a = i[o];
                                n.fromArray(r[o]);
                                for (let i = 0; i < a.length; i += 3) t.set(a[i + 0], a[i + 1], a[i + 2]).applyMatrix4(n).sub(e), Ammo.HEAPF64[f + 0] = t.x, Ammo.HEAPF64[f + 1] = t.y, Ammo.HEAPF64[f + 2] = t.z, f += 3;
                                if (s[o]) { const t = s[o]; for (let e = 0; e < t.length; e++) Ammo.HEAP32[g] = t[e], g++ } else
                                    for (let t = 0; t < a.length / 3; t++) Ammo.HEAP32[g] = t, g++
                            }
                            d.Compute(), Ammo._free(p), Ammo._free(m);
                            const v = d.GetNClusters(),
                                y = [];
                            for (let t = 0; t < v; t++) {
                                const e = new Ammo.btConvexHullShape;
                                e.setMargin(a.margin);
                                const n = d.GetNPointsCH(t),
                                    i = d.GetNTrianglesCH(t),
                                    r = Ammo._malloc(3 * n * 8),
                                    s = Ammo._malloc(3 * i * 4);
                                d.GetCH(t, r, s);
                                const o = r / 8;
                                for (let t = 0; t < n; t++) {
                                    const i = new Ammo.btVector3,
                                        r = Ammo.HEAPF64[o + 3 * t + 0],
                                        s = Ammo.HEAPF64[o + 3 * t + 1],
                                        a = Ammo.HEAPF64[o + 3 * t + 2];
                                    i.setValue(r, s, a), e.addPoint(i, t === n - 1), Ammo.destroy(i)
                                }
                                dL(e, a, c), y.push(e)
                            }
                            return y
                        }
                    }(),
                    cL = function() {
                        const t = new ui,
                            e = new ui,
                            n = new Gi;
                        return function(i, r, s, o, a = {}) {
                            if (a.type = "vhacd", uL(a), a.fit === oL) return console.warn("cannot use fit: manual with type: vhacd"), [];
                            if (!Ammo.hasOwnProperty("VHACD")) return console.warn("VHACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."), [];
                            const l = fL(i, r),
                                c = mL(o, a);
                            let h = 0,
                                u = 0;
                            e.addVectors(l.max, l.min).multiplyScalar(.5);
                            for (let t = 0; t < i.length; t++) h += i[t].length / 3, s && s[t] ? u += s[t].length / 3 : u += i[t].length / 9;
                            const d = new Ammo.VHACD,
                                p = new Ammo.Parameters;
                            a.hasOwnProperty("resolution") && p.set_m_resolution(a.resolution), a.hasOwnProperty("depth") && p.set_m_depth(a.depth), a.hasOwnProperty("concavity") && p.set_m_concavity(a.concavity), a.hasOwnProperty("planeDownsampling") && p.set_m_planeDownsampling(a.planeDownsampling), a.hasOwnProperty("convexhullDownsampling") && p.set_m_convexhullDownsampling(a.convexhullDownsampling), a.hasOwnProperty("alpha") && p.set_m_alpha(a.alpha), a.hasOwnProperty("beta") && p.set_m_beta(a.beta), a.hasOwnProperty("gamma") && p.set_m_gamma(a.gamma), a.hasOwnProperty("pca") && p.set_m_pca(a.pca), a.hasOwnProperty("mode") && p.set_m_mode(a.mode), a.hasOwnProperty("maxNumVerticesPerCH") && p.set_m_maxNumVerticesPerCH(a.maxNumVerticesPerCH), a.hasOwnProperty("minVolumePerCH") && p.set_m_minVolumePerCH(a.minVolumePerCH), a.hasOwnProperty("convexhullApproximation") && p.set_m_convexhullApproximation(a.convexhullApproximation), a.hasOwnProperty("oclAcceleration") && p.set_m_oclAcceleration(a.oclAcceleration);
                            const m = Ammo._malloc(3 * h * 8 + 3),
                                f = Ammo._malloc(3 * u * 4);
                            let g = m / 8,
                                v = f / 4;
                            for (let o = 0; o < i.length; o++) {
                                const a = i[o];
                                n.fromArray(r[o]);
                                for (let i = 0; i < a.length; i += 3) t.set(a[i + 0], a[i + 1], a[i + 2]).applyMatrix4(n).sub(e), Ammo.HEAPF64[g + 0] = t.x, Ammo.HEAPF64[g + 1] = t.y, Ammo.HEAPF64[g + 2] = t.z, g += 3;
                                if (s[o]) { const t = s[o]; for (let e = 0; e < t.length; e++) Ammo.HEAP32[v] = t[e], v++ } else
                                    for (let t = 0; t < a.length / 3; t++) Ammo.HEAP32[v] = t, v++
                            }
                            d.Compute(m, 3, h, f, 3, u, p), Ammo._free(m), Ammo._free(f);
                            const y = d.GetNConvexHulls(),
                                x = [],
                                _ = new Ammo.ConvexHull;
                            for (let t = 0; t < y; t++) {
                                d.GetConvexHull(t, _);
                                const e = _.get_m_nPoints(),
                                    n = (_.get_m_points(), new Ammo.btConvexHullShape);
                                n.setMargin(a.margin);
                                for (let t = 0; t < e; t++) {
                                    const i = new Ammo.btVector3,
                                        r = _.get_m_points(3 * t + 0),
                                        s = _.get_m_points(3 * t + 1),
                                        o = _.get_m_points(3 * t + 2);
                                    i.setValue(r, s, o), n.addPoint(i, t === e - 1), Ammo.destroy(i)
                                }
                                dL(n, a, c), x.push(n)
                            }
                            return Ammo.destroy(_), Ammo.destroy(d), x
                        }
                    }(),
                    hL = function() {
                        const t = new ui,
                            e = new ui,
                            n = new ui,
                            i = new Gi;
                        return function(r, s, o, a, l = {}) {
                            if (l.type = "mesh", uL(l), l.fit === oL) return console.warn("cannot use fit: manual with type: mesh"), null;
                            const c = mL(a, l),
                                h = new Ammo.btVector3,
                                u = new Ammo.btVector3,
                                d = new Ammo.btVector3,
                                p = new Ammo.btTriangleMesh(!0, !1);
                            for (let a = 0; a < r.length; a++) {
                                const l = r[a],
                                    c = o[a] ? o[a] : null;
                                if (i.fromArray(s[a]), c)
                                    for (let r = 0; r < c.length; r += 3) {
                                        const s = 3 * c[r],
                                            o = 3 * c[r + 1],
                                            a = 3 * c[r + 2];
                                        t.set(l[s], l[s + 1], l[s + 2]).applyMatrix4(i), e.set(l[o], l[o + 1], l[o + 2]).applyMatrix4(i), n.set(l[a], l[a + 1], l[a + 2]).applyMatrix4(i), h.setValue(t.x, t.y, t.z), u.setValue(e.x, e.y, e.z), d.setValue(n.x, n.y, n.z), p.addTriangle(h, u, d, !1)
                                    } else
                                        for (let r = 0; r < l.length; r += 9) t.set(l[r + 0], l[r + 1], l[r + 2]).applyMatrix4(i), e.set(l[r + 3], l[r + 4], l[r + 5]).applyMatrix4(i), n.set(l[r + 6], l[r + 7], l[r + 8]).applyMatrix4(i), h.setValue(t.x, t.y, t.z), u.setValue(e.x, e.y, e.z), d.setValue(n.x, n.y, n.z), p.addTriangle(h, u, d, !1)
                            }
                            const m = new Ammo.btVector3(c.x, c.y, c.z);
                            let f;
                            return p.setScaling(m), Ammo.destroy(m), f = l.concave ? new Ammo.btBvhTriangleMeshShape(p, !0, !0) : new Ammo.btConvexTriangleMeshShape(p, !0), f.resources = [p], Ammo.destroy(h), Ammo.destroy(u), Ammo.destroy(d), dL(f, l), f
                        }
                    }();

                function uL(t) { t.type = t.type || sL, t.margin = t.hasOwnProperty("margin") ? t.margin : .01 }
                const dL = function(t, e, n) {},
                    pL = function() {
                        const t = new Gi;
                        return function(e, n, i) {
                            parseInt(a) >= 123 ? t.copy(e.matrixWorld).invert() : t.getInverse(e.matrixWorld), (new ui).setFromMatrixScale(e.matrixWorld), e.traverse((r => {
                                const s = new Gi;
                                r.isMesh && (n.includeInvisible || r.el && r.el.object3D.visible || r.visible) && (r === e ? s.identity() : (r.updateWorldMatrix(!0), s.multiplyMatrices(t, r.matrixWorld)), i(r.geometry.isBufferGeometry ? r.geometry.attributes.position.array : r.geometry.vertices, s.elements, r.geometry.index ? r.geometry.index.array : null))
                            }))
                        }
                    }(),
                    mL = function() { const t = new Gi; return function(e, n = {}) { const i = new ui(1, 1, 1); return "all" === n.fit && (t.fromArray(e), i.setFromMatrixScale(t)), i } }(),
                    fL = (new ui, function(t, e) {
                        const n = new mi;
                        let i = 1 / 0,
                            r = 1 / 0,
                            s = 1 / 0,
                            o = -1 / 0,
                            a = -1 / 0,
                            l = -1 / 0;
                        return n.min.set(0, 0, 0), n.max.set(0, 0, 0), gL(t, e, (t => { t.x < i && (i = t.x), t.y < r && (r = t.y), t.z < s && (s = t.z), t.x > o && (o = t.x), t.y > a && (a = t.y), t.z > l && (l = t.z) })), n.min.set(i, r, s), n.max.set(o, a, l), n
                    }),
                    gL = function() {
                        const t = new ui,
                            e = new Gi;
                        return function(n, i, r) { for (let s = 0; s < n.length; s++) { e.fromArray(i[s]); for (let i = 0; i < n[s].length; i += 3) t.set(n[s][i], n[s][i + 1], n[s][i + 2]).applyMatrix4(e), r(t) } }
                    }();
                class vL extends nL.Events {
                    addCollider(t, e, n) {
                        t.body && e.body && (t.body.checkCollisions = !0, e.body.checkCollisions = !0, this.on("collision", (i => {
                            var r, s;
                            const { bodies: o, event: a } = i;
                            (null === (r = o[0]) || void 0 === r ? void 0 : r.name) && (null === (s = o[1]) || void 0 === s ? void 0 : s.name) && (null == t ? void 0 : t.name) && (null == e ? void 0 : e.name) && (o[0].name === t.name && o[1].name === e.name || o[1].name === t.name && o[0].name === e.name) && n(a)
                        })))
                    }
                }
                const yL = new ui,
                    xL = new Yd,
                    _L = new zs,
                    bL = new ui,
                    wL = new Sr;
                class ML {
                    constructor() { this.tolerance = -1, this.faces = [], this.newFaces = [], this.assigned = new AL, this.unassigned = new AL, this.vertices = [] }
                    setFromPoints(t) {!0 !== Array.isArray(t) && console.error("THREE.ConvexHull: Points parameter is not an array."), t.length < 4 && console.error("THREE.ConvexHull: The algorithm needs at least four points."), this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++) this.vertices.push(new EL(t[e])); return this.compute(), this }
                    setFromObject(t) {
                        const e = [];
                        return t.updateMatrixWorld(!0), t.traverse((function(t) {
                            const n = t.geometry;
                            if (void 0 !== n) {
                                if (n.isGeometry) return void console.error("THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.");
                                if (n.isBufferGeometry) {
                                    const i = n.attributes.position;
                                    if (void 0 !== i)
                                        for (let n = 0, r = i.count; n < r; n++) {
                                            const r = new ui;
                                            r.fromBufferAttribute(i, n).applyMatrix4(t.matrixWorld), e.push(r)
                                        }
                                }
                            }
                        })), this.setFromPoints(e)
                    }
                    containsPoint(t) {
                        const e = this.faces;
                        for (let n = 0, i = e.length; n < i; n++)
                            if (e[n].distanceToPoint(t) > this.tolerance) return !1;
                        return !0
                    }
                    intersectRay(t, e) {
                        const n = this.faces;
                        let i = -1 / 0,
                            r = 1 / 0;
                        for (let e = 0, s = n.length; e < s; e++) {
                            const s = n[e],
                                o = s.distanceToPoint(t.origin),
                                a = s.normal.dot(t.direction);
                            if (o > 0 && a >= 0) return null;
                            const l = 0 !== a ? -o / a : 0;
                            if (!(l <= 0) && (a > 0 ? r = Math.min(l, r) : i = Math.max(l, i), i > r)) return null
                        }
                        return i !== -1 / 0 ? t.at(i, e) : t.at(r, e), e
                    }
                    intersectsRay(t) { return null !== this.intersectRay(t, yL) }
                    makeEmpty() { return this.faces = [], this.vertices = [], this }
                    addVertexToFace(t, e) { return t.face = e, null === e.outside ? this.assigned.append(t) : this.assigned.insertBefore(e.outside, t), e.outside = t, this }
                    removeVertexFromFace(t, e) { return t === e.outside && (null !== t.next && t.next.face === e ? e.outside = t.next : e.outside = null), this.assigned.remove(t), this }
                    removeAllVerticesFromFace(t) { if (null !== t.outside) { const e = t.outside; let n = t.outside; for (; null !== n.next && n.next.face === t;) n = n.next; return this.assigned.removeSubList(e, n), e.prev = n.next = null, t.outside = null, e } }
                    deleteFaceVertices(t, e) {
                        const n = this.removeAllVerticesFromFace(t);
                        if (void 0 !== n)
                            if (void 0 === e) this.unassigned.appendChain(n);
                            else {
                                let t = n;
                                do {
                                    const n = t.next;
                                    e.distanceToPoint(t.point) > this.tolerance ? this.addVertexToFace(t, e) : this.unassigned.append(t), t = n
                                } while (null !== t)
                            }
                        return this
                    }
                    resolveUnassignedPoints(t) {
                        if (!1 === this.unassigned.isEmpty()) {
                            let e = this.unassigned.first();
                            do {
                                const n = e.next;
                                let i = this.tolerance,
                                    r = null;
                                for (let n = 0; n < t.length; n++) { const s = t[n]; if (0 === s.mark) { const t = s.distanceToPoint(e.point); if (t > i && (i = t, r = s), i > 1e3 * this.tolerance) break } }
                                null !== r && this.addVertexToFace(e, r), e = n
                            } while (null !== e)
                        }
                        return this
                    }
                    computeExtremes() {
                        const t = new ui,
                            e = new ui,
                            n = [],
                            i = [];
                        for (let t = 0; t < 3; t++) n[t] = i[t] = this.vertices[0];
                        t.copy(this.vertices[0].point), e.copy(this.vertices[0].point);
                        for (let r = 0, s = this.vertices.length; r < s; r++) {
                            const s = this.vertices[r],
                                o = s.point;
                            for (let e = 0; e < 3; e++) o.getComponent(e) < t.getComponent(e) && (t.setComponent(e, o.getComponent(e)), n[e] = s);
                            for (let t = 0; t < 3; t++) o.getComponent(t) > e.getComponent(t) && (e.setComponent(t, o.getComponent(t)), i[t] = s)
                        }
                        return this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(t.x), Math.abs(e.x)) + Math.max(Math.abs(t.y), Math.abs(e.y)) + Math.max(Math.abs(t.z), Math.abs(e.z))), { min: n, max: i }
                    }
                    computeInitialHull() {
                        const t = this.vertices,
                            e = this.computeExtremes(),
                            n = e.min,
                            i = e.max;
                        let r = 0,
                            s = 0;
                        for (let t = 0; t < 3; t++) {
                            const e = i[t].point.getComponent(t) - n[t].point.getComponent(t);
                            e > r && (r = e, s = t)
                        }
                        const o = n[s],
                            a = i[s];
                        let l, c;
                        r = 0, xL.set(o.point, a.point);
                        for (let e = 0, n = this.vertices.length; e < n; e++) {
                            const n = t[e];
                            if (n !== o && n !== a) {
                                xL.closestPointToPoint(n.point, !0, bL);
                                const t = bL.distanceToSquared(n.point);
                                t > r && (r = t, l = n)
                            }
                        }
                        r = -1, _L.setFromCoplanarPoints(o.point, a.point, l.point);
                        for (let e = 0, n = this.vertices.length; e < n; e++) {
                            const n = t[e];
                            if (n !== o && n !== a && n !== l) {
                                const t = Math.abs(_L.distanceToPoint(n.point));
                                t > r && (r = t, c = n)
                            }
                        }
                        const h = [];
                        if (_L.distanceToPoint(c.point) < 0) {
                            h.push(SL.create(o, a, l), SL.create(c, a, o), SL.create(c, l, a), SL.create(c, o, l));
                            for (let t = 0; t < 3; t++) {
                                const e = (t + 1) % 3;
                                h[t + 1].getEdge(2).setTwin(h[0].getEdge(e)), h[t + 1].getEdge(1).setTwin(h[e + 1].getEdge(0))
                            }
                        } else {
                            h.push(SL.create(o, l, a), SL.create(c, o, a), SL.create(c, a, l), SL.create(c, l, o));
                            for (let t = 0; t < 3; t++) {
                                const e = (t + 1) % 3;
                                h[t + 1].getEdge(2).setTwin(h[0].getEdge((3 - t) % 3)), h[t + 1].getEdge(0).setTwin(h[e + 1].getEdge(1))
                            }
                        }
                        for (let t = 0; t < 4; t++) this.faces.push(h[t]);
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            if (n !== o && n !== a && n !== l && n !== c) {
                                r = this.tolerance;
                                let t = null;
                                for (let e = 0; e < 4; e++) {
                                    const i = this.faces[e].distanceToPoint(n.point);
                                    i > r && (r = i, t = this.faces[e])
                                }
                                null !== t && this.addVertexToFace(n, t)
                            }
                        }
                        return this
                    }
                    reindexFaces() {
                        const t = [];
                        for (let e = 0; e < this.faces.length; e++) {
                            const n = this.faces[e];
                            0 === n.mark && t.push(n)
                        }
                        return this.faces = t, this
                    }
                    nextVertexToAdd() {
                        if (!1 === this.assigned.isEmpty()) {
                            let t, e = 0;
                            const n = this.assigned.first().face;
                            let i = n.outside;
                            do {
                                const r = n.distanceToPoint(i.point);
                                r > e && (e = r, t = i), i = i.next
                            } while (null !== i && i.face === n);
                            return t
                        }
                    }
                    computeHorizon(t, e, n, i) {
                        let r;
                        this.deleteFaceVertices(n), n.mark = 1, r = null === e ? e = n.getEdge(0) : e.next;
                        do {
                            const e = r.twin,
                                n = e.face;
                            0 === n.mark && (n.distanceToPoint(t) > this.tolerance ? this.computeHorizon(t, e, n, i) : i.push(r)), r = r.next
                        } while (r !== e);
                        return this
                    }
                    addAdjoiningFace(t, e) { const n = SL.create(t, e.tail(), e.head()); return this.faces.push(n), n.getEdge(-1).setTwin(e.twin), n.getEdge(0) }
                    addNewFaces(t, e) {
                        this.newFaces = [];
                        let n = null,
                            i = null;
                        for (let r = 0; r < e.length; r++) {
                            const s = e[r],
                                o = this.addAdjoiningFace(t, s);
                            null === n ? n = o : o.next.setTwin(i), this.newFaces.push(o.face), i = o
                        }
                        return n.next.setTwin(i), this
                    }
                    addVertexToHull(t) { const e = []; return this.unassigned.clear(), this.removeVertexFromFace(t, t.face), this.computeHorizon(t.point, null, t.face, e), this.addNewFaces(t, e), this.resolveUnassignedPoints(this.newFaces), this }
                    cleanup() { return this.assigned.clear(), this.unassigned.clear(), this.newFaces = [], this }
                    compute() { let t; for (this.computeInitialHull(); void 0 !== (t = this.nextVertexToAdd());) this.addVertexToHull(t); return this.reindexFaces(), this.cleanup(), this }
                }
                class SL {
                    constructor() { this.normal = new ui, this.midpoint = new ui, this.area = 0, this.constant = 0, this.outside = null, this.mark = 0, this.edge = null }
                    static create(t, e, n) {
                        const i = new SL,
                            r = new TL(t, i),
                            s = new TL(e, i),
                            o = new TL(n, i);
                        return r.next = o.prev = s, s.next = r.prev = o, o.next = s.prev = r, i.edge = r, i.compute()
                    }
                    getEdge(t) { let e = this.edge; for (; t > 0;) e = e.next, t--; for (; t < 0;) e = e.prev, t++; return e }
                    compute() {
                        const t = this.edge.tail(),
                            e = this.edge.head(),
                            n = this.edge.next.head();
                        return wL.set(t.point, e.point, n.point), wL.getNormal(this.normal), wL.getMidpoint(this.midpoint), this.area = wL.getArea(), this.constant = this.normal.dot(this.midpoint), this
                    }
                    distanceToPoint(t) { return this.normal.dot(t) - this.constant }
                }
                class TL {
                    constructor(t, e) { this.vertex = t, this.prev = null, this.next = null, this.twin = null, this.face = e }
                    head() { return this.vertex }
                    tail() { return this.prev ? this.prev.vertex : null }
                    length() {
                        const t = this.head(),
                            e = this.tail();
                        return null !== e ? e.point.distanceTo(t.point) : -1
                    }
                    lengthSquared() {
                        const t = this.head(),
                            e = this.tail();
                        return null !== e ? e.point.distanceToSquared(t.point) : -1
                    }
                    setTwin(t) { return this.twin = t, t.twin = this, this }
                }
                class EL { constructor(t) { this.point = t, this.prev = null, this.next = null, this.face = null } }
                class AL {
                    constructor() { this.head = null, this.tail = null }
                    first() { return this.head }
                    last() { return this.tail }
                    clear() { return this.head = this.tail = null, this }
                    insertBefore(t, e) { return e.prev = t.prev, e.next = t, null === e.prev ? this.head = e : e.prev.next = e, t.prev = e, this }
                    insertAfter(t, e) { return e.prev = t, e.next = t.next, null === e.next ? this.tail = e : e.next.prev = e, t.next = e, this }
                    append(t) { return null === this.head ? this.head = t : this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t, this }
                    appendChain(t) { for (null === this.head ? this.head = t : this.tail.next = t, t.prev = this.tail; null !== t.next;) t = t.next; return this.tail = t, this }
                    remove(t) { return null === t.prev ? this.head = t.next : t.prev.next = t.next, null === t.next ? this.tail = t.prev : t.next.prev = t.prev, this }
                    removeSubList(t, e) { return null === t.prev ? this.head = e.next : t.prev.next = e.next, null === e.next ? this.tail = t.prev : e.next.prev = t.prev, this }
                    isEmpty() { return null === this.head }
                }
                class LL extends rs {
                    constructor(t) {
                        super();
                        const e = [],
                            n = [];
                        void 0 === ML && console.error("THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on ConvexHull");
                        const i = (new ML).setFromPoints(t).faces;
                        for (let t = 0; t < i.length; t++) {
                            const r = i[t];
                            let s = r.edge;
                            do {
                                const t = s.head().point;
                                e.push(t.x, t.y, t.z), n.push(r.normal.x, r.normal.y, r.normal.z), s = s.next
                            } while (s !== r.edge)
                        }
                        this.setAttribute("position", new qr(e, 3)), this.setAttribute("normal", new qr(n, 3))
                    }
                }
                const RL = t => new(window.THREE && window.THREE.ConvexGeometry ? window.THREE.ConvexGeometry : LL)(t),
                    CL = function(t, e) { this.minSizeForBreak = t || 1.4, this.smallDelta = e || 1e-4, this.tempLine1 = new Yd, this.tempPlane1 = new zs, this.tempPlane2 = new zs, this.tempPlane_Cut = new zs, this.tempCM1 = new ui, this.tempCM2 = new ui, this.tempVector3 = new ui, this.tempVector3_2 = new ui, this.tempVector3_3 = new ui, this.tempVector3_P0 = new ui, this.tempVector3_P1 = new ui, this.tempVector3_P2 = new ui, this.tempVector3_N0 = new ui, this.tempVector3_N1 = new ui, this.tempVector3_AB = new ui, this.tempVector3_CB = new ui, this.tempResultObjects = { object1: null, object2: null }, this.segments = []; for (var n = 0; n < 900; n++) this.segments[n] = !1 };
                var PL;
                CL.prototype = {
                    constructor: CL,
                    prepareBreakableObject: function(t, e, n, i, r) {
                        t.geometry.isBufferGeometry || console.error("THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry."), t.userData.ammoPhysicsData = {};
                        var s = t.userData.ammoPhysicsData;
                        s.mass = e, s.velocity = n.clone(), s.angularVelocity = i.clone(), s.breakable = r
                    },
                    subdivideByImpact: function(t, e, n, i, r) {
                        var s = [],
                            o = this.tempPlane1,
                            a = this.tempPlane2;
                        this.tempVector3.addVectors(e, n), o.setFromCoplanarPoints(e, t.position, this.tempVector3);
                        var l = r + i,
                            c = this;
                        return function r(h, u, d, p) {
                            if (Math.random() < .05 * p || p > l) s.push(h);
                            else {
                                var m = Math.PI;
                                0 === p ? (a.normal.copy(o.normal), a.constant = o.constant) : p <= i ? (m = (d - u) * (.2 + .6 * Math.random()) + u, c.tempVector3_2.copy(t.position).sub(e).applyAxisAngle(n, m).add(e), a.setFromCoplanarPoints(e, c.tempVector3, c.tempVector3_2)) : (m = (.5 * (1 & p) + .2 * (2 - Math.random())) * Math.PI, c.tempVector3_2.copy(e).sub(h.position).applyAxisAngle(n, m).add(h.position), c.tempVector3_3.copy(n).add(h.position), a.setFromCoplanarPoints(h.position, c.tempVector3_3, c.tempVector3_2)), c.cutByPlane(h, a, c.tempResultObjects);
                                var f = c.tempResultObjects.object1,
                                    g = c.tempResultObjects.object2;
                                f && r(f, u, m, p + 1), g && r(g, m, d, p + 1)
                            }
                        }(t, 0, 2 * Math.PI, 0), s
                    },
                    cutByPlane: function(t, e, n) {
                        var i = t.geometry,
                            r = i.attributes.position.array,
                            s = i.attributes.normal.array,
                            o = r.length / 3,
                            a = o / 3,
                            l = i.getIndex();

                        function c(t, e) { var n = 3 * t + e; return l ? l[n] : n }
                        l && (a = (l = l.array).length / 3);
                        for (var h = [], u = [], d = this.smallDelta, p = o * o, m = 0; m < p; m++) this.segments[m] = !1;
                        var f = this.tempVector3_P0,
                            g = this.tempVector3_P1,
                            v = this.tempVector3_N0,
                            y = this.tempVector3_N1;
                        for (m = 0; m < a - 1; m++) {
                            var x = c(m, 0),
                                _ = c(m, 1),
                                b = c(m, 2);
                            v.set(s[x], s[x] + 1, s[x] + 2);
                            for (var w = m + 1; w < a; w++) {
                                var M = c(w, 0),
                                    S = c(w, 1),
                                    T = c(w, 2);
                                y.set(s[M], s[M] + 1, s[M] + 2), 1 - v.dot(y) < d && (x === M || x === S || x === T ? _ === M || _ === S || _ === T ? (this.segments[x * o + _] = !0, this.segments[_ * o + x] = !0) : (this.segments[b * o + x] = !0, this.segments[x * o + b] = !0) : _ !== M && _ !== S && _ !== T || (this.segments[b * o + _] = !0, this.segments[_ * o + b] = !0))
                            }
                        }
                        var E = this.tempPlane_Cut;
                        for (t.updateMatrix(), CL.transformPlaneToLocalSpace(e, t.matrix, E), m = 0; m < a; m++)
                            for (var A = c(m, 0), L = c(m, 1), R = c(m, 2), C = 0; C < 3; C++) {
                                var P = 0 === C ? A : 1 === C ? L : R,
                                    I = 0 === C ? L : 1 === C ? R : A;
                                if (!this.segments[P * o + I]) {
                                    this.segments[P * o + I] = !0, this.segments[I * o + P] = !0, f.set(r[3 * P], r[3 * P + 1], r[3 * P + 2]), g.set(r[3 * I], r[3 * I + 1], r[3 * I + 2]);
                                    var D = 0;
                                    (N = E.distanceToPoint(f)) > d ? (D = 2, u.push(f.clone())) : N < -d ? (D = 1, h.push(f.clone())) : (D = 3, h.push(f.clone()), u.push(f.clone()));
                                    var N, B = 0;
                                    if ((N = E.distanceToPoint(g)) > d ? (B = 2, u.push(g.clone())) : N < -d ? (B = 1, h.push(g.clone())) : (B = 3, h.push(g.clone()), u.push(g.clone())), 1 === D && 2 === B || 2 === D && 1 === B) {
                                        this.tempLine1.start.copy(f), this.tempLine1.end.copy(g);
                                        var O = new ui;
                                        if (void 0 === (O = E.intersectLine(this.tempLine1, O))) return console.error("Internal error: segment does not intersect plane."), n.segmentedObject1 = null, n.segmentedObject2 = null, 0;
                                        h.push(O), u.push(O.clone())
                                    }
                                }
                            }
                        var F = .5 * t.userData.ammoPhysicsData.mass;
                        this.tempCM1.set(0, 0, 0);
                        var z = 0,
                            U = h.length;
                        if (U > 0) {
                            for (m = 0; m < U; m++) this.tempCM1.add(h[m]);
                            for (this.tempCM1.divideScalar(U), m = 0; m < U; m++)(G = h[m]).sub(this.tempCM1), z = Math.max(z, G.x, G.y, G.z);
                            this.tempCM1.add(t.position)
                        }
                        this.tempCM2.set(0, 0, 0);
                        var H = 0,
                            k = u.length;
                        if (k > 0) {
                            for (m = 0; m < k; m++) this.tempCM2.add(u[m]);
                            for (this.tempCM2.divideScalar(k), m = 0; m < k; m++) {
                                var G;
                                (G = u[m]).sub(this.tempCM2), H = Math.max(H, G.x, G.y, G.z)
                            }
                            this.tempCM2.add(t.position)
                        }
                        var V = null,
                            W = null,
                            j = 0;
                        if (U > 4) try {
                            (V = new ws(RL(h), t.material)).position.copy(this.tempCM1), V.quaternion.copy(t.quaternion), V.userData = t.userData, this.prepareBreakableObject(V, F, t.userData.ammoPhysicsData.velocity, t.userData.ammoPhysicsData.angularVelocity, 2 * z > this.minSizeForBreak), j++
                        } catch (t) { LA("Error in ConvexObjectBreaker.ts", !0), LA(t, !0) }
                        if (k > 4) try {
                            (W = new ws(RL(u), t.material)).position.copy(this.tempCM2), W.quaternion.copy(t.quaternion), W.userData = t.userData, this.prepareBreakableObject(W, F, t.userData.ammoPhysicsData.velocity, t.userData.ammoPhysicsData.angularVelocity, 2 * H > this.minSizeForBreak), j++
                        } catch (t) { LA("Error in ConvexObjectBreaker.ts", !0), LA(t, !0) }
                        return n.object1 = V, n.object2 = W, j
                    }
                }, CL.transformFreeVector = function(t, e) {
                    var n = t.x,
                        i = t.y,
                        r = t.z,
                        s = e.elements;
                    return t.x = s[0] * n + s[4] * i + s[8] * r, t.y = s[1] * n + s[5] * i + s[9] * r, t.z = s[2] * n + s[6] * i + s[10] * r, t
                }, CL.transformFreeVectorInverse = function(t, e) {
                    var n = t.x,
                        i = t.y,
                        r = t.z,
                        s = e.elements;
                    return t.x = s[0] * n + s[1] * i + s[2] * r, t.y = s[4] * n + s[5] * i + s[6] * r, t.z = s[8] * n + s[9] * i + s[10] * r, t
                }, CL.transformTiedVectorInverse = function(t, e) {
                    var n = t.x,
                        i = t.y,
                        r = t.z,
                        s = e.elements;
                    return t.x = s[0] * n + s[1] * i + s[2] * r - s[12], t.y = s[4] * n + s[5] * i + s[6] * r - s[13], t.z = s[8] * n + s[9] * i + s[10] * r - s[14], t
                }, CL.transformPlaneToLocalSpace = (PL = new ui, function(t, e, n) {
                    n.normal.copy(t.normal), n.constant = t.constant;
                    var i = CL.transformTiedVectorInverse(t.coplanarPoint(PL), e);
                    CL.transformFreeVectorInverse(n.normal, e), n.constant = -i.dot(n.normal)
                });
                var IL = n(205);
                const DL = (t, e) => { e.forEach((e => { Object.getOwnPropertyNames(e.prototype).forEach((n => { Object.defineProperty(t.prototype, n, Object.getOwnPropertyDescriptor(e.prototype, n)) })) })) };
                class NL {
                    constructor(t) { this.physics = t }
                    setRayFromWorld(t = 0, e = 0, n = 0) { this._btRayFrom.setValue(t, e, n) }
                    setRayToWorld(t = 0, e = 0, n = 0) { this._btRayTo.setValue(t, e, n) }
                    hasHit() { return this._btRayCallback.hasHit() }
                    rayTest() { void 0 !== this._btRayCallback && Ammo.destroy(this._btRayCallback), this._btRayCallback = "closest" === this.type ? new Ammo.ClosestRayResultCallback(this._btRayFrom, this._btRayTo) : new Ammo.AllHitsRayResultCallback(this._btRayFrom, this._btRayTo), this.physics.physicsWorld.rayTest(this._btRayFrom, this._btRayTo, this._btRayCallback) }
                    destroy() { void 0 !== this._btRayFrom && Ammo.destroy(this._btRayFrom), void 0 !== this._btRayTo && Ammo.destroy(this._btRayTo), void 0 !== this._btRayCallback && Ammo.destroy(this._btRayCallback) }
                }
                class BL { constructor(t) { this.physics = t, this.type = "closest", this._btRayFrom = new Ammo.btVector3(0, 0, 0), this._btRayTo = new Ammo.btVector3(0, 0, 0) } }
                class OL { constructor(t) { this.physics = t, this.type = "allHits", this._btRayFrom = new Ammo.btVector3(0, 0, 0), this._btRayTo = new Ammo.btVector3(0, 0, 0) } }
                DL(BL, [NL, class {
                    constructor(t) { this.physics = t }
                    getHitPointWorld() { const t = this._btRayCallback.get_m_hitPointWorld(); return { x: t.x(), y: t.y(), z: t.z() } }
                    getHitNormalWorld() { const t = this._btRayCallback.get_m_hitNormalWorld(); return { x: t.x(), y: t.y(), z: t.z() } }
                    getCollisionObject() { return Ammo.castObject(this._btRayCallback.get_m_collisionObject(), Ammo.btRigidBody).threeObject }
                }]), DL(OL, [NL, class {
                    constructor(t) { this.physics = t }
                    getHitPointsWorld() {
                        const t = this._btRayCallback.get_m_hitPointWorld(),
                            e = [];
                        for (let n = t.size() - 1; n >= 0; n--) {
                            const i = t.at(n);
                            e.push({ x: i.x(), y: i.y(), z: i.z() })
                        }
                        return e
                    }
                    getHitPointWorld() { return LA("Use getHitPointsWorld() instead of getHitPointWorld() for the AllHitsRayCaster!"), this.getHitPointsWorld() }
                    getHitNormalsWorld() {
                        const t = this._btRayCallback.get_m_hitNormalWorld(),
                            e = [];
                        for (let n = t.size() - 1; n >= 0; n--) {
                            const i = t.at(n);
                            e.push({ x: i.x(), y: i.y(), z: i.z() })
                        }
                        return e
                    }
                    getCollisionObjects() {
                        const t = [],
                            e = this._btRayCallback.get_m_collisionObjects();
                        for (let n = e.size() - 1; n >= 0; n--) {
                            const i = Ammo.castObject(e.at(n), Ammo.btRigidBody);
                            t.push(i.threeObject)
                        }
                        return t
                    }
                }]);
                class FL extends nL.Events {
                    constructor(t, e = {}) { super(), this.scene = t, this.config = e, this.rigidBodies = [], this.earlierDetectedCollisions = [], this.complexShapes = ["plane", "hull", "hacd", "vhacd", "convexMesh", "concaveMesh"], this.gravity = e.gravity || { x: 0, y: -9.81, z: 0 }, this.isHeadless = "headless" === t, this.tmpEuler = new Qi, this.tmpQuaternion = new hi, this.tmpVector3 = new ui, this.tmpVector3a = new ui, this.tmpMatrix4 = new Gi, this.tmpMatrix4a = new Gi, this.tmpBtVector3 = new Ammo.btVector3, this.tmpBtQuaternion = new Ammo.btQuaternion(0, 0, 0, 1), this.emptyV3 = new ui, this.impactPoint = new ui, this.impactNormal = new ui, "headless" !== t && (this.defaultMaterial = new RA), this.start() }
                    get tmpTrans() { return console.warn("Use worldTransform instead of tmpTrans."), this.worldTransform }
                    set tmpTrans(t) { console.warn("Use worldTransform instead of tmpTrans."), this.worldTransform = t }
                    destroy(t) { var e; const n = Object.keys(t).includes("body") ? t.body : t; if (void 0 === (null == n ? void 0 : n.ammo)) return; let i = n.ammo.threeObject; const r = i.name; if (r && i && (null === (e = null == i ? void 0 : i.body) || void 0 === e ? void 0 : e.ammo)) { i.body.isSoftBody ? this.physicsWorld.removeSoftBody(i.body.ammo) : this.physicsWorld.removeRigidBody(i.body.ammo), i.body.destructor(), i.body = void 0, i.hasBody = !1, delete n.ammo.threeObject; for (let t = 0; t < this.rigidBodies.length; t++) this.rigidBodies[t].name === r && (this.rigidBodies.splice(t, 1), t--) } "headless" === this.scene && i && (i = null) }
                    setup() {
                        if (this.worldTransform = new Ammo.btTransform, "function" == typeof this.config.setupPhysicsWorld ? this.physicsWorld = this.config.setupPhysicsWorld() : this.physicsWorld = this.setupPhysicsWorld(), "headless" !== this.scene) { this.convexBreaker = new CL, this.objectsToRemove = [], this.numObjectsToRemove = 0; for (let t = 0; t < 500; t++) this.objectsToRemove[t] = null }
                        this.collisionEvents = new vL, this.factory = new PA(this.scene), this.shapes = new class {
                            constructor(t, e) { this.factory = t, this.addExisting = e }
                            addPlane(t = {}, e = {}) { const n = this.factory.add.plane(t, e); return this.addExisting(n, t), n }
                            addSphere(t = {}, e = {}) { const n = this.factory.add.sphere(t, e); return this.addExisting(n, t), n }
                            addBox(t = {}, e = {}) { const n = this.factory.add.box(t, e); return this.addExisting(n, t), n }
                            addGround(t, e = {}) {
                                const n = this.factory.add.ground(t, e),
                                    i = Object.assign(Object.assign({}, t), { mass: 0, collisionFlags: 1 });
                                return this.addExisting(n, i), n
                            }
                            addCylinder(t = {}, e = {}) { const n = this.factory.add.cylinder(t, e); return this.addExisting(n, t), n }
                            addCone(t = {}, e = {}) { const n = this.factory.add.cone(t, e); return this.addExisting(n, t), n }
                            addTorus(t = {}, e = {}) { const n = this.factory.add.torus(t, e); return this.addExisting(n, t), n }
                            addExtrude(t, e = {}) { const n = this.factory.add.extrude(t, e); return n.translateX(1), this.addExisting(n), n }
                        }(this.factory, ((t, e) => this.addExisting(t, e))), this.constraints = new rL(this.worldTransform, this.physicsWorld), "headless" !== this.scene && (this.debugDrawer = new class {
                            constructor(t, e, n = {}) {
                                this.scene = t, this.world = e, this.options = n, this.debugDrawMode = n.debugDrawMode || 1;
                                const i = 32768 & this.debugDrawMode || !1,
                                    r = n.maxBufferSize || 1e6;
                                this.geometry = new rs;
                                const s = new Float32Array(3 * r),
                                    o = new Float32Array(3 * r);
                                this.geometry.setAttribute("position", new Fr(s, 3).setUsage(Rn)), this.geometry.setAttribute("color", new Fr(o, 3).setUsage(Rn)), this.index = 0;
                                const a = new ql({ vertexColors: !0, depthTest: !i });
                                this.mesh = new ec(this.geometry, a), i && (this.mesh.renderOrder = 999), this.mesh.frustumCulled = !1, this.enabled = !1, this.debugDrawer = new Ammo.DebugDrawer, this.debugDrawer.drawLine = this.drawLine.bind(this), this.debugDrawer.drawContactPoint = this.drawContactPoint.bind(this), this.debugDrawer.reportErrorWarning = this.reportErrorWarning.bind(this), this.debugDrawer.draw3dText = this.draw3dText.bind(this), this.debugDrawer.setDebugMode = this.setDebugMode.bind(this), this.debugDrawer.getDebugMode = this.getDebugMode.bind(this), this.world.setDebugDrawer(this.debugDrawer)
                            }
                            enable() { this.enabled = !0, this.scene.add(this.mesh) }
                            disable() { this.enabled = !1, this.scene.remove(this.mesh) }
                            update() { this.enabled && (0 != this.index && (this.geometry.attributes.position.needsUpdate = !0, this.geometry.attributes.color.needsUpdate = !0), this.index = 0, this.world.debugDrawWorld(), this.geometry.setDrawRange(0, this.index)) }
                            drawLine(t, e, n) {
                                const i = Ammo.HEAPF32,
                                    r = i[(n + 0) / 4],
                                    s = i[(n + 4) / 4],
                                    o = i[(n + 8) / 4],
                                    a = i[(t + 0) / 4],
                                    l = i[(t + 4) / 4],
                                    c = i[(t + 8) / 4];
                                this.geometry.attributes.position.setXYZ(this.index, a, l, c), this.geometry.attributes.color.setXYZ(this.index++, r, s, o);
                                const h = i[(e + 0) / 4],
                                    u = i[(e + 4) / 4],
                                    d = i[(e + 8) / 4];
                                this.geometry.attributes.position.setXYZ(this.index, h, u, d), this.geometry.attributes.color.setXYZ(this.index++, r, s, o)
                            }
                            drawContactPoint(t, e, n, i, r) {
                                const s = Ammo.HEAPF32,
                                    o = s[(r + 0) / 4],
                                    a = s[(r + 4) / 4],
                                    l = s[(r + 8) / 4],
                                    c = s[(t + 0) / 4],
                                    h = s[(t + 4) / 4],
                                    u = s[(t + 8) / 4];
                                this.geometry.attributes.position.setXYZ(this.index, c, h, u), this.geometry.attributes.color.setXYZ(this.index++, o, a, l);
                                const d = s[(e + 0) / 4] * n,
                                    p = s[(e + 4) / 4] * n,
                                    m = s[(e + 8) / 4] * n;
                                this.geometry.attributes.position.setXYZ(this.index, c + d, h + p, u + m), this.geometry.attributes.color.setXYZ(this.index++, o, a, l)
                            }
                            reportErrorWarning(t) { Ammo.hasOwnProperty("Pointer_stringify") ? console.warn(Ammo.Pointer_stringify(t)) : this.warnedOnce || (this.warnedOnce = !0, console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag")) }
                            draw3dText(t, e) { console.warn("TODO: draw3dText") }
                            setDebugMode(t) { this.debugDrawMode = t }
                            getDebugMode() { return this.debugDrawMode }
                        }(this.scene, this.physicsWorld, {}))
                    }
                    updateDebugger() { "headless" !== this.scene && this.debugDrawer && this.debugDrawer.enabled && this.debugDrawer.update() }
                    setupPhysicsWorld() {
                        const t = this.gravity,
                            { softBodies: e = !1 } = this.config;
                        let n;
                        if (!e) {
                            const t = new Ammo.btDefaultCollisionConfiguration,
                                e = new Ammo.btCollisionDispatcher(t),
                                i = new Ammo.btDbvtBroadphase,
                                r = new Ammo.btSequentialImpulseConstraintSolver;
                            n = new Ammo.btDiscreteDynamicsWorld(e, i, r, t)
                        }
                        if (e) {
                            const t = new Ammo.btSoftBodyRigidBodyCollisionConfiguration,
                                e = new Ammo.btCollisionDispatcher(t),
                                i = new Ammo.btDbvtBroadphase,
                                r = new Ammo.btSequentialImpulseConstraintSolver,
                                s = new Ammo.btDefaultSoftBodySolver;
                            n = new Ammo.btSoftRigidDynamicsWorld(e, i, r, t, s)
                        }
                        return n.setGravity(new Ammo.btVector3(t.x, t.y, t.z)), n
                    }
                    createDebrisFromBreakableObject(t, e) { "headless" !== this.scene && (t.material = e.material, t.shape = "hull", t.fragmentDepth = e.fragmentDepth + 1, t.name = `${e.name}__DEBRIS_${t.id}`, this.scene.add(t), this.addExisting(t, { autoCenter: !0 }), t.body.fractureImpulse = e.body.fractureImpulse, t.body.breakable = !1, setTimeout((() => { t.body.breakable = !0 }), 2500)) }
                    removeDebris(t) { "headless" !== this.scene && (this.scene.remove(t), this.destroy(t)) }
                    update(t) { this.updatePhysics(t), this.detectCollisions() }
                    updatePhysics(t) {
                        const e = t / 1e3;
                        this.physicsWorld.stepSimulation(e, this.config.maxSubSteps || 4, this.config.fixedTimeStep || 1 / 60);
                        for (let t = 0; t < this.rigidBodies.length; t++) {
                            const e = this.rigidBodies[t],
                                n = e.body.ammo.getMotionState();
                            if (n)
                                if (n.getWorldTransform(this.worldTransform), e.body.didUpdate && (e.body._emitUpdateEvents && e.body.eventEmitter.emit("update"), e.body.didUpdate = !1), e.body.ammo.isKinematicObject() && e.body.needUpdate) e.getWorldQuaternion(this.tmpQuaternion), e.getWorldPosition(this.tmpVector3), this.tmpBtVector3.setValue(this.tmpVector3.x, this.tmpVector3.y, this.tmpVector3.z), this.tmpBtQuaternion.setValue(this.tmpQuaternion.x, this.tmpQuaternion.y, this.tmpQuaternion.z, this.tmpQuaternion.w), this.worldTransform.setOrigin(this.tmpBtVector3), this.worldTransform.setRotation(this.tmpBtQuaternion), n.setWorldTransform(this.worldTransform), e.body.needUpdate = !1;
                                else if (e.body.skipUpdate);
                            else if (!e.body.ammo.isStaticObject()) {
                                const t = this.worldTransform.getOrigin(),
                                    n = this.worldTransform.getRotation(),
                                    i = e.body.offset;
                                if (e.body.ignoreScale) this.tmpVector3a.set(e.scale.x, e.scale.y, e.scale.z);
                                else {
                                    const t = e.body.ammo.getCollisionShape().getLocalScaling();
                                    this.tmpVector3a.set(t.x(), t.y(), t.z())
                                }
                                this.tmpVector3.set(t.x() + i.x, t.y() + i.y, t.z() + i.z), this.tmpQuaternion.set(n.x(), n.y(), n.z(), n.w()), this.tmpMatrix4.compose(this.tmpVector3, this.tmpQuaternion, this.tmpVector3a), e.parent ? parseInt(a) >= 123 ? this.tmpMatrix4a.copy(e.parent.matrixWorld).invert() : this.tmpMatrix4a.getInverse(e.parent.matrixWorld) : this.tmpMatrix4a.identity(), this.tmpMatrix4a.multiply(this.tmpMatrix4), this.tmpMatrix4a.decompose(e.position, e.quaternion, e.scale)
                            }
                        }
                    }
                    detectCollisions() {
                        var t, e;
                        const n = [];
                        this.impactPoint.set(0, 0, 0), this.impactNormal.set(0, 0, 0);
                        const i = this.physicsWorld.getDispatcher(),
                            r = i.getNumManifolds();
                        for (let s = 0; s < r; s++) {
                            const r = i.getManifoldByIndexInternal(s),
                                o = r.getNumContacts(),
                                a = Ammo.castObject(r.getBody0(), Ammo.btRigidBody),
                                l = Ammo.castObject(r.getBody1(), Ammo.btRigidBody),
                                c = a.threeObject,
                                h = l.threeObject;
                            if (!c || !h) continue;
                            if ("" === a.name && "" === l.name) continue;
                            const u = null === (t = c.body) || void 0 === t ? void 0 : t.checkCollisions,
                                d = null === (e = h.body) || void 0 === e ? void 0 : e.checkCollisions,
                                p = c.body.breakable,
                                m = h.body.breakable,
                                f = c.body.fractureImpulse,
                                g = h.body.fractureImpulse,
                                v = u || d,
                                y = p || m;
                            if (void 0 === c.fragmentDepth && (c.fragmentDepth = 0), void 0 === h.fragmentDepth && (h.fragmentDepth = 0), !v && !y) continue;
                            let x = !1,
                                _ = 0,
                                b = "start";
                            for (let t = 0; t < o; t++) {
                                const e = r.getContactPoint(t);
                                if (e.getDistance() <= 0) {
                                    x = !0;
                                    const t = e.getAppliedImpulse(),
                                        i = e.get_m_positionWorldOnB(),
                                        r = e.get_m_normalWorldOnB();
                                    if (u || d) {
                                        const t = [c.name, h.name].sort(),
                                            e = `${t[0]}__${t[1]}`;
                                        this.earlierDetectedCollisions.find((t => t.combinedName === e)) && (b = "collision"), n.find((t => t.combinedName === e)) || (n.push({ combinedName: e, collision: !0 }), this.collisionEvents.emit("collision", { bodies: [c, h], event: b }))
                                    }
                                    t >= _ && (_ = t, (p || m) && (this.impactPoint.set(i.x(), i.y(), i.z()), this.impactNormal.set(r.x(), r.y(), r.z())));
                                    break
                                }
                            }
                            if (!x) continue;
                            if (!y) continue;
                            const w = 2;
                            if (this.emptyV3.set(0, 0, 0), c.userData.ammoPhysicsData = { mass: 1, velocity: this.emptyV3, angularVelocity: this.emptyV3, breakable: p, physicsBody: a }, h.userData.ammoPhysicsData = { mass: 1, velocity: this.emptyV3, angularVelocity: this.emptyV3, breakable: m, physicsBody: l }, p && _ > f && c.fragmentDepth < w) {
                                const t = this.convexBreaker.subdivideByImpact(c, this.impactPoint, this.impactNormal, 1, 2),
                                    e = t.length;
                                for (let n = 0; n < e; n++) {
                                    const e = a.getLinearVelocity(),
                                        i = a.getAngularVelocity(),
                                        r = t[n];
                                    r.userData.ammoPhysicsData.velocity.set(e.x(), e.y(), e.z()), r.userData.ammoPhysicsData.angularVelocity.set(i.x(), i.y(), i.z()), this.createDebrisFromBreakableObject(r, c)
                                }
                                this.objectsToRemove[this.numObjectsToRemove++] = c
                            }
                            if (m && _ > g && h.fragmentDepth < w) {
                                const t = this.convexBreaker.subdivideByImpact(h, this.impactPoint, this.impactNormal, 1, 2),
                                    e = t.length;
                                for (let n = 0; n < e; n++) {
                                    const e = l.getLinearVelocity(),
                                        i = l.getAngularVelocity(),
                                        r = t[n];
                                    r.userData.ammoPhysicsData.velocity.set(e.x(), e.y(), e.z()), r.userData.ammoPhysicsData.angularVelocity.set(i.x(), i.y(), i.z()), this.createDebrisFromBreakableObject(r, h)
                                }
                                this.objectsToRemove[this.numObjectsToRemove++] = h
                            }
                        }
                        for (let t = 0; t < this.numObjectsToRemove; t++) this.removeDebris(this.objectsToRemove[t]);
                        this.numObjectsToRemove = 0, this.earlierDetectedCollisions.forEach((t => {
                            const { combinedName: e } = t;
                            if (!n.find((t => t.combinedName === e))) {
                                const t = e.split("__"),
                                    n = this.rigidBodies.find((e => e.name === t[0])),
                                    i = this.rigidBodies.find((e => e.name === t[1])),
                                    r = "end";
                                n && i && this.collisionEvents.emit("collision", { bodies: [n, i], event: r })
                            }
                        })), this.earlierDetectedCollisions = [...n]
                    }
                    setGravity(t = 0, e = -9.8, n = 0) { this.tmpBtVector3.setValue(t, e, n), this.physicsWorld.setGravity(this.tmpBtVector3) }
                    get debug() { return this.isHeadless ? null : { enable: () => { this.debugDrawer.enable() }, mode: (t = 1) => { this.debugDrawer.setDebugMode(t) }, disable: () => { this.debugDrawer.disable() } } }
                    start() { "undefined" != typeof Ammo ? "function" == typeof Ammo ? Ammo().then((() => { this.setup() })) : this.setup() : LA("Are you sure you included ammo.js?") }
                    get add() { return { collider: (t, e, n) => this.collisionEvents.addCollider(t, e, n), constraints: this.constraints.addConstraints, existing: (t, e) => this.addExisting(t, e), plane: (t = {}, e = {}) => this.shapes.addPlane(t, e), sphere: (t = {}, e = {}) => this.shapes.addSphere(t, e), ground: (t = {}, e = {}) => this.shapes.addGround(t, e), box: (t = {}, e = {}) => this.shapes.addBox(t, e), cylinder: (t = {}, e = {}) => this.shapes.addCylinder(t, e), cone: (t = {}, e = {}) => this.shapes.addCone(t, e), torus: (t = {}, e = {}) => this.shapes.addTorus(t, e), extrude: (t, e = {}) => this.shapes.addExtrude(t, e), raycaster: (t = "closest") => "closest" === t ? new BL(this) : new OL(this) } }
                    prepareThreeObjectForCollisionShape(t, e = {}) { var n, i; const { autoCenter: r = !1 } = e, s = { width: 1, height: 1, depth: 1, radius: 1, radiusTop: 1, radiusBottom: 1, tube: .4, tubularSegments: 6 }; let o = "unknown"; const a = (null === (n = t.geometry) || void 0 === n ? void 0 : n.type) || "unknown"; /box/i.test(a) ? o = "box" : /cone/i.test(a) ? o = "cone" : /cylinder/i.test(a) ? o = "cylinder" : /extrude/i.test(a) ? o = "extrude" : /plane/i.test(a) ? o = "plane" : /sphere/i.test(a) ? o = "sphere" : /torus/i.test(a) && (o = "torus"); let l = Object.assign(Object.assign({}, s), null === (i = null == t ? void 0 : t.geometry) || void 0 === i ? void 0 : i.parameters); return e.shape ? (l = Object.assign(Object.assign({}, s), e), o = e.shape) : t.shape && (o = t.shape), Object.keys(l).forEach((t => { void 0 === l[t] && s[t] && (l[t] = s[t]) })), r && t.geometry.center(), "cylinder" === o && (l.radius = e.radius || l.radiusTop), "extrude" === o && (o = "hacd"), "mesh" !== o && "convex" !== o || (o = "convexMesh"), "concave" === o && (o = "concaveMesh"), "unknown" === o && (LA(`Shape for ${null==t?void 0:t.name} not recognized! Will fallback to box.`), o = "box"), { shape: o, params: l, object: t } }
                    createCollisionShape(t, e, n) {
                        const i = (null == n ? void 0 : n.quaternion) ? null == n ? void 0 : n.quaternion : new hi(0, 0, 0, 1),
                            { axis: r = "y" } = e,
                            s = new Ammo.btVector3,
                            o = null == n ? void 0 : n.geometry;
                        n && (null == o ? void 0 : o.isGeometry) && (n.geometry = (new rs).fromGeometry(o));
                        let a, l = {};
                        switch (-1 !== this.complexShapes.indexOf(t) && (l = (t => {
                            const e = (new Gi).elements,
                                n = [],
                                i = [],
                                r = [];
                            return pL(t, {}, ((t, e, s) => { n.push(t), i.push(e), r.push(s) })), { vertices: n, matrices: i, indexes: r, matrixWorld: e }
                        })(n)), t) {
                            case "box":
                                s.setValue(e.width / 2, e.height / 2, e.depth / 2), a = new Ammo.btBoxShape(s);
                                break;
                            case "sphere":
                                a = new Ammo.btSphereShape(e.radius);
                                break;
                            case "cylinder":
                                switch (r) {
                                    case "y":
                                        s.setValue(e.radius, e.height / 2, e.radius), a = new Ammo.btCylinderShape(s);
                                        break;
                                    case "x":
                                        s.setValue(e.height / 2, e.radius, e.radius), a = new Ammo.btCylinderShapeX(s);
                                        break;
                                    case "z":
                                        s.setValue(e.radius, e.radius, e.height / 2), a = new Ammo.btCylinderShapeZ(s)
                                }
                                break;
                            case "cone":
                                switch (r) {
                                    case "y":
                                        a = new Ammo.btConeShape(e.radius, e.height);
                                        break;
                                    case "x":
                                        a = new Ammo.btConeShapeX(e.radius, e.height);
                                        break;
                                    case "z":
                                        a = new Ammo.btConeShapeZ(e.radius, e.height)
                                }
                                break;
                            case "capsule":
                                switch (r) {
                                    case "y":
                                        a = new Ammo.btCapsuleShape(e.radius, e.height);
                                        break;
                                    case "x":
                                        a = new Ammo.btCapsuleShapeX(e.radius, e.height);
                                        break;
                                    case "z":
                                        a = new Ammo.btCapsuleShapeZ(e.radius, e.height)
                                }
                                break;
                            case "torus":
                                a = ((t, e) => {
                                    const { radius: n = 1, tube: i = .4, tubularSegments: r = 8 } = t, s = Math.PI, o = r, a = Math.sqrt(2 * i * i - 2 * i * i * Math.cos(2 * s / o)), l = new Ammo.btVector3(i, s / o + .5 * a, i), c = new Ammo.btCylinderShape(l);
                                    c.setMargin(.05);
                                    const h = new Ammo.btCompoundShape,
                                        u = new Ammo.btVector3(0, 0, 1),
                                        d = new Ammo.btVector3(0, n, 0),
                                        p = new Ammo.btQuaternion(e.x, e.y, e.z, e.w);
                                    for (let t = 0; t < o; t++) {
                                        const e = 2 * t * s / o,
                                            n = d.rotate(u, e),
                                            i = new Ammo.btTransform;
                                        p.setRotation(u, e + Math.PI / 2), i.setIdentity(), i.setOrigin(n), i.setRotation(p), h.addChildShape(i, c)
                                    }
                                    return h
                                })(e, i);
                                break;
                            case "plane":
                            case "convexMesh":
                                a = hL(l.vertices, l.matrices, l.indexes, l.matrixWorld, Object.assign(Object.assign({}, e), { concave: !1 }));
                                break;
                            case "hull":
                                a = aL(l.vertices, l.matrices, l.matrixWorld, e);
                                break;
                            case "hacd":
                                a = lL(l.vertices, l.matrices, l.indexes, l.matrixWorld, e);
                                break;
                            case "vhacd":
                                a = cL(l.vertices, l.matrices, l.indexes, l.matrixWorld, e);
                                break;
                            case "concaveMesh":
                                a = hL(l.vertices, l.matrices, l.indexes, l.matrixWorld, Object.assign(Object.assign({}, e), { concave: !0 }))
                        }
                        Ammo.destroy(s);
                        const { x: c, y: h, z: u } = e;
                        return (c || h || u) && (a.offset = { x: c || 0, y: h || 0, z: u || 0 }), Array.isArray(a) && (a = this.mergeCollisionShapesToCompoundShape(a)), a
                    }
                    mergeCollisionShapesToCompoundShape(t) {
                        const e = new Ammo.btCompoundShape;
                        return t.forEach((t => {
                            const n = t._tmp;
                            if (n) {
                                const { pos: i, quat: r, scale: s, margin: o } = n, a = this.applyPosQuatScaleMargin(t, i, r, s, o);
                                e.addChildShape(a, t)
                            } else {
                                const n = new Ammo.btTransform;
                                n.setIdentity(), e.addChildShape(n, t)
                            }
                        })), e
                    }
                    addExisting(t, e = {}) {
                        const { hasBody: n } = t;
                        if (n) return void LA(`Object "${t.name}" already has a physical body!`);
                        const i = new ui,
                            r = new hi,
                            s = new ui;
                        t.getWorldPosition(i), t.getWorldQuaternion(r), t.getWorldScale(s);
                        const o = "1" === (e.collisionFlags || 0).toString(2).slice(-1),
                            a = "1" === (e.collisionFlags || 0).toString(2).slice(-2, -1),
                            { shape: l = "unknown", compound: c = [], mass: h = (o || a ? 0 : 1), collisionFlags: u = 0, collisionGroup: d = 1, collisionMask: p = -1, offset: m, breakable: f = !1, addChildren: g = !0, margin: v = .01, ignoreScale: y = !1, fractureImpulse: x = 1 } = e;
                        if (y && s.set(1, 1, 1), c.length >= 1) {
                            const e = c.map((t => this.createCollisionShape(t.shape, t))),
                                n = this.mergeCollisionShapesToCompoundShape(e),
                                o = this.applyPosQuatScaleMargin(n, i, r, s, v),
                                l = this.collisionShapeToRigidBody(n, o, h, a);
                            return this.addRigidBodyToWorld(t, l, u, d, p, m), t.body.breakable = f, t.body.fractureImpulse = x, void(t.body.ignoreScale = y)
                        }
                        const _ = [];
                        if ("unknown" !== l || t.isMesh) {
                            const n = this.prepareThreeObjectForCollisionShape(t, e),
                                i = this.createCollisionShape(n.shape, n.params, n.object);
                            _.push(i)
                        }
                        if ("unknown" === l && g && t.children.length >= 1 && t.children.forEach((t => {
                                if (t.isMesh) {
                                    const e = this.prepareThreeObjectForCollisionShape(t),
                                        n = this.createCollisionShape(e.shape, e.params, e.object);
                                    n._tmp = { pos: t.position.clone(), quat: t.quaternion.clone(), scale: t.scale.clone(), margin: v }, _.push(n)
                                }
                            })), 0 === _.length) {
                            const n = this.prepareThreeObjectForCollisionShape(t, e),
                                i = this.createCollisionShape(n.shape, n.params, n.object);
                            _.push(i)
                        }
                        const b = 1 === _.length ? _[0] : this.mergeCollisionShapesToCompoundShape(_),
                            w = this.applyPosQuatScaleMargin(b, i, r, s, v),
                            M = this.collisionShapeToRigidBody(b, w, h, a);
                        this.addRigidBodyToWorld(t, M, u, d, p, m), t.body.breakable = f, t.body.fractureImpulse = x, t.body.ignoreScale = y
                    }
                    addRigidBodyToWorld(t, e, n, i, r, s) {
                        this.rigidBodies.push(t), this.physicsWorld.addRigidBody(e, i, r);
                        const o = Object.values(e)[0];
                        t.name || (t.name = `object-${t.id}`), e.name = t.name, t.body = new class {
                            constructor(t, e) { this.physics = t, this.ammo = e, this.ignoreScale = !1, this.isSoftBody = !1, this.offset = { x: 0, y: 0, z: 0 }, this.errors = [], this.checkCollisions = !1, this.breakable = !1, this.fractureImpulse = 1, this.didUpdate = !1, this.skipUpdate = !1, this._emitUpdateEvents = !1, this._needUpdate = !1, this.tmpEuler = new f_, this.tmpQuaternion = new Ax, this.tmpBtVector3 = new Ammo.btVector3, this.tmpBtVector3_1 = new Ammo.btVector3, this.tmpBtQuaternion = new Ammo.btQuaternion(0, 0, 0, 1), this.eventEmitter = new nL.Events, this.name = e.name }
                            destructor() { this.eventEmitter && this.eventEmitter.removeAllListeners(), Ammo.destroy(this.tmpBtVector3), Ammo.destroy(this.tmpBtVector3_1), Ammo.destroy(this.tmpBtQuaternion), Ammo.destroy(this.ammo.getCollisionShape()), Ammo.destroy(this.ammo) }
                            setupEventEmitter() { void 0 === this.eventEmitter && (this.eventEmitter = new nL.Events) }
                            get needUpdate() { return this._needUpdate }
                            set needUpdate(t) {!t && this._needUpdate && (this.didUpdate = !0), this._needUpdate = t }
                            onUpdateEvent(t, e = !1) { this.setupEventEmitter(), this._emitUpdateEvents = !0, e ? this.eventEmitter.once("update", (() => { t() })) : this.eventEmitter.on("update", (() => { t() })) }
                            get on() { return { update: t => this.onUpdateEvent(t), collision: t => this.onCollision(t) } }
                            get once() { return { update: t => this.onUpdateEvent(t, !0) } }
                            onCollision(t) {
                                this.checkCollisions = !0, this.physics.collisionEvents.on("collision", (e => {
                                    const { bodies: n, event: i } = e;
                                    n[0].name === this.name ? t(n[1], i) : n[1].name === this.name && t(n[0], i)
                                }))
                            }
                            transform() {
                                const t = this.physics.worldTransform;
                                this.ammo.getMotionState().getWorldTransform(t)
                            }
                            refresh() {
                                const t = this.physics.worldTransform;
                                this.ammo.getMotionState().setWorldTransform(t)
                            }
                            setRotation(t, e, n) {
                                const i = this.tmpEuler.set(t, e, n),
                                    r = this.tmpQuaternion.set(0, 0, 0, 1);
                                r.setFromEuler(i), this.tmpBtQuaternion.setValue(0, 0, 0, 1);
                                const s = this.tmpBtQuaternion;
                                s.setValue(r.x, r.y, r.z, r.w), this.physics.worldTransform.setRotation(s)
                            }
                            get rotation() {
                                let t, e, n;
                                const i = this.physics.worldTransform.getRotation();
                                let r = this.tmpQuaternion.set(i.x(), i.y(), i.z(), i.w());
                                r.w > 1 && (r = r.normalize());
                                const s = 2 * Math.acos(r.w),
                                    o = Math.sqrt(1 - r.w * r.w);
                                return o < .001 ? (t = r.x, e = r.y, n = r.z) : (t = r.x / o, e = r.y / o, n = r.z / o), { x: t * s, y: e * s, z: n * s }
                            }
                            get quaternion() { const t = this.physics.worldTransform.getRotation(); return { x: t.x(), y: t.y(), z: t.z(), w: t.w() } }
                            setPosition(t, e, n) { this.physics.worldTransform.getOrigin().setValue(t, e, n) }
                            get position() { const t = this.physics.worldTransform; return { x: t.getOrigin().x(), y: t.getOrigin().y(), z: t.getOrigin().z() } }
                            get velocity() { return { x: this.ammo.getLinearVelocity().x(), y: this.ammo.getLinearVelocity().y(), z: this.ammo.getLinearVelocity().z() } }
                            get angularVelocity() { return { x: this.ammo.getAngularVelocity().x(), y: this.ammo.getAngularVelocity().y(), z: this.ammo.getAngularVelocity().z() } }
                            setVelocity(t, e, n) { this.tmpBtVector3.setValue(t, e, n), this.ammo.setLinearVelocity(this.tmpBtVector3) }
                            setVelocityX(t) { this.tmpBtVector3.setValue(t, this.velocity.y, this.velocity.z), this.ammo.setLinearVelocity(this.tmpBtVector3) }
                            setVelocityY(t) { this.tmpBtVector3.setValue(this.velocity.x, t, this.velocity.z), this.ammo.setLinearVelocity(this.tmpBtVector3) }
                            setVelocityZ(t) { this.tmpBtVector3.setValue(this.velocity.x, this.velocity.y, t), this.ammo.setLinearVelocity(this.tmpBtVector3) }
                            setAngularVelocity(t, e, n) { this.tmpBtVector3.setValue(t, e, n), this.ammo.setAngularVelocity(this.tmpBtVector3) }
                            setAngularVelocityX(t) { this.tmpBtVector3.setValue(t, this.angularVelocity.y, this.angularVelocity.z), this.ammo.setAngularVelocity(this.tmpBtVector3) }
                            setAngularVelocityY(t) { this.tmpBtVector3.setValue(this.angularVelocity.x, t, this.angularVelocity.z), this.ammo.setAngularVelocity(this.tmpBtVector3) }
                            setAngularVelocityZ(t) { this.tmpBtVector3.setValue(this.angularVelocity.x, this.angularVelocity.y, t), this.ammo.setAngularVelocity(this.tmpBtVector3) }
                            applyForce(t, e, n) { this.tmpBtVector3.setValue(t, e, n), this.ammo.applyCentralImpulse(this.tmpBtVector3) }
                            applyForceX(t) { this.tmpBtVector3.setValue(t, 0, 0), this.ammo.applyCentralImpulse(this.tmpBtVector3) }
                            applyForceY(t) { this.tmpBtVector3.setValue(0, t, 0), this.ammo.applyCentralImpulse(this.tmpBtVector3) }
                            applyForceZ(t) { this.tmpBtVector3.setValue(0, 0, t), this.ammo.applyCentralImpulse(this.tmpBtVector3) }
                            applyCentralForce(t, e, n) { this.tmpBtVector3.setValue(t, e, n), this.ammo.applyCentralForce(this.tmpBtVector3) }
                            applyCentralImpulse(t, e, n) { this.tmpBtVector3.setValue(t, e, n), this.ammo.applyCentralImpulse(this.tmpBtVector3) }
                            applyCentralLocalForce(t, e, n) { this.tmpBtVector3.setValue(t, e, n), this.ammo.applyCentralLocalForce(this.tmpBtVector3) }
                            applyImpulse(t, e) { this.tmpBtVector3.setValue(t.x || 0, t.y || 0, t.z || 0), this.tmpBtVector3_1.setValue(e.x || 0, e.y || 0, e.z || 0), this.ammo.applyImpulse(this.tmpBtVector3, this.tmpBtVector3_1) }
                            applyLocalTorque(t, e, n) { this.tmpBtVector3.setValue(t, e, n), this.ammo.applyLocalTorque(this.tmpBtVector3) }
                            applyTorque(t, e, n) { this.tmpBtVector3.setValue(t, e, n), this.ammo.applyTorque(this.tmpBtVector3) }
                            applyTorqueImpulse(t, e, n) { this.tmpBtVector3.setValue(t, e, n), this.ammo.applyTorqueImpulse(this.tmpBtVector3) }
                            setCollisionFlags(t) { this.ammo.setCollisionFlags(t) }
                            getCollisionFlags() { return this.ammo.getCollisionFlags() }
                            setRestitution(t) { this.ammo.setRestitution(t) }
                            setBounciness(t) { this.setRestitution(t) }
                            setFriction(t) { this.ammo.setFriction(t) }
                            setDamping(t, e) { this.ammo.setDamping(t, e) }
                            setGravity(t, e, n) { this.tmpBtVector3.setValue(t, e, n), this.ammo.setGravity(this.tmpBtVector3) }
                            setLinearFactor(t, e, n) { this.tmpBtVector3.setValue(t, e, n), this.ammo.setLinearFactor(this.tmpBtVector3) }
                            setAngularFactor(t, e, n) { this.tmpBtVector3.setValue(t, e, n), this.ammo.setAngularFactor(this.tmpBtVector3) }
                            setCcdMotionThreshold(t) { this.ammo.setCcdMotionThreshold(t) }
                            setCcdSweptSphereRadius(t) { this.ammo.setCcdSweptSphereRadius(t) }
                        }(this, e), t.hasBody = !0, t.ptr = o, e.threeObject = t, s && (t.body.offset = Object.assign({ x: 0, y: 0, z: 0 }, s)), t.body.setCollisionFlags(n)
                    }
                    applyPosQuatScaleMargin(t, e = new ui, n = new hi, i = new ui, r = .01) {
                        t.setMargin(r);
                        const s = new Ammo.btQuaternion(0, 0, 0, 1);
                        s.setValue(n.x, n.y, n.z, n.w);
                        const o = new Ammo.btTransform;
                        o.setIdentity(), o.getOrigin().setValue(e.x, e.y, e.z), o.setRotation(s), Ammo.destroy(s);
                        const a = new Ammo.btVector3(i.x, i.y, i.z);
                        return t.setLocalScaling(a), Ammo.destroy(a), o
                    }
                    collisionShapeToRigidBody(t, e, n, i) {
                        const r = new Ammo.btDefaultMotionState(e),
                            s = new Ammo.btVector3(0, 0, 0);
                        n > 0 && t.calculateLocalInertia(n, s);
                        const o = new Ammo.btRigidBodyConstructionInfo(n, r, t, s),
                            a = new Ammo.btRigidBody(o);
                        return (n > 0 || i) && a.setActivationState(4), a
                    }
                }
                console.log("%c %c %c %c %c Powered by enable3d v0.23.0 %c https://enable3d.io/", "background: #ff0000", "background: #ffff00", "background: #00ff00", "background: #00ffff", "color: #fff; background: #000000;", "background: none");
                class zL extends class {
                    constructor(t = {}) {
                        this.threeGraphicsConfig = t;
                        const { alpha: e = !1, anisotropy: n = 1, camera: i = $A.Perspective({ z: 25, y: 5 }), antialias: r = !1, usePhysics: s = !0, renderer: o } = t;
                        this.textureAnisotropy = n, this.camera = i, this.scene = new al, this.renderer = o || new il({ antialias: r, alpha: e }), this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.type = g, this.cache = su, this.cache.enabled = !0, s && ("undefined" != typeof Ammo ? this.physics = new FL(this.scene, t) : LA("Are you sure you included ammo.js?"))
                    }
                } {
                    constructor(t) {
                        var e;
                        super(t), this.projectConfig = t, this.scenes = new Map, this.renderer.setSize(window.innerWidth, window.innerHeight), this.projectConfig.parent ? this.parent = document.getElementById(this.projectConfig.parent) : this.parent = document.body, this.parent || (LA(`Parent "${this.projectConfig.parent}" not found! Will add it to the body.`), this.parent = document.body), this.parent.appendChild(this.renderer.domElement), this.canvas = this.renderer.domElement;
                        let n = "";
                        this.projectConfig.scenes.forEach(((t, e) => {
                            const i = new t;
                            0 === e && (n = i.sceneKey);
                            const r = { sceneConfig: { textureAnisotropy: this.textureAnisotropy, autoStart: !1 }, renderer: this.renderer, parent: this.parent, canvas: this.canvas, scene: this.scene, scenes: this.scenes, camera: this.camera, cache: this.cache, physics: this.physics };
                            i.initializeScene(r), 0 === e && (i.setSize(this.parent.clientWidth, this.parent.clientHeight), i.setPixelRatio(Math.max(1, window.devicePixelRatio / 2))), this.scenes.set(i.sceneKey, i)
                        })), null === (e = this.scenes.get(n)) || void 0 === e || e.start(n)
                    }
                }
                class UL extends sS { constructor() { super(), this.isExtendedGroup = !0, this.isMesh = !1, this.hasBody = !1, this.fragmentDepth = 0, this.breakable = !1, this.fractureImpulse = 1, this.name = `object-${this.id}` } }
                const HL = [{ name: "pointer", enabled: !0, test: "onpointerdown" in window, events: { down: "pointerdown", move: "pointermove", up: "pointerup" } }, { name: "touch", enabled: !0, test: "ontouchstart" in window && window.navigator.maxTouchPoints >= 1, events: { down: "touchstart", move: "touchmove", up: "touchend" } }, { name: "mouse", enabled: !0, test: "onmousedown" in window, events: { down: "mousedown", move: "mousemove", up: "mouseup" } }];
                class kL {
                    constructor(t) { this._events = new nL.Events, this.domElement = null, this._isDown = !1, this._isPaused = !1, this.active = { touch: !1, mouse: !1, pointer: !1 }, this.registered = { touch: !1, mouse: !1, pointer: !1 }, this._currentPosition = { x: -1, y: -1 }, this._lastPosition = { x: -1, y: -1 }, this._isPointerLockAvailable = "onpointerlockchange" in document, this._add(t) }
                    static get VERSION() { return "0.0.3" }
                    get isDown() { return this._isDown }
                    set _position(t) { t.x === this._currentPosition.x && t.y == this._currentPosition.y || (this._lastPosition = this._currentPosition, this._currentPosition = t) }
                    get currentPosition() { return this._currentPosition }
                    get lastPosition() { return this._lastPosition }
                    get isPaused() { return this._isPaused }
                    pause() { this._isPaused = !0 }
                    resume() { this._isPaused = !1 }
                    _onPointerLockChange() { return new Promise((t => { document.addEventListener("pointerlockchange", (e => { t(e) }), { once: !0 }) })) }
                    get pointerLock() {
                        return {
                            onceChange: this._onPointerLockChange,
                            request: () => new Promise(((t, e) => this._isPointerLockAvailable ? this.pointerLock.isLocked ? e("Pointer is already locked!") : (this._onPointerLockChange().then((e => { t(e) })), void this.once.down((() => {
                                var t;
                                null === (t = this.domElement) || void 0 === t || t.requestPointerLock()
                            }))) : e("PointerLock is not available!"))),
                            exit: () => new Promise(((t, e) => {
                                if (!this.pointerLock.isLocked) return e("Pointer is not locked!");
                                this._onPointerLockChange().then((e => { t(e) })), document.exitPointerLock()
                            })),
                            available: this._isPointerLockAvailable,
                            isLocked: !!document.pointerLockElement
                        }
                    }
                    get once() { return { down: t => { this._events.once("down", (e => { t(e) })) }, move: t => { this._events.once("move", (e => { t(e) })) }, up: t => { this._events.once("up", (e => { t(e) })) } } }
                    get on() { return { down: t => { this._events.on("down", (e => { this._isPaused || t(e) })) }, move: t => { this._events.on("move", (e => { this._isPaused || t(e) })) }, up: t => { this._events.on("up", (e => { this._isPaused || t(e) })) } } }
                    _add(t) {
                        const e = this.domElement = null != t ? t : window;
                        e || console.warn("[tap] No domElement found!"), this._onDown = this._onDown.bind(this), this._onMove = this._onMove.bind(this), this._onUp = this._onUp.bind(this), HL.forEach((t => { t.test && t.enabled && (this.active[t.name] = !0, e.addEventListener(t.events.down, this._onDown, !1), e.addEventListener(t.events.move, this._onMove, !1), e.addEventListener(t.events.up, this._onUp, !1)) }))
                    }
                    _remove(t) {
                        if (!this.active[t]) return;
                        const e = this.domElement;
                        e || console.warn("[tap] No domElement found!"), HL.forEach((n => { n.name === t && (e.removeEventListener(n.events.down, this._onDown, !1), e.removeEventListener(n.events.move, this._onMove, !1), e.removeEventListener(n.events.up, this._onUp, !1)) })), this.active[t] = !1
                    }
                    destroy() { this.pause(), Object.keys(this.active).forEach((t => { this._remove(t) })), this._events.removeAllListeners(), this._events = null, this.domElement = null, this._isDown = null, this._isPaused = null, this.active = null, this.registered = null, this._currentPosition = null, this._lastPosition = null }
                    _calcPosition(t) { let e, n; return t.touches && t.touches[0] ? (e = t.touches[0].pageX, n = t.touches[0].pageY) : t.clientX ? (e = t.clientX, n = t.clientY) : (e = this._currentPosition.x, n = this._currentPosition.y), this.pointerLock.isLocked && (e = t.movementX, n = t.movementY), this._position = { x: e, y: n }, { x: e, y: n } }
                    _removeDuplicates(t) { return "pointerdown" === t.type && (this.registered.pointer = !0), "touchstart" === t.type && (this.registered.touch = !0), "mousedown" === t.type && (this.registered.mouse = !0), "touchstart" === t.type && this.active.touch && this.registered.pointer ? (this._remove("touch"), !1) : "mousedown" !== t.type || !this.active.mouse || !this.registered.pointer && !this.registered.touch || (this._remove("mouse"), !1) }
                    _onDown(t) { this._removeDuplicates(t) && (this._isDown = !0, this._events.emit("down", { position: this._calcPosition(t), event: t })) }
                    _onMove(t) { this._events.emit("move", { position: this._calcPosition(t), event: t, dragging: this._isDown }) }
                    _onUp(t) { this._isDown = !1, this._events.emit("up", { position: this._calcPosition(t), event: t }) }
                }
                const GL = (t, e, n, i, r, s) => { i < 2 * s && (s = i / 2), r < 2 * s && (s = r / 2), t.beginPath(), t.moveTo(e + s, n), t.arcTo(e + i, n, e + i, n + r, s), t.arcTo(e + i, n + r, e, n + r, s), t.arcTo(e, n + r, e, n, s), t.arcTo(e, n, e + i, n, s), t.closePath() },
                    VL = new Map,
                    WL = t => { const e = new ri(t); return e.minFilter = Mt, e.generateMipmaps = !1, e.needsUpdate = !0, e },
                    jL = document.createElement("canvas");
                let qL, XL, YL, ZL = !1;
                const JL = [],
                    KL = new Ud,
                    QL = new $n,
                    $L = new $n,
                    tR = new $n,
                    eR = [],
                    nR = t => { eR.includes(t) || (console.warn(t), eR.push(t)) },
                    iR = (t, e) => { tR.x = t, tR.y = e },
                    rR = () => qL,
                    sR = () => { oR(), YL && YL.destroy() },
                    oR = () => { for (; JL.length > 0;) JL.pop() },
                    aR = t => {
                        return e = void 0, n = void 0, r = function*() {
                            if (!YL) return;
                            const { currentPosition: { x: e, y: n }, isDown: i } = YL;
                            if (QL.x === e && QL.y === n && ZL === i) return;
                            if (ZL = i, QL.x = e, QL.y = n, 0 === tR.x || void 0 === tR.x) return void nR("[FLAT] Please call FLAT.setSize() first!");
                            $L.x = e / tR.x * 2 - 1, $L.y = -n / tR.y * 2 + 1, KL.setFromCamera($L, t);
                            let r = [...JL];
                            const s = KL.intersectObjects(r);
                            0 === s.length ? document.body.style.cursor = "default" : document.body.style.cursor = "pointer", XL && XL.enabled && s.length >= 0 && (XL.enabled = !1), XL && !XL.enabled && 0 === s.length && (XL.enabled = !0);
                            for (let t = 0; t < s.length; t++) {
                                const e = s[t].object;
                                let n = !1;
                                if (e.pixelPerfect) {
                                    const t = t => { jL.width = t.width, jL.height = t.height; const e = jL.getContext("2d"); return e.drawImage(t, 0, 0), e.getImageData(0, 0, t.width, t.height) },
                                        i = (t, e, n) => {
                                            const i = 4 * (e + t.width * n),
                                                r = t.data;
                                            return { r: r[i], g: r[i + 1], b: r[i + 2], a: r[i + 3] }
                                        },
                                        r = s[0].uv,
                                        { x: o, y: a } = e.texture.transformUv(r),
                                        l = t(yield createImageBitmap(e.texture.image)),
                                        { r: c, g: h, b: u, a: d } = i(l, Math.round(o * l.width), Math.round(a * l.height));
                                    n = c + h + u + d === 0
                                }
                                if (e.pixelPerfect && n) continue;
                                e.event = YL.isDown ? "down" : "over";
                                const i = r.findIndex((t => t.uuid === e.uuid));
                                r = [...r.slice(0, i), ...r.slice(i + 1)];
                                break
                            }
                            return r.forEach((t => { t.event = "out" })), s
                        }, new((i = void 0) || (i = Promise))((function(t, s) {
                            function o(t) { try { l(r.next(t)) } catch (t) { s(t) } }

                            function a(t) { try { l(r.throw(t)) } catch (t) { s(t) } }

                            function l(e) {
                                var n;
                                e.done ? t(e.value) : (n = e.value, n instanceof i ? n : new i((function(t) { t(n) }))).then(o, a)
                            }
                            l((r = r.apply(e, n || [])).next())
                        }));
                        var e, n, i, r
                    };
                class lR extends Tl {
                    constructor(t, e = !0) { super(new ul({ map: e ? t.clone() : t, color: 16777215 })), this._event = "out", this._pixelPerfect = !1, this._isInteractive = !1, this._depth = 0, this._bodyOffset = { x: 0, y: 0 }, this._internalScale = { x: 1, y: 1 }, this._pixelRatio = 1, this.onInputOver = () => {}, this.onInputOut = () => {}, this.onInputDown = () => {}, this._setTexture(), this.setScale(this._internalScale.x, this._internalScale.y), this.setDepth(this._calcZ()) }
                    _onInputOver() {}
                    _onInputOut() {}
                    _onInputDown() {}
                    set event(t) { this._event !== t && (this._event = t, "over" === t ? (this._onInputOver(), this.onInputOver()) : "out" === t ? (this._onInputOut(), this.onInputOut()) : "down" === t && (this._onInputDown(), this.onInputDown())) }
                    setPixelRatio(t) { this._pixelRatio = t, this.setScale(this._internalScale.x, this._internalScale.y) }
                    setInteractive({ pixelPerfect: t = !1 } = {}) {
                        var e;
                        this._isInteractive || (this._isInteractive = !0, this._pixelPerfect = t, e = this, 0 === JL.length && (() => {
                            const t = rR();
                            t ? YL = new kL(t) : nR('Please call "FLAT.initEvents()" first.')
                        })(), JL.push(e))
                    }
                    get pixelPerfect() { return this._pixelPerfect }
                    _calcZ() { return this._depth / 100 - 1e-8 * this.id }
                    getTexture() { return this.texture }
                    setTexture(t) { this._setTexture(t) }
                    get texture() { return this.material.map }
                    _setTexture(t) {
                        if (!this.material.map) return void console.warn("Something went wrong!");
                        t && (this.material.map = t);
                        const { width: e, height: n } = this.material.map.image;
                        this.textureWidth = e, this.textureHeight = n, this.material.map.needsUpdate = !0
                    }
                    getBodyOffset() { return { x: this._bodyOffset.x * this.getScale().x, y: this._bodyOffset.y * this.getScale().y } }
                    setPosition(t, e) { this.position.set(t, e, this._calcZ()) }
                    setDepth(t) { this._depth = t, this.position.setZ(this._calcZ()) }
                    setRotation(t) { this.material.rotation = t }
                    getRotation() { return this.material.rotation }
                    getPixelRatio() { return this._pixelRatio }
                    getScale() { return { x: this._internalScale.x, y: this._internalScale.y } }
                    setScale(t, e) {
                        this._internalScale.x = t, this._internalScale.y = e || t;
                        const n = t,
                            i = e || t;
                        this.scale.set(n * this.textureWidth / this._pixelRatio, i * this.textureHeight / this._pixelRatio, 1)
                    }
                }
                class cR extends lR {
                    constructor(t) { super(t), this._anims = [], this._flipX = !1, this._frame = { name: "", index: -1, width: -1, height: -1 }, this._currentIndex = 0, this._currentAnimationName = "" }
                    get frame() { return { name: this._frame.name, index: this._frame.index, width: this._frame.width * this._internalScale.x * 1 / this._pixelRatio, height: this._frame.height * this._internalScale.y * 1 / this._pixelRatio } }
                    get anims() { return { add: this._add.bind(this), get: this.getAnimationByName.bind(this), play: this._play.bind(this), stop: this._stop.bind(this), getName: () => this._currentAnimationName, name: this._currentAnimationName } }
                    getAnimationByName(t) { return this._anims.filter((e => e.name === t))[0] }
                    _add(t, e) {
                        const { start: n, end: i, rate: r = 30, repeat: s = -1, timeline: o = [] } = e;
                        if (this.getAnimationByName(t)) console.warn(`The animation "${t}" does already exist!`);
                        else {
                            if (0 === o.length) { if (void 0 === i || void 0 === n) return void console.warn('You need to provide "start" and "end or a "timeline"!'); for (let t = n; t <= i; t++) o.push(t) }
                            this._anims.push({ name: t, timeline: o, rate: r, repeat: s })
                        }
                    }
                    _stop() { this.interval && clearInterval(this.interval) }
                    _play(t) {
                        this._stop(), this._currentAnimationName = t;
                        const e = this.getAnimationByName(t);
                        e || console.warn(`Animation "${t}" does not exist!`);
                        const { timeline: n, rate: i, repeat: r } = e;
                        this._currentIndex = -1;
                        let s = 0;
                        const o = () => {
                            if (this._currentIndex++, this._currentIndex >= n.length && (this._currentIndex = 0, s++), this._currentIndex = n[this._currentIndex], !(-1 === r || s < r)) return this._stop(), void this._events.emit("complete");
                            this.setFrame(this._currentIndex)
                        };
                        return o(), this.interval = window.setInterval((() => { o() }), 1e3 / i), { onComplete: t => this._events.once("complete", t) }
                    }
                    get _events() { return { emit: t => { this._eventEmitter || (this._eventEmitter = new nL.Events), this._eventEmitter.emit(t) }, once: (t, e) => { this._eventEmitter || (this._eventEmitter = new nL.Events), this._eventEmitter.once(t, e) } } }
                }
                class hR extends cR {
                    constructor(t, e) {
                        super(t);
                        const { width: n = this.textureWidth, height: i = this.textureHeight } = e;
                        this._tilesHoriz = this.textureWidth / n, this._tilesVert = this.textureHeight / i, this._tilesHoriz !== Math.round(this._tilesHoriz) && console.warn("The horizontal row does not seem to fit!"), this._tilesVert !== Math.round(this._tilesVert) && console.warn("The vertical row does not seem to fit!"), this._width = n, this._height = i, this._frame.width = n, this._frame.height = i, this.sizeFrame(1 / this._tilesHoriz, 1 / this._tilesVert), this.scaleFrame()
                    }
                    setScale(t, e) { super.setScale(t, e), this.scaleFrame() }
                    scaleFrame() { this.scale.set(this._width * this._internalScale.x / this._pixelRatio, this._height * this._internalScale.y / this._pixelRatio, 1) }
                    getRow(t) { return Math.floor(t / this._tilesHoriz) }
                    getColumn(t) { return t % this._tilesHoriz }
                    sizeFrame(t, e) { this.texture.wrapS = this.texture.wrapT = ft, this.texture.repeat.set(t, e), this.texture.needsUpdate = !0 }
                    offsetTexture(t, e) { this._flipX && (t += 1 / this._tilesHoriz), this.texture.offset.setX(t), this.texture.offset.setY(e) }
                    flipX(t) {
                        this._flipX = t;
                        let e = 1 / this._tilesHoriz;
                        const n = 1 / this._tilesVert;
                        t && (e *= -1), this.texture.repeat.set(e, n), this.setFrame(this._frame.index)
                    }
                    setFrame(t) {
                        this._frame.index = t;
                        const e = this.getColumn(t) / this._tilesHoriz,
                            n = (this._tilesVert - this.getRow(t) - 1) / this._tilesVert;
                        this.offsetTexture(e, n)
                    }
                }
                class uR extends hR {
                    constructor(t, e, n, i, r) { super(t, e), this.overFrame = n, this.outFrame = i, this.downFrame = r, this.setFrame(i) }
                    _onInputOver() { this.setFrame(this.overFrame) }
                    _onInputOut() { this.setFrame(this.outFrame) }
                    _onInputDown() { this.setFrame(this.downFrame) }
                }
                class dR extends ri {
                    constructor(t, e, n) {
                        const i = jL.getContext("2d");
                        i.clearRect(0, 0, jL.width, jL.height), jL.height = e, jL.width = t, n(i), super(i.getImageData(0, 0, jL.width, jL.height)), this.minFilter = Mt, this.generateMipmaps = !1, this.width = t, this.height = e, this.drawCanvas = n, this.needsUpdate = !0
                    }
                    clone() { return new dR(this.width, this.height, this.drawCanvas).copy(this) }
                }
                class pR extends lR {
                    constructor(t, e, n) {
                        const i = jL.getContext("2d");
                        i.clearRect(0, 0, jL.width, jL.height), jL.height = e, jL.width = t, n(i);
                        const r = i.getImageData(0, 0, jL.width, jL.height);
                        super(WL(r)), this._drawCanvas = n
                    }
                    clone() { return new pR(this.textureWidth, this.textureHeight, this._drawCanvas).clone() }
                }
                const mR = ({ canvas: t, orbitControls: e }) => {
                    (t => { t && (XL = t) })(e), (t => { qL = t })(t)
                };
                class fR extends ri {
                    constructor(t, e = {}) {
                        const { imageData: n, width: i, height: r } = vR(t, e);
                        super(n), this.width = i, this.height = r, this._text = t, this._styles = e, this._image = n, this.minFilter = Mt, this.generateMipmaps = !1, this.needsUpdate = !0
                    }
                    getText() { return this._text }
                    getStyles() { return this._styles }
                    clone() { return new this.constructor(this._text, this._styles).copy(this) }
                }
                class gR extends lR {
                    constructor(t) { super(t, !1), this._text = t.getText(), this._styles = t.getStyles() }
                    getText() { return this._text }
                    getStyles() { return this._styles }
                    setStyles(t) { this._styles = t, this.texture.dispose(), this.setTexture(WL(vR(this._text, t).imageData)) }
                    setText(t) { this._text = t, this.texture.dispose(), this.setTexture(WL(vR(t, this._styles).imageData)), this._update() }
                    _update() {
                        this.textureHeight = this.texture.image.height, this.textureWidth = this.texture.image.width, this.texture.needsUpdate = !0, this.material.needsUpdate = !0;
                        const { x: t, y: e } = this._internalScale;
                        this.setScale(t, e)
                    }
                }
                const vR = (t, e) => {
                    const { align: n = "center", background: i = "", baseline: r = "middle", borderColor: s = "", borderRadius: o = 0, borderWidth: a = 0, fillStyle: l = "SlateBlue", fontFamily: c = "Arial", fontSize: h = 48, fontWeight: u = "", lineHeight: d = 1, lineWidth: p = 4, padding: m = 0, strokeStyle: f = "" } = e, { offset: { x: g = 0, y: v = 0 } = {} } = e;
                    let y, x;
                    "number" != typeof m ? (y = m.x || 0, x = m.y || 0) : (y = m, x = m);
                    const _ = `${u} ${h}px ${c}`,
                        b = jL.getContext("2d");
                    b.clearRect(0, 0, jL.width, jL.height);
                    const w = t.split("\n");
                    b.font = _;
                    const M = ((t, e, n, i = 1) => {
                            const r = e + n;
                            let s = VL.get(r);
                            if (!s) {
                                const o = document.createElement("p");
                                o.style.fontFamily = n, o.style.fontSize = `${e}px`, o.style.whiteSpace = "nowrap", o.style.lineHeight = i.toString(), o.textContent = t, document.body.appendChild(o), s = Math.ceil(o.offsetHeight), document.body.removeChild(o), VL.set(r, s)
                            }
                            return s
                        })(t, h, c, d),
                        S = l ? 2 * p : p,
                        T = M * w.length + 2 * x + 2 * a,
                        E = ((t, e) => Math.max(...e.map((e => Math.ceil(t.measureText(e).width)))))(b, w) + S + 2 * y + 2 * a;
                    jL.height = T, jL.width = E, s && (b.strokeStyle = s, GL(b, a / 2, a / 2, jL.width - a, jL.height - a, o), b.lineWidth = a, b.stroke()), i && (b.fillStyle = i, GL(b, a, a, jL.width - 2 * a, jL.height - 2 * a, s ? o / 2 : o), b.fill()), b.font = _, b.textAlign = n, b.textBaseline = r, f && p && (b.strokeStyle = f, b.lineWidth = S), l && (b.fillStyle = l);
                    for (var A = 0; A < w.length; A++) {
                        let t = A * M + M / 2,
                            e = 0;
                        "left" === n && (e = S / 2, e += y, e += a), "center" === n && (e = E / 2), "right" === n && (e = E - S / 2, e -= y, e -= a), t += x, t += a, t += v, e += g, f && p && b.strokeText(w[A], e, t), l && b.fillText(w[A], e, t)
                    }
                    return { imageData: b.getImageData(0, 0, jL.width, jL.height), width: E, height: T }
                };
                class yR extends cR {
                    constructor(t, e) { super(t.texture), this.positionOffset = { x: 0, y: 0 }, this.JSONHash = t.json, e && this.setFrame(e) }
                    setScale(t, e) { this._internalScale.x = t, this._internalScale.y = e || t, this.scaleFrame() }
                    scaleFrame() {
                        var t;
                        if (!(null === (t = this._frame) || void 0 === t ? void 0 : t.name)) return;
                        const { frame: { w: e, h: n } } = this.getFrame(this._frame.name), i = e * this._internalScale.x / this._pixelRatio, r = n * this._internalScale.y / this._pixelRatio;
                        this.scale.set(i, r, 1)
                    }
                    sizeFrame(t, e) { this.texture.wrapS = this.texture.wrapT = ft, this.texture.repeat.set(t, e), this.texture.needsUpdate = !0 }
                    offsetTexture(t, e) { this.texture.offset.setX(t), this.texture.offset.setY(e) }
                    flipX(t) { this._flipX = t, this.update() }
                    getFrame(t) { return this.JSONHash.frames[t] }
                    setFrame(t) { this.update(t) }
                    update(t) {
                        if (t || (t = this._frame.name), !t) return;
                        const e = this.getFrame(t);
                        e || console.warn(`Frame ${t} not found!`);
                        const { frame: n, rotated: i, trimmed: r, spriteSourceSize: s, sourceSize: o } = e;
                        this._frame.name = t, this.texture.rotation = 0;
                        const a = n.x / this.textureWidth;
                        let l = 1 - (n.y + n.h) / this.textureHeight,
                            c = n.w,
                            h = n.h;
                        if (this._frame.width = c, this._frame.height = h, i && (this.texture.rotation = Math.PI / 2, l = 1 - n.y / this.textureHeight, [c, h] = [h, c], this._flipX && (this.texture.rotation *= -1)), r) {
                            const t = ((o.w - n.w) / 2 - s.x) / (1 / this._internalScale.x),
                                e = ((o.h - n.h) / 2 - s.y) / (1 / this._internalScale.x);
                            this._flipX ? this.position.x += t - this.positionOffset.x : this.position.x -= t - this.positionOffset.x, this.position.y += e - this.positionOffset.y, this.positionOffset.x = t, this.positionOffset.y = e
                        }
                        let u = a,
                            d = l,
                            p = c / this.textureWidth;
                        const m = h / this.textureHeight;
                        this._flipX && (p *= -1, i ? d -= n.w / this.textureHeight : u += n.w / this.textureWidth), this.offsetTexture(u, d), this.sizeFrame(p, m), this.scaleFrame()
                    }
                }
                var xR = n(842);
                const _R = { colors: { dynamic: "#ff0000", static: "#90ee90", sensor: "#ffff00", sleeping: "#464646" }, lineWidth: 2, fill: !1, opacity: .25 },
                    bR = (t, e = 0, n, i) => {
                        const r = ((t = {}) => { const { colors: e } = _R; return t.isStatic ? e.static : t.isSensor ? e.sensor : t.isSleeping ? e.sleeping : e.dynamic })(t),
                            s = _R.opacity,
                            o = _R.lineWidth,
                            a = _R.fill;
                        let l = null != n ? n : r + Math.round(255 * s).toString(16);
                        a || (l = null != n ? n : "transparent"), !t.isSleeping || t.isStatic || t.isSensor || (l = null != n ? n : r);
                        const c = null != i ? i : r;
                        t.render.fillStyle = l, t.render.strokeStyle = c, t.render.lineWidth = o, e >= 5 || t.parts.forEach((t => { bR(t, e + 1, l, c) }))
                    };
                class wR {
                    constructor(t = !0) {
                        this._objects = new Map, this.width = window.innerWidth, this.height = window.innerHeight;
                        const e = t;
                        if (this.engine = xR.Engine.create({ enableSleeping: !0 }), this.world = this.engine.world, this.runner = xR.Runner.create(), e) {
                            const t = document.createElement("canvas");
                            t.id = "matter-debug", t.style.position = "absolute", t.style.top = "0px", t.style.left = "0px", t.style.pointerEvents = "none", document.body.append(t), this.render = xR.Render.create({ canvas: t, engine: this.engine, options: { width: this.width, height: this.height, background: "transparent", wireframeBackground: "transparent", wireframes: !1, showConvexHulls: !0, showPositions: !0, showVelocity: !0 } }), xR.Render.run(this.render)
                        }
                        xR.Runner.run(this.runner, this.engine), xR.Events.on(this.engine, "afterUpdate", (() => this.update()))
                    }
                    destroy() { xR.World.clear(this.world, !1), xR.Engine.clear(this.engine) }
                    parsePhysics(t) {
                        const e = JSON.parse(t);
                        delete e.generator_info;
                        let n = {};
                        for (const t in e) {
                            const i = e[t].fixtures;
                            n = Object.assign(Object.assign({}, n), {
                                [t]: i
                            })
                        }
                        return n
                    }
                    addBodyFromFixtures(t, e, n) {
                        const i = [];
                        let r;
                        return n.forEach((n => {
                            let r;
                            n.vertices ? r = this.add.fromVertices(t, e, n.vertices) : n.circle ? r = this.add.circle(t + n.circle.x, e + n.circle.y, n.circle.radius) : console.log("Shape not recognized!"), r && i.push(r)
                        })), r = i.length > 1 ? xR.Body.create({ parts: i }) : i[0], xR.Body.setPosition(r, { x: t, y: e }), r
                    }
                    fromVertices_Fixed(t, e, n, i = {}) {
                        const r = [];
                        for (var s = 0; s < n.length; s++) {
                            const o = xR.Bodies.fromVertices(t, e, [n[s]], Object.assign({}, i));
                            r.push(o);
                            const a = xR.Vertices.centre(n[s]);
                            xR.Body.setPosition(o, { x: o.position.x + a.x, y: o.position.y + a.y })
                        }
                        return xR.Body.create(Object.assign(Object.assign({}, i), { parts: r }))
                    }
                    fromVertices(t, e, n, i = {}) { return this.fromVertices_Fixed(t, e, n, Object.assign({}, i)) }
                    setBounds(t = 0, e = 0, n = this.width, i = this.height, r = 50) { xR.World.add(this.world, [this.add.rectangle(t + n / 2, e + 0 - r / 2, n + 2 * r, r, { isStatic: !0 }), this.add.rectangle(t + n / 2, e + i + r / 2, n + 2 * r, r, { isStatic: !0 }), this.add.rectangle(t + 0 - r / 2, e + i / 2, r, i + 2 * r, { isStatic: !0 }), this.add.rectangle(t + n + r / 2, e + i / 2, r, i + 2 * r, { isStatic: !0 })]) }
                    rectangle(t, e, n, i, r = {}) { return xR.Bodies.rectangle(t, e, n, i, Object.assign({}, r)) }
                    circle(t, e, n, i = {}) { return xR.Bodies.circle(t, e, n, Object.assign({}, i)) }
                    existing(t) { this.add.bodyToSprite(t), this._objects.set(t.body.id.toString(), t) }
                    calcBodyOffset(t) {
                        const e = t.body,
                            n = e.bounds.max.x - e.bounds.min.x,
                            i = e.bounds.max.y - e.bounds.min.y,
                            r = xR.Vector.sub(e.bounds.min, e.position),
                            s = (e.position, { x: r.x + n / 2, y: r.y + i / 2 });
                        t._bodyOffset = s
                    }
                    _addBodyToSprite(t) {
                        this.add.body(t.body), this.calcBodyOffset(t);
                        const e = t.getScale().x,
                            n = t.getScale().y;
                        ((t, e, n) => {
                            t.circleRadius || t.parts.forEach((t => {
                                ((t, e, n) => { t.circleRadius && (e === n ? t.circleRadius *= e : t.circleRadius = void 0) })(t, e, n)
                            })), xR.Body.scale(t, e, n)
                        })(t.body, e, n), t.setBodyPosition = (e, n) => { xR.Body.setPosition(t.body, { x: e - t.getBodyOffset().x, y: n - t.getBodyOffset().y }) }
                    }
                    _addBody(t) { xR.World.add(this.world, t) }
                    get add() { return { body: this._addBody.bind(this), bodyToSprite: this._addBodyToSprite.bind(this), fromVertices: this.fromVertices.bind(this), circle: this.circle.bind(this), existing: this.existing.bind(this), rectangle: this.rectangle.bind(this) } }
                    adjustDebugColor(t) { bR(t) }
                    update() {
                        this._objects.forEach((t => {
                            const { body: e } = t, { angle: n, position: i } = e, { x: r, y: s } = i, o = new $n(t.getBodyOffset().x, t.getBodyOffset().y);
                            o.rotateAround(new $n, n), t.setPosition(r + o.x, this.height - s - o.y), t.setRotation(-n), bR(e)
                        }))
                    }
                }
                class MR extends nL.Events {
                    constructor() { super(...arguments), this.id = -1 }
                    get add() { return { axis: (t = {}) => this.addAxis(t), button: (t = {}) => this.addButton(t) } }
                    addAxis(t = {}) {
                        this.id++;
                        const { styles: e = { left: 35, bottom: 35, size: 100 } } = t, n = this.circle({ styles: e }), i = this.thumb({ styles: e });
                        n.appendChild(i), document.body.appendChild(n);
                        const { maxRadius: r = 40, rotationDamping: s = .06, moveDamping: o = .01 } = t, a = { id: this.id, domElement: i, maxRadius: r, maxRadiusSquared: r * r, origin: { left: i.offsetLeft, top: i.offsetTop }, offset: { x: 0, y: 0 }, rotationDamping: s, moveDamping: o };
                        if (null == a ? void 0 : a.domElement) { const { domElement: t } = a; "ontouchstart" in window ? t.addEventListener("touchstart", (t => { t.preventDefault(), this.tap(t, a), t.stopPropagation() })) : t.addEventListener("mousedown", (t => { t.preventDefault(), this.tap(t, a), t.stopPropagation() })) }
                        return { onMove: t => { this.on(`axis_onmove_${a.id}`, (e => { t(e) })) } }
                    }
                    addButton(t = {}) {
                        this.id++;
                        const { styles: e = { right: 35, bottom: 35, size: 80 }, letter: n = "A" } = t, i = this.circle({ styles: e }), r = this.letter({ letter: n });
                        i.appendChild(r), document.body.appendChild(i);
                        const s = { id: this.id, domElement: i, offset: { x: 0, y: 0 } };
                        return (null == s ? void 0 : s.domElement) && this.click(s), { onClick: t => { this.on(`button_onclick_${s.id}`, (e => { t(e) })) }, onRelease: t => { this.on(`button_onrelease_${s.id}`, (e => { t(e) })) } }
                    }
                    circle(t = {}) { const { styles: e } = t, { top: n, right: i, bottom: r, left: s, size: o } = e, a = document.createElement("div"); let l = `position:absolute; width:${o}px; height:${o}px; background:rgba(126, 126, 126, 0.5); border:#444 solid medium; border-radius:50%; cursor: pointer; `; return n && (l += `top:${n}px; `), i && (l += `right:${i}px; `), r && (l += `bottom:${r}px; `), s && (l += `left:${s}px; `), a.style.cssText = l, a }
                    thumb(t = {}) { const { styles: e } = t, { size: n } = e, i = document.createElement("div"); return i.style.cssText = `position: absolute; left: ${n/4}px; top: ${n/4}px; width: ${n/2}px; height: ${n/2}px; border-radius: 50%; background: #fff; `, i }
                    letter(t = {}) { const { letter: e } = t, n = document.createElement("span"); return n.innerText = e, n.style.cssText = "position: absolute; text-align: center; top: 4px; width: 80px; height: 80px; font-size: 64px; color: #fff; ", n }
                    click(t) { const { id: e, domElement: n } = t; "ontouchstart" in window ? (n.addEventListener("touchstart", (t => { t.preventDefault(), this.emit(`button_onclick_${e}`) })), n.addEventListener("touchend", (t => { t.preventDefault(), this.emit(`button_onrelease_${e}`) }))) : (n.addEventListener("mousedown", (t => { t.preventDefault(), this.emit(`button_onclick_${e}`), t.stopPropagation() })), n.addEventListener("mouseup", (t => { t.preventDefault(), this.emit(`button_onrelease_${e}`), t.stopPropagation() }))) }
                    tap(t, e) { t = t || window.event, e.offset = this.getMousePosition(t), "ontouchstart" in window ? (document.ontouchmove = t => { t.target === e.domElement && this.move(t, e) }, document.ontouchend = t => { t.target === e.domElement && this.up(e) }) : (document.onmousemove = t => { t.target === e.domElement && this.move(t, e) }, document.onmouseup = t => { this.up(e) }) }
                    move(t, e) {
                        const { domElement: n, maxRadius: i, maxRadiusSquared: r, origin: s, offset: o, id: a } = e;
                        t = t || window.event;
                        const l = this.getMousePosition(t);
                        let c = l.x - o.x,
                            h = l.y - o.y;
                        const u = c * c + h * h;
                        if (u > r) {
                            const t = Math.sqrt(u);
                            c /= t, h /= t, c *= i, h *= i
                        }
                        n.style.top = `${h+n.clientHeight/2}px`, n.style.left = `${c+n.clientWidth/2}px`;
                        const d = -(h - s.top + n.clientHeight / 2) / i,
                            p = (c - s.left + n.clientWidth / 2) / i;
                        this.emit(`axis_onmove_${a}`, { top: d, right: p })
                    }
                    up(t) { const { domElement: e, origin: n, id: i } = t; "ontouchstart" in window ? (document.ontouchmove = null, document.touchend = null) : (document.onmousemove = null, document.onmouseup = null), e.style.top = `${n.top}px`, e.style.left = `${n.left}px`, this.emit(`axis_onmove_${i}`, { top: 0, right: 0 }) }
                    getMousePosition(t) { return { x: t.targetTouches ? t.targetTouches[0].pageX : t.clientX, y: t.targetTouches ? t.targetTouches[0].pageY : t.clientY } }
                }
                class SR {
                    constructor(t, e, n) {
                        this.camera = t, this.target = e, this.config = n;
                        const { offset: i = new Lx(0, 0, 0), sensitivity: r = new vx(.25, .25), radius: s = 8, targetRadius: o = 10, interpolationFactor: a = .05, pointerLock: l = !0, autoUpdate: c = !0, theta: h = 0, phi: u = 0, maxPhi: d = 85, minPhi: p = -85 } = n;
                        this.offset = i, this.sensitivity = r, this.radius = s, this.targetRadius = o, this.interpolationFactor = a, this.theta = h, this.phi = u, this.maxPhi = d, this.minPhi = p
                    }
                    update(t, e) {
                        const n = this.target.position.clone().add(this.offset);
                        this.theta -= t * (this.sensitivity.x / 2), this.theta %= 360, this.phi += e * (this.sensitivity.y / 2), this.phi = Math.min(this.maxPhi, Math.max(this.minPhi, this.phi)), this.radius = gx.lerp(this.radius, this.targetRadius, this.interpolationFactor), this.camera.position.x = n.x + this.radius * Math.sin(this.theta * Math.PI / 180) * Math.cos(this.phi * Math.PI / 180), this.camera.position.y = n.y + this.radius * Math.sin(this.phi * Math.PI / 180), this.camera.position.z = n.z + this.radius * Math.cos(this.theta * Math.PI / 180) * Math.cos(this.phi * Math.PI / 180), this.camera.updateMatrix(), this.camera.lookAt(n)
                    }
                }
                class TR {
                    constructor(t, e, n) {
                        this.camera = t, this.target = e, this.config = n;
                        const { offset: i = new Lx(0, 0, 0), sensitivity: r = new vx(.25, .25), radius: s = 8, targetRadius: o = 10, interpolationFactor: a = .05, pointerLock: l = !0, autoUpdate: c = !0 } = n;
                        this.offset = i, this.sensitivity = r, this.radius = s, this.targetRadius = o, this.interpolationFactor = a, this.theta = 0, this.phi = 0
                    }
                    update(t, e) {
                        const n = this.target.position.clone().add(this.offset);
                        this.camera.position.copy(n), this.theta -= t * (this.sensitivity.x / 2), this.theta %= 360, this.phi += e * (-this.sensitivity.y / 2), this.phi = Math.min(85, Math.max(-85, this.phi));
                        const i = new Lx;
                        i.x = n.x + this.radius * Math.sin(this.theta * Math.PI / 180) * Math.cos(this.phi * Math.PI / 180), i.y = n.y + this.radius * Math.sin(this.phi * Math.PI / 180), i.z = n.z + this.radius * Math.cos(this.theta * Math.PI / 180) * Math.cos(this.phi * Math.PI / 180), this.camera.updateMatrix(), this.camera.lookAt(i)
                    }
                }
                class ER {
                    constructor(t, e = !0) { this._element = t, this._isRunning = !1, e && this.request() }
                    isLocked() { return !!document.pointerLockElement }
                    exit() { this._isRunning = !1, document.exitPointerLock(), this.removeListeners() }
                    removeListeners() { document.removeEventListener("pointerlockchange", (() => this.pointerLockChangeHandler())), this._element.removeEventListener("pointerdown", (() => this.pointerDownHandlerHandler())) }
                    pointerLockChangeHandler() { this._isRunning && this._request() }
                    pointerDownHandlerHandler() { this._isRunning && this._element.requestPointerLock() }
                    request() { this._isRunning = !0, this._request() }
                    _request() { document.addEventListener("pointerlockchange", (() => this.pointerLockChangeHandler()), { once: !0 }), document.pointerLockElement || this._element.addEventListener("pointerdown", (() => this.pointerDownHandlerHandler()), { once: !0 }) }
                }
                class AR {
                    constructor(t, e = !0) { this._element = t, this._isRunning = !1, this._position = { x: 0, y: 0 }, this._delta = { x: 0, y: 0 }, this._onMoveCallback = () => {}, this._isPointerDown = !1, e && this.start() }
                    get isTouchDevice() { return "ontouchstart" in window }
                    get isPointerDown() { return this._isPointerDown }
                    start() { this._isRunning || (this._isRunning = !0, this.isTouchDevice ? (this._element.addEventListener("touchstart", (t => this.onTouchStart(t))), this._element.addEventListener("touchend", (t => this.onTouchEnd(t))), this._element.addEventListener("touchmove", (t => this.onTouchMove(t)))) : (this._element.addEventListener("mousedown", (t => this.onPointerDown(t))), this._element.addEventListener("mouseup", (t => this.onPointerUp(t))), this._element.addEventListener("mouseleave", (t => this.onPointerLeave(t))), this._element.addEventListener("mouseover", (t => this.onPointerOver(t))), this._element.addEventListener("mousemove", (t => this.onPointerMove(t))))) }
                    stop() { this.isTouchDevice ? (this._element.removeEventListener("touchstart", (t => this.onTouchStart(t))), this._element.removeEventListener("touchend", (t => this.onTouchEnd(t))), this._element.removeEventListener("touchmove", (t => this.onTouchMove(t)))) : (this._element.removeEventListener("mousedown", (t => this.onPointerDown(t))), this._element.removeEventListener("mouseleave", (t => this.onPointerLeave(t))), this._element.removeEventListener("mouseup", (t => this.onPointerUp(t))), this._element.removeEventListener("mouseover", (t => this.onPointerOver(t))), this._element.removeEventListener("mousemove", (t => this.onPointerMove(t)))), this._isRunning = !1 }
                    removeListeners() { this.stop() }
                    onMove(t) { this._onMoveCallback = t }
                    onPointerDown(t) { this._isPointerDown = !0 }
                    onPointerUp(t) { this._isPointerDown = !1 }
                    onPointerLeave(t) { this._isPointerDown = !1 }
                    onPointerMove(t) {
                        const e = t.movementX,
                            n = t.movementY;
                        this._delta = { x: e, y: n }, this._onMoveCallback(this._delta)
                    }
                    onPointerOver(t) {}
                    onTouchStart(t) {
                        const e = t.touches[0].clientX,
                            n = t.touches[0].clientY;
                        this._position = { x: e, y: n }
                    }
                    onTouchEnd(t) { this._position = { x: 0, y: 0 }, this._delta = { x: 0, y: 0 }, this._onMoveCallback(this._delta) }
                    onTouchMove(t) {
                        const e = t.touches[0].clientX,
                            n = t.touches[0].clientY;
                        this._delta = { x: e - this._position.x, y: n - this._position.y }, this._onMoveCallback(this._delta), this._position = { x: e, y: n }
                    }
                }
                var LR = { uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}", fragmentShader: "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\t\t}" };
                class RR {
                    constructor() { this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1 }
                    setSize() {}
                    render() { console.error("THREE.Pass: .render() must be implemented in derived pass.") }
                }
                const CR = new Du(-1, 1, 1, -1, 0, 1),
                    PR = new rs;
                PR.setAttribute("position", new qr([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), PR.setAttribute("uv", new qr([0, 2, 0, 0, 2, 0], 2));
                class IR {
                    constructor(t) { this._mesh = new ws(PR, t) }
                    dispose() { this._mesh.geometry.dispose() }
                    render(t) { t.render(this._mesh, CR) }
                    get material() { return this._mesh.material }
                    set material(t) { this._mesh.material = t }
                }
                class DR extends RR {
                    constructor(t, e) { super(), this.textureID = void 0 !== e ? e : "tDiffuse", t instanceof Ls ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = As.clone(t.uniforms), this.material = new Ls({ defines: Object.assign({}, t.defines), uniforms: this.uniforms, vertexShader: t.vertexShader, fragmentShader: t.fragmentShader })), this.fsQuad = new IR(this.material) }
                    render(t, e, n) { this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t)) }
                }
                class NR extends RR {
                    constructor(t, e) { super(), this.scene = t, this.camera = e, this.clear = !0, this.needsSwap = !1, this.inverse = !1 }
                    render(t, e, n) {
                        const i = t.getContext(),
                            r = t.state;
                        let s, o;
                        r.buffers.color.setMask(!1), r.buffers.depth.setMask(!1), r.buffers.color.setLocked(!0), r.buffers.depth.setLocked(!0), this.inverse ? (s = 0, o = 1) : (s = 1, o = 0), r.buffers.stencil.setTest(!0), r.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE), r.buffers.stencil.setFunc(i.ALWAYS, s, 4294967295), r.buffers.stencil.setClear(o), r.buffers.stencil.setLocked(!0), t.setRenderTarget(n), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), r.buffers.color.setLocked(!1), r.buffers.depth.setLocked(!1), r.buffers.stencil.setLocked(!1), r.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295), r.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP), r.buffers.stencil.setLocked(!0)
                    }
                }
                class BR extends RR {
                    constructor() { super(), this.needsSwap = !1 }
                    render(t) { t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1) }
                }
                class OR {
                    constructor(t, e) {
                        if (this.renderer = t, void 0 === e) {
                            const n = { minFilter: Mt, magFilter: Mt, format: Gt },
                                i = t.getSize(new $n);
                            this._pixelRatio = t.getPixelRatio(), this._width = i.width, this._height = i.height, (e = new ai(this._width * this._pixelRatio, this._height * this._pixelRatio, n)).texture.name = "EffectComposer.rt1"
                        } else this._pixelRatio = 1, this._width = e.width, this._height = e.height;
                        this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], void 0 === LR && console.error("THREE.EffectComposer relies on CopyShader"), void 0 === DR && console.error("THREE.EffectComposer relies on ShaderPass"), this.copyPass = new DR(LR), this.clock = new ld
                    }
                    swapBuffers() {
                        const t = this.readBuffer;
                        this.readBuffer = this.writeBuffer, this.writeBuffer = t
                    }
                    addPass(t) { this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) }
                    insertPass(t, e) { this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) }
                    removePass(t) { const e = this.passes.indexOf(t); - 1 !== e && this.passes.splice(e, 1) }
                    isLastEnabledPass(t) {
                        for (let e = t + 1; e < this.passes.length; e++)
                            if (this.passes[e].enabled) return !1;
                        return !0
                    }
                    render(t) {
                        void 0 === t && (t = this.clock.getDelta());
                        const e = this.renderer.getRenderTarget();
                        let n = !1;
                        for (let e = 0, i = this.passes.length; e < i; e++) {
                            const i = this.passes[e];
                            if (!1 !== i.enabled) {
                                if (i.renderToScreen = this.renderToScreen && this.isLastEnabledPass(e), i.render(this.renderer, this.writeBuffer, this.readBuffer, t, n), i.needsSwap) {
                                    if (n) {
                                        const e = this.renderer.getContext(),
                                            n = this.renderer.state.buffers.stencil;
                                        n.setFunc(e.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), n.setFunc(e.EQUAL, 1, 4294967295)
                                    }
                                    this.swapBuffers()
                                }
                                void 0 !== NR && (i instanceof NR ? n = !0 : i instanceof BR && (n = !1))
                            }
                        }
                        this.renderer.setRenderTarget(e)
                    }
                    reset(t) {
                        if (void 0 === t) {
                            const e = this.renderer.getSize(new $n);
                            this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, (t = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                        }
                        this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
                    }
                    setSize(t, e) {
                        this._width = t, this._height = e;
                        const n = this._width * this._pixelRatio,
                            i = this._height * this._pixelRatio;
                        this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i);
                        for (let t = 0; t < this.passes.length; t++) this.passes[t].setSize(n, i)
                    }
                    setPixelRatio(t) { this._pixelRatio = t, this.setSize(this._width, this._height) }
                }
                new Du(-1, 1, 1, -1, 0, 1);
                const FR = new rs;
                FR.setAttribute("position", new qr([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), FR.setAttribute("uv", new qr([0, 2, 0, 0, 2, 0], 2));
                class zR extends RR {
                    constructor(t, e, n, i, r) { super(), this.scene = t, this.camera = e, this.overrideMaterial = n, this.clearColor = i, this.clearAlpha = void 0 !== r ? r : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new Dr }
                    render(t, e, n) {
                        const i = t.autoClear;
                        let r, s;
                        t.autoClear = !1, void 0 !== this.overrideMaterial && (s = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (t.getClearColor(this._oldClearColor), r = t.getClearAlpha(), t.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && t.clearDepth(), t.setRenderTarget(this.renderToScreen ? null : n), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), t.render(this.scene, this.camera), this.clearColor && t.setClearColor(this._oldClearColor, r), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = s), t.autoClear = i
                    }
                }
                const UR = { uniforms: { tDiffuse: { value: null }, tDisp: { value: null }, byp: { value: 0 }, amount: { value: .08 }, angle: { value: .02 }, seed: { value: .02 }, seed_x: { value: .02 }, seed_y: { value: .02 }, distortion_x: { value: .5 }, distortion_y: { value: .6 }, col_s: { value: .05 } }, vertexShader: "\n\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}", fragmentShader: "\n\n\t\tuniform int byp; //should we apply the glitch ?\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDisp;\n\n\t\tuniform float amount;\n\t\tuniform float angle;\n\t\tuniform float seed;\n\t\tuniform float seed_x;\n\t\tuniform float seed_y;\n\t\tuniform float distortion_x;\n\t\tuniform float distortion_y;\n\t\tuniform float col_s;\n\n\t\tvarying vec2 vUv;\n\n\n\t\tfloat rand(vec2 co){\n\t\t\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\t\t}\n\n\t\tvoid main() {\n\t\t\tif(byp<1) {\n\t\t\t\tvec2 p = vUv;\n\t\t\t\tfloat xs = floor(gl_FragCoord.x / 0.5);\n\t\t\t\tfloat ys = floor(gl_FragCoord.y / 0.5);\n\t\t\t\t//based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\n\t\t\t\tvec4 normal = texture2D (tDisp, p*seed*seed);\n\t\t\t\tif(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {\n\t\t\t\t\tif(seed_x>0.){\n\t\t\t\t\t\tp.y = 1. - (p.y + distortion_y);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.y = distortion_y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {\n\t\t\t\t\tif(seed_y>0.){\n\t\t\t\t\t\tp.x=distortion_x;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.x = 1. - (p.x + distortion_x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp.x+=normal.x*seed_x*(seed/5.);\n\t\t\t\tp.y+=normal.y*seed_y*(seed/5.);\n\t\t\t\t//base from RGB shift shader\n\t\t\t\tvec2 offset = amount * vec2( cos(angle), sin(angle));\n\t\t\t\tvec4 cr = texture2D(tDiffuse, p + offset);\n\t\t\t\tvec4 cga = texture2D(tDiffuse, p);\n\t\t\t\tvec4 cb = texture2D(tDiffuse, p - offset);\n\t\t\t\tgl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\n\t\t\t\t//add noise\n\t\t\t\tvec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);\n\t\t\t\tgl_FragColor = gl_FragColor+ snow;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgl_FragColor=texture2D (tDiffuse, vUv);\n\t\t\t}\n\t\t}" };
                class HR extends RR {
                    constructor(t = 64) {
                        super(), void 0 === UR && console.error("THREE.GlitchPass relies on DigitalGlitch");
                        const e = UR;
                        this.uniforms = As.clone(e.uniforms), this.uniforms.tDisp.value = this.generateHeightmap(t), this.material = new Ls({ uniforms: this.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader }), this.fsQuad = new IR(this.material), this.goWild = !1, this.curF = 0, this.generateTrigger()
                    }
                    render(t, e, n) { this.uniforms.tDiffuse.value = n.texture, this.uniforms.seed.value = Math.random(), this.uniforms.byp.value = 0, this.curF % this.randX == 0 || 1 == this.goWild ? (this.uniforms.amount.value = Math.random() / 30, this.uniforms.angle.value = Qn.randFloat(-Math.PI, Math.PI), this.uniforms.seed_x.value = Qn.randFloat(-1, 1), this.uniforms.seed_y.value = Qn.randFloat(-1, 1), this.uniforms.distortion_x.value = Qn.randFloat(0, 1), this.uniforms.distortion_y.value = Qn.randFloat(0, 1), this.curF = 0, this.generateTrigger()) : this.curF % this.randX < this.randX / 5 ? (this.uniforms.amount.value = Math.random() / 90, this.uniforms.angle.value = Qn.randFloat(-Math.PI, Math.PI), this.uniforms.distortion_x.value = Qn.randFloat(0, 1), this.uniforms.distortion_y.value = Qn.randFloat(0, 1), this.uniforms.seed_x.value = Qn.randFloat(-.3, .3), this.uniforms.seed_y.value = Qn.randFloat(-.3, .3)) : 0 == this.goWild && (this.uniforms.byp.value = 1), this.curF++, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(), this.fsQuad.render(t)) }
                    generateTrigger() { this.randX = Qn.randInt(120, 240) }
                    generateHeightmap(t) {
                        const e = new Float32Array(t * t * 3),
                            n = t * t;
                        for (let t = 0; t < n; t++) {
                            const n = Qn.randFloat(0, 1);
                            e[3 * t + 0] = n, e[3 * t + 1] = n, e[3 * t + 2] = n
                        }
                        return new Fl(e, t, t, kt, Nt)
                    }
                }
                const kR = { uniforms: { tDiffuse: { value: null }, tSize: { value: new $n(256, 256) }, center: { value: new $n(.5, .5) }, angle: { value: 1.57 }, scale: { value: 1 } }, vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}", fragmentShader: "\n\n\t\tuniform vec2 center;\n\t\tuniform float angle;\n\t\tuniform float scale;\n\t\tuniform vec2 tSize;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tfloat pattern() {\n\n\t\t\tfloat s = sin( angle ), c = cos( angle );\n\n\t\t\tvec2 tex = vUv * tSize - center;\n\t\t\tvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\n\n\t\t\treturn ( sin( point.x ) * sin( point.y ) ) * 4.0;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 color = texture2D( tDiffuse, vUv );\n\n\t\t\tfloat average = ( color.r + color.g + color.b ) / 3.0;\n\n\t\t\tgl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\n\n\t\t}" }
            },
            842: function(t, e, n) {
                var i;
                i = function() {
                    return function(t) {
                        var e = {};

                        function n(i) { if (e[i]) return e[i].exports; var r = e[i] = { i, l: !1, exports: {} }; return t[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports }
                        return n.m = t, n.c = e, n.d = function(t, e, i) { n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: i }) }, n.r = function(t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, n.t = function(t, e) {
                            if (1 & e && (t = n(t)), 8 & e) return t;
                            if (4 & e && "object" == typeof t && t && t.__esModule) return t;
                            var i = Object.create(null);
                            if (n.r(i), Object.defineProperty(i, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t)
                                for (var r in t) n.d(i, r, function(e) { return t[e] }.bind(null, r));
                            return i
                        }, n.n = function(t) { var e = t && t.__esModule ? function() { return t.default } : function() { return t }; return n.d(e, "a", e), e }, n.o = function(t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, n.p = "", n(n.s = 22)
                    }([function(t, e) {
                        var i = {};
                        t.exports = i,
                            function() {
                                i._nextId = 0, i._seed = 0, i._nowStartTime = +new Date, i._warnedOnce = {}, i._decomp = null, i.extend = function(t, e) {
                                    var n, r;
                                    "boolean" == typeof e ? (n = 2, r = e) : (n = 1, r = !0);
                                    for (var s = n; s < arguments.length; s++) {
                                        var o = arguments[s];
                                        if (o)
                                            for (var a in o) r && o[a] && o[a].constructor === Object ? t[a] && t[a].constructor !== Object ? t[a] = o[a] : (t[a] = t[a] || {}, i.extend(t[a], r, o[a])) : t[a] = o[a]
                                    }
                                    return t
                                }, i.clone = function(t, e) { return i.extend({}, e, t) }, i.keys = function(t) { if (Object.keys) return Object.keys(t); var e = []; for (var n in t) e.push(n); return e }, i.values = function(t) { var e = []; if (Object.keys) { for (var n = Object.keys(t), i = 0; i < n.length; i++) e.push(t[n[i]]); return e } for (var r in t) e.push(t[r]); return e }, i.get = function(t, e, n, i) { e = e.split(".").slice(n, i); for (var r = 0; r < e.length; r += 1) t = t[e[r]]; return t }, i.set = function(t, e, n, r, s) { var o = e.split(".").slice(r, s); return i.get(t, e, 0, -1)[o[o.length - 1]] = n, n }, i.shuffle = function(t) {
                                    for (var e = t.length - 1; e > 0; e--) {
                                        var n = Math.floor(i.random() * (e + 1)),
                                            r = t[e];
                                        t[e] = t[n], t[n] = r
                                    }
                                    return t
                                }, i.choose = function(t) { return t[Math.floor(i.random() * t.length)] }, i.isElement = function(t) { return "undefined" != typeof HTMLElement ? t instanceof HTMLElement : !!(t && t.nodeType && t.nodeName) }, i.isArray = function(t) { return "[object Array]" === Object.prototype.toString.call(t) }, i.isFunction = function(t) { return "function" == typeof t }, i.isPlainObject = function(t) { return "object" == typeof t && t.constructor === Object }, i.isString = function(t) { return "[object String]" === toString.call(t) }, i.clamp = function(t, e, n) { return t < e ? e : t > n ? n : t }, i.sign = function(t) { return t < 0 ? -1 : 1 }, i.now = function() { if ("undefined" != typeof window && window.performance) { if (window.performance.now) return window.performance.now(); if (window.performance.webkitNow) return window.performance.webkitNow() } return Date.now ? Date.now() : new Date - i._nowStartTime }, i.random = function(e, n) { return n = void 0 !== n ? n : 1, (e = void 0 !== e ? e : 0) + t() * (n - e) };
                                var t = function() { return i._seed = (9301 * i._seed + 49297) % 233280, i._seed / 233280 };
                                i.colorToNumber = function(t) { return 3 == (t = t.replace("#", "")).length && (t = t.charAt(0) + t.charAt(0) + t.charAt(1) + t.charAt(1) + t.charAt(2) + t.charAt(2)), parseInt(t, 16) }, i.logLevel = 1, i.log = function() { console && i.logLevel > 0 && i.logLevel <= 3 && console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, i.info = function() { console && i.logLevel > 0 && i.logLevel <= 2 && console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, i.warn = function() { console && i.logLevel > 0 && i.logLevel <= 3 && console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments))) }, i.warnOnce = function() {
                                    var t = Array.prototype.slice.call(arguments).join(" ");
                                    i._warnedOnce[t] || (i.warn(t), i._warnedOnce[t] = !0)
                                }, i.deprecated = function(t, e, n) { t[e] = i.chain((function() { i.warnOnce("🔅 deprecated 🔅", n) }), t[e]) }, i.nextId = function() { return i._nextId++ }, i.indexOf = function(t, e) {
                                    if (t.indexOf) return t.indexOf(e);
                                    for (var n = 0; n < t.length; n++)
                                        if (t[n] === e) return n;
                                    return -1
                                }, i.map = function(t, e) { if (t.map) return t.map(e); for (var n = [], i = 0; i < t.length; i += 1) n.push(e(t[i])); return n }, i.topologicalSort = function(t) {
                                    var e = [],
                                        n = [],
                                        r = [];
                                    for (var s in t) n[s] || r[s] || i._topologicalSort(s, n, r, t, e);
                                    return e
                                }, i._topologicalSort = function(t, e, n, r, s) {
                                    var o = r[t] || [];
                                    n[t] = !0;
                                    for (var a = 0; a < o.length; a += 1) {
                                        var l = o[a];
                                        n[l] || e[l] || i._topologicalSort(l, e, n, r, s)
                                    }
                                    n[t] = !1, e[t] = !0, s.push(t)
                                }, i.chain = function() {
                                    for (var t = [], e = 0; e < arguments.length; e += 1) {
                                        var n = arguments[e];
                                        n._chained ? t.push.apply(t, n._chained) : t.push(n)
                                    }
                                    var i = function() {
                                        for (var e, n = new Array(arguments.length), i = 0, r = arguments.length; i < r; i++) n[i] = arguments[i];
                                        for (i = 0; i < t.length; i += 1) {
                                            var s = t[i].apply(e, n);
                                            void 0 !== s && (e = s)
                                        }
                                        return e
                                    };
                                    return i._chained = t, i
                                }, i.chainPathBefore = function(t, e, n) { return i.set(t, e, i.chain(n, i.get(t, e))) }, i.chainPathAfter = function(t, e, n) { return i.set(t, e, i.chain(i.get(t, e), n)) }, i.setDecomp = function(t) { i._decomp = t }, i.getDecomp = function() { var t = i._decomp; try { t || "undefined" == typeof window || (t = window.decomp), t || void 0 === n.g || (t = n.g.decomp) } catch (e) { t = null } return t }
                            }()
                    }, function(t, e) {
                        var n = {};
                        t.exports = n, n.create = function(t) { var e = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } }; return t && n.update(e, t), e }, n.update = function(t, e, n) {
                            t.min.x = 1 / 0, t.max.x = -1 / 0, t.min.y = 1 / 0, t.max.y = -1 / 0;
                            for (var i = 0; i < e.length; i++) {
                                var r = e[i];
                                r.x > t.max.x && (t.max.x = r.x), r.x < t.min.x && (t.min.x = r.x), r.y > t.max.y && (t.max.y = r.y), r.y < t.min.y && (t.min.y = r.y)
                            }
                            n && (n.x > 0 ? t.max.x += n.x : t.min.x += n.x, n.y > 0 ? t.max.y += n.y : t.min.y += n.y)
                        }, n.contains = function(t, e) { return e.x >= t.min.x && e.x <= t.max.x && e.y >= t.min.y && e.y <= t.max.y }, n.overlaps = function(t, e) { return t.min.x <= e.max.x && t.max.x >= e.min.x && t.max.y >= e.min.y && t.min.y <= e.max.y }, n.translate = function(t, e) { t.min.x += e.x, t.max.x += e.x, t.min.y += e.y, t.max.y += e.y }, n.shift = function(t, e) {
                            var n = t.max.x - t.min.x,
                                i = t.max.y - t.min.y;
                            t.min.x = e.x, t.max.x = e.x + n, t.min.y = e.y, t.max.y = e.y + i
                        }
                    }, function(t, e) {
                        var n = {};
                        t.exports = n, n.create = function(t, e) { return { x: t || 0, y: e || 0 } }, n.clone = function(t) { return { x: t.x, y: t.y } }, n.magnitude = function(t) { return Math.sqrt(t.x * t.x + t.y * t.y) }, n.magnitudeSquared = function(t) { return t.x * t.x + t.y * t.y }, n.rotate = function(t, e, n) {
                            var i = Math.cos(e),
                                r = Math.sin(e);
                            n || (n = {});
                            var s = t.x * i - t.y * r;
                            return n.y = t.x * r + t.y * i, n.x = s, n
                        }, n.rotateAbout = function(t, e, n, i) {
                            var r = Math.cos(e),
                                s = Math.sin(e);
                            i || (i = {});
                            var o = n.x + ((t.x - n.x) * r - (t.y - n.y) * s);
                            return i.y = n.y + ((t.x - n.x) * s + (t.y - n.y) * r), i.x = o, i
                        }, n.normalise = function(t) { var e = n.magnitude(t); return 0 === e ? { x: 0, y: 0 } : { x: t.x / e, y: t.y / e } }, n.dot = function(t, e) { return t.x * e.x + t.y * e.y }, n.cross = function(t, e) { return t.x * e.y - t.y * e.x }, n.cross3 = function(t, e, n) { return (e.x - t.x) * (n.y - t.y) - (e.y - t.y) * (n.x - t.x) }, n.add = function(t, e, n) { return n || (n = {}), n.x = t.x + e.x, n.y = t.y + e.y, n }, n.sub = function(t, e, n) { return n || (n = {}), n.x = t.x - e.x, n.y = t.y - e.y, n }, n.mult = function(t, e) { return { x: t.x * e, y: t.y * e } }, n.div = function(t, e) { return { x: t.x / e, y: t.y / e } }, n.perp = function(t, e) { return { x: (e = !0 === e ? -1 : 1) * -t.y, y: e * t.x } }, n.neg = function(t) { return { x: -t.x, y: -t.y } }, n.angle = function(t, e) { return Math.atan2(e.y - t.y, e.x - t.x) }, n._temp = [n.create(), n.create(), n.create(), n.create(), n.create(), n.create()]
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(2),
                            s = n(0);
                        i.create = function(t, e) {
                            for (var n = [], i = 0; i < t.length; i++) {
                                var r = t[i],
                                    s = { x: r.x, y: r.y, index: i, body: e, isInternal: !1 };
                                n.push(s)
                            }
                            return n
                        }, i.fromPath = function(t, e) { var n = []; return t.replace(/L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/gi, (function(t, e, i) { n.push({ x: parseFloat(e), y: parseFloat(i) }) })), i.create(n, e) }, i.centre = function(t) { for (var e, n, s, o = i.area(t, !0), a = { x: 0, y: 0 }, l = 0; l < t.length; l++) s = (l + 1) % t.length, e = r.cross(t[l], t[s]), n = r.mult(r.add(t[l], t[s]), e), a = r.add(a, n); return r.div(a, 6 * o) }, i.mean = function(t) { for (var e = { x: 0, y: 0 }, n = 0; n < t.length; n++) e.x += t[n].x, e.y += t[n].y; return r.div(e, t.length) }, i.area = function(t, e) { for (var n = 0, i = t.length - 1, r = 0; r < t.length; r++) n += (t[i].x - t[r].x) * (t[i].y + t[r].y), i = r; return e ? n / 2 : Math.abs(n) / 2 }, i.inertia = function(t, e) { for (var n, i, s = 0, o = 0, a = t, l = 0; l < a.length; l++) i = (l + 1) % a.length, s += (n = Math.abs(r.cross(a[i], a[l]))) * (r.dot(a[i], a[i]) + r.dot(a[i], a[l]) + r.dot(a[l], a[l])), o += n; return e / 6 * (s / o) }, i.translate = function(t, e, n) {
                            var i;
                            if (n)
                                for (i = 0; i < t.length; i++) t[i].x += e.x * n, t[i].y += e.y * n;
                            else
                                for (i = 0; i < t.length; i++) t[i].x += e.x, t[i].y += e.y;
                            return t
                        }, i.rotate = function(t, e, n) {
                            if (0 !== e) {
                                for (var i = Math.cos(e), r = Math.sin(e), s = 0; s < t.length; s++) {
                                    var o = t[s],
                                        a = o.x - n.x,
                                        l = o.y - n.y;
                                    o.x = n.x + (a * i - l * r), o.y = n.y + (a * r + l * i)
                                }
                                return t
                            }
                        }, i.contains = function(t, e) {
                            for (var n = 0; n < t.length; n++) {
                                var i = t[n],
                                    r = t[(n + 1) % t.length];
                                if ((e.x - i.x) * (r.y - i.y) + (e.y - i.y) * (i.x - r.x) > 0) return !1
                            }
                            return !0
                        }, i.scale = function(t, e, n, s) {
                            if (1 === e && 1 === n) return t;
                            var o, a;
                            s = s || i.centre(t);
                            for (var l = 0; l < t.length; l++) o = t[l], a = r.sub(o, s), t[l].x = s.x + a.x * e, t[l].y = s.y + a.y * n;
                            return t
                        }, i.chamfer = function(t, e, n, i, o) {
                            e = "number" == typeof e ? [e] : e || [8], n = void 0 !== n ? n : -1, i = i || 2, o = o || 14;
                            for (var a = [], l = 0; l < t.length; l++) {
                                var c = t[l - 1 >= 0 ? l - 1 : t.length - 1],
                                    h = t[l],
                                    u = t[(l + 1) % t.length],
                                    d = e[l < e.length ? l : e.length - 1];
                                if (0 !== d) {
                                    var p = r.normalise({ x: h.y - c.y, y: c.x - h.x }),
                                        m = r.normalise({ x: u.y - h.y, y: h.x - u.x }),
                                        f = Math.sqrt(2 * Math.pow(d, 2)),
                                        g = r.mult(s.clone(p), d),
                                        v = r.normalise(r.mult(r.add(p, m), .5)),
                                        y = r.sub(h, r.mult(v, f)),
                                        x = n; - 1 === n && (x = 1.75 * Math.pow(d, .32)), (x = s.clamp(x, i, o)) % 2 == 1 && (x += 1);
                                    for (var _ = Math.acos(r.dot(p, m)) / x, b = 0; b < x; b++) a.push(r.add(r.rotate(g, _ * b), y))
                                } else a.push(h)
                            }
                            return a
                        }, i.clockwiseSort = function(t) { var e = i.mean(t); return t.sort((function(t, n) { return r.angle(e, t) - r.angle(e, n) })), t }, i.isConvex = function(t) {
                            var e, n, i, r, s = 0,
                                o = t.length;
                            if (o < 3) return null;
                            for (e = 0; e < o; e++)
                                if (i = (e + 2) % o, r = (t[n = (e + 1) % o].x - t[e].x) * (t[i].y - t[n].y), (r -= (t[n].y - t[e].y) * (t[i].x - t[n].x)) < 0 ? s |= 1 : r > 0 && (s |= 2), 3 === s) return !1;
                            return 0 !== s || null
                        }, i.hull = function(t) {
                            var e, n, i = [],
                                s = [];
                            for ((t = t.slice(0)).sort((function(t, e) { var n = t.x - e.x; return 0 !== n ? n : t.y - e.y })), n = 0; n < t.length; n += 1) {
                                for (e = t[n]; s.length >= 2 && r.cross3(s[s.length - 2], s[s.length - 1], e) <= 0;) s.pop();
                                s.push(e)
                            }
                            for (n = t.length - 1; n >= 0; n -= 1) {
                                for (e = t[n]; i.length >= 2 && r.cross3(i[i.length - 2], i[i.length - 1], e) <= 0;) i.pop();
                                i.push(e)
                            }
                            return i.pop(), s.pop(), i.concat(s)
                        }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(0);
                        i.on = function(t, e, n) { for (var i, r = e.split(" "), s = 0; s < r.length; s++) i = r[s], t.events = t.events || {}, t.events[i] = t.events[i] || [], t.events[i].push(n); return n }, i.off = function(t, e, n) {
                            if (e) {
                                "function" == typeof e && (n = e, e = r.keys(t.events).join(" "));
                                for (var i = e.split(" "), s = 0; s < i.length; s++) {
                                    var o = t.events[i[s]],
                                        a = [];
                                    if (n && o)
                                        for (var l = 0; l < o.length; l++) o[l] !== n && a.push(o[l]);
                                    t.events[i[s]] = a
                                }
                            } else t.events = {}
                        }, i.trigger = function(t, e, n) {
                            var i, s, o, a, l = t.events;
                            if (l && r.keys(l).length > 0) {
                                n || (n = {}), i = e.split(" ");
                                for (var c = 0; c < i.length; c++)
                                    if (o = l[s = i[c]]) {
                                        (a = r.clone(n, !1)).name = s, a.source = t;
                                        for (var h = 0; h < o.length; h++) o[h].apply(t, [a])
                                    }
                            }
                        }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(4),
                            s = n(0),
                            o = n(1),
                            a = n(6);
                        i.create = function(t) { return s.extend({ id: s.nextId(), type: "composite", parent: null, isModified: !1, bodies: [], constraints: [], composites: [], label: "Composite", plugin: {} }, t) }, i.setModified = function(t, e, n, r) {
                            if (t.isModified = e, n && t.parent && i.setModified(t.parent, e, n, r), r)
                                for (var s = 0; s < t.composites.length; s++) {
                                    var o = t.composites[s];
                                    i.setModified(o, e, n, r)
                                }
                        }, i.add = function(t, e) {
                            var n = [].concat(e);
                            r.trigger(t, "beforeAdd", { object: e });
                            for (var o = 0; o < n.length; o++) {
                                var a = n[o];
                                switch (a.type) {
                                    case "body":
                                        if (a.parent !== a) { s.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)"); break }
                                        i.addBody(t, a);
                                        break;
                                    case "constraint":
                                        i.addConstraint(t, a);
                                        break;
                                    case "composite":
                                        i.addComposite(t, a);
                                        break;
                                    case "mouseConstraint":
                                        i.addConstraint(t, a.constraint)
                                }
                            }
                            return r.trigger(t, "afterAdd", { object: e }), t
                        }, i.remove = function(t, e, n) {
                            var s = [].concat(e);
                            r.trigger(t, "beforeRemove", { object: e });
                            for (var o = 0; o < s.length; o++) {
                                var a = s[o];
                                switch (a.type) {
                                    case "body":
                                        i.removeBody(t, a, n);
                                        break;
                                    case "constraint":
                                        i.removeConstraint(t, a, n);
                                        break;
                                    case "composite":
                                        i.removeComposite(t, a, n);
                                        break;
                                    case "mouseConstraint":
                                        i.removeConstraint(t, a.constraint)
                                }
                            }
                            return r.trigger(t, "afterRemove", { object: e }), t
                        }, i.addComposite = function(t, e) { return t.composites.push(e), e.parent = t, i.setModified(t, !0, !0, !1), t }, i.removeComposite = function(t, e, n) {
                            var r = s.indexOf(t.composites, e);
                            if (-1 !== r && (i.removeCompositeAt(t, r), i.setModified(t, !0, !0, !1)), n)
                                for (var o = 0; o < t.composites.length; o++) i.removeComposite(t.composites[o], e, !0);
                            return t
                        }, i.removeCompositeAt = function(t, e) { return t.composites.splice(e, 1), i.setModified(t, !0, !0, !1), t }, i.addBody = function(t, e) { return t.bodies.push(e), i.setModified(t, !0, !0, !1), t }, i.removeBody = function(t, e, n) {
                            var r = s.indexOf(t.bodies, e);
                            if (-1 !== r && (i.removeBodyAt(t, r), i.setModified(t, !0, !0, !1)), n)
                                for (var o = 0; o < t.composites.length; o++) i.removeBody(t.composites[o], e, !0);
                            return t
                        }, i.removeBodyAt = function(t, e) { return t.bodies.splice(e, 1), i.setModified(t, !0, !0, !1), t }, i.addConstraint = function(t, e) { return t.constraints.push(e), i.setModified(t, !0, !0, !1), t }, i.removeConstraint = function(t, e, n) {
                            var r = s.indexOf(t.constraints, e);
                            if (-1 !== r && i.removeConstraintAt(t, r), n)
                                for (var o = 0; o < t.composites.length; o++) i.removeConstraint(t.composites[o], e, !0);
                            return t
                        }, i.removeConstraintAt = function(t, e) { return t.constraints.splice(e, 1), i.setModified(t, !0, !0, !1), t }, i.clear = function(t, e, n) {
                            if (n)
                                for (var r = 0; r < t.composites.length; r++) i.clear(t.composites[r], e, !0);
                            return e ? t.bodies = t.bodies.filter((function(t) { return t.isStatic })) : t.bodies.length = 0, t.constraints.length = 0, t.composites.length = 0, i.setModified(t, !0, !0, !1), t
                        }, i.allBodies = function(t) { for (var e = [].concat(t.bodies), n = 0; n < t.composites.length; n++) e = e.concat(i.allBodies(t.composites[n])); return e }, i.allConstraints = function(t) { for (var e = [].concat(t.constraints), n = 0; n < t.composites.length; n++) e = e.concat(i.allConstraints(t.composites[n])); return e }, i.allComposites = function(t) { for (var e = [].concat(t.composites), n = 0; n < t.composites.length; n++) e = e.concat(i.allComposites(t.composites[n])); return e }, i.get = function(t, e, n) {
                            var r, s;
                            switch (n) {
                                case "body":
                                    r = i.allBodies(t);
                                    break;
                                case "constraint":
                                    r = i.allConstraints(t);
                                    break;
                                case "composite":
                                    r = i.allComposites(t).concat(t)
                            }
                            return r ? 0 === (s = r.filter((function(t) { return t.id.toString() === e.toString() }))).length ? null : s[0] : null
                        }, i.move = function(t, e, n) { return i.remove(t, e), i.add(n, e), t }, i.rebase = function(t) { for (var e = i.allBodies(t).concat(i.allConstraints(t)).concat(i.allComposites(t)), n = 0; n < e.length; n++) e[n].id = s.nextId(); return i.setModified(t, !0, !0, !1), t }, i.translate = function(t, e, n) { for (var r = n ? i.allBodies(t) : t.bodies, s = 0; s < r.length; s++) a.translate(r[s], e); return i.setModified(t, !0, !0, !1), t }, i.rotate = function(t, e, n, r) {
                            for (var s = Math.cos(e), o = Math.sin(e), l = r ? i.allBodies(t) : t.bodies, c = 0; c < l.length; c++) {
                                var h = l[c],
                                    u = h.position.x - n.x,
                                    d = h.position.y - n.y;
                                a.setPosition(h, { x: n.x + (u * s - d * o), y: n.y + (u * o + d * s) }), a.rotate(h, e)
                            }
                            return i.setModified(t, !0, !0, !1), t
                        }, i.scale = function(t, e, n, r, s) {
                            for (var o = s ? i.allBodies(t) : t.bodies, l = 0; l < o.length; l++) {
                                var c = o[l],
                                    h = c.position.x - r.x,
                                    u = c.position.y - r.y;
                                a.setPosition(c, { x: r.x + h * e, y: r.y + u * n }), a.scale(c, e, n)
                            }
                            return i.setModified(t, !0, !0, !1), t
                        }, i.bounds = function(t) {
                            for (var e = i.allBodies(t), n = [], r = 0; r < e.length; r += 1) {
                                var s = e[r];
                                n.push(s.bounds.min, s.bounds.max)
                            }
                            return o.create(n)
                        }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(3),
                            s = n(2),
                            o = n(7),
                            a = (n(16), n(0)),
                            l = n(1),
                            c = n(10);
                        ! function() {
                            i._inertiaScale = 4, i._nextCollidingGroupId = 1, i._nextNonCollidingGroupId = -1, i._nextCategory = 1, i.create = function(e) {
                                var n = { id: a.nextId(), type: "body", label: "Body", parts: [], plugin: {}, angle: 0, vertices: r.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"), position: { x: 0, y: 0 }, force: { x: 0, y: 0 }, torque: 0, positionImpulse: { x: 0, y: 0 }, constraintImpulse: { x: 0, y: 0, angle: 0 }, totalContacts: 0, speed: 0, angularSpeed: 0, velocity: { x: 0, y: 0 }, angularVelocity: 0, isSensor: !1, isStatic: !1, isSleeping: !1, motion: 0, sleepThreshold: 60, density: .001, restitution: 0, friction: .1, frictionStatic: .5, frictionAir: .01, collisionFilter: { category: 1, mask: 4294967295, group: 0 }, slop: .05, timeScale: 1, render: { visible: !0, opacity: 1, strokeStyle: null, fillStyle: null, lineWidth: null, sprite: { xScale: 1, yScale: 1, xOffset: 0, yOffset: 0 } }, events: null, bounds: null, chamfer: null, circleRadius: 0, positionPrev: null, anglePrev: 0, parent: null, axes: null, area: 0, mass: 0, inertia: 0, _original: null },
                                    i = a.extend(n, e);
                                return t(i, e), i
                            }, i.nextGroup = function(t) { return t ? i._nextNonCollidingGroupId-- : i._nextCollidingGroupId++ }, i.nextCategory = function() { return i._nextCategory = i._nextCategory << 1, i._nextCategory };
                            var t = function(t, e) {
                                e = e || {}, i.set(t, { bounds: t.bounds || l.create(t.vertices), positionPrev: t.positionPrev || s.clone(t.position), anglePrev: t.anglePrev || t.angle, vertices: t.vertices, parts: t.parts || [t], isStatic: t.isStatic, isSleeping: t.isSleeping, parent: t.parent || t }), r.rotate(t.vertices, t.angle, t.position), c.rotate(t.axes, t.angle), l.update(t.bounds, t.vertices, t.velocity), i.set(t, { axes: e.axes || t.axes, area: e.area || t.area, mass: e.mass || t.mass, inertia: e.inertia || t.inertia });
                                var n = t.isStatic ? "#14151f" : a.choose(["#f19648", "#f5d259", "#f55a3c", "#063e7b", "#ececd1"]),
                                    o = t.isStatic ? "#555" : "#ccc",
                                    h = t.isStatic && null === t.render.fillStyle ? 1 : 0;
                                t.render.fillStyle = t.render.fillStyle || n, t.render.strokeStyle = t.render.strokeStyle || o, t.render.lineWidth = t.render.lineWidth || h, t.render.sprite.xOffset += -(t.bounds.min.x - t.position.x) / (t.bounds.max.x - t.bounds.min.x), t.render.sprite.yOffset += -(t.bounds.min.y - t.position.y) / (t.bounds.max.y - t.bounds.min.y)
                            };
                            i.set = function(t, e, n) {
                                var r;
                                for (r in "string" == typeof e && (r = e, (e = {})[r] = n), e)
                                    if (Object.prototype.hasOwnProperty.call(e, r)) switch (n = e[r], r) {
                                        case "isStatic":
                                            i.setStatic(t, n);
                                            break;
                                        case "isSleeping":
                                            o.set(t, n);
                                            break;
                                        case "mass":
                                            i.setMass(t, n);
                                            break;
                                        case "density":
                                            i.setDensity(t, n);
                                            break;
                                        case "inertia":
                                            i.setInertia(t, n);
                                            break;
                                        case "vertices":
                                            i.setVertices(t, n);
                                            break;
                                        case "position":
                                            i.setPosition(t, n);
                                            break;
                                        case "angle":
                                            i.setAngle(t, n);
                                            break;
                                        case "velocity":
                                            i.setVelocity(t, n);
                                            break;
                                        case "angularVelocity":
                                            i.setAngularVelocity(t, n);
                                            break;
                                        case "parts":
                                            i.setParts(t, n);
                                            break;
                                        case "centre":
                                            i.setCentre(t, n);
                                            break;
                                        default:
                                            t[r] = n
                                    }
                            }, i.setStatic = function(t, e) {
                                for (var n = 0; n < t.parts.length; n++) {
                                    var i = t.parts[n];
                                    i.isStatic = e, e ? (i._original = { restitution: i.restitution, friction: i.friction, mass: i.mass, inertia: i.inertia, density: i.density, inverseMass: i.inverseMass, inverseInertia: i.inverseInertia }, i.restitution = 0, i.friction = 1, i.mass = i.inertia = i.density = 1 / 0, i.inverseMass = i.inverseInertia = 0, i.positionPrev.x = i.position.x, i.positionPrev.y = i.position.y, i.anglePrev = i.angle, i.angularVelocity = 0, i.speed = 0, i.angularSpeed = 0, i.motion = 0) : i._original && (i.restitution = i._original.restitution, i.friction = i._original.friction, i.mass = i._original.mass, i.inertia = i._original.inertia, i.density = i._original.density, i.inverseMass = i._original.inverseMass, i.inverseInertia = i._original.inverseInertia, i._original = null)
                                }
                            }, i.setMass = function(t, e) {
                                var n = t.inertia / (t.mass / 6);
                                t.inertia = n * (e / 6), t.inverseInertia = 1 / t.inertia, t.mass = e, t.inverseMass = 1 / t.mass, t.density = t.mass / t.area
                            }, i.setDensity = function(t, e) { i.setMass(t, e * t.area), t.density = e }, i.setInertia = function(t, e) { t.inertia = e, t.inverseInertia = 1 / t.inertia }, i.setVertices = function(t, e) {
                                e[0].body === t ? t.vertices = e : t.vertices = r.create(e, t), t.axes = c.fromVertices(t.vertices), t.area = r.area(t.vertices), i.setMass(t, t.density * t.area);
                                var n = r.centre(t.vertices);
                                r.translate(t.vertices, n, -1), i.setInertia(t, i._inertiaScale * r.inertia(t.vertices, t.mass)), r.translate(t.vertices, t.position), l.update(t.bounds, t.vertices, t.velocity)
                            }, i.setParts = function(t, e, n) {
                                var s;
                                for (e = e.slice(0), t.parts.length = 0, t.parts.push(t), t.parent = t, s = 0; s < e.length; s++) {
                                    var o = e[s];
                                    o !== t && (o.parent = t, t.parts.push(o))
                                }
                                if (1 !== t.parts.length) {
                                    if (n = void 0 === n || n) {
                                        var a = [];
                                        for (s = 0; s < e.length; s++) a = a.concat(e[s].vertices);
                                        r.clockwiseSort(a);
                                        var l = r.hull(a),
                                            c = r.centre(l);
                                        i.setVertices(t, l), r.translate(t.vertices, c)
                                    }
                                    var h = i._totalProperties(t);
                                    t.area = h.area, t.parent = t, t.position.x = h.centre.x, t.position.y = h.centre.y, t.positionPrev.x = h.centre.x, t.positionPrev.y = h.centre.y, i.setMass(t, h.mass), i.setInertia(t, h.inertia), i.setPosition(t, h.centre)
                                }
                            }, i.setCentre = function(t, e, n) { n ? (t.positionPrev.x += e.x, t.positionPrev.y += e.y, t.position.x += e.x, t.position.y += e.y) : (t.positionPrev.x = e.x - (t.position.x - t.positionPrev.x), t.positionPrev.y = e.y - (t.position.y - t.positionPrev.y), t.position.x = e.x, t.position.y = e.y) }, i.setPosition = function(t, e) {
                                var n = s.sub(e, t.position);
                                t.positionPrev.x += n.x, t.positionPrev.y += n.y;
                                for (var i = 0; i < t.parts.length; i++) {
                                    var o = t.parts[i];
                                    o.position.x += n.x, o.position.y += n.y, r.translate(o.vertices, n), l.update(o.bounds, o.vertices, t.velocity)
                                }
                            }, i.setAngle = function(t, e) {
                                var n = e - t.angle;
                                t.anglePrev += n;
                                for (var i = 0; i < t.parts.length; i++) {
                                    var o = t.parts[i];
                                    o.angle += n, r.rotate(o.vertices, n, t.position), c.rotate(o.axes, n), l.update(o.bounds, o.vertices, t.velocity), i > 0 && s.rotateAbout(o.position, n, t.position, o.position)
                                }
                            }, i.setVelocity = function(t, e) { t.positionPrev.x = t.position.x - e.x, t.positionPrev.y = t.position.y - e.y, t.velocity.x = e.x, t.velocity.y = e.y, t.speed = s.magnitude(t.velocity) }, i.setAngularVelocity = function(t, e) { t.anglePrev = t.angle - e, t.angularVelocity = e, t.angularSpeed = Math.abs(t.angularVelocity) }, i.translate = function(t, e) { i.setPosition(t, s.add(t.position, e)) }, i.rotate = function(t, e, n) {
                                if (n) {
                                    var r = Math.cos(e),
                                        s = Math.sin(e),
                                        o = t.position.x - n.x,
                                        a = t.position.y - n.y;
                                    i.setPosition(t, { x: n.x + (o * r - a * s), y: n.y + (o * s + a * r) }), i.setAngle(t, t.angle + e)
                                } else i.setAngle(t, t.angle + e)
                            }, i.scale = function(t, e, n, s) {
                                var o = 0,
                                    a = 0;
                                s = s || t.position;
                                for (var h = 0; h < t.parts.length; h++) {
                                    var u = t.parts[h];
                                    r.scale(u.vertices, e, n, s), u.axes = c.fromVertices(u.vertices), u.area = r.area(u.vertices), i.setMass(u, t.density * u.area), r.translate(u.vertices, { x: -u.position.x, y: -u.position.y }), i.setInertia(u, i._inertiaScale * r.inertia(u.vertices, u.mass)), r.translate(u.vertices, { x: u.position.x, y: u.position.y }), h > 0 && (o += u.area, a += u.inertia), u.position.x = s.x + (u.position.x - s.x) * e, u.position.y = s.y + (u.position.y - s.y) * n, l.update(u.bounds, u.vertices, t.velocity)
                                }
                                t.parts.length > 1 && (t.area = o, t.isStatic || (i.setMass(t, t.density * o), i.setInertia(t, a))), t.circleRadius && (e === n ? t.circleRadius *= e : t.circleRadius = null)
                            }, i.update = function(t, e, n, i) {
                                var o = Math.pow(e * n * t.timeScale, 2),
                                    a = 1 - t.frictionAir * n * t.timeScale,
                                    h = t.position.x - t.positionPrev.x,
                                    u = t.position.y - t.positionPrev.y;
                                t.velocity.x = h * a * i + t.force.x / t.mass * o, t.velocity.y = u * a * i + t.force.y / t.mass * o, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.position.x += t.velocity.x, t.position.y += t.velocity.y, t.angularVelocity = (t.angle - t.anglePrev) * a * i + t.torque / t.inertia * o, t.anglePrev = t.angle, t.angle += t.angularVelocity, t.speed = s.magnitude(t.velocity), t.angularSpeed = Math.abs(t.angularVelocity);
                                for (var d = 0; d < t.parts.length; d++) {
                                    var p = t.parts[d];
                                    r.translate(p.vertices, t.velocity), d > 0 && (p.position.x += t.velocity.x, p.position.y += t.velocity.y), 0 !== t.angularVelocity && (r.rotate(p.vertices, t.angularVelocity, t.position), c.rotate(p.axes, t.angularVelocity), d > 0 && s.rotateAbout(p.position, t.angularVelocity, t.position, p.position)), l.update(p.bounds, p.vertices, t.velocity)
                                }
                            }, i.applyForce = function(t, e, n) {
                                t.force.x += n.x, t.force.y += n.y;
                                var i = e.x - t.position.x,
                                    r = e.y - t.position.y;
                                t.torque += i * n.y - r * n.x
                            }, i._totalProperties = function(t) {
                                for (var e = { mass: 0, area: 0, inertia: 0, centre: { x: 0, y: 0 } }, n = 1 === t.parts.length ? 0 : 1; n < t.parts.length; n++) {
                                    var i = t.parts[n],
                                        r = i.mass !== 1 / 0 ? i.mass : 1;
                                    e.mass += r, e.area += i.area, e.inertia += i.inertia, e.centre = s.add(e.centre, s.mult(i.position, r))
                                }
                                return e.centre = s.div(e.centre, e.mass), e
                            }
                        }()
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(4);
                        i._motionWakeThreshold = .18, i._motionSleepThreshold = .08, i._minBias = .9, i.update = function(t, e) {
                            for (var n = e * e * e, r = 0; r < t.length; r++) {
                                var s = t[r],
                                    o = s.speed * s.speed + s.angularSpeed * s.angularSpeed;
                                if (0 === s.force.x && 0 === s.force.y) {
                                    var a = Math.min(s.motion, o),
                                        l = Math.max(s.motion, o);
                                    s.motion = i._minBias * a + (1 - i._minBias) * l, s.sleepThreshold > 0 && s.motion < i._motionSleepThreshold * n ? (s.sleepCounter += 1, s.sleepCounter >= s.sleepThreshold && i.set(s, !0)) : s.sleepCounter > 0 && (s.sleepCounter -= 1)
                                } else i.set(s, !1)
                            }
                        }, i.afterCollisions = function(t, e) {
                            for (var n = e * e * e, r = 0; r < t.length; r++) {
                                var s = t[r];
                                if (s.isActive) {
                                    var o = s.collision,
                                        a = o.bodyA.parent,
                                        l = o.bodyB.parent;
                                    if (!(a.isSleeping && l.isSleeping || a.isStatic || l.isStatic) && (a.isSleeping || l.isSleeping)) {
                                        var c = a.isSleeping && !a.isStatic ? a : l,
                                            h = c === a ? l : a;
                                        !c.isStatic && h.motion > i._motionWakeThreshold * n && i.set(c, !1)
                                    }
                                }
                            }
                        }, i.set = function(t, e) {
                            var n = t.isSleeping;
                            e ? (t.isSleeping = !0, t.sleepCounter = t.sleepThreshold, t.positionImpulse.x = 0, t.positionImpulse.y = 0, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.anglePrev = t.angle, t.speed = 0, t.angularSpeed = 0, t.motion = 0, n || r.trigger(t, "sleepStart")) : (t.isSleeping = !1, t.sleepCounter = 0, n && r.trigger(t, "sleepEnd"))
                        }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(3),
                            s = n(2),
                            o = n(7),
                            a = n(1),
                            l = n(10),
                            c = n(0);
                        i._warming = .4, i._torqueDampen = 1, i._minLength = 1e-6, i.create = function(t) {
                            var e = t;
                            e.bodyA && !e.pointA && (e.pointA = { x: 0, y: 0 }), e.bodyB && !e.pointB && (e.pointB = { x: 0, y: 0 });
                            var n = e.bodyA ? s.add(e.bodyA.position, e.pointA) : e.pointA,
                                i = e.bodyB ? s.add(e.bodyB.position, e.pointB) : e.pointB,
                                r = s.magnitude(s.sub(n, i));
                            e.length = void 0 !== e.length ? e.length : r, e.id = e.id || c.nextId(), e.label = e.label || "Constraint", e.type = "constraint", e.stiffness = e.stiffness || (e.length > 0 ? 1 : .7), e.damping = e.damping || 0, e.angularStiffness = e.angularStiffness || 0, e.angleA = e.bodyA ? e.bodyA.angle : e.angleA, e.angleB = e.bodyB ? e.bodyB.angle : e.angleB, e.plugin = {};
                            var o = { visible: !0, lineWidth: 2, strokeStyle: "#ffffff", type: "line", anchors: !0 };
                            return 0 === e.length && e.stiffness > .1 ? (o.type = "pin", o.anchors = !1) : e.stiffness < .9 && (o.type = "spring"), e.render = c.extend(o, e.render), e
                        }, i.preSolveAll = function(t) {
                            for (var e = 0; e < t.length; e += 1) {
                                var n = t[e],
                                    i = n.constraintImpulse;
                                n.isStatic || 0 === i.x && 0 === i.y && 0 === i.angle || (n.position.x += i.x, n.position.y += i.y, n.angle += i.angle)
                            }
                        }, i.solveAll = function(t, e) {
                            for (var n = 0; n < t.length; n += 1) {
                                var r = t[n],
                                    s = !r.bodyA || r.bodyA && r.bodyA.isStatic,
                                    o = !r.bodyB || r.bodyB && r.bodyB.isStatic;
                                (s || o) && i.solve(t[n], e)
                            }
                            for (n = 0; n < t.length; n += 1) s = !(r = t[n]).bodyA || r.bodyA && r.bodyA.isStatic, o = !r.bodyB || r.bodyB && r.bodyB.isStatic, s || o || i.solve(t[n], e)
                        }, i.solve = function(t, e) {
                            var n = t.bodyA,
                                r = t.bodyB,
                                o = t.pointA,
                                a = t.pointB;
                            if (n || r) {
                                n && !n.isStatic && (s.rotate(o, n.angle - t.angleA, o), t.angleA = n.angle), r && !r.isStatic && (s.rotate(a, r.angle - t.angleB, a), t.angleB = r.angle);
                                var l = o,
                                    c = a;
                                if (n && (l = s.add(n.position, o)), r && (c = s.add(r.position, a)), l && c) {
                                    var h = s.sub(l, c),
                                        u = s.magnitude(h);
                                    u < i._minLength && (u = i._minLength);
                                    var d, p, m, f, g, v = (u - t.length) / u,
                                        y = t.stiffness < 1 ? t.stiffness * e : t.stiffness,
                                        x = s.mult(h, v * y),
                                        _ = (n ? n.inverseMass : 0) + (r ? r.inverseMass : 0),
                                        b = _ + ((n ? n.inverseInertia : 0) + (r ? r.inverseInertia : 0));
                                    if (t.damping) {
                                        var w = s.create();
                                        m = s.div(h, u), g = s.sub(r && s.sub(r.position, r.positionPrev) || w, n && s.sub(n.position, n.positionPrev) || w), f = s.dot(m, g)
                                    }
                                    n && !n.isStatic && (p = n.inverseMass / _, n.constraintImpulse.x -= x.x * p, n.constraintImpulse.y -= x.y * p, n.position.x -= x.x * p, n.position.y -= x.y * p, t.damping && (n.positionPrev.x -= t.damping * m.x * f * p, n.positionPrev.y -= t.damping * m.y * f * p), d = s.cross(o, x) / b * i._torqueDampen * n.inverseInertia * (1 - t.angularStiffness), n.constraintImpulse.angle -= d, n.angle -= d), r && !r.isStatic && (p = r.inverseMass / _, r.constraintImpulse.x += x.x * p, r.constraintImpulse.y += x.y * p, r.position.x += x.x * p, r.position.y += x.y * p, t.damping && (r.positionPrev.x += t.damping * m.x * f * p, r.positionPrev.y += t.damping * m.y * f * p), d = s.cross(a, x) / b * i._torqueDampen * r.inverseInertia * (1 - t.angularStiffness), r.constraintImpulse.angle += d, r.angle += d)
                                }
                            }
                        }, i.postSolveAll = function(t) {
                            for (var e = 0; e < t.length; e++) {
                                var n = t[e],
                                    c = n.constraintImpulse;
                                if (!(n.isStatic || 0 === c.x && 0 === c.y && 0 === c.angle)) {
                                    o.set(n, !1);
                                    for (var h = 0; h < n.parts.length; h++) {
                                        var u = n.parts[h];
                                        r.translate(u.vertices, c), h > 0 && (u.position.x += c.x, u.position.y += c.y), 0 !== c.angle && (r.rotate(u.vertices, c.angle, n.position), l.rotate(u.axes, c.angle), h > 0 && s.rotateAbout(u.position, c.angle, n.position, u.position)), a.update(u.bounds, u.vertices, n.velocity)
                                    }
                                    c.angle *= i._warming, c.x *= i._warming, c.y *= i._warming
                                }
                            }
                        }, i.pointAWorld = function(t) { return { x: (t.bodyA ? t.bodyA.position.x : 0) + t.pointA.x, y: (t.bodyA ? t.bodyA.position.y : 0) + t.pointA.y } }, i.pointBWorld = function(t) { return { x: (t.bodyB ? t.bodyB.position.x : 0) + t.pointB.x, y: (t.bodyB ? t.bodyB.position.y : 0) + t.pointB.y } }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(17);
                        i.create = function(t, e) {
                            var n = t.bodyA,
                                r = t.bodyB,
                                s = t.parentA,
                                o = t.parentB,
                                a = { id: i.id(n, r), bodyA: n, bodyB: r, contacts: {}, activeContacts: [], separation: 0, isActive: !0, confirmedActive: !0, isSensor: n.isSensor || r.isSensor, timeCreated: e, timeUpdated: e, inverseMass: s.inverseMass + o.inverseMass, friction: Math.min(s.friction, o.friction), frictionStatic: Math.max(s.frictionStatic, o.frictionStatic), restitution: Math.max(s.restitution, o.restitution), slop: Math.max(s.slop, o.slop) };
                            return i.update(a, t, e), a
                        }, i.update = function(t, e, n) {
                            var s = t.contacts,
                                o = e.supports,
                                a = t.activeContacts,
                                l = e.parentA,
                                c = e.parentB;
                            if (t.collision = e, t.inverseMass = l.inverseMass + c.inverseMass, t.friction = Math.min(l.friction, c.friction), t.frictionStatic = Math.max(l.frictionStatic, c.frictionStatic), t.restitution = Math.max(l.restitution, c.restitution), t.slop = Math.max(l.slop, c.slop), a.length = 0, e.collided) {
                                for (var h = 0; h < o.length; h++) {
                                    var u = o[h],
                                        d = r.id(u),
                                        p = s[d];
                                    p ? a.push(p) : a.push(s[d] = r.create(u))
                                }
                                t.separation = e.depth, i.setActive(t, !0, n)
                            } else !0 === t.isActive && i.setActive(t, !1, n)
                        }, i.setActive = function(t, e, n) { e ? (t.isActive = !0, t.timeUpdated = n) : (t.isActive = !1, t.activeContacts.length = 0) }, i.id = function(t, e) { return t.id < e.id ? "A" + t.id + "B" + e.id : "A" + e.id + "B" + t.id }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(2),
                            s = n(0);
                        i.fromVertices = function(t) {
                            for (var e = {}, n = 0; n < t.length; n++) {
                                var i = (n + 1) % t.length,
                                    o = r.normalise({ x: t[i].y - t[n].y, y: t[n].x - t[i].x }),
                                    a = 0 === o.y ? 1 / 0 : o.x / o.y;
                                e[a = a.toFixed(3).toString()] = o
                            }
                            return s.values(e)
                        }, i.rotate = function(t, e) {
                            if (0 !== e)
                                for (var n = Math.cos(e), i = Math.sin(e), r = 0; r < t.length; r++) {
                                    var s, o = t[r];
                                    s = o.x * n - o.y * i, o.y = o.x * i + o.y * n, o.x = s
                                }
                        }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(3),
                            s = n(0),
                            o = n(6),
                            a = n(1),
                            l = n(2);
                        i.rectangle = function(t, e, n, i, a) {
                            a = a || {};
                            var l = { label: "Rectangle Body", position: { x: t, y: e }, vertices: r.fromPath("L 0 0 L " + n + " 0 L " + n + " " + i + " L 0 " + i) };
                            if (a.chamfer) {
                                var c = a.chamfer;
                                l.vertices = r.chamfer(l.vertices, c.radius, c.quality, c.qualityMin, c.qualityMax), delete a.chamfer
                            }
                            return o.create(s.extend({}, l, a))
                        }, i.trapezoid = function(t, e, n, i, a, l) {
                            l = l || {};
                            var c, h = n * (a *= .5),
                                u = h + (1 - 2 * a) * n,
                                d = u + h;
                            c = a < .5 ? "L 0 0 L " + h + " " + -i + " L " + u + " " + -i + " L " + d + " 0" : "L 0 0 L " + u + " " + -i + " L " + d + " 0";
                            var p = { label: "Trapezoid Body", position: { x: t, y: e }, vertices: r.fromPath(c) };
                            if (l.chamfer) {
                                var m = l.chamfer;
                                p.vertices = r.chamfer(p.vertices, m.radius, m.quality, m.qualityMin, m.qualityMax), delete l.chamfer
                            }
                            return o.create(s.extend({}, p, l))
                        }, i.circle = function(t, e, n, r, o) {
                            r = r || {};
                            var a = { label: "Circle Body", circleRadius: n };
                            o = o || 25;
                            var l = Math.ceil(Math.max(10, Math.min(o, n)));
                            return l % 2 == 1 && (l += 1), i.polygon(t, e, l, n, s.extend({}, a, r))
                        }, i.polygon = function(t, e, n, a, l) {
                            if (l = l || {}, n < 3) return i.circle(t, e, a, l);
                            for (var c = 2 * Math.PI / n, h = "", u = .5 * c, d = 0; d < n; d += 1) {
                                var p = u + d * c,
                                    m = Math.cos(p) * a,
                                    f = Math.sin(p) * a;
                                h += "L " + m.toFixed(3) + " " + f.toFixed(3) + " "
                            }
                            var g = { label: "Polygon Body", position: { x: t, y: e }, vertices: r.fromPath(h) };
                            if (l.chamfer) {
                                var v = l.chamfer;
                                g.vertices = r.chamfer(g.vertices, v.radius, v.quality, v.qualityMin, v.qualityMax), delete l.chamfer
                            }
                            return o.create(s.extend({}, g, l))
                        }, i.fromVertices = function(t, e, n, i, c, h, u, d) {
                            var p, m, f, g, v, y, x, _, b, w, M = s.getDecomp();
                            for (p = Boolean(M && M.quickDecomp), i = i || {}, f = [], c = void 0 !== c && c, h = void 0 !== h ? h : .01, u = void 0 !== u ? u : 10, d = void 0 !== d ? d : .01, s.isArray(n[0]) || (n = [n]), b = 0; b < n.length; b += 1)
                                if (v = n[b], !(g = r.isConvex(v)) && !p && s.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."), g || !p) v = g ? r.clockwiseSort(v) : r.hull(v), f.push({ position: { x: t, y: e }, vertices: v });
                                else {
                                    var S = v.map((function(t) { return [t.x, t.y] }));
                                    M.makeCCW(S), !1 !== h && M.removeCollinearPoints(S, h), !1 !== d && M.removeDuplicatePoints && M.removeDuplicatePoints(S, d);
                                    var T = M.quickDecomp(S);
                                    for (y = 0; y < T.length; y++) {
                                        var E = T[y].map((function(t) { return { x: t[0], y: t[1] } }));
                                        u > 0 && r.area(E) < u || f.push({ position: r.centre(E), vertices: E })
                                    }
                                }
                            for (y = 0; y < f.length; y++) f[y] = o.create(s.extend(f[y], i));
                            if (c)
                                for (y = 0; y < f.length; y++) {
                                    var A = f[y];
                                    for (x = y + 1; x < f.length; x++) {
                                        var L = f[x];
                                        if (a.overlaps(A.bounds, L.bounds)) {
                                            var R = A.vertices,
                                                C = L.vertices;
                                            for (_ = 0; _ < A.vertices.length; _++)
                                                for (w = 0; w < L.vertices.length; w++) {
                                                    var P = l.magnitudeSquared(l.sub(R[(_ + 1) % R.length], C[w])),
                                                        I = l.magnitudeSquared(l.sub(R[_], C[(w + 1) % C.length]));
                                                    P < 5 && I < 5 && (R[_].isInternal = !0, C[w].isInternal = !0)
                                                }
                                        }
                                    }
                                }
                            return f.length > 1 ? (m = o.create(s.extend({ parts: f.slice(0) }, i)), o.setPosition(m, { x: t, y: e }), m) : f[0]
                        }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(0);
                        i.create = function(t) {
                            var e = {};
                            return t || r.log("Mouse.create: element was undefined, defaulting to document.body", "warn"), e.element = t || document.body, e.absolute = { x: 0, y: 0 }, e.position = { x: 0, y: 0 }, e.mousedownPosition = { x: 0, y: 0 }, e.mouseupPosition = { x: 0, y: 0 }, e.offset = { x: 0, y: 0 }, e.scale = { x: 1, y: 1 }, e.wheelDelta = 0, e.button = -1, e.pixelRatio = parseInt(e.element.getAttribute("data-pixel-ratio"), 10) || 1, e.sourceEvents = { mousemove: null, mousedown: null, mouseup: null, mousewheel: null }, e.mousemove = function(t) {
                                var n = i._getRelativeMousePosition(t, e.element, e.pixelRatio);
                                t.changedTouches && (e.button = 0, t.preventDefault()), e.absolute.x = n.x, e.absolute.y = n.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y, e.sourceEvents.mousemove = t
                            }, e.mousedown = function(t) {
                                var n = i._getRelativeMousePosition(t, e.element, e.pixelRatio);
                                t.changedTouches ? (e.button = 0, t.preventDefault()) : e.button = t.button, e.absolute.x = n.x, e.absolute.y = n.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y, e.mousedownPosition.x = e.position.x, e.mousedownPosition.y = e.position.y, e.sourceEvents.mousedown = t
                            }, e.mouseup = function(t) {
                                var n = i._getRelativeMousePosition(t, e.element, e.pixelRatio);
                                t.changedTouches && t.preventDefault(), e.button = -1, e.absolute.x = n.x, e.absolute.y = n.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y, e.mouseupPosition.x = e.position.x, e.mouseupPosition.y = e.position.y, e.sourceEvents.mouseup = t
                            }, e.mousewheel = function(t) { e.wheelDelta = Math.max(-1, Math.min(1, t.wheelDelta || -t.detail)), t.preventDefault() }, i.setElement(e, e.element), e
                        }, i.setElement = function(t, e) { t.element = e, e.addEventListener("mousemove", t.mousemove), e.addEventListener("mousedown", t.mousedown), e.addEventListener("mouseup", t.mouseup), e.addEventListener("mousewheel", t.mousewheel), e.addEventListener("DOMMouseScroll", t.mousewheel), e.addEventListener("touchmove", t.mousemove), e.addEventListener("touchstart", t.mousedown), e.addEventListener("touchend", t.mouseup) }, i.clearSourceEvents = function(t) { t.sourceEvents.mousemove = null, t.sourceEvents.mousedown = null, t.sourceEvents.mouseup = null, t.sourceEvents.mousewheel = null, t.wheelDelta = 0 }, i.setOffset = function(t, e) { t.offset.x = e.x, t.offset.y = e.y, t.position.x = t.absolute.x * t.scale.x + t.offset.x, t.position.y = t.absolute.y * t.scale.y + t.offset.y }, i.setScale = function(t, e) { t.scale.x = e.x, t.scale.y = e.y, t.position.x = t.absolute.x * t.scale.x + t.offset.x, t.position.y = t.absolute.y * t.scale.y + t.offset.y }, i._getRelativeMousePosition = function(t, e, n) {
                            var i, r, s = e.getBoundingClientRect(),
                                o = document.documentElement || document.body.parentNode || document.body,
                                a = void 0 !== window.pageXOffset ? window.pageXOffset : o.scrollLeft,
                                l = void 0 !== window.pageYOffset ? window.pageYOffset : o.scrollTop,
                                c = t.changedTouches;
                            return c ? (i = c[0].pageX - s.left - a, r = c[0].pageY - s.top - l) : (i = t.pageX - s.left - a, r = t.pageY - s.top - l), { x: i / (e.clientWidth / (e.width || e.clientWidth) * n), y: r / (e.clientHeight / (e.height || e.clientHeight) * n) }
                        }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(14),
                            s = n(9),
                            o = n(1);
                        i.collisions = function(t, e) {
                            for (var n = [], a = e.pairs.table, l = 0; l < t.length; l++) {
                                var c = t[l][0],
                                    h = t[l][1];
                                if ((!c.isStatic && !c.isSleeping || !h.isStatic && !h.isSleeping) && i.canCollide(c.collisionFilter, h.collisionFilter) && o.overlaps(c.bounds, h.bounds))
                                    for (var u = c.parts.length > 1 ? 1 : 0; u < c.parts.length; u++)
                                        for (var d = c.parts[u], p = h.parts.length > 1 ? 1 : 0; p < h.parts.length; p++) {
                                            var m = h.parts[p];
                                            if (d === c && m === h || o.overlaps(d.bounds, m.bounds)) {
                                                var f, g = a[s.id(d, m)];
                                                f = g && g.isActive ? g.collision : null;
                                                var v = r.collides(d, m, f);
                                                v.collided && n.push(v)
                                            }
                                        }
                            }
                            return n
                        }, i.canCollide = function(t, e) { return t.group === e.group && 0 !== t.group ? t.group > 0 : 0 != (t.mask & e.category) && 0 != (e.mask & t.category) }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(3),
                            s = n(2);
                        i.collides = function(t, e, n) {
                            var o, a, l, c, h = !1;
                            if (n) {
                                var u = t.parent,
                                    d = e.parent,
                                    p = u.speed * u.speed + u.angularSpeed * u.angularSpeed + d.speed * d.speed + d.angularSpeed * d.angularSpeed;
                                h = n && n.collided && p < .2, c = n
                            } else c = { collided: !1, bodyA: t, bodyB: e };
                            if (n && h) {
                                var m = c.axisBody,
                                    f = m === t ? e : t,
                                    g = [m.axes[n.axisNumber]];
                                if (l = i._overlapAxes(m.vertices, f.vertices, g), c.reused = !0, l.overlap <= 0) return c.collided = !1, c
                            } else {
                                if ((o = i._overlapAxes(t.vertices, e.vertices, t.axes)).overlap <= 0) return c.collided = !1, c;
                                if ((a = i._overlapAxes(e.vertices, t.vertices, e.axes)).overlap <= 0) return c.collided = !1, c;
                                o.overlap < a.overlap ? (l = o, c.axisBody = t) : (l = a, c.axisBody = e), c.axisNumber = l.axisNumber
                            }
                            c.bodyA = t.id < e.id ? t : e, c.bodyB = t.id < e.id ? e : t, c.collided = !0, c.depth = l.overlap, c.parentA = c.bodyA.parent, c.parentB = c.bodyB.parent, t = c.bodyA, e = c.bodyB, s.dot(l.axis, s.sub(e.position, t.position)) < 0 ? c.normal = { x: l.axis.x, y: l.axis.y } : c.normal = { x: -l.axis.x, y: -l.axis.y }, c.tangent = s.perp(c.normal), c.penetration = c.penetration || {}, c.penetration.x = c.normal.x * c.depth, c.penetration.y = c.normal.y * c.depth;
                            var v = i._findSupports(t, e, c.normal),
                                y = [];
                            if (r.contains(t.vertices, v[0]) && y.push(v[0]), r.contains(t.vertices, v[1]) && y.push(v[1]), y.length < 2) {
                                var x = i._findSupports(e, t, s.neg(c.normal));
                                r.contains(e.vertices, x[0]) && y.push(x[0]), y.length < 2 && r.contains(e.vertices, x[1]) && y.push(x[1])
                            }
                            return y.length < 1 && (y = [v[0]]), c.supports = y, c
                        }, i._overlapAxes = function(t, e, n) {
                            for (var r, o, a = s._temp[0], l = s._temp[1], c = { overlap: Number.MAX_VALUE }, h = 0; h < n.length; h++) {
                                if (o = n[h], i._projectToAxis(a, t, o), i._projectToAxis(l, e, o), (r = Math.min(a.max - l.min, l.max - a.min)) <= 0) return c.overlap = r, c;
                                r < c.overlap && (c.overlap = r, c.axis = o, c.axisNumber = h)
                            }
                            return c
                        }, i._projectToAxis = function(t, e, n) {
                            for (var i = s.dot(e[0], n), r = i, o = 1; o < e.length; o += 1) {
                                var a = s.dot(e[o], n);
                                a > r ? r = a : a < i && (i = a)
                            }
                            t.min = i, t.max = r
                        }, i._findSupports = function(t, e, n) { for (var i, r, o, a, l = Number.MAX_VALUE, c = s._temp[0], h = e.vertices, u = t.position, d = 0; d < h.length; d++) r = h[d], c.x = r.x - u.x, c.y = r.y - u.y, (i = -s.dot(n, c)) < l && (l = i, o = r); return r = h[o.index - 1 >= 0 ? o.index - 1 : h.length - 1], c.x = r.x - u.x, c.y = r.y - u.y, l = -s.dot(n, c), a = r, r = h[(o.index + 1) % h.length], c.x = r.x - u.x, c.y = r.y - u.y, (i = -s.dot(n, c)) < l && (a = r), [o, a] }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(0);
                        i._registry = {}, i.register = function(t) {
                            if (i.isPlugin(t) || r.warn("Plugin.register:", i.toString(t), "does not implement all required fields."), t.name in i._registry) {
                                var e = i._registry[t.name],
                                    n = i.versionParse(t.version).number,
                                    s = i.versionParse(e.version).number;
                                n > s ? (r.warn("Plugin.register:", i.toString(e), "was upgraded to", i.toString(t)), i._registry[t.name] = t) : n < s ? r.warn("Plugin.register:", i.toString(e), "can not be downgraded to", i.toString(t)) : t !== e && r.warn("Plugin.register:", i.toString(t), "is already registered to different plugin object")
                            } else i._registry[t.name] = t;
                            return t
                        }, i.resolve = function(t) { return i._registry[i.dependencyParse(t).name] }, i.toString = function(t) { return "string" == typeof t ? t : (t.name || "anonymous") + "@" + (t.version || t.range || "0.0.0") }, i.isPlugin = function(t) { return t && t.name && t.version && t.install }, i.isUsed = function(t, e) { return t.used.indexOf(e) > -1 }, i.isFor = function(t, e) { var n = t.for && i.dependencyParse(t.for); return !t.for || e.name === n.name && i.versionSatisfies(e.version, n.range) }, i.use = function(t, e) {
                            if (t.uses = (t.uses || []).concat(e || []), 0 !== t.uses.length) {
                                for (var n = i.dependencies(t), s = r.topologicalSort(n), o = [], a = 0; a < s.length; a += 1)
                                    if (s[a] !== t.name) {
                                        var l = i.resolve(s[a]);
                                        l ? i.isUsed(t, l.name) || (i.isFor(l, t) || (r.warn("Plugin.use:", i.toString(l), "is for", l.for, "but installed on", i.toString(t) + "."), l._warned = !0), l.install ? l.install(t) : (r.warn("Plugin.use:", i.toString(l), "does not specify an install function."), l._warned = !0), l._warned ? (o.push("🔶 " + i.toString(l)), delete l._warned) : o.push("✅ " + i.toString(l)), t.used.push(l.name)) : o.push("❌ " + s[a])
                                    }
                                o.length > 0 && r.info(o.join("  "))
                            } else r.warn("Plugin.use:", i.toString(t), "does not specify any dependencies to install.")
                        }, i.dependencies = function(t, e) {
                            var n = i.dependencyParse(t),
                                s = n.name;
                            if (!(s in (e = e || {}))) {
                                t = i.resolve(t) || t, e[s] = r.map(t.uses || [], (function(e) {
                                    i.isPlugin(e) && i.register(e);
                                    var s = i.dependencyParse(e),
                                        o = i.resolve(e);
                                    return o && !i.versionSatisfies(o.version, s.range) ? (r.warn("Plugin.dependencies:", i.toString(o), "does not satisfy", i.toString(s), "used by", i.toString(n) + "."), o._warned = !0, t._warned = !0) : o || (r.warn("Plugin.dependencies:", i.toString(e), "used by", i.toString(n), "could not be resolved."), t._warned = !0), s.name
                                }));
                                for (var o = 0; o < e[s].length; o += 1) i.dependencies(e[s][o], e);
                                return e
                            }
                        }, i.dependencyParse = function(t) { return r.isString(t) ? (/^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/.test(t) || r.warn("Plugin.dependencyParse:", t, "is not a valid dependency string."), { name: t.split("@")[0], range: t.split("@")[1] || "*" }) : { name: t.name, range: t.range || t.version } }, i.versionParse = function(t) {
                            var e = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-]+)?$/;
                            e.test(t) || r.warn("Plugin.versionParse:", t, "is not a valid version or range.");
                            var n = e.exec(t),
                                i = Number(n[4]),
                                s = Number(n[5]),
                                o = Number(n[6]);
                            return { isRange: Boolean(n[1] || n[2]), version: n[3], range: t, operator: n[1] || n[2] || "", major: i, minor: s, patch: o, parts: [i, s, o], prerelease: n[7], number: 1e8 * i + 1e4 * s + o }
                        }, i.versionSatisfies = function(t, e) {
                            e = e || "*";
                            var n = i.versionParse(e),
                                r = i.versionParse(t);
                            if (n.isRange) { if ("*" === n.operator || "*" === t) return !0; if (">" === n.operator) return r.number > n.number; if (">=" === n.operator) return r.number >= n.number; if ("~" === n.operator) return r.major === n.major && r.minor === n.minor && r.patch >= n.patch; if ("^" === n.operator) return n.major > 0 ? r.major === n.major && r.number >= n.number : n.minor > 0 ? r.minor === n.minor && r.patch >= n.patch : r.patch === n.patch }
                            return t === e || "*" === t
                        }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(0),
                            s = n(5),
                            o = n(1),
                            a = n(4),
                            l = n(2),
                            c = n(12);
                        ! function() {
                            var t, e;
                            "undefined" != typeof window && (t = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(t) { window.setTimeout((function() { t(r.now()) }), 1e3 / 60) }, e = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), i._goodFps = 30, i._goodDelta = 1e3 / 60, i.create = function(t) {
                                var e = { controller: i, engine: null, element: null, canvas: null, mouse: null, frameRequestId: null, timing: { historySize: 60, delta: 0, deltaHistory: [], lastTime: 0, lastTimestamp: 0, lastElapsed: 0, timestampElapsed: 0, timestampElapsedHistory: [], engineDeltaHistory: [], engineElapsedHistory: [], elapsedHistory: [] }, options: { width: 800, height: 600, pixelRatio: 1, background: "#14151f", wireframeBackground: "#14151f", hasBounds: !!t.bounds, enabled: !0, wireframes: !0, showSleeping: !0, showDebug: !1, showStats: !1, showPerformance: !1, showBroadphase: !1, showBounds: !1, showVelocity: !1, showCollisions: !1, showSeparations: !1, showAxes: !1, showPositions: !1, showAngleIndicator: !1, showIds: !1, showVertexNumbers: !1, showConvexHulls: !1, showInternalEdges: !1, showMousePosition: !1 } },
                                    n = r.extend(e, t);
                                return n.canvas && (n.canvas.width = n.options.width || n.canvas.width, n.canvas.height = n.options.height || n.canvas.height), n.mouse = t.mouse, n.engine = t.engine, n.canvas = n.canvas || u(n.options.width, n.options.height), n.context = n.canvas.getContext("2d"), n.textures = {}, n.bounds = n.bounds || { min: { x: 0, y: 0 }, max: { x: n.canvas.width, y: n.canvas.height } }, 1 !== n.options.pixelRatio && i.setPixelRatio(n, n.options.pixelRatio), r.isElement(n.element) ? n.element.appendChild(n.canvas) : n.canvas.parentNode || r.log("Render.create: options.element was undefined, render.canvas was created but not appended", "warn"), n
                            }, i.run = function(e) {! function r(s) { e.frameRequestId = t(r), n(e, s), i.world(e, s), (e.options.showStats || e.options.showDebug) && i.stats(e, e.context, s), (e.options.showPerformance || e.options.showDebug) && i.performance(e, e.context, s) }() }, i.stop = function(t) { e(t.frameRequestId) }, i.setPixelRatio = function(t, e) {
                                var n = t.options,
                                    i = t.canvas;
                                "auto" === e && (e = d(i)), n.pixelRatio = e, i.setAttribute("data-pixel-ratio", e), i.width = n.width * e, i.height = n.height * e, i.style.width = n.width + "px", i.style.height = n.height + "px"
                            }, i.lookAt = function(t, e, n, i) {
                                i = void 0 === i || i, e = r.isArray(e) ? e : [e], n = n || { x: 0, y: 0 };
                                for (var s = { min: { x: 1 / 0, y: 1 / 0 }, max: { x: -1 / 0, y: -1 / 0 } }, o = 0; o < e.length; o += 1) {
                                    var a = e[o],
                                        l = a.bounds ? a.bounds.min : a.min || a.position || a,
                                        h = a.bounds ? a.bounds.max : a.max || a.position || a;
                                    l && h && (l.x < s.min.x && (s.min.x = l.x), h.x > s.max.x && (s.max.x = h.x), l.y < s.min.y && (s.min.y = l.y), h.y > s.max.y && (s.max.y = h.y))
                                }
                                var u = s.max.x - s.min.x + 2 * n.x,
                                    d = s.max.y - s.min.y + 2 * n.y,
                                    p = t.canvas.height,
                                    m = t.canvas.width / p,
                                    f = u / d,
                                    g = 1,
                                    v = 1;
                                f > m ? v = f / m : g = m / f, t.options.hasBounds = !0, t.bounds.min.x = s.min.x, t.bounds.max.x = s.min.x + u * g, t.bounds.min.y = s.min.y, t.bounds.max.y = s.min.y + d * v, i && (t.bounds.min.x += .5 * u - u * g * .5, t.bounds.max.x += .5 * u - u * g * .5, t.bounds.min.y += .5 * d - d * v * .5, t.bounds.max.y += .5 * d - d * v * .5), t.bounds.min.x -= n.x, t.bounds.max.x -= n.x, t.bounds.min.y -= n.y, t.bounds.max.y -= n.y, t.mouse && (c.setScale(t.mouse, { x: (t.bounds.max.x - t.bounds.min.x) / t.canvas.width, y: (t.bounds.max.y - t.bounds.min.y) / t.canvas.height }), c.setOffset(t.mouse, t.bounds.min))
                            }, i.startViewTransform = function(t) {
                                var e = t.bounds.max.x - t.bounds.min.x,
                                    n = t.bounds.max.y - t.bounds.min.y,
                                    i = e / t.options.width,
                                    r = n / t.options.height;
                                t.context.setTransform(t.options.pixelRatio / i, 0, 0, t.options.pixelRatio / r, 0, 0), t.context.translate(-t.bounds.min.x, -t.bounds.min.y)
                            }, i.endViewTransform = function(t) { t.context.setTransform(t.options.pixelRatio, 0, 0, t.options.pixelRatio, 0, 0) }, i.world = function(t, e) {
                                var n, h = r.now(),
                                    u = t.engine,
                                    d = u.world,
                                    p = t.canvas,
                                    f = t.context,
                                    g = t.options,
                                    v = t.timing,
                                    y = s.allBodies(d),
                                    x = s.allConstraints(d),
                                    _ = g.wireframes ? g.wireframeBackground : g.background,
                                    b = [],
                                    w = [],
                                    M = { timestamp: u.timing.timestamp };
                                if (a.trigger(t, "beforeRender", M), t.currentBackground !== _ && m(t, _), f.globalCompositeOperation = "source-in", f.fillStyle = "transparent", f.fillRect(0, 0, p.width, p.height), f.globalCompositeOperation = "source-over", g.hasBounds) {
                                    for (n = 0; n < y.length; n++) {
                                        var S = y[n];
                                        o.overlaps(S.bounds, t.bounds) && b.push(S)
                                    }
                                    for (n = 0; n < x.length; n++) {
                                        var T = x[n],
                                            E = T.bodyA,
                                            A = T.bodyB,
                                            L = T.pointA,
                                            R = T.pointB;
                                        E && (L = l.add(E.position, T.pointA)), A && (R = l.add(A.position, T.pointB)), L && R && (o.contains(t.bounds, L) || o.contains(t.bounds, R)) && w.push(T)
                                    }
                                    i.startViewTransform(t), t.mouse && (c.setScale(t.mouse, { x: (t.bounds.max.x - t.bounds.min.x) / t.options.width, y: (t.bounds.max.y - t.bounds.min.y) / t.options.height }), c.setOffset(t.mouse, t.bounds.min))
                                } else w = x, b = y, 1 !== t.options.pixelRatio && t.context.setTransform(t.options.pixelRatio, 0, 0, t.options.pixelRatio, 0, 0);
                                !g.wireframes || u.enableSleeping && g.showSleeping ? i.bodies(t, b, f) : (g.showConvexHulls && i.bodyConvexHulls(t, b, f), i.bodyWireframes(t, b, f)), g.showBounds && i.bodyBounds(t, b, f), (g.showAxes || g.showAngleIndicator) && i.bodyAxes(t, b, f), g.showPositions && i.bodyPositions(t, b, f), g.showVelocity && i.bodyVelocity(t, b, f), g.showIds && i.bodyIds(t, b, f), g.showSeparations && i.separations(t, u.pairs.list, f), g.showCollisions && i.collisions(t, u.pairs.list, f), g.showVertexNumbers && i.vertexNumbers(t, b, f), g.showMousePosition && i.mousePosition(t, t.mouse, f), i.constraints(w, f), g.showBroadphase && i.grid(t, u.grid, f), g.hasBounds && i.endViewTransform(t), a.trigger(t, "afterRender", M), v.lastElapsed = r.now() - h
                            }, i.stats = function(t, e, n) {
                                for (var i = t.engine, r = i.world, o = s.allBodies(r), a = 0, l = 0, c = 0; c < o.length; c += 1) a += o[c].parts.length;
                                var h = { Part: a, Body: o.length, Cons: s.allConstraints(r).length, Comp: s.allComposites(r).length, Pair: i.pairs.list.length };
                                for (var u in e.fillStyle = "#0e0f19", e.fillRect(l, 0, 302.5, 44), e.font = "12px Arial", e.textBaseline = "top", e.textAlign = "right", h) {
                                    var d = h[u];
                                    e.fillStyle = "#aaa", e.fillText(u, l + 55, 8), e.fillStyle = "#eee", e.fillText(d, l + 55, 26), l += 55
                                }
                            }, i.performance = function(t, e) {
                                var n = t.engine,
                                    r = t.timing,
                                    s = r.deltaHistory,
                                    o = r.elapsedHistory,
                                    a = r.timestampElapsedHistory,
                                    l = r.engineDeltaHistory,
                                    c = r.engineElapsedHistory,
                                    u = n.timing.lastDelta,
                                    d = h(s),
                                    p = h(o),
                                    m = h(l),
                                    f = h(c),
                                    g = h(a) / d || 0,
                                    v = 1e3 / d || 0;
                                e.fillStyle = "#0e0f19", e.fillRect(0, 50, 370, 34), i.status(e, 10, 69, 60, 4, s.length, Math.round(v) + " fps", v / i._goodFps, (function(t) { return s[t] / d - 1 })), i.status(e, 82, 69, 60, 4, l.length, u.toFixed(2) + " dt", i._goodDelta / u, (function(t) { return l[t] / m - 1 })), i.status(e, 154, 69, 60, 4, c.length, f.toFixed(2) + " ut", 1 - f / i._goodFps, (function(t) { return c[t] / f - 1 })), i.status(e, 226, 69, 60, 4, o.length, p.toFixed(2) + " rt", 1 - p / i._goodFps, (function(t) { return o[t] / p - 1 })), i.status(e, 298, 69, 60, 4, a.length, g.toFixed(2) + " x", g * g * g, (function(t) { return (a[t] / s[t] / g || 0) - 1 }))
                            }, i.status = function(t, e, n, i, s, o, a, l, c) {
                                t.strokeStyle = "#888", t.fillStyle = "#444", t.lineWidth = 1, t.fillRect(e, n + 7, i, 1), t.beginPath(), t.moveTo(e, n + 7 - s * r.clamp(.4 * c(0), -2, 2));
                                for (var h = 0; h < i; h += 1) t.lineTo(e + h, n + 7 - (h < o ? s * r.clamp(.4 * c(h), -2, 2) : 0));
                                t.stroke(), t.fillStyle = "hsl(" + r.clamp(25 + 95 * l, 0, 120) + ",100%,60%)", t.fillRect(e, n - 7, 4, 4), t.font = "12px Arial", t.textBaseline = "middle", t.textAlign = "right", t.fillStyle = "#eee", t.fillText(a, e + i, n - 5)
                            }, i.constraints = function(t, e) {
                                for (var n = e, i = 0; i < t.length; i++) {
                                    var s = t[i];
                                    if (s.render.visible && s.pointA && s.pointB) {
                                        var o, a, c = s.bodyA,
                                            h = s.bodyB;
                                        if (o = c ? l.add(c.position, s.pointA) : s.pointA, "pin" === s.render.type) n.beginPath(), n.arc(o.x, o.y, 3, 0, 2 * Math.PI), n.closePath();
                                        else {
                                            if (a = h ? l.add(h.position, s.pointB) : s.pointB, n.beginPath(), n.moveTo(o.x, o.y), "spring" === s.render.type)
                                                for (var u, d = l.sub(a, o), p = l.perp(l.normalise(d)), m = Math.ceil(r.clamp(s.length / 5, 12, 20)), f = 1; f < m; f += 1) u = f % 2 == 0 ? 1 : -1, n.lineTo(o.x + d.x * (f / m) + p.x * u * 4, o.y + d.y * (f / m) + p.y * u * 4);
                                            n.lineTo(a.x, a.y)
                                        }
                                        s.render.lineWidth && (n.lineWidth = s.render.lineWidth, n.strokeStyle = s.render.strokeStyle, n.stroke()), s.render.anchors && (n.fillStyle = s.render.strokeStyle, n.beginPath(), n.arc(o.x, o.y, 3, 0, 2 * Math.PI), n.arc(a.x, a.y, 3, 0, 2 * Math.PI), n.closePath(), n.fill())
                                    }
                                }
                            }, i.bodies = function(t, e, n) {
                                var i, r, s, o, a = n,
                                    l = (t.engine, t.options),
                                    c = l.showInternalEdges || !l.wireframes;
                                for (s = 0; s < e.length; s++)
                                    if ((i = e[s]).render.visible)
                                        for (o = i.parts.length > 1 ? 1 : 0; o < i.parts.length; o++)
                                            if ((r = i.parts[o]).render.visible) {
                                                if (l.showSleeping && i.isSleeping ? a.globalAlpha = .5 * r.render.opacity : 1 !== r.render.opacity && (a.globalAlpha = r.render.opacity), r.render.sprite && r.render.sprite.texture && !l.wireframes) {
                                                    var h = r.render.sprite,
                                                        u = p(t, h.texture);
                                                    a.translate(r.position.x, r.position.y), a.rotate(r.angle), a.drawImage(u, u.width * -h.xOffset * h.xScale, u.height * -h.yOffset * h.yScale, u.width * h.xScale, u.height * h.yScale), a.rotate(-r.angle), a.translate(-r.position.x, -r.position.y)
                                                } else {
                                                    if (r.circleRadius) a.beginPath(), a.arc(r.position.x, r.position.y, r.circleRadius, 0, 2 * Math.PI);
                                                    else {
                                                        a.beginPath(), a.moveTo(r.vertices[0].x, r.vertices[0].y);
                                                        for (var d = 1; d < r.vertices.length; d++) !r.vertices[d - 1].isInternal || c ? a.lineTo(r.vertices[d].x, r.vertices[d].y) : a.moveTo(r.vertices[d].x, r.vertices[d].y), r.vertices[d].isInternal && !c && a.moveTo(r.vertices[(d + 1) % r.vertices.length].x, r.vertices[(d + 1) % r.vertices.length].y);
                                                        a.lineTo(r.vertices[0].x, r.vertices[0].y), a.closePath()
                                                    }
                                                    l.wireframes ? (a.lineWidth = 1, a.strokeStyle = "#bbb", a.stroke()) : (a.fillStyle = r.render.fillStyle, r.render.lineWidth && (a.lineWidth = r.render.lineWidth, a.strokeStyle = r.render.strokeStyle, a.stroke()), a.fill())
                                                }
                                                a.globalAlpha = 1
                                            }
                            }, i.bodyWireframes = function(t, e, n) {
                                var i, r, s, o, a, l = n,
                                    c = t.options.showInternalEdges;
                                for (l.beginPath(), s = 0; s < e.length; s++)
                                    if ((i = e[s]).render.visible)
                                        for (a = i.parts.length > 1 ? 1 : 0; a < i.parts.length; a++) {
                                            for (r = i.parts[a], l.moveTo(r.vertices[0].x, r.vertices[0].y), o = 1; o < r.vertices.length; o++) !r.vertices[o - 1].isInternal || c ? l.lineTo(r.vertices[o].x, r.vertices[o].y) : l.moveTo(r.vertices[o].x, r.vertices[o].y), r.vertices[o].isInternal && !c && l.moveTo(r.vertices[(o + 1) % r.vertices.length].x, r.vertices[(o + 1) % r.vertices.length].y);
                                            l.lineTo(r.vertices[0].x, r.vertices[0].y)
                                        }
                                l.lineWidth = 1, l.strokeStyle = "#bbb", l.stroke()
                            }, i.bodyConvexHulls = function(t, e, n) {
                                var i, r, s, o = n;
                                for (o.beginPath(), r = 0; r < e.length; r++)
                                    if ((i = e[r]).render.visible && 1 !== i.parts.length) {
                                        for (o.moveTo(i.vertices[0].x, i.vertices[0].y), s = 1; s < i.vertices.length; s++) o.lineTo(i.vertices[s].x, i.vertices[s].y);
                                        o.lineTo(i.vertices[0].x, i.vertices[0].y)
                                    }
                                o.lineWidth = 1, o.strokeStyle = "rgba(255,255,255,0.2)", o.stroke()
                            }, i.vertexNumbers = function(t, e, n) { var i, r, s, o = n; for (i = 0; i < e.length; i++) { var a = e[i].parts; for (s = a.length > 1 ? 1 : 0; s < a.length; s++) { var l = a[s]; for (r = 0; r < l.vertices.length; r++) o.fillStyle = "rgba(255,255,255,0.2)", o.fillText(i + "_" + r, l.position.x + .8 * (l.vertices[r].x - l.position.x), l.position.y + .8 * (l.vertices[r].y - l.position.y)) } } }, i.mousePosition = function(t, e, n) {
                                var i = n;
                                i.fillStyle = "rgba(255,255,255,0.8)", i.fillText(e.position.x + "  " + e.position.y, e.position.x + 5, e.position.y - 5)
                            }, i.bodyBounds = function(t, e, n) {
                                var i = n,
                                    r = (t.engine, t.options);
                                i.beginPath();
                                for (var s = 0; s < e.length; s++)
                                    if (e[s].render.visible)
                                        for (var o = e[s].parts, a = o.length > 1 ? 1 : 0; a < o.length; a++) {
                                            var l = o[a];
                                            i.rect(l.bounds.min.x, l.bounds.min.y, l.bounds.max.x - l.bounds.min.x, l.bounds.max.y - l.bounds.min.y)
                                        }
                                r.wireframes ? i.strokeStyle = "rgba(255,255,255,0.08)" : i.strokeStyle = "rgba(0,0,0,0.1)", i.lineWidth = 1, i.stroke()
                            }, i.bodyAxes = function(t, e, n) {
                                var i, r, s, o, a = n,
                                    l = (t.engine, t.options);
                                for (a.beginPath(), r = 0; r < e.length; r++) {
                                    var c = e[r],
                                        h = c.parts;
                                    if (c.render.visible)
                                        if (l.showAxes)
                                            for (s = h.length > 1 ? 1 : 0; s < h.length; s++)
                                                for (i = h[s], o = 0; o < i.axes.length; o++) {
                                                    var u = i.axes[o];
                                                    a.moveTo(i.position.x, i.position.y), a.lineTo(i.position.x + 20 * u.x, i.position.y + 20 * u.y)
                                                } else
                                                    for (s = h.length > 1 ? 1 : 0; s < h.length; s++)
                                                        for (i = h[s], o = 0; o < i.axes.length; o++) a.moveTo(i.position.x, i.position.y), a.lineTo((i.vertices[0].x + i.vertices[i.vertices.length - 1].x) / 2, (i.vertices[0].y + i.vertices[i.vertices.length - 1].y) / 2)
                                }
                                l.wireframes ? (a.strokeStyle = "indianred", a.lineWidth = 1) : (a.strokeStyle = "rgba(255, 255, 255, 0.4)", a.globalCompositeOperation = "overlay", a.lineWidth = 2), a.stroke(), a.globalCompositeOperation = "source-over"
                            }, i.bodyPositions = function(t, e, n) {
                                var i, r, s, o, a = n,
                                    l = (t.engine, t.options);
                                for (a.beginPath(), s = 0; s < e.length; s++)
                                    if ((i = e[s]).render.visible)
                                        for (o = 0; o < i.parts.length; o++) r = i.parts[o], a.arc(r.position.x, r.position.y, 3, 0, 2 * Math.PI, !1), a.closePath();
                                for (l.wireframes ? a.fillStyle = "indianred" : a.fillStyle = "rgba(0,0,0,0.5)", a.fill(), a.beginPath(), s = 0; s < e.length; s++)(i = e[s]).render.visible && (a.arc(i.positionPrev.x, i.positionPrev.y, 2, 0, 2 * Math.PI, !1), a.closePath());
                                a.fillStyle = "rgba(255,165,0,0.8)", a.fill()
                            }, i.bodyVelocity = function(t, e, n) {
                                var i = n;
                                i.beginPath();
                                for (var r = 0; r < e.length; r++) {
                                    var s = e[r];
                                    s.render.visible && (i.moveTo(s.position.x, s.position.y), i.lineTo(s.position.x + 2 * (s.position.x - s.positionPrev.x), s.position.y + 2 * (s.position.y - s.positionPrev.y)))
                                }
                                i.lineWidth = 3, i.strokeStyle = "cornflowerblue", i.stroke()
                            }, i.bodyIds = function(t, e, n) {
                                var i, r, s = n;
                                for (i = 0; i < e.length; i++)
                                    if (e[i].render.visible) {
                                        var o = e[i].parts;
                                        for (r = o.length > 1 ? 1 : 0; r < o.length; r++) {
                                            var a = o[r];
                                            s.font = "12px Arial", s.fillStyle = "rgba(255,255,255,0.5)", s.fillText(a.id, a.position.x + 10, a.position.y - 10)
                                        }
                                    }
                            }, i.collisions = function(t, e, n) {
                                var i, r, s, o, a = n,
                                    l = t.options;
                                for (a.beginPath(), s = 0; s < e.length; s++)
                                    if ((i = e[s]).isActive)
                                        for (r = i.collision, o = 0; o < i.activeContacts.length; o++) {
                                            var c = i.activeContacts[o].vertex;
                                            a.rect(c.x - 1.5, c.y - 1.5, 3.5, 3.5)
                                        }
                                for (l.wireframes ? a.fillStyle = "rgba(255,255,255,0.7)" : a.fillStyle = "orange", a.fill(), a.beginPath(), s = 0; s < e.length; s++)
                                    if ((i = e[s]).isActive && (r = i.collision, i.activeContacts.length > 0)) {
                                        var h = i.activeContacts[0].vertex.x,
                                            u = i.activeContacts[0].vertex.y;
                                        2 === i.activeContacts.length && (h = (i.activeContacts[0].vertex.x + i.activeContacts[1].vertex.x) / 2, u = (i.activeContacts[0].vertex.y + i.activeContacts[1].vertex.y) / 2), r.bodyB === r.supports[0].body || !0 === r.bodyA.isStatic ? a.moveTo(h - 8 * r.normal.x, u - 8 * r.normal.y) : a.moveTo(h + 8 * r.normal.x, u + 8 * r.normal.y), a.lineTo(h, u)
                                    }
                                l.wireframes ? a.strokeStyle = "rgba(255,165,0,0.7)" : a.strokeStyle = "orange", a.lineWidth = 1, a.stroke()
                            }, i.separations = function(t, e, n) {
                                var i, r, s, o, a, l = n,
                                    c = t.options;
                                for (l.beginPath(), a = 0; a < e.length; a++)
                                    if ((i = e[a]).isActive) {
                                        s = (r = i.collision).bodyA;
                                        var h = 1;
                                        (o = r.bodyB).isStatic || s.isStatic || (h = .5), o.isStatic && (h = 0), l.moveTo(o.position.x, o.position.y), l.lineTo(o.position.x - r.penetration.x * h, o.position.y - r.penetration.y * h), h = 1, o.isStatic || s.isStatic || (h = .5), s.isStatic && (h = 0), l.moveTo(s.position.x, s.position.y), l.lineTo(s.position.x + r.penetration.x * h, s.position.y + r.penetration.y * h)
                                    }
                                c.wireframes ? l.strokeStyle = "rgba(255,165,0,0.5)" : l.strokeStyle = "orange", l.stroke()
                            }, i.grid = function(t, e, n) {
                                var i = n;
                                t.options.wireframes ? i.strokeStyle = "rgba(255,180,0,0.1)" : i.strokeStyle = "rgba(255,180,0,0.5)", i.beginPath();
                                for (var s = r.keys(e.buckets), o = 0; o < s.length; o++) {
                                    var a = s[o];
                                    if (!(e.buckets[a].length < 2)) {
                                        var l = a.split(/C|R/);
                                        i.rect(.5 + parseInt(l[1], 10) * e.bucketWidth, .5 + parseInt(l[2], 10) * e.bucketHeight, e.bucketWidth, e.bucketHeight)
                                    }
                                }
                                i.lineWidth = 1, i.stroke()
                            }, i.inspector = function(t, e) {
                                t.engine;
                                var n, i = t.selected,
                                    r = t.render,
                                    s = r.options;
                                if (s.hasBounds) {
                                    var o = r.bounds.max.x - r.bounds.min.x,
                                        a = r.bounds.max.y - r.bounds.min.y,
                                        l = o / r.options.width,
                                        c = a / r.options.height;
                                    e.scale(1 / l, 1 / c), e.translate(-r.bounds.min.x, -r.bounds.min.y)
                                }
                                for (var h = 0; h < i.length; h++) {
                                    var u = i[h].data;
                                    switch (e.translate(.5, .5), e.lineWidth = 1, e.strokeStyle = "rgba(255,165,0,0.9)", e.setLineDash([1, 2]), u.type) {
                                        case "body":
                                            n = u.bounds, e.beginPath(), e.rect(Math.floor(n.min.x - 3), Math.floor(n.min.y - 3), Math.floor(n.max.x - n.min.x + 6), Math.floor(n.max.y - n.min.y + 6)), e.closePath(), e.stroke();
                                            break;
                                        case "constraint":
                                            var d = u.pointA;
                                            u.bodyA && (d = u.pointB), e.beginPath(), e.arc(d.x, d.y, 10, 0, 2 * Math.PI), e.closePath(), e.stroke()
                                    }
                                    e.setLineDash([]), e.translate(-.5, -.5)
                                }
                                null !== t.selectStart && (e.translate(.5, .5), e.lineWidth = 1, e.strokeStyle = "rgba(255,165,0,0.6)", e.fillStyle = "rgba(255,165,0,0.1)", n = t.selectBounds, e.beginPath(), e.rect(Math.floor(n.min.x), Math.floor(n.min.y), Math.floor(n.max.x - n.min.x), Math.floor(n.max.y - n.min.y)), e.closePath(), e.stroke(), e.fill(), e.translate(-.5, -.5)), s.hasBounds && e.setTransform(1, 0, 0, 1, 0, 0)
                            };
                            var n = function(t, e) {
                                    var n = t.engine,
                                        r = t.timing,
                                        s = r.historySize,
                                        o = n.timing.timestamp;
                                    r.delta = e - r.lastTime || i._goodDelta, r.lastTime = e, r.timestampElapsed = o - r.lastTimestamp || 0, r.lastTimestamp = o, r.deltaHistory.unshift(r.delta), r.deltaHistory.length = Math.min(r.deltaHistory.length, s), r.engineDeltaHistory.unshift(n.timing.lastDelta), r.engineDeltaHistory.length = Math.min(r.engineDeltaHistory.length, s), r.timestampElapsedHistory.unshift(r.timestampElapsed), r.timestampElapsedHistory.length = Math.min(r.timestampElapsedHistory.length, s), r.engineElapsedHistory.unshift(n.timing.lastElapsed), r.engineElapsedHistory.length = Math.min(r.engineElapsedHistory.length, s), r.elapsedHistory.unshift(r.lastElapsed), r.elapsedHistory.length = Math.min(r.elapsedHistory.length, s)
                                },
                                h = function(t) { for (var e = 0, n = 0; n < t.length; n += 1) e += t[n]; return e / t.length || 0 },
                                u = function(t, e) { var n = document.createElement("canvas"); return n.width = t, n.height = e, n.oncontextmenu = function() { return !1 }, n.onselectstart = function() { return !1 }, n },
                                d = function(t) { var e = t.getContext("2d"); return (window.devicePixelRatio || 1) / (e.webkitBackingStorePixelRatio || e.mozBackingStorePixelRatio || e.msBackingStorePixelRatio || e.oBackingStorePixelRatio || e.backingStorePixelRatio || 1) },
                                p = function(t, e) { var n = t.textures[e]; return n || ((n = t.textures[e] = new Image).src = e, n) },
                                m = function(t, e) { var n = e; /(jpg|gif|png)$/.test(e) && (n = "url(" + e + ")"), t.canvas.style.background = n, t.canvas.style.backgroundSize = "contain", t.currentBackground = e }
                        }()
                    }, function(t, e) {
                        var n = {};
                        t.exports = n, n.create = function(t) { return { id: n.id(t), vertex: t, normalImpulse: 0, tangentImpulse: 0 } }, n.id = function(t) { return t.body.id + "_" + t.index }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(7),
                            s = n(19),
                            o = n(13),
                            a = n(20),
                            l = n(21),
                            c = n(4),
                            h = n(5),
                            u = n(8),
                            d = n(0),
                            p = n(6);
                        i.create = function(t) { t = t || {}; var e = d.extend({ positionIterations: 6, velocityIterations: 4, constraintIterations: 2, enableSleeping: !1, events: [], plugin: {}, grid: null, gravity: { x: 0, y: 1, scale: .001 }, timing: { timestamp: 0, timeScale: 1, lastDelta: 0, lastElapsed: 0 } }, t); return e.world = t.world || h.create({ label: "World" }), e.grid = l.create(t.grid || t.broadphase), e.pairs = a.create(), e.world.gravity = e.gravity, e.broadphase = e.grid, e.metrics = {}, e }, i.update = function(t, e, n) {
                            var p = d.now();
                            e = e || 1e3 / 60, n = n || 1;
                            var m, f, g = t.world,
                                v = t.timing,
                                y = t.grid;
                            v.timestamp += e * v.timeScale, v.lastDelta = e * v.timeScale;
                            var x = { timestamp: v.timestamp };
                            c.trigger(t, "beforeUpdate", x);
                            var _ = h.allBodies(g),
                                b = h.allConstraints(g);
                            for (t.enableSleeping && r.update(_, v.timeScale), i._bodiesApplyGravity(_, t.gravity), i._bodiesUpdate(_, e, v.timeScale, n, g.bounds), u.preSolveAll(_), f = 0; f < t.constraintIterations; f++) u.solveAll(b, v.timeScale);
                            u.postSolveAll(_), g.isModified && l.clear(y), l.update(y, _, t, g.isModified), m = y.pairsList, g.isModified && h.setModified(g, !1, !1, !0);
                            var w = o.collisions(m, t),
                                M = t.pairs,
                                S = v.timestamp;
                            for (a.update(M, w, S), a.removeOld(M, S), t.enableSleeping && r.afterCollisions(M.list, v.timeScale), M.collisionStart.length > 0 && c.trigger(t, "collisionStart", { pairs: M.collisionStart }), s.preSolvePosition(M.list), f = 0; f < t.positionIterations; f++) s.solvePosition(M.list, v.timeScale);
                            for (s.postSolvePosition(_), u.preSolveAll(_), f = 0; f < t.constraintIterations; f++) u.solveAll(b, v.timeScale);
                            for (u.postSolveAll(_), s.preSolveVelocity(M.list), f = 0; f < t.velocityIterations; f++) s.solveVelocity(M.list, v.timeScale);
                            return M.collisionActive.length > 0 && c.trigger(t, "collisionActive", { pairs: M.collisionActive }), M.collisionEnd.length > 0 && c.trigger(t, "collisionEnd", { pairs: M.collisionEnd }), i._bodiesClearForces(_), c.trigger(t, "afterUpdate", x), t.timing.lastElapsed = d.now() - p, t
                        }, i.merge = function(t, e) {
                            if (d.extend(t, e), e.world) {
                                t.world = e.world, i.clear(t);
                                for (var n = h.allBodies(t.world), s = 0; s < n.length; s++) {
                                    var o = n[s];
                                    r.set(o, !1), o.id = d.nextId()
                                }
                            }
                        }, i.clear = function(t) {
                            var e = t.world,
                                n = h.allBodies(e);
                            a.clear(t.pairs), l.clear(t.grid), l.update(t.grid, n, t, !0)
                        }, i._bodiesClearForces = function(t) {
                            for (var e = 0; e < t.length; e++) {
                                var n = t[e];
                                n.force.x = 0, n.force.y = 0, n.torque = 0
                            }
                        }, i._bodiesApplyGravity = function(t, e) {
                            var n = void 0 !== e.scale ? e.scale : .001;
                            if ((0 !== e.x || 0 !== e.y) && 0 !== n)
                                for (var i = 0; i < t.length; i++) {
                                    var r = t[i];
                                    r.isStatic || r.isSleeping || (r.force.y += r.mass * e.y * n, r.force.x += r.mass * e.x * n)
                                }
                        }, i._bodiesUpdate = function(t, e, n, i, r) {
                            for (var s = 0; s < t.length; s++) {
                                var o = t[s];
                                o.isStatic || o.isSleeping || p.update(o, e, n, i)
                            }
                        }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(3),
                            s = n(2),
                            o = n(0),
                            a = n(1);
                        i._restingThresh = 4, i._restingThreshTangent = 6, i._positionDampen = .9, i._positionWarming = .8, i._frictionNormalMultiplier = 5, i.preSolvePosition = function(t) { var e, n, i; for (e = 0; e < t.length; e++)(n = t[e]).isActive && (i = n.activeContacts.length, n.collision.parentA.totalContacts += i, n.collision.parentB.totalContacts += i) }, i.solvePosition = function(t, e) {
                            var n, r, o, a, l, c, h, u, d, p = s._temp[0],
                                m = s._temp[1],
                                f = s._temp[2],
                                g = s._temp[3];
                            for (n = 0; n < t.length; n++)(r = t[n]).isActive && !r.isSensor && (a = (o = r.collision).parentA, l = o.parentB, c = o.normal, h = s.sub(s.add(l.positionImpulse, l.position, p), s.add(a.positionImpulse, s.sub(l.position, o.penetration, m), f), g), r.separation = s.dot(c, h));
                            for (n = 0; n < t.length; n++)(r = t[n]).isActive && !r.isSensor && (a = (o = r.collision).parentA, l = o.parentB, c = o.normal, d = (r.separation - r.slop) * e, (a.isStatic || l.isStatic) && (d *= 2), a.isStatic || a.isSleeping || (u = i._positionDampen / a.totalContacts, a.positionImpulse.x += c.x * d * u, a.positionImpulse.y += c.y * d * u), l.isStatic || l.isSleeping || (u = i._positionDampen / l.totalContacts, l.positionImpulse.x -= c.x * d * u, l.positionImpulse.y -= c.y * d * u))
                        }, i.postSolvePosition = function(t) {
                            for (var e = 0; e < t.length; e++) {
                                var n = t[e];
                                if (n.totalContacts = 0, 0 !== n.positionImpulse.x || 0 !== n.positionImpulse.y) {
                                    for (var o = 0; o < n.parts.length; o++) {
                                        var l = n.parts[o];
                                        r.translate(l.vertices, n.positionImpulse), a.update(l.bounds, l.vertices, n.velocity), l.position.x += n.positionImpulse.x, l.position.y += n.positionImpulse.y
                                    }
                                    n.positionPrev.x += n.positionImpulse.x, n.positionPrev.y += n.positionImpulse.y, s.dot(n.positionImpulse, n.velocity) < 0 ? (n.positionImpulse.x = 0, n.positionImpulse.y = 0) : (n.positionImpulse.x *= i._positionWarming, n.positionImpulse.y *= i._positionWarming)
                                }
                            }
                        }, i.preSolveVelocity = function(t) {
                            var e, n, i, r, o, a, l, c, h, u, d, p, m, f, g = s._temp[0],
                                v = s._temp[1];
                            for (e = 0; e < t.length; e++)
                                if ((i = t[e]).isActive && !i.isSensor)
                                    for (r = i.activeContacts, a = (o = i.collision).parentA, l = o.parentB, c = o.normal, h = o.tangent, n = 0; n < r.length; n++) d = (u = r[n]).vertex, p = u.normalImpulse, m = u.tangentImpulse, 0 === p && 0 === m || (g.x = c.x * p + h.x * m, g.y = c.y * p + h.y * m, a.isStatic || a.isSleeping || (f = s.sub(d, a.position, v), a.positionPrev.x += g.x * a.inverseMass, a.positionPrev.y += g.y * a.inverseMass, a.anglePrev += s.cross(f, g) * a.inverseInertia), l.isStatic || l.isSleeping || (f = s.sub(d, l.position, v), l.positionPrev.x -= g.x * l.inverseMass, l.positionPrev.y -= g.y * l.inverseMass, l.anglePrev -= s.cross(f, g) * l.inverseInertia))
                        }, i.solveVelocity = function(t, e) {
                            for (var n = e * e, r = s._temp[0], a = s._temp[1], l = s._temp[2], c = s._temp[3], h = s._temp[4], u = s._temp[5], d = 0; d < t.length; d++) {
                                var p = t[d];
                                if (p.isActive && !p.isSensor) {
                                    var m = p.collision,
                                        f = m.parentA,
                                        g = m.parentB,
                                        v = m.normal,
                                        y = m.tangent,
                                        x = p.activeContacts,
                                        _ = 1 / x.length;
                                    f.velocity.x = f.position.x - f.positionPrev.x, f.velocity.y = f.position.y - f.positionPrev.y, g.velocity.x = g.position.x - g.positionPrev.x, g.velocity.y = g.position.y - g.positionPrev.y, f.angularVelocity = f.angle - f.anglePrev, g.angularVelocity = g.angle - g.anglePrev;
                                    for (var b = 0; b < x.length; b++) {
                                        var w = x[b],
                                            M = w.vertex,
                                            S = s.sub(M, f.position, a),
                                            T = s.sub(M, g.position, l),
                                            E = s.add(f.velocity, s.mult(s.perp(S), f.angularVelocity), c),
                                            A = s.add(g.velocity, s.mult(s.perp(T), g.angularVelocity), h),
                                            L = s.sub(E, A, u),
                                            R = s.dot(v, L),
                                            C = s.dot(y, L),
                                            P = Math.abs(C),
                                            I = o.sign(C),
                                            D = (1 + p.restitution) * R,
                                            N = o.clamp(p.separation + R, 0, 1) * i._frictionNormalMultiplier,
                                            B = C,
                                            O = 1 / 0;
                                        P > p.friction * p.frictionStatic * N * n && (O = P, B = o.clamp(p.friction * I * n, -O, O));
                                        var F = s.cross(S, v),
                                            z = s.cross(T, v),
                                            U = _ / (f.inverseMass + g.inverseMass + f.inverseInertia * F * F + g.inverseInertia * z * z);
                                        if (D *= U, B *= U, R < 0 && R * R > i._restingThresh * n) w.normalImpulse = 0;
                                        else {
                                            var H = w.normalImpulse;
                                            w.normalImpulse = Math.min(w.normalImpulse + D, 0), D = w.normalImpulse - H
                                        }
                                        if (C * C > i._restingThreshTangent * n) w.tangentImpulse = 0;
                                        else {
                                            var k = w.tangentImpulse;
                                            w.tangentImpulse = o.clamp(w.tangentImpulse + B, -O, O), B = w.tangentImpulse - k
                                        }
                                        r.x = v.x * D + y.x * B, r.y = v.y * D + y.y * B, f.isStatic || f.isSleeping || (f.positionPrev.x += r.x * f.inverseMass, f.positionPrev.y += r.y * f.inverseMass, f.anglePrev += s.cross(S, r) * f.inverseInertia), g.isStatic || g.isSleeping || (g.positionPrev.x -= r.x * g.inverseMass, g.positionPrev.y -= r.y * g.inverseMass, g.anglePrev -= s.cross(T, r) * g.inverseInertia)
                                    }
                                }
                            }
                        }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(9),
                            s = n(0);
                        i._pairMaxIdleLife = 1e3, i.create = function(t) { return s.extend({ table: {}, list: [], collisionStart: [], collisionActive: [], collisionEnd: [] }, t) }, i.update = function(t, e, n) {
                            var i, s, o, a, l = t.list,
                                c = t.table,
                                h = t.collisionStart,
                                u = t.collisionEnd,
                                d = t.collisionActive;
                            for (h.length = 0, u.length = 0, d.length = 0, a = 0; a < l.length; a++) l[a].confirmedActive = !1;
                            for (a = 0; a < e.length; a++)(i = e[a]).collided && ((o = c[s = r.id(i.bodyA, i.bodyB)]) ? (o.isActive ? d.push(o) : h.push(o), r.update(o, i, n), o.confirmedActive = !0) : (o = r.create(i, n), c[s] = o, h.push(o), l.push(o)));
                            for (a = 0; a < l.length; a++)(o = l[a]).isActive && !o.confirmedActive && (r.setActive(o, !1, n), u.push(o))
                        }, i.removeOld = function(t, e) {
                            var n, r, s, o, a = t.list,
                                l = t.table,
                                c = [];
                            for (o = 0; o < a.length; o++)(r = (n = a[o]).collision).bodyA.isSleeping || r.bodyB.isSleeping ? n.timeUpdated = e : e - n.timeUpdated > i._pairMaxIdleLife && c.push(o);
                            for (o = 0; o < c.length; o++) delete l[(n = a[s = c[o] - o]).id], a.splice(s, 1)
                        }, i.clear = function(t) { return t.table = {}, t.list.length = 0, t.collisionStart.length = 0, t.collisionActive.length = 0, t.collisionEnd.length = 0, t }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(9),
                            s = n(0);
                        i.create = function(t) { return s.extend({ buckets: {}, pairs: {}, pairsList: [], bucketWidth: 48, bucketHeight: 48 }, t) }, i.update = function(t, e, n, r) {
                            var s, o, a, l, c, h = n.world,
                                u = t.buckets,
                                d = !1;
                            for (s = 0; s < e.length; s++) {
                                var p = e[s];
                                if ((!p.isSleeping || r) && (!h.bounds || !(p.bounds.max.x < h.bounds.min.x || p.bounds.min.x > h.bounds.max.x || p.bounds.max.y < h.bounds.min.y || p.bounds.min.y > h.bounds.max.y))) {
                                    var m = i._getRegion(t, p);
                                    if (!p.region || m.id !== p.region.id || r) {
                                        p.region && !r || (p.region = m);
                                        var f = i._regionUnion(m, p.region);
                                        for (o = f.startCol; o <= f.endCol; o++)
                                            for (a = f.startRow; a <= f.endRow; a++) {
                                                l = u[c = i._getBucketId(o, a)];
                                                var g = o >= m.startCol && o <= m.endCol && a >= m.startRow && a <= m.endRow,
                                                    v = o >= p.region.startCol && o <= p.region.endCol && a >= p.region.startRow && a <= p.region.endRow;
                                                !g && v && v && l && i._bucketRemoveBody(t, l, p), (p.region === m || g && !v || r) && (l || (l = i._createBucket(u, c)), i._bucketAddBody(t, l, p))
                                            }
                                        p.region = m, d = !0
                                    }
                                }
                            }
                            d && (t.pairsList = i._createActivePairsList(t))
                        }, i.clear = function(t) { t.buckets = {}, t.pairs = {}, t.pairsList = [] }, i._regionUnion = function(t, e) {
                            var n = Math.min(t.startCol, e.startCol),
                                r = Math.max(t.endCol, e.endCol),
                                s = Math.min(t.startRow, e.startRow),
                                o = Math.max(t.endRow, e.endRow);
                            return i._createRegion(n, r, s, o)
                        }, i._getRegion = function(t, e) {
                            var n = e.bounds,
                                r = Math.floor(n.min.x / t.bucketWidth),
                                s = Math.floor(n.max.x / t.bucketWidth),
                                o = Math.floor(n.min.y / t.bucketHeight),
                                a = Math.floor(n.max.y / t.bucketHeight);
                            return i._createRegion(r, s, o, a)
                        }, i._createRegion = function(t, e, n, i) { return { id: t + "," + e + "," + n + "," + i, startCol: t, endCol: e, startRow: n, endRow: i } }, i._getBucketId = function(t, e) { return "C" + t + "R" + e }, i._createBucket = function(t, e) { return t[e] = [] }, i._bucketAddBody = function(t, e, n) {
                            for (var i = 0; i < e.length; i++) {
                                var s = e[i];
                                if (!(n.id === s.id || n.isStatic && s.isStatic)) {
                                    var o = r.id(n, s),
                                        a = t.pairs[o];
                                    a ? a[2] += 1 : t.pairs[o] = [n, s, 1]
                                }
                            }
                            e.push(n)
                        }, i._bucketRemoveBody = function(t, e, n) {
                            e.splice(s.indexOf(e, n), 1);
                            for (var i = 0; i < e.length; i++) {
                                var o = e[i],
                                    a = r.id(n, o),
                                    l = t.pairs[a];
                                l && (l[2] -= 1)
                            }
                        }, i._createActivePairsList = function(t) {
                            var e, n, i = [];
                            e = s.keys(t.pairs);
                            for (var r = 0; r < e.length; r++)(n = t.pairs[e[r]])[2] > 0 ? i.push(n) : delete t.pairs[e[r]];
                            return i
                        }
                    }, function(t, e, n) {
                        var i = t.exports = n(23);
                        i.Axes = n(10), i.Bodies = n(11), i.Body = n(6), i.Bounds = n(1), i.Common = n(0), i.Composite = n(5), i.Composites = n(24), i.Constraint = n(8), i.Contact = n(17), i.Detector = n(13), i.Engine = n(18), i.Events = n(4), i.Grid = n(21), i.Mouse = n(12), i.MouseConstraint = n(25), i.Pair = n(9), i.Pairs = n(20), i.Plugin = n(15), i.Query = n(26), i.Render = n(16), i.Resolver = n(19), i.Runner = n(27), i.SAT = n(14), i.Sleeping = n(7), i.Svg = n(28), i.Vector = n(2), i.Vertices = n(3), i.World = n(29), i.Engine.run = i.Runner.run, i.Common.deprecated(i.Engine, "run", "Engine.run ➤ use Matter.Runner.run(engine) instead")
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(15),
                            s = n(0);
                        i.name = "matter-js", i.version = "0.17.1", i.uses = [], i.used = [], i.use = function() { r.use(i, Array.prototype.slice.call(arguments)) }, i.before = function(t, e) { return t = t.replace(/^Matter./, ""), s.chainPathBefore(i, t, e) }, i.after = function(t, e) { return t = t.replace(/^Matter./, ""), s.chainPathAfter(i, t, e) }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(5),
                            s = n(8),
                            o = n(0),
                            a = n(6),
                            l = n(11),
                            c = o.deprecated;
                        i.stack = function(t, e, n, i, s, o, l) {
                            for (var c, h = r.create({ label: "Stack" }), u = t, d = e, p = 0, m = 0; m < i; m++) {
                                for (var f = 0, g = 0; g < n; g++) {
                                    var v = l(u, d, g, m, c, p);
                                    if (v) {
                                        var y = v.bounds.max.y - v.bounds.min.y,
                                            x = v.bounds.max.x - v.bounds.min.x;
                                        y > f && (f = y), a.translate(v, { x: .5 * x, y: .5 * y }), u = v.bounds.max.x + s, r.addBody(h, v), c = v, p += 1
                                    } else u += s
                                }
                                d += f + o, u = t
                            }
                            return h
                        }, i.chain = function(t, e, n, i, a, l) {
                            for (var c = t.bodies, h = 1; h < c.length; h++) {
                                var u = c[h - 1],
                                    d = c[h],
                                    p = u.bounds.max.y - u.bounds.min.y,
                                    m = u.bounds.max.x - u.bounds.min.x,
                                    f = d.bounds.max.y - d.bounds.min.y,
                                    g = { bodyA: u, pointA: { x: m * e, y: p * n }, bodyB: d, pointB: { x: (d.bounds.max.x - d.bounds.min.x) * i, y: f * a } },
                                    v = o.extend(g, l);
                                r.addConstraint(t, s.create(v))
                            }
                            return t.label += " Chain", t
                        }, i.mesh = function(t, e, n, i, a) {
                            var l, c, h, u, d, p = t.bodies;
                            for (l = 0; l < n; l++) {
                                for (c = 1; c < e; c++) h = p[c - 1 + l * e], u = p[c + l * e], r.addConstraint(t, s.create(o.extend({ bodyA: h, bodyB: u }, a)));
                                if (l > 0)
                                    for (c = 0; c < e; c++) h = p[c + (l - 1) * e], u = p[c + l * e], r.addConstraint(t, s.create(o.extend({ bodyA: h, bodyB: u }, a))), i && c > 0 && (d = p[c - 1 + (l - 1) * e], r.addConstraint(t, s.create(o.extend({ bodyA: d, bodyB: u }, a)))), i && c < e - 1 && (d = p[c + 1 + (l - 1) * e], r.addConstraint(t, s.create(o.extend({ bodyA: d, bodyB: u }, a))))
                            }
                            return t.label += " Mesh", t
                        }, i.pyramid = function(t, e, n, r, s, o, l) {
                            return i.stack(t, e, n, r, s, o, (function(e, i, o, c, h, u) {
                                var d = Math.min(r, Math.ceil(n / 2)),
                                    p = h ? h.bounds.max.x - h.bounds.min.x : 0;
                                if (!(c > d || o < (c = d - c) || o > n - 1 - c)) return 1 === u && a.translate(h, { x: (o + (n % 2 == 1 ? 1 : -1)) * p, y: 0 }), l(t + (h ? o * p : 0) + o * s, i, o, c, h, u)
                            }))
                        }, i.newtonsCradle = function(t, e, n, i, o) {
                            for (var a = r.create({ label: "Newtons Cradle" }), c = 0; c < n; c++) {
                                var h = l.circle(t + c * (1.9 * i), e + o, i, { inertia: 1 / 0, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1 }),
                                    u = s.create({ pointA: { x: t + c * (1.9 * i), y: e }, bodyB: h });
                                r.addBody(a, h), r.addConstraint(a, u)
                            }
                            return a
                        }, c(i, "newtonsCradle", "Composites.newtonsCradle ➤ moved to newtonsCradle example"), i.car = function(t, e, n, i, o) {
                            var c = a.nextGroup(!0),
                                h = .5 * -n + 20,
                                u = .5 * n - 20,
                                d = r.create({ label: "Car" }),
                                p = l.rectangle(t, e, n, i, { collisionFilter: { group: c }, chamfer: { radius: .5 * i }, density: 2e-4 }),
                                m = l.circle(t + h, e + 0, o, { collisionFilter: { group: c }, friction: .8 }),
                                f = l.circle(t + u, e + 0, o, { collisionFilter: { group: c }, friction: .8 }),
                                g = s.create({ bodyB: p, pointB: { x: h, y: 0 }, bodyA: m, stiffness: 1, length: 0 }),
                                v = s.create({ bodyB: p, pointB: { x: u, y: 0 }, bodyA: f, stiffness: 1, length: 0 });
                            return r.addBody(d, p), r.addBody(d, m), r.addBody(d, f), r.addConstraint(d, g), r.addConstraint(d, v), d
                        }, c(i, "car", "Composites.car ➤ moved to car example"), i.softBody = function(t, e, n, r, s, a, c, h, u, d) { u = o.extend({ inertia: 1 / 0 }, u), d = o.extend({ stiffness: .2, render: { type: "line", anchors: !1 } }, d); var p = i.stack(t, e, n, r, s, a, (function(t, e) { return l.circle(t, e, h, u) })); return i.mesh(p, n, r, c, d), p.label = "Soft Body", p }, c(i, "softBody", "Composites.softBody ➤ moved to softBody and cloth examples")
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(3),
                            s = n(7),
                            o = n(12),
                            a = n(4),
                            l = n(13),
                            c = n(8),
                            h = n(5),
                            u = n(0),
                            d = n(1);
                        i.create = function(t, e) {
                            var n = (t ? t.mouse : null) || (e ? e.mouse : null);
                            n || (t && t.render && t.render.canvas ? n = o.create(t.render.canvas) : e && e.element ? n = o.create(e.element) : (n = o.create(), u.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected")));
                            var r = { type: "mouseConstraint", mouse: n, element: null, body: null, constraint: c.create({ label: "Mouse Constraint", pointA: n.position, pointB: { x: 0, y: 0 }, length: .01, stiffness: .1, angularStiffness: 1, render: { strokeStyle: "#90EE90", lineWidth: 3 } }), collisionFilter: { category: 1, mask: 4294967295, group: 0 } },
                                s = u.extend(r, e);
                            return a.on(t, "beforeUpdate", (function() {
                                var e = h.allBodies(t.world);
                                i.update(s, e), i._triggerEvents(s)
                            })), s
                        }, i.update = function(t, e) {
                            var n = t.mouse,
                                i = t.constraint,
                                o = t.body;
                            if (0 === n.button) {
                                if (i.bodyB) s.set(i.bodyB, !1), i.pointA = n.position;
                                else
                                    for (var c = 0; c < e.length; c++)
                                        if (o = e[c], d.contains(o.bounds, n.position) && l.canCollide(o.collisionFilter, t.collisionFilter))
                                            for (var h = o.parts.length > 1 ? 1 : 0; h < o.parts.length; h++) { var u = o.parts[h]; if (r.contains(u.vertices, n.position)) { i.pointA = n.position, i.bodyB = t.body = o, i.pointB = { x: n.position.x - o.position.x, y: n.position.y - o.position.y }, i.angleB = o.angle, s.set(o, !1), a.trigger(t, "startdrag", { mouse: n, body: o }); break } }
                            } else i.bodyB = t.body = null, i.pointB = null, o && a.trigger(t, "enddrag", { mouse: n, body: o })
                        }, i._triggerEvents = function(t) {
                            var e = t.mouse,
                                n = e.sourceEvents;
                            n.mousemove && a.trigger(t, "mousemove", { mouse: e }), n.mousedown && a.trigger(t, "mousedown", { mouse: e }), n.mouseup && a.trigger(t, "mouseup", { mouse: e }), o.clearSourceEvents(e)
                        }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(2),
                            s = n(14),
                            o = n(1),
                            a = n(11),
                            l = n(3);
                        i.collides = function(t, e) {
                            for (var n = [], i = 0; i < e.length; i++) {
                                var r = e[i];
                                if (o.overlaps(r.bounds, t.bounds))
                                    for (var a = 1 === r.parts.length ? 0 : 1; a < r.parts.length; a++) { var l = r.parts[a]; if (o.overlaps(l.bounds, t.bounds)) { var c = s.collides(l, t); if (c.collided) { n.push(c); break } } }
                            }
                            return n
                        }, i.ray = function(t, e, n, s) {
                            s = s || 1e-100;
                            for (var o = r.angle(e, n), l = r.magnitude(r.sub(e, n)), c = .5 * (n.x + e.x), h = .5 * (n.y + e.y), u = a.rectangle(c, h, l, s, { angle: o }), d = i.collides(u, t), p = 0; p < d.length; p += 1) {
                                var m = d[p];
                                m.body = m.bodyB = m.bodyA
                            }
                            return d
                        }, i.region = function(t, e, n) {
                            for (var i = [], r = 0; r < t.length; r++) {
                                var s = t[r],
                                    a = o.overlaps(s.bounds, e);
                                (a && !n || !a && n) && i.push(s)
                            }
                            return i
                        }, i.point = function(t, e) {
                            for (var n = [], i = 0; i < t.length; i++) {
                                var r = t[i];
                                if (o.contains(r.bounds, e))
                                    for (var s = 1 === r.parts.length ? 0 : 1; s < r.parts.length; s++) { var a = r.parts[s]; if (o.contains(a.bounds, e) && l.contains(a.vertices, e)) { n.push(r); break } }
                            }
                            return n
                        }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r, s, o, a = n(4),
                            l = n(18),
                            c = n(0);
                        "undefined" != typeof window && (r = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame, s = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), r || (r = function(t) { o = setTimeout((function() { t(c.now()) }), 1e3 / 60) }, s = function() { clearTimeout(o) }), i.create = function(t) { var e = c.extend({ fps: 60, correction: 1, deltaSampleSize: 60, counterTimestamp: 0, frameCounter: 0, deltaHistory: [], timePrev: null, timeScalePrev: 1, frameRequestId: null, isFixed: !1, enabled: !0 }, t); return e.delta = e.delta || 1e3 / e.fps, e.deltaMin = e.deltaMin || 1e3 / e.fps, e.deltaMax = e.deltaMax || 1e3 / (.5 * e.fps), e.fps = 1e3 / e.delta, e }, i.run = function(t, e) {
                            return void 0 !== t.positionIterations && (e = t, t = i.create()),
                                function n(s) { t.frameRequestId = r(n), s && t.enabled && i.tick(t, e, s) }(), t
                        }, i.tick = function(t, e, n) {
                            var i, r = e.timing,
                                s = 1,
                                o = { timestamp: r.timestamp };
                            a.trigger(t, "beforeTick", o), t.isFixed ? i = t.delta : (i = n - t.timePrev || t.delta, t.timePrev = n, t.deltaHistory.push(i), t.deltaHistory = t.deltaHistory.slice(-t.deltaSampleSize), s = (i = (i = (i = Math.min.apply(null, t.deltaHistory)) < t.deltaMin ? t.deltaMin : i) > t.deltaMax ? t.deltaMax : i) / t.delta, t.delta = i), 0 !== t.timeScalePrev && (s *= r.timeScale / t.timeScalePrev), 0 === r.timeScale && (s = 0), t.timeScalePrev = r.timeScale, t.correction = s, t.frameCounter += 1, n - t.counterTimestamp >= 1e3 && (t.fps = t.frameCounter * ((n - t.counterTimestamp) / 1e3), t.counterTimestamp = n, t.frameCounter = 0), a.trigger(t, "tick", o), a.trigger(t, "beforeUpdate", o), l.update(e, i, s), a.trigger(t, "afterUpdate", o), a.trigger(t, "afterTick", o)
                        }, i.stop = function(t) { s(t.frameRequestId) }, i.start = function(t, e) { i.run(t, e) }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i, n(1);
                        var r = n(0);
                        i.pathToVertices = function(t, e) {
                            "undefined" == typeof window || "SVGPathSeg" in window || r.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
                            var n, s, o, a, l, c, h, u, d, p, m, f = [],
                                g = 0,
                                v = 0,
                                y = 0;
                            e = e || 15;
                            var x = function(t, e, n) { var i = n % 2 == 1 && n > 1; if (!d || t != d.x || e != d.y) { d && i ? (p = d.x, m = d.y) : (p = 0, m = 0); var r = { x: p + t, y: m + e };!i && d || (d = r), f.push(r), v = p + t, y = m + e } },
                                _ = function(t) {
                                    var e = t.pathSegTypeAsLetter.toUpperCase();
                                    if ("Z" !== e) {
                                        switch (e) {
                                            case "M":
                                            case "L":
                                            case "T":
                                            case "C":
                                            case "S":
                                            case "Q":
                                                v = t.x, y = t.y;
                                                break;
                                            case "H":
                                                v = t.x;
                                                break;
                                            case "V":
                                                y = t.y
                                        }
                                        x(v, y, t.pathSegType)
                                    }
                                };
                            for (i._svgPathToAbsolute(t), o = t.getTotalLength(), c = [], n = 0; n < t.pathSegList.numberOfItems; n += 1) c.push(t.pathSegList.getItem(n));
                            for (h = c.concat(); g < o;) {
                                if ((l = c[t.getPathSegAtLength(g)]) != u) {
                                    for (; h.length && h[0] != l;) _(h.shift());
                                    u = l
                                }
                                switch (l.pathSegTypeAsLetter.toUpperCase()) {
                                    case "C":
                                    case "T":
                                    case "S":
                                    case "Q":
                                    case "A":
                                        a = t.getPointAtLength(g), x(a.x, a.y, 0)
                                }
                                g += e
                            }
                            for (n = 0, s = h.length; n < s; ++n) _(h[n]);
                            return f
                        }, i._svgPathToAbsolute = function(t) {
                            for (var e, n, i, r, s, o, a = t.pathSegList, l = 0, c = 0, h = a.numberOfItems, u = 0; u < h; ++u) {
                                var d = a.getItem(u),
                                    p = d.pathSegTypeAsLetter;
                                if (/[MLHVCSQTA]/.test(p)) "x" in d && (l = d.x), "y" in d && (c = d.y);
                                else switch ("x1" in d && (i = l + d.x1), "x2" in d && (s = l + d.x2), "y1" in d && (r = c + d.y1), "y2" in d && (o = c + d.y2), "x" in d && (l += d.x), "y" in d && (c += d.y), p) {
                                    case "m":
                                        a.replaceItem(t.createSVGPathSegMovetoAbs(l, c), u);
                                        break;
                                    case "l":
                                        a.replaceItem(t.createSVGPathSegLinetoAbs(l, c), u);
                                        break;
                                    case "h":
                                        a.replaceItem(t.createSVGPathSegLinetoHorizontalAbs(l), u);
                                        break;
                                    case "v":
                                        a.replaceItem(t.createSVGPathSegLinetoVerticalAbs(c), u);
                                        break;
                                    case "c":
                                        a.replaceItem(t.createSVGPathSegCurvetoCubicAbs(l, c, i, r, s, o), u);
                                        break;
                                    case "s":
                                        a.replaceItem(t.createSVGPathSegCurvetoCubicSmoothAbs(l, c, s, o), u);
                                        break;
                                    case "q":
                                        a.replaceItem(t.createSVGPathSegCurvetoQuadraticAbs(l, c, i, r), u);
                                        break;
                                    case "t":
                                        a.replaceItem(t.createSVGPathSegCurvetoQuadraticSmoothAbs(l, c), u);
                                        break;
                                    case "a":
                                        a.replaceItem(t.createSVGPathSegArcAbs(l, c, d.r1, d.r2, d.angle, d.largeArcFlag, d.sweepFlag), u);
                                        break;
                                    case "z":
                                    case "Z":
                                        l = e, c = n
                                }
                                "M" != p && "m" != p || (e = l, n = c)
                            }
                        }
                    }, function(t, e, n) {
                        var i = {};
                        t.exports = i;
                        var r = n(5);
                        n(0), i.create = r.create, i.add = r.add, i.remove = r.remove, i.clear = r.clear, i.addComposite = r.addComposite, i.addBody = r.addBody, i.addConstraint = r.addConstraint
                    }])
                }, t.exports = i()
            },
            212: (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, { ACESFilmicToneMapping: () => nt, AddEquation: () => T, AddOperation: () => K, AdditiveAnimationBlendMode: () => qe, AdditiveBlending: () => b, AlphaFormat: () => Ot, AlwaysDepth: () => G, AlwaysStencilFunc: () => Sn, AmbientLight: () => id, AmbientLightProbe: () => _d, AnimationClip: () => Lu, AnimationLoader: () => Ou, AnimationMixer: () => Kd, AnimationObjectGroup: () => Zd, AnimationUtils: () => fu, ArcCurve: () => Jc, ArrayCamera: () => _l, ArrowHelper: () => Hp, Audio: () => Pd, AudioAnalyser: () => Fd, AudioContext: () => vd, AudioListener: () => Cd, AudioLoader: () => yd, AxesHelper: () => kp, AxisHelper: () => gm, BackSide: () => f, BasicDepthPacking: () => sn, BasicShadowMap: () => h, BinaryTextureLoader: () => bm, Bone: () => sc, BooleanKeyframeTrack: () => bu, BoundingBoxHelper: () => vm, Box2: () => ap, Box3: () => gi, Box3Helper: () => Bp, BoxBufferGeometry: () => Ms, BoxGeometry: () => Ms, BoxHelper: () => Np, BufferAttribute: () => Ur, BufferGeometry: () => is, BufferGeometryLoader: () => hd, ByteType: () => Tt, Cache: () => Cu, Camera: () => Ls, CameraHelper: () => Pp, CanvasRenderer: () => Mm, CanvasTexture: () => Oc, CatmullRomCurve3: () => nh, CineonToneMapping: () => et, CircleBufferGeometry: () => zc, CircleGeometry: () => zc, ClampToEdgeWrapping: () => dt, Clock: () => Sd, Color: () => Br, ColorKeyframeTrack: () => wu, CompressedTexture: () => Bc, CompressedTextureLoader: () => Fu, ConeBufferGeometry: () => Hc, ConeGeometry: () => Hc, CubeCamera: () => Ps, CubeReflectionMapping: () => st, CubeRefractionMapping: () => ot, CubeTexture: () => Is, CubeTextureLoader: () => Uu, CubeUVReflectionMapping: () => ct, CubeUVRefractionMapping: () => ht, CubicBezierCurve: () => oh, CubicBezierCurve3: () => ah, CubicInterpolant: () => vu, CullFaceBack: () => a, CullFaceFront: () => l, CullFaceFrontBack: () => c, CullFaceNone: () => o, Curve: () => Yc, CurvePath: () => mh, CustomBlending: () => S, CustomToneMapping: () => it, CylinderBufferGeometry: () => Uc, CylinderGeometry: () => Uc, Cylindrical: () => sp, DataTexture: () => oc, DataTexture2DArray: () => Ao, DataTexture3D: () => Do, DataTextureLoader: () => Hu, DataUtils: () => jp, DecrementStencilOp: () => pn, DecrementWrapStencilOp: () => fn, DefaultLoadingManager: () => Iu, DepthFormat: () => Gt, DepthStencilFormat: () => Vt, DepthTexture: () => Fc, DirectionalLight: () => nd, DirectionalLightHelper: () => Lp, DiscreteInterpolant: () => xu, DodecahedronBufferGeometry: () => Gc, DodecahedronGeometry: () => Gc, DoubleSide: () => g, DstAlphaFactor: () => O, DstColorFactor: () => z, DynamicBufferAttribute: () => om, DynamicCopyUsage: () => In, DynamicDrawUsage: () => En, DynamicReadUsage: () => Rn, EdgesGeometry: () => Xc, EdgesHelper: () => ym, EllipseCurve: () => Zc, EqualDepth: () => j, EqualStencilFunc: () => xn, EquirectangularReflectionMapping: () => at, EquirectangularRefractionMapping: () => lt, Euler: () => tr, EventDispatcher: () => On, ExtrudeBufferGeometry: () => Wh, ExtrudeGeometry: () => Wh, FaceColors: () => Zp, FileLoader: () => Bu, FlatShading: () => v, Float16BufferAttribute: () => Xr, Float32Attribute: () => mm, Float32BufferAttribute: () => Yr, Float64Attribute: () => fm, Float64BufferAttribute: () => Zr, FloatType: () => Ct, Fog: () => Rl, FogExp2: () => Ll, Font: () => Cm, FontLoader: () => Rm, FrontSide: () => m, Frustum: () => Hs, GLBufferAttribute: () => tp, GLSL1: () => Nn, GLSL3: () => Bn, GammaEncoding: () => Qe, GreaterDepth: () => X, GreaterEqualDepth: () => q, GreaterEqualStencilFunc: () => Mn, GreaterStencilFunc: () => bn, GridHelper: () => Mp, Group: () => bl, HalfFloatType: () => Pt, HemisphereLight: () => Vu, HemisphereLightHelper: () => wp, HemisphereLightProbe: () => xd, IcosahedronBufferGeometry: () => qh, IcosahedronGeometry: () => qh, ImageBitmapLoader: () => fd, ImageLoader: () => zu, ImageUtils: () => ri, ImmediateRenderObject: () => Pm, IncrementStencilOp: () => dn, IncrementWrapStencilOp: () => mn, InstancedBufferAttribute: () => hc, InstancedBufferGeometry: () => cd, InstancedInterleavedBuffer: () => $d, InstancedMesh: () => fc, Int16Attribute: () => hm, Int16BufferAttribute: () => Vr, Int32Attribute: () => dm, Int32BufferAttribute: () => jr, Int8Attribute: () => am, Int8BufferAttribute: () => Hr, IntType: () => Lt, InterleavedBuffer: () => Pl, InterleavedBufferAttribute: () => Dl, Interpolant: () => gu, InterpolateDiscrete: () => Ue, InterpolateLinear: () => He, InterpolateSmooth: () => ke, InvertStencilOp: () => gn, JSONLoader: () => Sm, KeepStencilOp: () => hn, KeyframeTrack: () => _u, LOD: () => Ql, LatheBufferGeometry: () => Xh, LatheGeometry: () => Xh, Layers: () => er, LensFlare: () => Em, LessDepth: () => V, LessEqualDepth: () => W, LessEqualStencilFunc: () => _n, LessStencilFunc: () => yn, Light: () => Gu, LightProbe: () => od, Line: () => wc, Line3: () => hp, LineBasicMaterial: () => gc, LineCurve: () => lh, LineCurve3: () => ch, LineDashedMaterial: () => pu, LineLoop: () => Ec, LinePieces: () => Xp, LineSegments: () => Tc, LineStrip: () => qp, LinearEncoding: () => Je, LinearFilter: () => xt, LinearInterpolant: () => yu, LinearMipMapLinearFilter: () => Mt, LinearMipMapNearestFilter: () => bt, LinearMipmapLinearFilter: () => wt, LinearMipmapNearestFilter: () => _t, LinearToneMapping: () => $, Loader: () => Du, LoaderUtils: () => ld, LoadingManager: () => Pu, LogLuvEncoding: () => tn, LoopOnce: () => Oe, LoopPingPong: () => ze, LoopRepeat: () => Fe, LuminanceAlphaFormat: () => Ht, LuminanceFormat: () => Ut, MOUSE: () => r, Material: () => Lr, MaterialLoader: () => ad, Math: () => Zn, MathUtils: () => Zn, Matrix3: () => Kn, Matrix4: () => Wi, MaxEquation: () => R, Mesh: () => bs, MeshBasicMaterial: () => Or, MeshDepthMaterial: () => ml, MeshDistanceMaterial: () => fl, MeshFaceMaterial: () => Kp, MeshLambertMaterial: () => uu, MeshMatcapMaterial: () => du, MeshNormalMaterial: () => hu, MeshPhongMaterial: () => lu, MeshPhysicalMaterial: () => au, MeshStandardMaterial: () => ou, MeshToonMaterial: () => cu, MinEquation: () => L, MirroredRepeatWrapping: () => pt, MixOperation: () => J, MultiMaterial: () => Qp, MultiplyBlending: () => M, MultiplyOperation: () => Z, NearestFilter: () => mt, NearestMipMapLinearFilter: () => yt, NearestMipMapNearestFilter: () => gt, NearestMipmapLinearFilter: () => vt, NearestMipmapNearestFilter: () => ft, NeverDepth: () => k, NeverStencilFunc: () => vn, NoBlending: () => x, NoColors: () => Yp, NoToneMapping: () => Q, NormalAnimationBlendMode: () => je, NormalBlending: () => _, NotEqualDepth: () => Y, NotEqualStencilFunc: () => wn, NumberKeyframeTrack: () => Mu, Object3D: () => fr, ObjectLoader: () => ud, ObjectSpaceNormalMap: () => ln, OctahedronBufferGeometry: () => Yh, OctahedronGeometry: () => Yh, OneFactor: () => P, OneMinusDstAlphaFactor: () => F, OneMinusDstColorFactor: () => U, OneMinusSrcAlphaFactor: () => B, OneMinusSrcColorFactor: () => D, OrthographicCamera: () => $s, PCFShadowMap: () => u, PCFSoftShadowMap: () => d, PMREMGenerator: () => fo, ParametricGeometry: () => Am, Particle: () => tm, ParticleBasicMaterial: () => im, ParticleSystem: () => em, ParticleSystemMaterial: () => rm, Path: () => fh, PerspectiveCamera: () => Rs, Plane: () => Fs, PlaneBufferGeometry: () => Vs, PlaneGeometry: () => Vs, PlaneHelper: () => Op, PointCloud: () => $p, PointCloudMaterial: () => nm, PointLight: () => td, PointLightHelper: () => yp, Points: () => Ic, PointsMaterial: () => Ac, PolarGridHelper: () => Sp, PolyhedronBufferGeometry: () => kc, PolyhedronGeometry: () => kc, PositionalAudio: () => Od, PropertyBinding: () => Yd, PropertyMixer: () => zd, QuadraticBezierCurve: () => hh, QuadraticBezierCurve3: () => uh, Quaternion: () => di, QuaternionKeyframeTrack: () => Tu, QuaternionLinearInterpolant: () => Su, REVISION: () => i, RGBADepthPacking: () => on, RGBAFormat: () => zt, RGBAIntegerFormat: () => Zt, RGBA_ASTC_10x10_Format: () => ye, RGBA_ASTC_10x5_Format: () => fe, RGBA_ASTC_10x6_Format: () => ge, RGBA_ASTC_10x8_Format: () => ve, RGBA_ASTC_12x10_Format: () => xe, RGBA_ASTC_12x12_Format: () => _e, RGBA_ASTC_4x4_Format: () => ae, RGBA_ASTC_5x4_Format: () => le, RGBA_ASTC_5x5_Format: () => ce, RGBA_ASTC_6x5_Format: () => he, RGBA_ASTC_6x6_Format: () => ue, RGBA_ASTC_8x5_Format: () => de, RGBA_ASTC_8x6_Format: () => pe, RGBA_ASTC_8x8_Format: () => me, RGBA_BPTC_Format: () => be, RGBA_ETC2_EAC_Format: () => oe, RGBA_PVRTC_2BPPV1_Format: () => ie, RGBA_PVRTC_4BPPV1_Format: () => ne, RGBA_S3TC_DXT1_Format: () => Kt, RGBA_S3TC_DXT3_Format: () => Qt, RGBA_S3TC_DXT5_Format: () => $t, RGBDEncoding: () => rn, RGBEEncoding: () => $e, RGBEFormat: () => kt, RGBFormat: () => Ft, RGBIntegerFormat: () => Yt, RGBM16Encoding: () => nn, RGBM7Encoding: () => en, RGB_ETC1_Format: () => re, RGB_ETC2_Format: () => se, RGB_PVRTC_2BPPV1_Format: () => ee, RGB_PVRTC_4BPPV1_Format: () => te, RGB_S3TC_DXT1_Format: () => Jt, RGFormat: () => qt, RGIntegerFormat: () => Xt, RawShaderMaterial: () => to, Ray: () => Vi, Raycaster: () => ep, RectAreaLight: () => rd, RedFormat: () => Wt, RedIntegerFormat: () => jt, ReinhardToneMapping: () => tt, RepeatWrapping: () => ut, ReplaceStencilOp: () => un, ReverseSubtractEquation: () => A, RingBufferGeometry: () => Zh, RingGeometry: () => Zh, SRGB8_ALPHA8_ASTC_10x10_Format: () => De, SRGB8_ALPHA8_ASTC_10x5_Format: () => Ce, SRGB8_ALPHA8_ASTC_10x6_Format: () => Pe, SRGB8_ALPHA8_ASTC_10x8_Format: () => Ie, SRGB8_ALPHA8_ASTC_12x10_Format: () => Ne, SRGB8_ALPHA8_ASTC_12x12_Format: () => Be, SRGB8_ALPHA8_ASTC_4x4_Format: () => we, SRGB8_ALPHA8_ASTC_5x4_Format: () => Me, SRGB8_ALPHA8_ASTC_5x5_Format: () => Se, SRGB8_ALPHA8_ASTC_6x5_Format: () => Te, SRGB8_ALPHA8_ASTC_6x6_Format: () => Ee, SRGB8_ALPHA8_ASTC_8x5_Format: () => Ae, SRGB8_ALPHA8_ASTC_8x6_Format: () => Le, SRGB8_ALPHA8_ASTC_8x8_Format: () => Re, Scene: () => Cl, SceneUtils: () => Tm, ShaderChunk: () => Ws, ShaderLib: () => qs, ShaderMaterial: () => As, ShadowMaterial: () => su, Shape: () => gh, ShapeBufferGeometry: () => Jh, ShapeGeometry: () => Jh, ShapePath: () => Gp, ShapeUtils: () => kh, ShortType: () => Et, Skeleton: () => cc, SkeletonHelper: () => gp, SkinnedMesh: () => rc, SmoothShading: () => y, Sphere: () => Bi, SphereBufferGeometry: () => Kh, SphereGeometry: () => Kh, Spherical: () => rp, SphericalHarmonics3: () => sd, SplineCurve: () => dh, SpotLight: () => Zu, SpotLightHelper: () => dp, Sprite: () => Yl, SpriteMaterial: () => Nl, SrcAlphaFactor: () => N, SrcAlphaSaturateFactor: () => H, SrcColorFactor: () => I, StaticCopyUsage: () => Pn, StaticDrawUsage: () => Tn, StaticReadUsage: () => Ln, StereoCamera: () => Md, StreamCopyUsage: () => Dn, StreamDrawUsage: () => An, StreamReadUsage: () => Cn, StringKeyframeTrack: () => Eu, SubtractEquation: () => E, SubtractiveBlending: () => w, TOUCH: () => s, TangentSpaceNormalMap: () => an, TetrahedronBufferGeometry: () => Qh, TetrahedronGeometry: () => Qh, TextGeometry: () => Lm, Texture: () => oi, TextureLoader: () => ku, TorusBufferGeometry: () => $h, TorusGeometry: () => $h, TorusKnotBufferGeometry: () => tu, TorusKnotGeometry: () => tu, Triangle: () => Er, TriangleFanDrawMode: () => Ze, TriangleStripDrawMode: () => Ye, TrianglesDrawMode: () => Xe, TubeBufferGeometry: () => eu, TubeGeometry: () => eu, UVMapping: () => rt, Uint16Attribute: () => um, Uint16BufferAttribute: () => Wr, Uint32Attribute: () => pm, Uint32BufferAttribute: () => qr, Uint8Attribute: () => lm, Uint8BufferAttribute: () => kr, Uint8ClampedAttribute: () => cm, Uint8ClampedBufferAttribute: () => Gr, Uniform: () => Qd, UniformsLib: () => js, UniformsUtils: () => Es, UnsignedByteType: () => St, UnsignedInt248Type: () => Bt, UnsignedIntType: () => Rt, UnsignedShort4444Type: () => It, UnsignedShort5551Type: () => Dt, UnsignedShort565Type: () => Nt, UnsignedShortType: () => At, VSMShadowMap: () => p, Vector2: () => Jn, Vector3: () => pi, Vector4: () => li, VectorKeyframeTrack: () => Au, Vertex: () => sm, VertexColors: () => Jp, VideoTexture: () => Nc, WebGL1Renderer: () => Al, WebGLCubeRenderTarget: () => Ds, WebGLMultipleRenderTargets: () => hi, WebGLMultisampleRenderTarget: () => ui, WebGLRenderTarget: () => ci, WebGLRenderTargetCube: () => wm, WebGLRenderer: () => El, WebGLUtils: () => xl, WireframeGeometry: () => nu, WireframeHelper: () => xm, WrapAroundEnding: () => We, XHRLoader: () => _m, ZeroCurvatureEnding: () => Ge, ZeroFactor: () => C, ZeroSlopeEnding: () => Ve, ZeroStencilOp: () => cn, sRGBEncoding: () => Ke });
                const i = "134",
                    r = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
                    s = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
                    o = 0,
                    a = 1,
                    l = 2,
                    c = 3,
                    h = 0,
                    u = 1,
                    d = 2,
                    p = 3,
                    m = 0,
                    f = 1,
                    g = 2,
                    v = 1,
                    y = 2,
                    x = 0,
                    _ = 1,
                    b = 2,
                    w = 3,
                    M = 4,
                    S = 5,
                    T = 100,
                    E = 101,
                    A = 102,
                    L = 103,
                    R = 104,
                    C = 200,
                    P = 201,
                    I = 202,
                    D = 203,
                    N = 204,
                    B = 205,
                    O = 206,
                    F = 207,
                    z = 208,
                    U = 209,
                    H = 210,
                    k = 0,
                    G = 1,
                    V = 2,
                    W = 3,
                    j = 4,
                    q = 5,
                    X = 6,
                    Y = 7,
                    Z = 0,
                    J = 1,
                    K = 2,
                    Q = 0,
                    $ = 1,
                    tt = 2,
                    et = 3,
                    nt = 4,
                    it = 5,
                    rt = 300,
                    st = 301,
                    ot = 302,
                    at = 303,
                    lt = 304,
                    ct = 306,
                    ht = 307,
                    ut = 1e3,
                    dt = 1001,
                    pt = 1002,
                    mt = 1003,
                    ft = 1004,
                    gt = 1004,
                    vt = 1005,
                    yt = 1005,
                    xt = 1006,
                    _t = 1007,
                    bt = 1007,
                    wt = 1008,
                    Mt = 1008,
                    St = 1009,
                    Tt = 1010,
                    Et = 1011,
                    At = 1012,
                    Lt = 1013,
                    Rt = 1014,
                    Ct = 1015,
                    Pt = 1016,
                    It = 1017,
                    Dt = 1018,
                    Nt = 1019,
                    Bt = 1020,
                    Ot = 1021,
                    Ft = 1022,
                    zt = 1023,
                    Ut = 1024,
                    Ht = 1025,
                    kt = zt,
                    Gt = 1026,
                    Vt = 1027,
                    Wt = 1028,
                    jt = 1029,
                    qt = 1030,
                    Xt = 1031,
                    Yt = 1032,
                    Zt = 1033,
                    Jt = 33776,
                    Kt = 33777,
                    Qt = 33778,
                    $t = 33779,
                    te = 35840,
                    ee = 35841,
                    ne = 35842,
                    ie = 35843,
                    re = 36196,
                    se = 37492,
                    oe = 37496,
                    ae = 37808,
                    le = 37809,
                    ce = 37810,
                    he = 37811,
                    ue = 37812,
                    de = 37813,
                    pe = 37814,
                    me = 37815,
                    fe = 37816,
                    ge = 37817,
                    ve = 37818,
                    ye = 37819,
                    xe = 37820,
                    _e = 37821,
                    be = 36492,
                    we = 37840,
                    Me = 37841,
                    Se = 37842,
                    Te = 37843,
                    Ee = 37844,
                    Ae = 37845,
                    Le = 37846,
                    Re = 37847,
                    Ce = 37848,
                    Pe = 37849,
                    Ie = 37850,
                    De = 37851,
                    Ne = 37852,
                    Be = 37853,
                    Oe = 2200,
                    Fe = 2201,
                    ze = 2202,
                    Ue = 2300,
                    He = 2301,
                    ke = 2302,
                    Ge = 2400,
                    Ve = 2401,
                    We = 2402,
                    je = 2500,
                    qe = 2501,
                    Xe = 0,
                    Ye = 1,
                    Ze = 2,
                    Je = 3e3,
                    Ke = 3001,
                    Qe = 3007,
                    $e = 3002,
                    tn = 3003,
                    en = 3004,
                    nn = 3005,
                    rn = 3006,
                    sn = 3200,
                    on = 3201,
                    an = 0,
                    ln = 1,
                    cn = 0,
                    hn = 7680,
                    un = 7681,
                    dn = 7682,
                    pn = 7683,
                    mn = 34055,
                    fn = 34056,
                    gn = 5386,
                    vn = 512,
                    yn = 513,
                    xn = 514,
                    _n = 515,
                    bn = 516,
                    wn = 517,
                    Mn = 518,
                    Sn = 519,
                    Tn = 35044,
                    En = 35048,
                    An = 35040,
                    Ln = 35045,
                    Rn = 35049,
                    Cn = 35041,
                    Pn = 35046,
                    In = 35050,
                    Dn = 35042,
                    Nn = "100",
                    Bn = "300 es";
                class On {
                    addEventListener(t, e) {
                        void 0 === this._listeners && (this._listeners = {});
                        const n = this._listeners;
                        void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
                    }
                    hasEventListener(t, e) { if (void 0 === this._listeners) return !1; const n = this._listeners; return void 0 !== n[t] && -1 !== n[t].indexOf(e) }
                    removeEventListener(t, e) { if (void 0 === this._listeners) return; const n = this._listeners[t]; if (void 0 !== n) { const t = n.indexOf(e); - 1 !== t && n.splice(t, 1) } }
                    dispatchEvent(t) {
                        if (void 0 === this._listeners) return;
                        const e = this._listeners[t.type];
                        if (void 0 !== e) {
                            t.target = this;
                            const n = e.slice(0);
                            for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
                            t.target = null
                        }
                    }
                }
                let Fn = 1234567;
                const zn = Math.PI / 180,
                    Un = 180 / Math.PI,
                    Hn = [];
                for (let t = 0; t < 256; t++) Hn[t] = (t < 16 ? "0" : "") + t.toString(16);
                const kn = "undefined" != typeof crypto && "randomUUID" in crypto;

                function Gn() {
                    if (kn) return crypto.randomUUID().toUpperCase();
                    const t = 4294967295 * Math.random() | 0,
                        e = 4294967295 * Math.random() | 0,
                        n = 4294967295 * Math.random() | 0,
                        i = 4294967295 * Math.random() | 0;
                    return (Hn[255 & t] + Hn[t >> 8 & 255] + Hn[t >> 16 & 255] + Hn[t >> 24 & 255] + "-" + Hn[255 & e] + Hn[e >> 8 & 255] + "-" + Hn[e >> 16 & 15 | 64] + Hn[e >> 24 & 255] + "-" + Hn[63 & n | 128] + Hn[n >> 8 & 255] + "-" + Hn[n >> 16 & 255] + Hn[n >> 24 & 255] + Hn[255 & i] + Hn[i >> 8 & 255] + Hn[i >> 16 & 255] + Hn[i >> 24 & 255]).toUpperCase()
                }

                function Vn(t, e, n) { return Math.max(e, Math.min(n, t)) }

                function Wn(t, e) { return (t % e + e) % e }

                function jn(t, e, n) { return (1 - n) * t + n * e }

                function qn(t) { return 0 == (t & t - 1) && 0 !== t }

                function Xn(t) { return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)) }

                function Yn(t) { return Math.pow(2, Math.floor(Math.log(t) / Math.LN2)) }
                var Zn = Object.freeze({
                    __proto__: null,
                    DEG2RAD: zn,
                    RAD2DEG: Un,
                    generateUUID: Gn,
                    clamp: Vn,
                    euclideanModulo: Wn,
                    mapLinear: function(t, e, n, i, r) { return i + (t - e) * (r - i) / (n - e) },
                    inverseLerp: function(t, e, n) { return t !== e ? (n - t) / (e - t) : 0 },
                    lerp: jn,
                    damp: function(t, e, n, i) { return jn(t, e, 1 - Math.exp(-n * i)) },
                    pingpong: function(t, e = 1) { return e - Math.abs(Wn(t, 2 * e) - e) },
                    smoothstep: function(t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t) },
                    smootherstep: function(t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10) },
                    randInt: function(t, e) { return t + Math.floor(Math.random() * (e - t + 1)) },
                    randFloat: function(t, e) { return t + Math.random() * (e - t) },
                    randFloatSpread: function(t) { return t * (.5 - Math.random()) },
                    seededRandom: function(t) { return void 0 !== t && (Fn = t % 2147483647), Fn = 16807 * Fn % 2147483647, (Fn - 1) / 2147483646 },
                    degToRad: function(t) { return t * zn },
                    radToDeg: function(t) { return t * Un },
                    isPowerOfTwo: qn,
                    ceilPowerOfTwo: Xn,
                    floorPowerOfTwo: Yn,
                    setQuaternionFromProperEuler: function(t, e, n, i, r) {
                        const s = Math.cos,
                            o = Math.sin,
                            a = s(n / 2),
                            l = o(n / 2),
                            c = s((e + i) / 2),
                            h = o((e + i) / 2),
                            u = s((e - i) / 2),
                            d = o((e - i) / 2),
                            p = s((i - e) / 2),
                            m = o((i - e) / 2);
                        switch (r) {
                            case "XYX":
                                t.set(a * h, l * u, l * d, a * c);
                                break;
                            case "YZY":
                                t.set(l * d, a * h, l * u, a * c);
                                break;
                            case "ZXZ":
                                t.set(l * u, l * d, a * h, a * c);
                                break;
                            case "XZX":
                                t.set(a * h, l * m, l * p, a * c);
                                break;
                            case "YXY":
                                t.set(l * p, a * h, l * m, a * c);
                                break;
                            case "ZYZ":
                                t.set(l * m, l * p, a * h, a * c);
                                break;
                            default:
                                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                        }
                    }
                });
                class Jn {
                    constructor(t = 0, e = 0) { this.x = t, this.y = e }
                    get width() { return this.x }
                    set width(t) { this.x = t }
                    get height() { return this.y }
                    set height(t) { this.y = t }
                    set(t, e) { return this.x = t, this.y = e, this }
                    setScalar(t) { return this.x = t, this.y = t, this }
                    setX(t) { return this.x = t, this }
                    setY(t) { return this.y = t, this }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() { return new this.constructor(this.x, this.y) }
                    copy(t) { return this.x = t.x, this.y = t.y, this }
                    add(t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this) }
                    addScalar(t) { return this.x += t, this.y += t, this }
                    addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this }
                    addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this }
                    sub(t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this) }
                    subScalar(t) { return this.x -= t, this.y -= t, this }
                    subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this }
                    multiply(t) { return this.x *= t.x, this.y *= t.y, this }
                    multiplyScalar(t) { return this.x *= t, this.y *= t, this }
                    divide(t) { return this.x /= t.x, this.y /= t.y, this }
                    divideScalar(t) { return this.multiplyScalar(1 / t) }
                    applyMatrix3(t) {
                        const e = this.x,
                            n = this.y,
                            i = t.elements;
                        return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
                    }
                    min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this }
                    max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this }
                    clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this }
                    clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this }
                    clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }
                    floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }
                    ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }
                    round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }
                    roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this }
                    negate() { return this.x = -this.x, this.y = -this.y, this }
                    dot(t) { return this.x * t.x + this.y * t.y }
                    cross(t) { return this.x * t.y - this.y * t.x }
                    lengthSq() { return this.x * this.x + this.y * this.y }
                    length() { return Math.sqrt(this.x * this.x + this.y * this.y) }
                    manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) }
                    normalize() { return this.divideScalar(this.length() || 1) }
                    angle() { return Math.atan2(-this.y, -this.x) + Math.PI }
                    distanceTo(t) { return Math.sqrt(this.distanceToSquared(t)) }
                    distanceToSquared(t) {
                        const e = this.x - t.x,
                            n = this.y - t.y;
                        return e * e + n * n
                    }
                    manhattanDistanceTo(t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) }
                    setLength(t) { return this.normalize().multiplyScalar(t) }
                    lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this }
                    lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this }
                    equals(t) { return t.x === this.x && t.y === this.y }
                    fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this }
                    toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t }
                    fromBufferAttribute(t, e, n) { return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this }
                    rotateAround(t, e) {
                        const n = Math.cos(e),
                            i = Math.sin(e),
                            r = this.x - t.x,
                            s = this.y - t.y;
                        return this.x = r * n - s * i + t.x, this.y = r * i + s * n + t.y, this
                    }
                    random() { return this.x = Math.random(), this.y = Math.random(), this } * [Symbol.iterator]() { yield this.x, yield this.y }
                }
                Jn.prototype.isVector2 = !0;
                class Kn {
                    constructor() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") }
                    set(t, e, n, i, r, s, o, a, l) { const c = this.elements; return c[0] = t, c[1] = i, c[2] = o, c[3] = e, c[4] = r, c[5] = a, c[6] = n, c[7] = s, c[8] = l, this }
                    identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this }
                    copy(t) {
                        const e = this.elements,
                            n = t.elements;
                        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
                    }
                    extractBasis(t, e, n) { return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this }
                    setFromMatrix4(t) { const e = t.elements; return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this }
                    multiply(t) { return this.multiplyMatrices(this, t) }
                    premultiply(t) { return this.multiplyMatrices(t, this) }
                    multiplyMatrices(t, e) {
                        const n = t.elements,
                            i = e.elements,
                            r = this.elements,
                            s = n[0],
                            o = n[3],
                            a = n[6],
                            l = n[1],
                            c = n[4],
                            h = n[7],
                            u = n[2],
                            d = n[5],
                            p = n[8],
                            m = i[0],
                            f = i[3],
                            g = i[6],
                            v = i[1],
                            y = i[4],
                            x = i[7],
                            _ = i[2],
                            b = i[5],
                            w = i[8];
                        return r[0] = s * m + o * v + a * _, r[3] = s * f + o * y + a * b, r[6] = s * g + o * x + a * w, r[1] = l * m + c * v + h * _, r[4] = l * f + c * y + h * b, r[7] = l * g + c * x + h * w, r[2] = u * m + d * v + p * _, r[5] = u * f + d * y + p * b, r[8] = u * g + d * x + p * w, this
                    }
                    multiplyScalar(t) { const e = this.elements; return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this }
                    determinant() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            i = t[2],
                            r = t[3],
                            s = t[4],
                            o = t[5],
                            a = t[6],
                            l = t[7],
                            c = t[8];
                        return e * s * c - e * o * l - n * r * c + n * o * a + i * r * l - i * s * a
                    }
                    invert() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            i = t[2],
                            r = t[3],
                            s = t[4],
                            o = t[5],
                            a = t[6],
                            l = t[7],
                            c = t[8],
                            h = c * s - o * l,
                            u = o * a - c * r,
                            d = l * r - s * a,
                            p = e * h + n * u + i * d;
                        if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const m = 1 / p;
                        return t[0] = h * m, t[1] = (i * l - c * n) * m, t[2] = (o * n - i * s) * m, t[3] = u * m, t[4] = (c * e - i * a) * m, t[5] = (i * r - o * e) * m, t[6] = d * m, t[7] = (n * a - l * e) * m, t[8] = (s * e - n * r) * m, this
                    }
                    transpose() { let t; const e = this.elements; return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this }
                    getNormalMatrix(t) { return this.setFromMatrix4(t).invert().transpose() }
                    transposeIntoArray(t) { const e = this.elements; return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this }
                    setUvTransform(t, e, n, i, r, s, o) {
                        const a = Math.cos(r),
                            l = Math.sin(r);
                        return this.set(n * a, n * l, -n * (a * s + l * o) + s + t, -i * l, i * a, -i * (-l * s + a * o) + o + e, 0, 0, 1), this
                    }
                    scale(t, e) { const n = this.elements; return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this }
                    rotate(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t),
                            i = this.elements,
                            r = i[0],
                            s = i[3],
                            o = i[6],
                            a = i[1],
                            l = i[4],
                            c = i[7];
                        return i[0] = e * r + n * a, i[3] = e * s + n * l, i[6] = e * o + n * c, i[1] = -n * r + e * a, i[4] = -n * s + e * l, i[7] = -n * o + e * c, this
                    }
                    translate(t, e) { const n = this.elements; return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this }
                    equals(t) {
                        const e = this.elements,
                            n = t.elements;
                        for (let t = 0; t < 9; t++)
                            if (e[t] !== n[t]) return !1;
                        return !0
                    }
                    fromArray(t, e = 0) { for (let n = 0; n < 9; n++) this.elements[n] = t[n + e]; return this }
                    toArray(t = [], e = 0) { const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t }
                    clone() { return (new this.constructor).fromArray(this.elements) }
                }

                function Qn(t) { if (0 === t.length) return -1 / 0; let e = t[0]; for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]); return e }
                Kn.prototype.isMatrix3 = !0;
                const $n = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };

                function ti(t, e) { return new $n[t](e) }

                function ei(t) { return document.createElementNS("http://www.w3.org/1999/xhtml", t) }

                function ni(t, e = 0) {
                    let n = 3735928559 ^ e,
                        i = 1103547991 ^ e;
                    for (let e, r = 0; r < t.length; r++) e = t.charCodeAt(r), n = Math.imul(n ^ e, 2654435761), i = Math.imul(i ^ e, 1597334677);
                    return n = Math.imul(n ^ n >>> 16, 2246822507) ^ Math.imul(i ^ i >>> 13, 3266489909), i = Math.imul(i ^ i >>> 16, 2246822507) ^ Math.imul(n ^ n >>> 13, 3266489909), 4294967296 * (2097151 & i) + (n >>> 0)
                }
                let ii;
                class ri {
                    static getDataURL(t) {
                        if (/^data:/i.test(t.src)) return t.src;
                        if ("undefined" == typeof HTMLCanvasElement) return t.src;
                        let e;
                        if (t instanceof HTMLCanvasElement) e = t;
                        else {
                            void 0 === ii && (ii = ei("canvas")), ii.width = t.width, ii.height = t.height;
                            const n = ii.getContext("2d");
                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = ii
                        }
                        return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
                    }
                }
                let si = 0;
                class oi extends On {
                    constructor(t = oi.DEFAULT_IMAGE, e = oi.DEFAULT_MAPPING, n = dt, i = dt, r = xt, s = wt, o = zt, a = St, l = 1, c = Je) { super(), Object.defineProperty(this, "id", { value: si++ }), this.uuid = Gn(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new Jn(0, 0), this.repeat = new Jn(1, 1), this.center = new Jn(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Kn, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1 }
                    updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this.userData = JSON.parse(JSON.stringify(t.userData)), this }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t;
                        if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                        const n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
                        if (void 0 !== this.image) {
                            const i = this.image;
                            if (void 0 === i.uuid && (i.uuid = Gn()), !e && void 0 === t.images[i.uuid]) {
                                let e;
                                if (Array.isArray(i)) { e = []; for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(ai(i[t].image)) : e.push(ai(i[t])) } else e = ai(i);
                                t.images[i.uuid] = { uuid: i.uuid, url: e }
                            }
                            n.image = i.uuid
                        }
                        return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n
                    }
                    dispose() { this.dispatchEvent({ type: "dispose" }) }
                    transformUv(t) {
                        if (this.mapping !== rt) return t;
                        if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                            case ut:
                                t.x = t.x - Math.floor(t.x);
                                break;
                            case dt:
                                t.x = t.x < 0 ? 0 : 1;
                                break;
                            case pt:
                                1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                        }
                        if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                            case ut:
                                t.y = t.y - Math.floor(t.y);
                                break;
                            case dt:
                                t.y = t.y < 0 ? 0 : 1;
                                break;
                            case pt:
                                1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                        }
                        return this.flipY && (t.y = 1 - t.y), t
                    }
                    set needsUpdate(t) {!0 === t && this.version++ }
                }

                function ai(t) { return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? ri.getDataURL(t) : t.data ? { data: Array.prototype.slice.call(t.data), width: t.width, height: t.height, type: t.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) }
                oi.DEFAULT_IMAGE = void 0, oi.DEFAULT_MAPPING = rt, oi.prototype.isTexture = !0;
                class li {
                    constructor(t = 0, e = 0, n = 0, i = 1) { this.x = t, this.y = e, this.z = n, this.w = i }
                    get width() { return this.z }
                    set width(t) { this.z = t }
                    get height() { return this.w }
                    set height(t) { this.w = t }
                    set(t, e, n, i) { return this.x = t, this.y = e, this.z = n, this.w = i, this }
                    setScalar(t) { return this.x = t, this.y = t, this.z = t, this.w = t, this }
                    setX(t) { return this.x = t, this }
                    setY(t) { return this.y = t, this }
                    setZ(t) { return this.z = t, this }
                    setW(t) { return this.w = t, this }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            case 3:
                                this.w = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            case 3:
                                return this.w;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() { return new this.constructor(this.x, this.y, this.z, this.w) }
                    copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this }
                    add(t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this) }
                    addScalar(t) { return this.x += t, this.y += t, this.z += t, this.w += t, this }
                    addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this }
                    addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this }
                    sub(t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this) }
                    subScalar(t) { return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this }
                    subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this }
                    multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this }
                    multiplyScalar(t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this }
                    applyMatrix4(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = this.w,
                            s = t.elements;
                        return this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r, this
                    }
                    divideScalar(t) { return this.multiplyScalar(1 / t) }
                    setAxisAngleFromQuaternion(t) { this.w = 2 * Math.acos(t.w); const e = Math.sqrt(1 - t.w * t.w); return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this }
                    setAxisAngleFromRotationMatrix(t) {
                        let e, n, i, r;
                        const s = .01,
                            o = .1,
                            a = t.elements,
                            l = a[0],
                            c = a[4],
                            h = a[8],
                            u = a[1],
                            d = a[5],
                            p = a[9],
                            m = a[2],
                            f = a[6],
                            g = a[10];
                        if (Math.abs(c - u) < s && Math.abs(h - m) < s && Math.abs(p - f) < s) {
                            if (Math.abs(c + u) < o && Math.abs(h + m) < o && Math.abs(p + f) < o && Math.abs(l + d + g - 3) < o) return this.set(1, 0, 0, 0), this;
                            e = Math.PI;
                            const t = (l + 1) / 2,
                                a = (d + 1) / 2,
                                v = (g + 1) / 2,
                                y = (c + u) / 4,
                                x = (h + m) / 4,
                                _ = (p + f) / 4;
                            return t > a && t > v ? t < s ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(t), i = y / n, r = x / n) : a > v ? a < s ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(a), n = y / i, r = _ / i) : v < s ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(v), n = x / r, i = _ / r), this.set(n, i, r, e), this
                        }
                        let v = Math.sqrt((f - p) * (f - p) + (h - m) * (h - m) + (u - c) * (u - c));
                        return Math.abs(v) < .001 && (v = 1), this.x = (f - p) / v, this.y = (h - m) / v, this.z = (u - c) / v, this.w = Math.acos((l + d + g - 1) / 2), this
                    }
                    min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this }
                    max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this }
                    clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this }
                    clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this }
                    clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }
                    floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this }
                    ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this }
                    round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this }
                    roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this }
                    negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this }
                    dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w }
                    lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }
                    length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }
                    manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) }
                    normalize() { return this.divideScalar(this.length() || 1) }
                    setLength(t) { return this.normalize().multiplyScalar(t) }
                    lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this }
                    lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this }
                    equals(t) { return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w }
                    fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this }
                    toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t }
                    fromBufferAttribute(t, e, n) { return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this }
                    random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } * [Symbol.iterator]() { yield this.x, yield this.y, yield this.z, yield this.w }
                }
                li.prototype.isVector4 = !0;
                class ci extends On {
                    constructor(t, e, n = {}) { super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new li(0, 0, t, e), this.scissorTest = !1, this.viewport = new li(0, 0, t, e), this.texture = new oi(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = { width: t, height: e, depth: 1 }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : xt, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null }
                    setTexture(t) { t.image = { width: this.width, height: this.height, depth: this.depth }, this.texture = t }
                    setSize(t, e, n = 1) { this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e) }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { return this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.image = {...this.texture.image }, this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this }
                    dispose() { this.dispatchEvent({ type: "dispose" }) }
                }
                ci.prototype.isWebGLRenderTarget = !0;
                class hi extends ci {
                    constructor(t, e, n) {
                        super(t, e);
                        const i = this.texture;
                        this.texture = [];
                        for (let t = 0; t < n; t++) this.texture[t] = i.clone()
                    }
                    setSize(t, e, n = 1) {
                        if (this.width !== t || this.height !== e || this.depth !== n) {
                            this.width = t, this.height = e, this.depth = n;
                            for (let i = 0, r = this.texture.length; i < r; i++) this.texture[i].image.width = t, this.texture[i].image.height = e, this.texture[i].image.depth = n;
                            this.dispose()
                        }
                        return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
                    }
                    copy(t) { this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this.texture.length = 0; for (let e = 0, n = t.texture.length; e < n; e++) this.texture[e] = t.texture[e].clone(); return this }
                }
                hi.prototype.isWebGLMultipleRenderTargets = !0;
                class ui extends ci {
                    constructor(t, e, n) { super(t, e, n), this.samples = 4 }
                    copy(t) { return super.copy.call(this, t), this.samples = t.samples, this }
                }
                ui.prototype.isWebGLMultisampleRenderTarget = !0;
                class di {
                    constructor(t = 0, e = 0, n = 0, i = 1) { this._x = t, this._y = e, this._z = n, this._w = i }
                    static slerp(t, e, n, i) { return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, i) }
                    static slerpFlat(t, e, n, i, r, s, o) {
                        let a = n[i + 0],
                            l = n[i + 1],
                            c = n[i + 2],
                            h = n[i + 3];
                        const u = r[s + 0],
                            d = r[s + 1],
                            p = r[s + 2],
                            m = r[s + 3];
                        if (0 === o) return t[e + 0] = a, t[e + 1] = l, t[e + 2] = c, void(t[e + 3] = h);
                        if (1 === o) return t[e + 0] = u, t[e + 1] = d, t[e + 2] = p, void(t[e + 3] = m);
                        if (h !== m || a !== u || l !== d || c !== p) {
                            let t = 1 - o;
                            const e = a * u + l * d + c * p + h * m,
                                n = e >= 0 ? 1 : -1,
                                i = 1 - e * e;
                            if (i > Number.EPSILON) {
                                const r = Math.sqrt(i),
                                    s = Math.atan2(r, e * n);
                                t = Math.sin(t * s) / r, o = Math.sin(o * s) / r
                            }
                            const r = o * n;
                            if (a = a * t + u * r, l = l * t + d * r, c = c * t + p * r, h = h * t + m * r, t === 1 - o) {
                                const t = 1 / Math.sqrt(a * a + l * l + c * c + h * h);
                                a *= t, l *= t, c *= t, h *= t
                            }
                        }
                        t[e] = a, t[e + 1] = l, t[e + 2] = c, t[e + 3] = h
                    }
                    static multiplyQuaternionsFlat(t, e, n, i, r, s) {
                        const o = n[i],
                            a = n[i + 1],
                            l = n[i + 2],
                            c = n[i + 3],
                            h = r[s],
                            u = r[s + 1],
                            d = r[s + 2],
                            p = r[s + 3];
                        return t[e] = o * p + c * h + a * d - l * u, t[e + 1] = a * p + c * u + l * h - o * d, t[e + 2] = l * p + c * d + o * u - a * h, t[e + 3] = c * p - o * h - a * u - l * d, t
                    }
                    get x() { return this._x }
                    set x(t) { this._x = t, this._onChangeCallback() }
                    get y() { return this._y }
                    set y(t) { this._y = t, this._onChangeCallback() }
                    get z() { return this._z }
                    set z(t) { this._z = t, this._onChangeCallback() }
                    get w() { return this._w }
                    set w(t) { this._w = t, this._onChangeCallback() }
                    set(t, e, n, i) { return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this }
                    clone() { return new this.constructor(this._x, this._y, this._z, this._w) }
                    copy(t) { return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this }
                    setFromEuler(t, e) {
                        if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                        const n = t._x,
                            i = t._y,
                            r = t._z,
                            s = t._order,
                            o = Math.cos,
                            a = Math.sin,
                            l = o(n / 2),
                            c = o(i / 2),
                            h = o(r / 2),
                            u = a(n / 2),
                            d = a(i / 2),
                            p = a(r / 2);
                        switch (s) {
                            case "XYZ":
                                this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                                break;
                            case "YXZ":
                                this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                                break;
                            case "ZXY":
                                this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                                break;
                            case "ZYX":
                                this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                                break;
                            case "YZX":
                                this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p;
                                break;
                            case "XZY":
                                this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p;
                                break;
                            default:
                                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                        }
                        return !1 !== e && this._onChangeCallback(), this
                    }
                    setFromAxisAngle(t, e) {
                        const n = e / 2,
                            i = Math.sin(n);
                        return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
                    }
                    setFromRotationMatrix(t) {
                        const e = t.elements,
                            n = e[0],
                            i = e[4],
                            r = e[8],
                            s = e[1],
                            o = e[5],
                            a = e[9],
                            l = e[2],
                            c = e[6],
                            h = e[10],
                            u = n + o + h;
                        if (u > 0) {
                            const t = .5 / Math.sqrt(u + 1);
                            this._w = .25 / t, this._x = (c - a) * t, this._y = (r - l) * t, this._z = (s - i) * t
                        } else if (n > o && n > h) {
                            const t = 2 * Math.sqrt(1 + n - o - h);
                            this._w = (c - a) / t, this._x = .25 * t, this._y = (i + s) / t, this._z = (r + l) / t
                        } else if (o > h) {
                            const t = 2 * Math.sqrt(1 + o - n - h);
                            this._w = (r - l) / t, this._x = (i + s) / t, this._y = .25 * t, this._z = (a + c) / t
                        } else {
                            const t = 2 * Math.sqrt(1 + h - n - o);
                            this._w = (s - i) / t, this._x = (r + l) / t, this._y = (a + c) / t, this._z = .25 * t
                        }
                        return this._onChangeCallback(), this
                    }
                    setFromUnitVectors(t, e) { let n = t.dot(e) + 1; return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize() }
                    angleTo(t) { return 2 * Math.acos(Math.abs(Vn(this.dot(t), -1, 1))) }
                    rotateTowards(t, e) { const n = this.angleTo(t); if (0 === n) return this; const i = Math.min(1, e / n); return this.slerp(t, i), this }
                    identity() { return this.set(0, 0, 0, 1) }
                    invert() { return this.conjugate() }
                    conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this }
                    dot(t) { return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w }
                    lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w }
                    length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) }
                    normalize() { let t = this.length(); return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this }
                    multiply(t, e) { return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t) }
                    premultiply(t) { return this.multiplyQuaternions(t, this) }
                    multiplyQuaternions(t, e) {
                        const n = t._x,
                            i = t._y,
                            r = t._z,
                            s = t._w,
                            o = e._x,
                            a = e._y,
                            l = e._z,
                            c = e._w;
                        return this._x = n * c + s * o + i * l - r * a, this._y = i * c + s * a + r * o - n * l, this._z = r * c + s * l + n * a - i * o, this._w = s * c - n * o - i * a - r * l, this._onChangeCallback(), this
                    }
                    slerp(t, e) {
                        if (0 === e) return this;
                        if (1 === e) return this.copy(t);
                        const n = this._x,
                            i = this._y,
                            r = this._z,
                            s = this._w;
                        let o = s * t._w + n * t._x + i * t._y + r * t._z;
                        if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this;
                        const a = 1 - o * o;
                        if (a <= Number.EPSILON) { const t = 1 - e; return this._w = t * s + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this }
                        const l = Math.sqrt(a),
                            c = Math.atan2(l, o),
                            h = Math.sin((1 - e) * c) / l,
                            u = Math.sin(e * c) / l;
                        return this._w = s * h + this._w * u, this._x = n * h + this._x * u, this._y = i * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this
                    }
                    slerpQuaternions(t, e, n) { this.copy(t).slerp(e, n) }
                    random() {
                        const t = Math.random(),
                            e = Math.sqrt(1 - t),
                            n = Math.sqrt(t),
                            i = 2 * Math.PI * Math.random(),
                            r = 2 * Math.PI * Math.random();
                        return this.set(e * Math.cos(i), n * Math.sin(r), n * Math.cos(r), e * Math.sin(i))
                    }
                    equals(t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w }
                    fromArray(t, e = 0) { return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this }
                    toArray(t = [], e = 0) { return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t }
                    fromBufferAttribute(t, e) { return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this }
                    _onChange(t) { return this._onChangeCallback = t, this }
                    _onChangeCallback() {}
                }
                di.prototype.isQuaternion = !0;
                class pi {
                    constructor(t = 0, e = 0, n = 0) { this.x = t, this.y = e, this.z = n }
                    set(t, e, n) { return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this }
                    setScalar(t) { return this.x = t, this.y = t, this.z = t, this }
                    setX(t) { return this.x = t, this }
                    setY(t) { return this.y = t, this }
                    setZ(t) { return this.z = t, this }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() { return new this.constructor(this.x, this.y, this.z) }
                    copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this }
                    add(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this) }
                    addScalar(t) { return this.x += t, this.y += t, this.z += t, this }
                    addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this }
                    addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this }
                    sub(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) }
                    subScalar(t) { return this.x -= t, this.y -= t, this.z -= t, this }
                    subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this }
                    multiply(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this) }
                    multiplyScalar(t) { return this.x *= t, this.y *= t, this.z *= t, this }
                    multiplyVectors(t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this }
                    applyEuler(t) { return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(fi.setFromEuler(t)) }
                    applyAxisAngle(t, e) { return this.applyQuaternion(fi.setFromAxisAngle(t, e)) }
                    applyMatrix3(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.elements;
                        return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
                    }
                    applyNormalMatrix(t) { return this.applyMatrix3(t).normalize() }
                    applyMatrix4(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.elements,
                            s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                        return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s, this
                    }
                    applyQuaternion(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.x,
                            s = t.y,
                            o = t.z,
                            a = t.w,
                            l = a * e + s * i - o * n,
                            c = a * n + o * e - r * i,
                            h = a * i + r * n - s * e,
                            u = -r * e - s * n - o * i;
                        return this.x = l * a + u * -r + c * -o - h * -s, this.y = c * a + u * -s + h * -r - l * -o, this.z = h * a + u * -o + l * -s - c * -r, this
                    }
                    project(t) { return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix) }
                    unproject(t) { return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld) }
                    transformDirection(t) {
                        const e = this.x,
                            n = this.y,
                            i = this.z,
                            r = t.elements;
                        return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
                    }
                    divide(t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this }
                    divideScalar(t) { return this.multiplyScalar(1 / t) }
                    min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this }
                    max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this }
                    clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this }
                    clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this }
                    clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }
                    floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this }
                    ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this }
                    round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this }
                    roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this }
                    negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }
                    dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z }
                    lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z }
                    length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }
                    manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }
                    normalize() { return this.divideScalar(this.length() || 1) }
                    setLength(t) { return this.normalize().multiplyScalar(t) }
                    lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this }
                    lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this }
                    cross(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t) }
                    crossVectors(t, e) {
                        const n = t.x,
                            i = t.y,
                            r = t.z,
                            s = e.x,
                            o = e.y,
                            a = e.z;
                        return this.x = i * a - r * o, this.y = r * s - n * a, this.z = n * o - i * s, this
                    }
                    projectOnVector(t) { const e = t.lengthSq(); if (0 === e) return this.set(0, 0, 0); const n = t.dot(this) / e; return this.copy(t).multiplyScalar(n) }
                    projectOnPlane(t) { return mi.copy(this).projectOnVector(t), this.sub(mi) }
                    reflect(t) { return this.sub(mi.copy(t).multiplyScalar(2 * this.dot(t))) }
                    angleTo(t) { const e = Math.sqrt(this.lengthSq() * t.lengthSq()); if (0 === e) return Math.PI / 2; const n = this.dot(t) / e; return Math.acos(Vn(n, -1, 1)) }
                    distanceTo(t) { return Math.sqrt(this.distanceToSquared(t)) }
                    distanceToSquared(t) {
                        const e = this.x - t.x,
                            n = this.y - t.y,
                            i = this.z - t.z;
                        return e * e + n * n + i * i
                    }
                    manhattanDistanceTo(t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z) }
                    setFromSpherical(t) { return this.setFromSphericalCoords(t.radius, t.phi, t.theta) }
                    setFromSphericalCoords(t, e, n) { const i = Math.sin(e) * t; return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this }
                    setFromCylindrical(t) { return this.setFromCylindricalCoords(t.radius, t.theta, t.y) }
                    setFromCylindricalCoords(t, e, n) { return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this }
                    setFromMatrixPosition(t) { const e = t.elements; return this.x = e[12], this.y = e[13], this.z = e[14], this }
                    setFromMatrixScale(t) {
                        const e = this.setFromMatrixColumn(t, 0).length(),
                            n = this.setFromMatrixColumn(t, 1).length(),
                            i = this.setFromMatrixColumn(t, 2).length();
                        return this.x = e, this.y = n, this.z = i, this
                    }
                    setFromMatrixColumn(t, e) { return this.fromArray(t.elements, 4 * e) }
                    setFromMatrix3Column(t, e) { return this.fromArray(t.elements, 3 * e) }
                    equals(t) { return t.x === this.x && t.y === this.y && t.z === this.z }
                    fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this }
                    toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t }
                    fromBufferAttribute(t, e, n) { return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this }
                    random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this }
                    randomDirection() {
                        const t = 2 * (Math.random() - .5),
                            e = Math.random() * Math.PI * 2,
                            n = Math.sqrt(1 - t ** 2);
                        return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this
                    } * [Symbol.iterator]() { yield this.x, yield this.y, yield this.z }
                }
                pi.prototype.isVector3 = !0;
                const mi = new pi,
                    fi = new di;
                class gi {
                    constructor(t = new pi(1 / 0, 1 / 0, 1 / 0), e = new pi(-1 / 0, -1 / 0, -1 / 0)) { this.min = t, this.max = e }
                    set(t, e) { return this.min.copy(t), this.max.copy(e), this }
                    setFromArray(t) {
                        let e = 1 / 0,
                            n = 1 / 0,
                            i = 1 / 0,
                            r = -1 / 0,
                            s = -1 / 0,
                            o = -1 / 0;
                        for (let a = 0, l = t.length; a < l; a += 3) {
                            const l = t[a],
                                c = t[a + 1],
                                h = t[a + 2];
                            l < e && (e = l), c < n && (n = c), h < i && (i = h), l > r && (r = l), c > s && (s = c), h > o && (o = h)
                        }
                        return this.min.set(e, n, i), this.max.set(r, s, o), this
                    }
                    setFromBufferAttribute(t) {
                        let e = 1 / 0,
                            n = 1 / 0,
                            i = 1 / 0,
                            r = -1 / 0,
                            s = -1 / 0,
                            o = -1 / 0;
                        for (let a = 0, l = t.count; a < l; a++) {
                            const l = t.getX(a),
                                c = t.getY(a),
                                h = t.getZ(a);
                            l < e && (e = l), c < n && (n = c), h < i && (i = h), l > r && (r = l), c > s && (s = c), h > o && (o = h)
                        }
                        return this.min.set(e, n, i), this.max.set(r, s, o), this
                    }
                    setFromPoints(t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]); return this }
                    setFromCenterAndSize(t, e) { const n = yi.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this }
                    setFromObject(t) { return this.makeEmpty(), this.expandByObject(t) }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { return this.min.copy(t.min), this.max.copy(t.max), this }
                    makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this }
                    isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z }
                    getCenter(t) { return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) }
                    getSize(t) { return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min) }
                    expandByPoint(t) { return this.min.min(t), this.max.max(t), this }
                    expandByVector(t) { return this.min.sub(t), this.max.add(t), this }
                    expandByScalar(t) { return this.min.addScalar(-t), this.max.addScalar(t), this }
                    expandByObject(t) {
                        t.updateWorldMatrix(!1, !1);
                        const e = t.geometry;
                        void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), xi.copy(e.boundingBox), xi.applyMatrix4(t.matrixWorld), this.union(xi));
                        const n = t.children;
                        for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);
                        return this
                    }
                    containsPoint(t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z) }
                    containsBox(t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z }
                    getParameter(t, e) { return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z)) }
                    intersectsBox(t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z) }
                    intersectsSphere(t) { return this.clampPoint(t.center, yi), yi.distanceToSquared(t.center) <= t.radius * t.radius }
                    intersectsPlane(t) { let e, n; return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant }
                    intersectsTriangle(t) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(Ei), Ai.subVectors(this.max, Ei), _i.subVectors(t.a, Ei), bi.subVectors(t.b, Ei), wi.subVectors(t.c, Ei), Mi.subVectors(bi, _i), Si.subVectors(wi, bi), Ti.subVectors(_i, wi);
                        let e = [0, -Mi.z, Mi.y, 0, -Si.z, Si.y, 0, -Ti.z, Ti.y, Mi.z, 0, -Mi.x, Si.z, 0, -Si.x, Ti.z, 0, -Ti.x, -Mi.y, Mi.x, 0, -Si.y, Si.x, 0, -Ti.y, Ti.x, 0];
                        return !!Ci(e, _i, bi, wi, Ai) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Ci(e, _i, bi, wi, Ai) && (Li.crossVectors(Mi, Si), e = [Li.x, Li.y, Li.z], Ci(e, _i, bi, wi, Ai)))
                    }
                    clampPoint(t, e) { return e.copy(t).clamp(this.min, this.max) }
                    distanceToPoint(t) { return yi.copy(t).clamp(this.min, this.max).sub(t).length() }
                    getBoundingSphere(t) { return this.getCenter(t.center), t.radius = .5 * this.getSize(yi).length(), t }
                    intersect(t) { return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this }
                    union(t) { return this.min.min(t.min), this.max.max(t.max), this }
                    applyMatrix4(t) { return this.isEmpty() || (vi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), vi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), vi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), vi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), vi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), vi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), vi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), vi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(vi)), this }
                    translate(t) { return this.min.add(t), this.max.add(t), this }
                    equals(t) { return t.min.equals(this.min) && t.max.equals(this.max) }
                }
                gi.prototype.isBox3 = !0;
                const vi = [new pi, new pi, new pi, new pi, new pi, new pi, new pi, new pi],
                    yi = new pi,
                    xi = new gi,
                    _i = new pi,
                    bi = new pi,
                    wi = new pi,
                    Mi = new pi,
                    Si = new pi,
                    Ti = new pi,
                    Ei = new pi,
                    Ai = new pi,
                    Li = new pi,
                    Ri = new pi;

                function Ci(t, e, n, i, r) {
                    for (let s = 0, o = t.length - 3; s <= o; s += 3) {
                        Ri.fromArray(t, s);
                        const o = r.x * Math.abs(Ri.x) + r.y * Math.abs(Ri.y) + r.z * Math.abs(Ri.z),
                            a = e.dot(Ri),
                            l = n.dot(Ri),
                            c = i.dot(Ri);
                        if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1
                    }
                    return !0
                }
                const Pi = new gi,
                    Ii = new pi,
                    Di = new pi,
                    Ni = new pi;
                class Bi {
                    constructor(t = new pi, e = -1) { this.center = t, this.radius = e }
                    set(t, e) { return this.center.copy(t), this.radius = e, this }
                    setFromPoints(t, e) {
                        const n = this.center;
                        void 0 !== e ? n.copy(e) : Pi.setFromPoints(t).getCenter(n);
                        let i = 0;
                        for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
                        return this.radius = Math.sqrt(i), this
                    }
                    copy(t) { return this.center.copy(t.center), this.radius = t.radius, this }
                    isEmpty() { return this.radius < 0 }
                    makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this }
                    containsPoint(t) { return t.distanceToSquared(this.center) <= this.radius * this.radius }
                    distanceToPoint(t) { return t.distanceTo(this.center) - this.radius }
                    intersectsSphere(t) { const e = this.radius + t.radius; return t.center.distanceToSquared(this.center) <= e * e }
                    intersectsBox(t) { return t.intersectsSphere(this) }
                    intersectsPlane(t) { return Math.abs(t.distanceToPoint(this.center)) <= this.radius }
                    clampPoint(t, e) { const n = this.center.distanceToSquared(t); return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e }
                    getBoundingBox(t) { return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t) }
                    applyMatrix4(t) { return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this }
                    translate(t) { return this.center.add(t), this }
                    expandByPoint(t) {
                        Ni.subVectors(t, this.center);
                        const e = Ni.lengthSq();
                        if (e > this.radius * this.radius) {
                            const t = Math.sqrt(e),
                                n = .5 * (t - this.radius);
                            this.center.add(Ni.multiplyScalar(n / t)), this.radius += n
                        }
                        return this
                    }
                    union(t) { return Di.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(Ii.copy(t.center).add(Di)), this.expandByPoint(Ii.copy(t.center).sub(Di)), this }
                    equals(t) { return t.center.equals(this.center) && t.radius === this.radius }
                    clone() { return (new this.constructor).copy(this) }
                }
                const Oi = new pi,
                    Fi = new pi,
                    zi = new pi,
                    Ui = new pi,
                    Hi = new pi,
                    ki = new pi,
                    Gi = new pi;
                class Vi {
                    constructor(t = new pi, e = new pi(0, 0, -1)) { this.origin = t, this.direction = e }
                    set(t, e) { return this.origin.copy(t), this.direction.copy(e), this }
                    copy(t) { return this.origin.copy(t.origin), this.direction.copy(t.direction), this }
                    at(t, e) { return e.copy(this.direction).multiplyScalar(t).add(this.origin) }
                    lookAt(t) { return this.direction.copy(t).sub(this.origin).normalize(), this }
                    recast(t) { return this.origin.copy(this.at(t, Oi)), this }
                    closestPointToPoint(t, e) { e.subVectors(t, this.origin); const n = e.dot(this.direction); return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin) }
                    distanceToPoint(t) { return Math.sqrt(this.distanceSqToPoint(t)) }
                    distanceSqToPoint(t) { const e = Oi.subVectors(t, this.origin).dot(this.direction); return e < 0 ? this.origin.distanceToSquared(t) : (Oi.copy(this.direction).multiplyScalar(e).add(this.origin), Oi.distanceToSquared(t)) }
                    distanceSqToSegment(t, e, n, i) {
                        Fi.copy(t).add(e).multiplyScalar(.5), zi.copy(e).sub(t).normalize(), Ui.copy(this.origin).sub(Fi);
                        const r = .5 * t.distanceTo(e),
                            s = -this.direction.dot(zi),
                            o = Ui.dot(this.direction),
                            a = -Ui.dot(zi),
                            l = Ui.lengthSq(),
                            c = Math.abs(1 - s * s);
                        let h, u, d, p;
                        if (c > 0)
                            if (h = s * a - o, u = s * o - a, p = r * c, h >= 0)
                                if (u >= -p)
                                    if (u <= p) {
                                        const t = 1 / c;
                                        h *= t, u *= t, d = h * (h + s * u + 2 * o) + u * (s * h + u + 2 * a) + l
                                    } else u = r, h = Math.max(0, -(s * u + o)), d = -h * h + u * (u + 2 * a) + l;
                        else u = -r, h = Math.max(0, -(s * u + o)), d = -h * h + u * (u + 2 * a) + l;
                        else u <= -p ? (h = Math.max(0, -(-s * r + o)), u = h > 0 ? -r : Math.min(Math.max(-r, -a), r), d = -h * h + u * (u + 2 * a) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-r, -a), r), d = u * (u + 2 * a) + l) : (h = Math.max(0, -(s * r + o)), u = h > 0 ? r : Math.min(Math.max(-r, -a), r), d = -h * h + u * (u + 2 * a) + l);
                        else u = s > 0 ? -r : r, h = Math.max(0, -(s * u + o)), d = -h * h + u * (u + 2 * a) + l;
                        return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(zi).multiplyScalar(u).add(Fi), d
                    }
                    intersectSphere(t, e) {
                        Oi.subVectors(t.center, this.origin);
                        const n = Oi.dot(this.direction),
                            i = Oi.dot(Oi) - n * n,
                            r = t.radius * t.radius;
                        if (i > r) return null;
                        const s = Math.sqrt(r - i),
                            o = n - s,
                            a = n + s;
                        return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e)
                    }
                    intersectsSphere(t) { return this.distanceSqToPoint(t.center) <= t.radius * t.radius }
                    distanceToPlane(t) { const e = t.normal.dot(this.direction); if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null; const n = -(this.origin.dot(t.normal) + t.constant) / e; return n >= 0 ? n : null }
                    intersectPlane(t, e) { const n = this.distanceToPlane(t); return null === n ? null : this.at(n, e) }
                    intersectsPlane(t) { const e = t.distanceToPoint(this.origin); return 0 === e || t.normal.dot(this.direction) * e < 0 }
                    intersectBox(t, e) {
                        let n, i, r, s, o, a;
                        const l = 1 / this.direction.x,
                            c = 1 / this.direction.y,
                            h = 1 / this.direction.z,
                            u = this.origin;
                        return l >= 0 ? (n = (t.min.x - u.x) * l, i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, i = (t.min.x - u.x) * l), c >= 0 ? (r = (t.min.y - u.y) * c, s = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c, s = (t.min.y - u.y) * c), n > s || r > i ? null : ((r > n || n != n) && (n = r), (s < i || i != i) && (i = s), h >= 0 ? (o = (t.min.z - u.z) * h, a = (t.max.z - u.z) * h) : (o = (t.max.z - u.z) * h, a = (t.min.z - u.z) * h), n > a || o > i ? null : ((o > n || n != n) && (n = o), (a < i || i != i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
                    }
                    intersectsBox(t) { return null !== this.intersectBox(t, Oi) }
                    intersectTriangle(t, e, n, i, r) {
                        Hi.subVectors(e, t), ki.subVectors(n, t), Gi.crossVectors(Hi, ki);
                        let s, o = this.direction.dot(Gi);
                        if (o > 0) {
                            if (i) return null;
                            s = 1
                        } else {
                            if (!(o < 0)) return null;
                            s = -1, o = -o
                        }
                        Ui.subVectors(this.origin, t);
                        const a = s * this.direction.dot(ki.crossVectors(Ui, ki));
                        if (a < 0) return null;
                        const l = s * this.direction.dot(Hi.cross(Ui));
                        if (l < 0) return null;
                        if (a + l > o) return null;
                        const c = -s * Ui.dot(Gi);
                        return c < 0 ? null : this.at(c / o, r)
                    }
                    applyMatrix4(t) { return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this }
                    equals(t) { return t.origin.equals(this.origin) && t.direction.equals(this.direction) }
                    clone() { return (new this.constructor).copy(this) }
                }
                class Wi {
                    constructor() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") }
                    set(t, e, n, i, r, s, o, a, l, c, h, u, d, p, m, f) { const g = this.elements; return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = o, g[13] = a, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = m, g[15] = f, this }
                    identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }
                    clone() { return (new Wi).fromArray(this.elements) }
                    copy(t) {
                        const e = this.elements,
                            n = t.elements;
                        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
                    }
                    copyPosition(t) {
                        const e = this.elements,
                            n = t.elements;
                        return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
                    }
                    setFromMatrix3(t) { const e = t.elements; return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this }
                    extractBasis(t, e, n) { return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this }
                    makeBasis(t, e, n) { return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this }
                    extractRotation(t) {
                        const e = this.elements,
                            n = t.elements,
                            i = 1 / ji.setFromMatrixColumn(t, 0).length(),
                            r = 1 / ji.setFromMatrixColumn(t, 1).length(),
                            s = 1 / ji.setFromMatrixColumn(t, 2).length();
                        return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                    }
                    makeRotationFromEuler(t) {
                        t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                        const e = this.elements,
                            n = t.x,
                            i = t.y,
                            r = t.z,
                            s = Math.cos(n),
                            o = Math.sin(n),
                            a = Math.cos(i),
                            l = Math.sin(i),
                            c = Math.cos(r),
                            h = Math.sin(r);
                        if ("XYZ" === t.order) {
                            const t = s * c,
                                n = s * h,
                                i = o * c,
                                r = o * h;
                            e[0] = a * c, e[4] = -a * h, e[8] = l, e[1] = n + i * l, e[5] = t - r * l, e[9] = -o * a, e[2] = r - t * l, e[6] = i + n * l, e[10] = s * a
                        } else if ("YXZ" === t.order) {
                            const t = a * c,
                                n = a * h,
                                i = l * c,
                                r = l * h;
                            e[0] = t + r * o, e[4] = i * o - n, e[8] = s * l, e[1] = s * h, e[5] = s * c, e[9] = -o, e[2] = n * o - i, e[6] = r + t * o, e[10] = s * a
                        } else if ("ZXY" === t.order) {
                            const t = a * c,
                                n = a * h,
                                i = l * c,
                                r = l * h;
                            e[0] = t - r * o, e[4] = -s * h, e[8] = i + n * o, e[1] = n + i * o, e[5] = s * c, e[9] = r - t * o, e[2] = -s * l, e[6] = o, e[10] = s * a
                        } else if ("ZYX" === t.order) {
                            const t = s * c,
                                n = s * h,
                                i = o * c,
                                r = o * h;
                            e[0] = a * c, e[4] = i * l - n, e[8] = t * l + r, e[1] = a * h, e[5] = r * l + t, e[9] = n * l - i, e[2] = -l, e[6] = o * a, e[10] = s * a
                        } else if ("YZX" === t.order) {
                            const t = s * a,
                                n = s * l,
                                i = o * a,
                                r = o * l;
                            e[0] = a * c, e[4] = r - t * h, e[8] = i * h + n, e[1] = h, e[5] = s * c, e[9] = -o * c, e[2] = -l * c, e[6] = n * h + i, e[10] = t - r * h
                        } else if ("XZY" === t.order) {
                            const t = s * a,
                                n = s * l,
                                i = o * a,
                                r = o * l;
                            e[0] = a * c, e[4] = -h, e[8] = l * c, e[1] = t * h + r, e[5] = s * c, e[9] = n * h - i, e[2] = i * h - n, e[6] = o * c, e[10] = r * h + t
                        }
                        return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                    }
                    makeRotationFromQuaternion(t) { return this.compose(Xi, t, Yi) }
                    lookAt(t, e, n) { const i = this.elements; return Ki.subVectors(t, e), 0 === Ki.lengthSq() && (Ki.z = 1), Ki.normalize(), Zi.crossVectors(n, Ki), 0 === Zi.lengthSq() && (1 === Math.abs(n.z) ? Ki.x += 1e-4 : Ki.z += 1e-4, Ki.normalize(), Zi.crossVectors(n, Ki)), Zi.normalize(), Ji.crossVectors(Ki, Zi), i[0] = Zi.x, i[4] = Ji.x, i[8] = Ki.x, i[1] = Zi.y, i[5] = Ji.y, i[9] = Ki.y, i[2] = Zi.z, i[6] = Ji.z, i[10] = Ki.z, this }
                    multiply(t, e) { return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t) }
                    premultiply(t) { return this.multiplyMatrices(t, this) }
                    multiplyMatrices(t, e) {
                        const n = t.elements,
                            i = e.elements,
                            r = this.elements,
                            s = n[0],
                            o = n[4],
                            a = n[8],
                            l = n[12],
                            c = n[1],
                            h = n[5],
                            u = n[9],
                            d = n[13],
                            p = n[2],
                            m = n[6],
                            f = n[10],
                            g = n[14],
                            v = n[3],
                            y = n[7],
                            x = n[11],
                            _ = n[15],
                            b = i[0],
                            w = i[4],
                            M = i[8],
                            S = i[12],
                            T = i[1],
                            E = i[5],
                            A = i[9],
                            L = i[13],
                            R = i[2],
                            C = i[6],
                            P = i[10],
                            I = i[14],
                            D = i[3],
                            N = i[7],
                            B = i[11],
                            O = i[15];
                        return r[0] = s * b + o * T + a * R + l * D, r[4] = s * w + o * E + a * C + l * N, r[8] = s * M + o * A + a * P + l * B, r[12] = s * S + o * L + a * I + l * O, r[1] = c * b + h * T + u * R + d * D, r[5] = c * w + h * E + u * C + d * N, r[9] = c * M + h * A + u * P + d * B, r[13] = c * S + h * L + u * I + d * O, r[2] = p * b + m * T + f * R + g * D, r[6] = p * w + m * E + f * C + g * N, r[10] = p * M + m * A + f * P + g * B, r[14] = p * S + m * L + f * I + g * O, r[3] = v * b + y * T + x * R + _ * D, r[7] = v * w + y * E + x * C + _ * N, r[11] = v * M + y * A + x * P + _ * B, r[15] = v * S + y * L + x * I + _ * O, this
                    }
                    multiplyScalar(t) { const e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this }
                    determinant() {
                        const t = this.elements,
                            e = t[0],
                            n = t[4],
                            i = t[8],
                            r = t[12],
                            s = t[1],
                            o = t[5],
                            a = t[9],
                            l = t[13],
                            c = t[2],
                            h = t[6],
                            u = t[10],
                            d = t[14];
                        return t[3] * (+r * a * h - i * l * h - r * o * u + n * l * u + i * o * d - n * a * d) + t[7] * (+e * a * d - e * l * u + r * s * u - i * s * d + i * l * c - r * a * c) + t[11] * (+e * l * h - e * o * d - r * s * h + n * s * d + r * o * c - n * l * c) + t[15] * (-i * o * c - e * a * h + e * o * u + i * s * h - n * s * u + n * a * c)
                    }
                    transpose() { const t = this.elements; let e; return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this }
                    setPosition(t, e, n) { const i = this.elements; return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this }
                    invert() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            i = t[2],
                            r = t[3],
                            s = t[4],
                            o = t[5],
                            a = t[6],
                            l = t[7],
                            c = t[8],
                            h = t[9],
                            u = t[10],
                            d = t[11],
                            p = t[12],
                            m = t[13],
                            f = t[14],
                            g = t[15],
                            v = h * f * l - m * u * l + m * a * d - o * f * d - h * a * g + o * u * g,
                            y = p * u * l - c * f * l - p * a * d + s * f * d + c * a * g - s * u * g,
                            x = c * m * l - p * h * l + p * o * d - s * m * d - c * o * g + s * h * g,
                            _ = p * h * a - c * m * a - p * o * u + s * m * u + c * o * f - s * h * f,
                            b = e * v + n * y + i * x + r * _;
                        if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const w = 1 / b;
                        return t[0] = v * w, t[1] = (m * u * r - h * f * r - m * i * d + n * f * d + h * i * g - n * u * g) * w, t[2] = (o * f * r - m * a * r + m * i * l - n * f * l - o * i * g + n * a * g) * w, t[3] = (h * a * r - o * u * r - h * i * l + n * u * l + o * i * d - n * a * d) * w, t[4] = y * w, t[5] = (c * f * r - p * u * r + p * i * d - e * f * d - c * i * g + e * u * g) * w, t[6] = (p * a * r - s * f * r - p * i * l + e * f * l + s * i * g - e * a * g) * w, t[7] = (s * u * r - c * a * r + c * i * l - e * u * l - s * i * d + e * a * d) * w, t[8] = x * w, t[9] = (p * h * r - c * m * r - p * n * d + e * m * d + c * n * g - e * h * g) * w, t[10] = (s * m * r - p * o * r + p * n * l - e * m * l - s * n * g + e * o * g) * w, t[11] = (c * o * r - s * h * r - c * n * l + e * h * l + s * n * d - e * o * d) * w, t[12] = _ * w, t[13] = (c * m * i - p * h * i + p * n * u - e * m * u - c * n * f + e * h * f) * w, t[14] = (p * o * i - s * m * i - p * n * a + e * m * a + s * n * f - e * o * f) * w, t[15] = (s * h * i - c * o * i + c * n * a - e * h * a - s * n * u + e * o * u) * w, this
                    }
                    scale(t) {
                        const e = this.elements,
                            n = t.x,
                            i = t.y,
                            r = t.z;
                        return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
                    }
                    getMaxScaleOnAxis() {
                        const t = this.elements,
                            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                            i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                        return Math.sqrt(Math.max(e, n, i))
                    }
                    makeTranslation(t, e, n) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this }
                    makeRotationX(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
                    }
                    makeRotationY(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
                    }
                    makeRotationZ(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                    }
                    makeRotationAxis(t, e) {
                        const n = Math.cos(e),
                            i = Math.sin(e),
                            r = 1 - n,
                            s = t.x,
                            o = t.y,
                            a = t.z,
                            l = r * s,
                            c = r * o;
                        return this.set(l * s + n, l * o - i * a, l * a + i * o, 0, l * o + i * a, c * o + n, c * a - i * s, 0, l * a - i * o, c * a + i * s, r * a * a + n, 0, 0, 0, 0, 1), this
                    }
                    makeScale(t, e, n) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this }
                    makeShear(t, e, n, i, r, s) { return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this }
                    compose(t, e, n) {
                        const i = this.elements,
                            r = e._x,
                            s = e._y,
                            o = e._z,
                            a = e._w,
                            l = r + r,
                            c = s + s,
                            h = o + o,
                            u = r * l,
                            d = r * c,
                            p = r * h,
                            m = s * c,
                            f = s * h,
                            g = o * h,
                            v = a * l,
                            y = a * c,
                            x = a * h,
                            _ = n.x,
                            b = n.y,
                            w = n.z;
                        return i[0] = (1 - (m + g)) * _, i[1] = (d + x) * _, i[2] = (p - y) * _, i[3] = 0, i[4] = (d - x) * b, i[5] = (1 - (u + g)) * b, i[6] = (f + v) * b, i[7] = 0, i[8] = (p + y) * w, i[9] = (f - v) * w, i[10] = (1 - (u + m)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
                    }
                    decompose(t, e, n) {
                        const i = this.elements;
                        let r = ji.set(i[0], i[1], i[2]).length();
                        const s = ji.set(i[4], i[5], i[6]).length(),
                            o = ji.set(i[8], i[9], i[10]).length();
                        this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], qi.copy(this);
                        const a = 1 / r,
                            l = 1 / s,
                            c = 1 / o;
                        return qi.elements[0] *= a, qi.elements[1] *= a, qi.elements[2] *= a, qi.elements[4] *= l, qi.elements[5] *= l, qi.elements[6] *= l, qi.elements[8] *= c, qi.elements[9] *= c, qi.elements[10] *= c, e.setFromRotationMatrix(qi), n.x = r, n.y = s, n.z = o, this
                    }
                    makePerspective(t, e, n, i, r, s) {
                        void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                        const o = this.elements,
                            a = 2 * r / (e - t),
                            l = 2 * r / (n - i),
                            c = (e + t) / (e - t),
                            h = (n + i) / (n - i),
                            u = -(s + r) / (s - r),
                            d = -2 * s * r / (s - r);
                        return o[0] = a, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = h, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
                    }
                    makeOrthographic(t, e, n, i, r, s) {
                        const o = this.elements,
                            a = 1 / (e - t),
                            l = 1 / (n - i),
                            c = 1 / (s - r),
                            h = (e + t) * a,
                            u = (n + i) * l,
                            d = (s + r) * c;
                        return o[0] = 2 * a, o[4] = 0, o[8] = 0, o[12] = -h, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
                    }
                    equals(t) {
                        const e = this.elements,
                            n = t.elements;
                        for (let t = 0; t < 16; t++)
                            if (e[t] !== n[t]) return !1;
                        return !0
                    }
                    fromArray(t, e = 0) { for (let n = 0; n < 16; n++) this.elements[n] = t[n + e]; return this }
                    toArray(t = [], e = 0) { const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t }
                }
                Wi.prototype.isMatrix4 = !0;
                const ji = new pi,
                    qi = new Wi,
                    Xi = new pi(0, 0, 0),
                    Yi = new pi(1, 1, 1),
                    Zi = new pi,
                    Ji = new pi,
                    Ki = new pi,
                    Qi = new Wi,
                    $i = new di;
                class tr {
                    constructor(t = 0, e = 0, n = 0, i = tr.DefaultOrder) { this._x = t, this._y = e, this._z = n, this._order = i }
                    get x() { return this._x }
                    set x(t) { this._x = t, this._onChangeCallback() }
                    get y() { return this._y }
                    set y(t) { this._y = t, this._onChangeCallback() }
                    get z() { return this._z }
                    set z(t) { this._z = t, this._onChangeCallback() }
                    get order() { return this._order }
                    set order(t) { this._order = t, this._onChangeCallback() }
                    set(t, e, n, i = this._order) { return this._x = t, this._y = e, this._z = n, this._order = i, this._onChangeCallback(), this }
                    clone() { return new this.constructor(this._x, this._y, this._z, this._order) }
                    copy(t) { return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this }
                    setFromRotationMatrix(t, e = this._order, n = !0) {
                        const i = t.elements,
                            r = i[0],
                            s = i[4],
                            o = i[8],
                            a = i[1],
                            l = i[5],
                            c = i[9],
                            h = i[2],
                            u = i[6],
                            d = i[10];
                        switch (e) {
                            case "XYZ":
                                this._y = Math.asin(Vn(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                                break;
                            case "YXZ":
                                this._x = Math.asin(-Vn(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
                                break;
                            case "ZXY":
                                this._x = Math.asin(Vn(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(a, r));
                                break;
                            case "ZYX":
                                this._y = Math.asin(-Vn(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(a, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
                                break;
                            case "YZX":
                                this._z = Math.asin(Vn(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(o, d));
                                break;
                            case "XZY":
                                this._z = Math.asin(-Vn(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
                                break;
                            default:
                                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                        }
                        return this._order = e, !0 === n && this._onChangeCallback(), this
                    }
                    setFromQuaternion(t, e, n) { return Qi.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Qi, e, n) }
                    setFromVector3(t, e = this._order) { return this.set(t.x, t.y, t.z, e) }
                    reorder(t) { return $i.setFromEuler(this), this.setFromQuaternion($i, t) }
                    equals(t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order }
                    fromArray(t) { return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this }
                    toArray(t = [], e = 0) { return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t }
                    toVector3(t) { return t ? t.set(this._x, this._y, this._z) : new pi(this._x, this._y, this._z) }
                    _onChange(t) { return this._onChangeCallback = t, this }
                    _onChangeCallback() {}
                }
                tr.prototype.isEuler = !0, tr.DefaultOrder = "XYZ", tr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
                class er {
                    constructor() { this.mask = 1 }
                    set(t) { this.mask = 1 << t | 0 }
                    enable(t) { this.mask |= 1 << t | 0 }
                    enableAll() { this.mask = -1 }
                    toggle(t) { this.mask ^= 1 << t | 0 }
                    disable(t) { this.mask &= ~(1 << t | 0) }
                    disableAll() { this.mask = 0 }
                    test(t) { return 0 != (this.mask & t.mask) }
                }
                let nr = 0;
                const ir = new pi,
                    rr = new di,
                    sr = new Wi,
                    or = new pi,
                    ar = new pi,
                    lr = new pi,
                    cr = new di,
                    hr = new pi(1, 0, 0),
                    ur = new pi(0, 1, 0),
                    dr = new pi(0, 0, 1),
                    pr = { type: "added" },
                    mr = { type: "removed" };
                class fr extends On {
                    constructor() {
                        super(), Object.defineProperty(this, "id", { value: nr++ }), this.uuid = Gn(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = fr.DefaultUp.clone();
                        const t = new pi,
                            e = new tr,
                            n = new di,
                            i = new pi(1, 1, 1);
                        e._onChange((function() { n.setFromEuler(e, !1) })), n._onChange((function() { e.setFromQuaternion(n, void 0, !1) })), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: i }, modelViewMatrix: { value: new Wi }, normalMatrix: { value: new Kn } }), this.matrix = new Wi, this.matrixWorld = new Wi, this.matrixAutoUpdate = fr.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new er, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                    }
                    onBeforeRender() {}
                    onAfterRender() {}
                    applyMatrix4(t) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale) }
                    applyQuaternion(t) { return this.quaternion.premultiply(t), this }
                    setRotationFromAxisAngle(t, e) { this.quaternion.setFromAxisAngle(t, e) }
                    setRotationFromEuler(t) { this.quaternion.setFromEuler(t, !0) }
                    setRotationFromMatrix(t) { this.quaternion.setFromRotationMatrix(t) }
                    setRotationFromQuaternion(t) { this.quaternion.copy(t) }
                    rotateOnAxis(t, e) { return rr.setFromAxisAngle(t, e), this.quaternion.multiply(rr), this }
                    rotateOnWorldAxis(t, e) { return rr.setFromAxisAngle(t, e), this.quaternion.premultiply(rr), this }
                    rotateX(t) { return this.rotateOnAxis(hr, t) }
                    rotateY(t) { return this.rotateOnAxis(ur, t) }
                    rotateZ(t) { return this.rotateOnAxis(dr, t) }
                    translateOnAxis(t, e) { return ir.copy(t).applyQuaternion(this.quaternion), this.position.add(ir.multiplyScalar(e)), this }
                    translateX(t) { return this.translateOnAxis(hr, t) }
                    translateY(t) { return this.translateOnAxis(ur, t) }
                    translateZ(t) { return this.translateOnAxis(dr, t) }
                    localToWorld(t) { return t.applyMatrix4(this.matrixWorld) }
                    worldToLocal(t) { return t.applyMatrix4(sr.copy(this.matrixWorld).invert()) }
                    lookAt(t, e, n) {
                        t.isVector3 ? or.copy(t) : or.set(t, e, n);
                        const i = this.parent;
                        this.updateWorldMatrix(!0, !1), ar.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? sr.lookAt(ar, or, this.up) : sr.lookAt(or, ar, this.up), this.quaternion.setFromRotationMatrix(sr), i && (sr.extractRotation(i.matrixWorld), rr.setFromRotationMatrix(sr), this.quaternion.premultiply(rr.invert()))
                    }
                    add(t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++) this.add(arguments[t]); return this } return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(pr)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this) }
                    remove(t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]); return this } const e = this.children.indexOf(t); return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(mr)), this }
                    removeFromParent() { const t = this.parent; return null !== t && t.remove(this), this }
                    clear() {
                        for (let t = 0; t < this.children.length; t++) {
                            const e = this.children[t];
                            e.parent = null, e.dispatchEvent(mr)
                        }
                        return this.children.length = 0, this
                    }
                    attach(t) { return this.updateWorldMatrix(!0, !1), sr.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), sr.multiply(t.parent.matrixWorld)), t.applyMatrix4(sr), this.add(t), t.updateWorldMatrix(!1, !0), this }
                    getObjectById(t) { return this.getObjectByProperty("id", t) }
                    getObjectByName(t) { return this.getObjectByProperty("name", t) }
                    getObjectByProperty(t, e) { if (this[t] === e) return this; for (let n = 0, i = this.children.length; n < i; n++) { const i = this.children[n].getObjectByProperty(t, e); if (void 0 !== i) return i } }
                    getWorldPosition(t) { return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld) }
                    getWorldQuaternion(t) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ar, t, lr), t }
                    getWorldScale(t) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ar, cr, t), t }
                    getWorldDirection(t) { this.updateWorldMatrix(!0, !1); const e = this.matrixWorld.elements; return t.set(e[8], e[9], e[10]).normalize() }
                    raycast() {}
                    traverse(t) { t(this); const e = this.children; for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t) }
                    traverseVisible(t) {
                        if (!1 === this.visible) return;
                        t(this);
                        const e = this.children;
                        for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
                    }
                    traverseAncestors(t) {
                        const e = this.parent;
                        null !== e && (t(e), e.traverseAncestors(t))
                    }
                    updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 }
                    updateMatrixWorld(t) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0); const e = this.children; for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t) }
                    updateWorldMatrix(t, e) { const n = this.parent; if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) { const t = this.children; for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0) } }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t,
                            n = {};
                        e && (t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
                        const i = {};

                        function r(e, n) { return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid }
                        if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && (i.environment = this.environment.toJSON(t).uuid);
                        else if (this.isMesh || this.isLine || this.isPoints) {
                            i.geometry = r(t.geometries, this.geometry);
                            const e = this.geometry.parameters;
                            if (void 0 !== e && void 0 !== e.shapes) {
                                const n = e.shapes;
                                if (Array.isArray(n))
                                    for (let e = 0, i = n.length; e < i; e++) {
                                        const i = n[e];
                                        r(t.shapes, i)
                                    } else r(t.shapes, n)
                            }
                        }
                        if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                            if (Array.isArray(this.material)) {
                                const e = [];
                                for (let n = 0, i = this.material.length; n < i; n++) e.push(r(t.materials, this.material[n]));
                                i.material = e
                            } else i.material = r(t.materials, this.material);
                        if (this.children.length > 0) { i.children = []; for (let e = 0; e < this.children.length; e++) i.children.push(this.children[e].toJSON(t).object) }
                        if (this.animations.length > 0) {
                            i.animations = [];
                            for (let e = 0; e < this.animations.length; e++) {
                                const n = this.animations[e];
                                i.animations.push(r(t.animations, n))
                            }
                        }
                        if (e) {
                            const e = s(t.geometries),
                                i = s(t.materials),
                                r = s(t.textures),
                                o = s(t.images),
                                a = s(t.shapes),
                                l = s(t.skeletons),
                                c = s(t.animations);
                            e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o), a.length > 0 && (n.shapes = a), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c)
                        }
                        return n.object = i, n;

                        function s(t) {
                            const e = [];
                            for (const n in t) {
                                const i = t[n];
                                delete i.metadata, e.push(i)
                            }
                            return e
                        }
                    }
                    clone(t) { return (new this.constructor).copy(this, t) }
                    copy(t, e = !0) {
                        if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                            for (let e = 0; e < t.children.length; e++) {
                                const n = t.children[e];
                                this.add(n.clone())
                            }
                        return this
                    }
                }
                fr.DefaultUp = new pi(0, 1, 0), fr.DefaultMatrixAutoUpdate = !0, fr.prototype.isObject3D = !0;
                const gr = new pi,
                    vr = new pi,
                    yr = new pi,
                    xr = new pi,
                    _r = new pi,
                    br = new pi,
                    wr = new pi,
                    Mr = new pi,
                    Sr = new pi,
                    Tr = new pi;
                class Er {
                    constructor(t = new pi, e = new pi, n = new pi) { this.a = t, this.b = e, this.c = n }
                    static getNormal(t, e, n, i) { i.subVectors(n, e), gr.subVectors(t, e), i.cross(gr); const r = i.lengthSq(); return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0) }
                    static getBarycoord(t, e, n, i, r) {
                        gr.subVectors(i, e), vr.subVectors(n, e), yr.subVectors(t, e);
                        const s = gr.dot(gr),
                            o = gr.dot(vr),
                            a = gr.dot(yr),
                            l = vr.dot(vr),
                            c = vr.dot(yr),
                            h = s * l - o * o;
                        if (0 === h) return r.set(-2, -1, -1);
                        const u = 1 / h,
                            d = (l * a - o * c) * u,
                            p = (s * c - o * a) * u;
                        return r.set(1 - d - p, p, d)
                    }
                    static containsPoint(t, e, n, i) { return this.getBarycoord(t, e, n, i, xr), xr.x >= 0 && xr.y >= 0 && xr.x + xr.y <= 1 }
                    static getUV(t, e, n, i, r, s, o, a) { return this.getBarycoord(t, e, n, i, xr), a.set(0, 0), a.addScaledVector(r, xr.x), a.addScaledVector(s, xr.y), a.addScaledVector(o, xr.z), a }
                    static isFrontFacing(t, e, n, i) { return gr.subVectors(n, e), vr.subVectors(t, e), gr.cross(vr).dot(i) < 0 }
                    set(t, e, n) { return this.a.copy(t), this.b.copy(e), this.c.copy(n), this }
                    setFromPointsAndIndices(t, e, n, i) { return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this }
                    setFromAttributeAndIndices(t, e, n, i) { return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, i), this }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this }
                    getArea() { return gr.subVectors(this.c, this.b), vr.subVectors(this.a, this.b), .5 * gr.cross(vr).length() }
                    getMidpoint(t) { return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) }
                    getNormal(t) { return Er.getNormal(this.a, this.b, this.c, t) }
                    getPlane(t) { return t.setFromCoplanarPoints(this.a, this.b, this.c) }
                    getBarycoord(t, e) { return Er.getBarycoord(t, this.a, this.b, this.c, e) }
                    getUV(t, e, n, i, r) { return Er.getUV(t, this.a, this.b, this.c, e, n, i, r) }
                    containsPoint(t) { return Er.containsPoint(t, this.a, this.b, this.c) }
                    isFrontFacing(t) { return Er.isFrontFacing(this.a, this.b, this.c, t) }
                    intersectsBox(t) { return t.intersectsTriangle(this) }
                    closestPointToPoint(t, e) {
                        const n = this.a,
                            i = this.b,
                            r = this.c;
                        let s, o;
                        _r.subVectors(i, n), br.subVectors(r, n), Mr.subVectors(t, n);
                        const a = _r.dot(Mr),
                            l = br.dot(Mr);
                        if (a <= 0 && l <= 0) return e.copy(n);
                        Sr.subVectors(t, i);
                        const c = _r.dot(Sr),
                            h = br.dot(Sr);
                        if (c >= 0 && h <= c) return e.copy(i);
                        const u = a * h - c * l;
                        if (u <= 0 && a >= 0 && c <= 0) return s = a / (a - c), e.copy(n).addScaledVector(_r, s);
                        Tr.subVectors(t, r);
                        const d = _r.dot(Tr),
                            p = br.dot(Tr);
                        if (p >= 0 && d <= p) return e.copy(r);
                        const m = d * l - a * p;
                        if (m <= 0 && l >= 0 && p <= 0) return o = l / (l - p), e.copy(n).addScaledVector(br, o);
                        const f = c * p - d * h;
                        if (f <= 0 && h - c >= 0 && d - p >= 0) return wr.subVectors(r, i), o = (h - c) / (h - c + (d - p)), e.copy(i).addScaledVector(wr, o);
                        const g = 1 / (f + m + u);
                        return s = m * g, o = u * g, e.copy(n).addScaledVector(_r, s).addScaledVector(br, o)
                    }
                    equals(t) { return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c) }
                }
                let Ar = 0;
                class Lr extends On {
                    constructor() { super(), Object.defineProperty(this, "id", { value: Ar++ }), this.uuid = Gn(), this.name = "", this.type = "Material", this.fog = !0, this.blending = _, this.side = m, this.vertexColors = !1, this.opacity = 1, this.format = zt, this.transparent = !1, this.blendSrc = N, this.blendDst = B, this.blendEquation = T, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = W, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Sn, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = hn, this.stencilZFail = hn, this.stencilZPass = hn, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 }
                    get alphaTest() { return this._alphaTest }
                    set alphaTest(t) { this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t }
                    onBuild() {}
                    onBeforeRender() {}
                    onBeforeCompile() {}
                    customProgramCacheKey() { return this.onBeforeCompile.toString() }
                    setValues(t) {
                        if (void 0 !== t)
                            for (const e in t) {
                                const n = t[e];
                                if (void 0 === n) { console.warn("THREE.Material: '" + e + "' parameter is undefined."); continue }
                                if ("shading" === e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === v; continue }
                                const i = this[e];
                                void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                            }
                    }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t;
                        e && (t = { textures: {}, images: {} });
                        const n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };

                        function i(t) {
                            const e = [];
                            for (const n in t) {
                                const i = t[n];
                                delete i.metadata, e.push(i)
                            }
                            return e
                        }
                        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== _ && (n.blending = this.blending), this.side !== m && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.format !== zt && (n.format = this.format), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                            const e = i(t.textures),
                                r = i(t.images);
                            e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
                        }
                        return n
                    }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) {
                        this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.format = t.format, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                        const e = t.clippingPlanes;
                        let n = null;
                        if (null !== e) {
                            const t = e.length;
                            n = new Array(t);
                            for (let i = 0; i !== t; ++i) n[i] = e[i].clone()
                        }
                        return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
                    }
                    dispose() { this.dispatchEvent({ type: "dispose" }) }
                    set needsUpdate(t) {!0 === t && this.version++ }
                }
                Lr.prototype.isMaterial = !0;
                const Rr = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 },
                    Cr = { h: 0, s: 0, l: 0 },
                    Pr = { h: 0, s: 0, l: 0 };

                function Ir(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t }

                function Dr(t) { return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4) }

                function Nr(t) { return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055 }
                class Br {
                    constructor(t, e, n) { return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n) }
                    set(t) { return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this }
                    setScalar(t) { return this.r = t, this.g = t, this.b = t, this }
                    setHex(t) { return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this }
                    setRGB(t, e, n) { return this.r = t, this.g = e, this.b = n, this }
                    setHSL(t, e, n) {
                        if (t = Wn(t, 1), e = Vn(e, 0, 1), n = Vn(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                        else {
                            const i = n <= .5 ? n * (1 + e) : n + e - n * e,
                                r = 2 * n - i;
                            this.r = Ir(r, i, t + 1 / 3), this.g = Ir(r, i, t), this.b = Ir(r, i, t - 1 / 3)
                        }
                        return this
                    }
                    setStyle(t) {
                        function e(e) { void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.") }
                        let n;
                        if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
                            let t;
                            const i = n[1],
                                r = n[2];
                            switch (i) {
                                case "rgb":
                                case "rgba":
                                    if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[4]), this;
                                    if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[4]), this;
                                    break;
                                case "hsl":
                                case "hsla":
                                    if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                                        const n = parseFloat(t[1]) / 360,
                                            i = parseInt(t[2], 10) / 100,
                                            r = parseInt(t[3], 10) / 100;
                                        return e(t[4]), this.setHSL(n, i, r)
                                    }
                            }
                        } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                            const t = n[1],
                                e = t.length;
                            if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
                            if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
                        }
                        return t && t.length > 0 ? this.setColorName(t) : this
                    }
                    setColorName(t) { const e = Rr[t.toLowerCase()]; return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this }
                    clone() { return new this.constructor(this.r, this.g, this.b) }
                    copy(t) { return this.r = t.r, this.g = t.g, this.b = t.b, this }
                    copyGammaToLinear(t, e = 2) { return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this }
                    copyLinearToGamma(t, e = 2) { const n = e > 0 ? 1 / e : 1; return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this }
                    convertGammaToLinear(t) { return this.copyGammaToLinear(this, t), this }
                    convertLinearToGamma(t) { return this.copyLinearToGamma(this, t), this }
                    copySRGBToLinear(t) { return this.r = Dr(t.r), this.g = Dr(t.g), this.b = Dr(t.b), this }
                    copyLinearToSRGB(t) { return this.r = Nr(t.r), this.g = Nr(t.g), this.b = Nr(t.b), this }
                    convertSRGBToLinear() { return this.copySRGBToLinear(this), this }
                    convertLinearToSRGB() { return this.copyLinearToSRGB(this), this }
                    getHex() { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 }
                    getHexString() { return ("000000" + this.getHex().toString(16)).slice(-6) }
                    getHSL(t) {
                        const e = this.r,
                            n = this.g,
                            i = this.b,
                            r = Math.max(e, n, i),
                            s = Math.min(e, n, i);
                        let o, a;
                        const l = (s + r) / 2;
                        if (s === r) o = 0, a = 0;
                        else {
                            const t = r - s;
                            switch (a = l <= .5 ? t / (r + s) : t / (2 - r - s), r) {
                                case e:
                                    o = (n - i) / t + (n < i ? 6 : 0);
                                    break;
                                case n:
                                    o = (i - e) / t + 2;
                                    break;
                                case i:
                                    o = (e - n) / t + 4
                            }
                            o /= 6
                        }
                        return t.h = o, t.s = a, t.l = l, t
                    }
                    getStyle() { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" }
                    offsetHSL(t, e, n) { return this.getHSL(Cr), Cr.h += t, Cr.s += e, Cr.l += n, this.setHSL(Cr.h, Cr.s, Cr.l), this }
                    add(t) { return this.r += t.r, this.g += t.g, this.b += t.b, this }
                    addColors(t, e) { return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this }
                    addScalar(t) { return this.r += t, this.g += t, this.b += t, this }
                    sub(t) { return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this }
                    multiply(t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this }
                    multiplyScalar(t) { return this.r *= t, this.g *= t, this.b *= t, this }
                    lerp(t, e) { return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this }
                    lerpColors(t, e, n) { return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this }
                    lerpHSL(t, e) {
                        this.getHSL(Cr), t.getHSL(Pr);
                        const n = jn(Cr.h, Pr.h, e),
                            i = jn(Cr.s, Pr.s, e),
                            r = jn(Cr.l, Pr.l, e);
                        return this.setHSL(n, i, r), this
                    }
                    equals(t) { return t.r === this.r && t.g === this.g && t.b === this.b }
                    fromArray(t, e = 0) { return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this }
                    toArray(t = [], e = 0) { return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t }
                    fromBufferAttribute(t, e) { return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this }
                    toJSON() { return this.getHex() }
                }
                Br.NAMES = Rr, Br.prototype.isColor = !0, Br.prototype.r = 1, Br.prototype.g = 1, Br.prototype.b = 1;
                class Or extends Lr {
                    constructor(t) { super(), this.type = "MeshBasicMaterial", this.color = new Br(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Z, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this }
                }
                Or.prototype.isMeshBasicMaterial = !0;
                const Fr = new pi,
                    zr = new Jn;
                class Ur {
                    constructor(t, e, n) {
                        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = Tn, this.updateRange = { offset: 0, count: -1 }, this.version = 0
                    }
                    onUploadCallback() {}
                    set needsUpdate(t) {!0 === t && this.version++ }
                    setUsage(t) { return this.usage = t, this }
                    copy(t) { return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this }
                    copyAt(t, e, n) { t *= this.itemSize, n *= e.itemSize; for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i]; return this }
                    copyArray(t) { return this.array.set(t), this }
                    copyColorsArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let i = 0, r = t.length; i < r; i++) {
                            let r = t[i];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new Br), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
                        }
                        return this
                    }
                    copyVector2sArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let i = 0, r = t.length; i < r; i++) {
                            let r = t[i];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new Jn), e[n++] = r.x, e[n++] = r.y
                        }
                        return this
                    }
                    copyVector3sArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let i = 0, r = t.length; i < r; i++) {
                            let r = t[i];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new pi), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
                        }
                        return this
                    }
                    copyVector4sArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let i = 0, r = t.length; i < r; i++) {
                            let r = t[i];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new li), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
                        }
                        return this
                    }
                    applyMatrix3(t) {
                        if (2 === this.itemSize)
                            for (let e = 0, n = this.count; e < n; e++) zr.fromBufferAttribute(this, e), zr.applyMatrix3(t), this.setXY(e, zr.x, zr.y);
                        else if (3 === this.itemSize)
                            for (let e = 0, n = this.count; e < n; e++) Fr.fromBufferAttribute(this, e), Fr.applyMatrix3(t), this.setXYZ(e, Fr.x, Fr.y, Fr.z);
                        return this
                    }
                    applyMatrix4(t) { for (let e = 0, n = this.count; e < n; e++) Fr.x = this.getX(e), Fr.y = this.getY(e), Fr.z = this.getZ(e), Fr.applyMatrix4(t), this.setXYZ(e, Fr.x, Fr.y, Fr.z); return this }
                    applyNormalMatrix(t) { for (let e = 0, n = this.count; e < n; e++) Fr.x = this.getX(e), Fr.y = this.getY(e), Fr.z = this.getZ(e), Fr.applyNormalMatrix(t), this.setXYZ(e, Fr.x, Fr.y, Fr.z); return this }
                    transformDirection(t) { for (let e = 0, n = this.count; e < n; e++) Fr.x = this.getX(e), Fr.y = this.getY(e), Fr.z = this.getZ(e), Fr.transformDirection(t), this.setXYZ(e, Fr.x, Fr.y, Fr.z); return this }
                    set(t, e = 0) { return this.array.set(t, e), this }
                    getX(t) { return this.array[t * this.itemSize] }
                    setX(t, e) { return this.array[t * this.itemSize] = e, this }
                    getY(t) { return this.array[t * this.itemSize + 1] }
                    setY(t, e) { return this.array[t * this.itemSize + 1] = e, this }
                    getZ(t) { return this.array[t * this.itemSize + 2] }
                    setZ(t, e) { return this.array[t * this.itemSize + 2] = e, this }
                    getW(t) { return this.array[t * this.itemSize + 3] }
                    setW(t, e) { return this.array[t * this.itemSize + 3] = e, this }
                    setXY(t, e, n) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this }
                    setXYZ(t, e, n, i) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this }
                    setXYZW(t, e, n, i, r) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this }
                    onUpload(t) { return this.onUploadCallback = t, this }
                    clone() { return new this.constructor(this.array, this.itemSize).copy(this) }
                    toJSON() { const t = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized }; return "" !== this.name && (t.name = this.name), this.usage !== Tn && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t }
                }
                Ur.prototype.isBufferAttribute = !0;
                class Hr extends Ur { constructor(t, e, n) { super(new Int8Array(t), e, n) } }
                class kr extends Ur { constructor(t, e, n) { super(new Uint8Array(t), e, n) } }
                class Gr extends Ur { constructor(t, e, n) { super(new Uint8ClampedArray(t), e, n) } }
                class Vr extends Ur { constructor(t, e, n) { super(new Int16Array(t), e, n) } }
                class Wr extends Ur { constructor(t, e, n) { super(new Uint16Array(t), e, n) } }
                class jr extends Ur { constructor(t, e, n) { super(new Int32Array(t), e, n) } }
                class qr extends Ur { constructor(t, e, n) { super(new Uint32Array(t), e, n) } }
                class Xr extends Ur { constructor(t, e, n) { super(new Uint16Array(t), e, n) } }
                Xr.prototype.isFloat16BufferAttribute = !0;
                class Yr extends Ur { constructor(t, e, n) { super(new Float32Array(t), e, n) } }
                class Zr extends Ur { constructor(t, e, n) { super(new Float64Array(t), e, n) } }
                let Jr = 0;
                const Kr = new Wi,
                    Qr = new fr,
                    $r = new pi,
                    ts = new gi,
                    es = new gi,
                    ns = new pi;
                class is extends On {
                    constructor() { super(), Object.defineProperty(this, "id", { value: Jr++ }), this.uuid = Gn(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} }
                    getIndex() { return this.index }
                    setIndex(t) { return Array.isArray(t) ? this.index = new(Qn(t) > 65535 ? qr : Wr)(t, 1) : this.index = t, this }
                    getAttribute(t) { return this.attributes[t] }
                    setAttribute(t, e) { return this.attributes[t] = e, this }
                    deleteAttribute(t) { return delete this.attributes[t], this }
                    hasAttribute(t) { return void 0 !== this.attributes[t] }
                    addGroup(t, e, n = 0) { this.groups.push({ start: t, count: e, materialIndex: n }) }
                    clearGroups() { this.groups = [] }
                    setDrawRange(t, e) { this.drawRange.start = t, this.drawRange.count = e }
                    applyMatrix4(t) {
                        const e = this.attributes.position;
                        void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                        const n = this.attributes.normal;
                        if (void 0 !== n) {
                            const e = (new Kn).getNormalMatrix(t);
                            n.applyNormalMatrix(e), n.needsUpdate = !0
                        }
                        const i = this.attributes.tangent;
                        return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                    }
                    applyQuaternion(t) { return Kr.makeRotationFromQuaternion(t), this.applyMatrix4(Kr), this }
                    rotateX(t) { return Kr.makeRotationX(t), this.applyMatrix4(Kr), this }
                    rotateY(t) { return Kr.makeRotationY(t), this.applyMatrix4(Kr), this }
                    rotateZ(t) { return Kr.makeRotationZ(t), this.applyMatrix4(Kr), this }
                    translate(t, e, n) { return Kr.makeTranslation(t, e, n), this.applyMatrix4(Kr), this }
                    scale(t, e, n) { return Kr.makeScale(t, e, n), this.applyMatrix4(Kr), this }
                    lookAt(t) { return Qr.lookAt(t), Qr.updateMatrix(), this.applyMatrix4(Qr.matrix), this }
                    center() { return this.computeBoundingBox(), this.boundingBox.getCenter($r).negate(), this.translate($r.x, $r.y, $r.z), this }
                    setFromPoints(t) {
                        const e = [];
                        for (let n = 0, i = t.length; n < i; n++) {
                            const i = t[n];
                            e.push(i.x, i.y, i.z || 0)
                        }
                        return this.setAttribute("position", new Yr(e, 3)), this
                    }
                    computeBoundingBox() {
                        null === this.boundingBox && (this.boundingBox = new gi);
                        const t = this.attributes.position,
                            e = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new pi(-1 / 0, -1 / 0, -1 / 0), new pi(1 / 0, 1 / 0, 1 / 0));
                        if (void 0 !== t) {
                            if (this.boundingBox.setFromBufferAttribute(t), e)
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t];
                                    ts.setFromBufferAttribute(n), this.morphTargetsRelative ? (ns.addVectors(this.boundingBox.min, ts.min), this.boundingBox.expandByPoint(ns), ns.addVectors(this.boundingBox.max, ts.max), this.boundingBox.expandByPoint(ns)) : (this.boundingBox.expandByPoint(ts.min), this.boundingBox.expandByPoint(ts.max))
                                }
                        } else this.boundingBox.makeEmpty();
                        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                    }
                    computeBoundingSphere() {
                        null === this.boundingSphere && (this.boundingSphere = new Bi);
                        const t = this.attributes.position,
                            e = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new pi, 1 / 0);
                        if (t) {
                            const n = this.boundingSphere.center;
                            if (ts.setFromBufferAttribute(t), e)
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t];
                                    es.setFromBufferAttribute(n), this.morphTargetsRelative ? (ns.addVectors(ts.min, es.min), ts.expandByPoint(ns), ns.addVectors(ts.max, es.max), ts.expandByPoint(ns)) : (ts.expandByPoint(es.min), ts.expandByPoint(es.max))
                                }
                            ts.getCenter(n);
                            let i = 0;
                            for (let e = 0, r = t.count; e < r; e++) ns.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(ns));
                            if (e)
                                for (let r = 0, s = e.length; r < s; r++) {
                                    const s = e[r],
                                        o = this.morphTargetsRelative;
                                    for (let e = 0, r = s.count; e < r; e++) ns.fromBufferAttribute(s, e), o && ($r.fromBufferAttribute(t, e), ns.add($r)), i = Math.max(i, n.distanceToSquared(ns))
                                }
                            this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                    computeTangents() {
                        const t = this.index,
                            e = this.attributes;
                        if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                        const n = t.array,
                            i = e.position.array,
                            r = e.normal.array,
                            s = e.uv.array,
                            o = i.length / 3;
                        void 0 === e.tangent && this.setAttribute("tangent", new Ur(new Float32Array(4 * o), 4));
                        const a = e.tangent.array,
                            l = [],
                            c = [];
                        for (let t = 0; t < o; t++) l[t] = new pi, c[t] = new pi;
                        const h = new pi,
                            u = new pi,
                            d = new pi,
                            p = new Jn,
                            m = new Jn,
                            f = new Jn,
                            g = new pi,
                            v = new pi;

                        function y(t, e, n) {
                            h.fromArray(i, 3 * t), u.fromArray(i, 3 * e), d.fromArray(i, 3 * n), p.fromArray(s, 2 * t), m.fromArray(s, 2 * e), f.fromArray(s, 2 * n), u.sub(h), d.sub(h), m.sub(p), f.sub(p);
                            const r = 1 / (m.x * f.y - f.x * m.y);
                            isFinite(r) && (g.copy(u).multiplyScalar(f.y).addScaledVector(d, -m.y).multiplyScalar(r), v.copy(d).multiplyScalar(m.x).addScaledVector(u, -f.x).multiplyScalar(r), l[t].add(g), l[e].add(g), l[n].add(g), c[t].add(v), c[e].add(v), c[n].add(v))
                        }
                        let x = this.groups;
                        0 === x.length && (x = [{ start: 0, count: n.length }]);
                        for (let t = 0, e = x.length; t < e; ++t) {
                            const e = x[t],
                                i = e.start;
                            for (let t = i, r = i + e.count; t < r; t += 3) y(n[t + 0], n[t + 1], n[t + 2])
                        }
                        const _ = new pi,
                            b = new pi,
                            w = new pi,
                            M = new pi;

                        function S(t) {
                            w.fromArray(r, 3 * t), M.copy(w);
                            const e = l[t];
                            _.copy(e), _.sub(w.multiplyScalar(w.dot(e))).normalize(), b.crossVectors(M, e);
                            const n = b.dot(c[t]) < 0 ? -1 : 1;
                            a[4 * t] = _.x, a[4 * t + 1] = _.y, a[4 * t + 2] = _.z, a[4 * t + 3] = n
                        }
                        for (let t = 0, e = x.length; t < e; ++t) {
                            const e = x[t],
                                i = e.start;
                            for (let t = i, r = i + e.count; t < r; t += 3) S(n[t + 0]), S(n[t + 1]), S(n[t + 2])
                        }
                    }
                    computeVertexNormals() {
                        const t = this.index,
                            e = this.getAttribute("position");
                        if (void 0 !== e) {
                            let n = this.getAttribute("normal");
                            if (void 0 === n) n = new Ur(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                            else
                                for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                            const i = new pi,
                                r = new pi,
                                s = new pi,
                                o = new pi,
                                a = new pi,
                                l = new pi,
                                c = new pi,
                                h = new pi;
                            if (t)
                                for (let u = 0, d = t.count; u < d; u += 3) {
                                    const d = t.getX(u + 0),
                                        p = t.getX(u + 1),
                                        m = t.getX(u + 2);
                                    i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), s.fromBufferAttribute(e, m), c.subVectors(s, r), h.subVectors(i, r), c.cross(h), o.fromBufferAttribute(n, d), a.fromBufferAttribute(n, p), l.fromBufferAttribute(n, m), o.add(c), a.add(c), l.add(c), n.setXYZ(d, o.x, o.y, o.z), n.setXYZ(p, a.x, a.y, a.z), n.setXYZ(m, l.x, l.y, l.z)
                                } else
                                    for (let t = 0, o = e.count; t < o; t += 3) i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), s.fromBufferAttribute(e, t + 2), c.subVectors(s, r), h.subVectors(i, r), c.cross(h), n.setXYZ(t + 0, c.x, c.y, c.z), n.setXYZ(t + 1, c.x, c.y, c.z), n.setXYZ(t + 2, c.x, c.y, c.z);
                            this.normalizeNormals(), n.needsUpdate = !0
                        }
                    }
                    merge(t, e) {
                        if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                        void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                        const n = this.attributes;
                        for (const i in n) {
                            if (void 0 === t.attributes[i]) continue;
                            const r = n[i].array,
                                s = t.attributes[i],
                                o = s.array,
                                a = s.itemSize * e,
                                l = Math.min(o.length, r.length - a);
                            for (let t = 0, e = a; t < l; t++, e++) r[e] = o[t]
                        }
                        return this
                    }
                    normalizeNormals() { const t = this.attributes.normal; for (let e = 0, n = t.count; e < n; e++) ns.fromBufferAttribute(t, e), ns.normalize(), t.setXYZ(e, ns.x, ns.y, ns.z) }
                    toNonIndexed() {
                        function t(t, e) {
                            const n = t.array,
                                i = t.itemSize,
                                r = t.normalized,
                                s = new n.constructor(e.length * i);
                            let o = 0,
                                a = 0;
                            for (let r = 0, l = e.length; r < l; r++) { o = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i; for (let t = 0; t < i; t++) s[a++] = n[o++] }
                            return new Ur(s, i, r)
                        }
                        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                        const e = new is,
                            n = this.index.array,
                            i = this.attributes;
                        for (const r in i) {
                            const s = t(i[r], n);
                            e.setAttribute(r, s)
                        }
                        const r = this.morphAttributes;
                        for (const i in r) {
                            const s = [],
                                o = r[i];
                            for (let e = 0, i = o.length; e < i; e++) {
                                const i = t(o[e], n);
                                s.push(i)
                            }
                            e.morphAttributes[i] = s
                        }
                        e.morphTargetsRelative = this.morphTargetsRelative;
                        const s = this.groups;
                        for (let t = 0, n = s.length; t < n; t++) {
                            const n = s[t];
                            e.addGroup(n.start, n.count, n.materialIndex)
                        }
                        return e
                    }
                    toJSON() {
                        const t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
                        if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) { const e = this.parameters; for (const n in e) void 0 !== e[n] && (t[n] = e[n]); return t }
                        t.data = { attributes: {} };
                        const e = this.index;
                        null !== e && (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) });
                        const n = this.attributes;
                        for (const e in n) {
                            const i = n[e];
                            t.data.attributes[e] = i.toJSON(t.data)
                        }
                        const i = {};
                        let r = !1;
                        for (const e in this.morphAttributes) {
                            const n = this.morphAttributes[e],
                                s = [];
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = n[e];
                                s.push(i.toJSON(t.data))
                            }
                            s.length > 0 && (i[e] = s, r = !0)
                        }
                        r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
                        const s = this.groups;
                        s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                        const o = this.boundingSphere;
                        return null !== o && (t.data.boundingSphere = { center: o.center.toArray(), radius: o.radius }), t
                    }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) {
                        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                        const e = {};
                        this.name = t.name;
                        const n = t.index;
                        null !== n && this.setIndex(n.clone(e));
                        const i = t.attributes;
                        for (const t in i) {
                            const n = i[t];
                            this.setAttribute(t, n.clone(e))
                        }
                        const r = t.morphAttributes;
                        for (const t in r) {
                            const n = [],
                                i = r[t];
                            for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
                            this.morphAttributes[t] = n
                        }
                        this.morphTargetsRelative = t.morphTargetsRelative;
                        const s = t.groups;
                        for (let t = 0, e = s.length; t < e; t++) {
                            const e = s[t];
                            this.addGroup(e.start, e.count, e.materialIndex)
                        }
                        const o = t.boundingBox;
                        null !== o && (this.boundingBox = o.clone());
                        const a = t.boundingSphere;
                        return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, void 0 !== t.parameters && (this.parameters = Object.assign({}, t.parameters)), this
                    }
                    dispose() { this.dispatchEvent({ type: "dispose" }) }
                }
                is.prototype.isBufferGeometry = !0;
                const rs = new Wi,
                    ss = new Vi,
                    os = new Bi,
                    as = new pi,
                    ls = new pi,
                    cs = new pi,
                    hs = new pi,
                    us = new pi,
                    ds = new pi,
                    ps = new pi,
                    ms = new pi,
                    fs = new pi,
                    gs = new Jn,
                    vs = new Jn,
                    ys = new Jn,
                    xs = new pi,
                    _s = new pi;
                class bs extends fr {
                    constructor(t = new is, e = new Or) { super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets() }
                    copy(t) { return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this }
                    updateMorphTargets() {
                        const t = this.geometry;
                        if (t.isBufferGeometry) {
                            const e = t.morphAttributes,
                                n = Object.keys(e);
                            if (n.length > 0) {
                                const t = e[n[0]];
                                if (void 0 !== t) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let e = 0, n = t.length; e < n; e++) {
                                        const n = t[e].name || String(e);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                    }
                                }
                            }
                        } else {
                            const e = t.morphTargets;
                            void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                        }
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            i = this.material,
                            r = this.matrixWorld;
                        if (void 0 === i) return;
                        if (null === n.boundingSphere && n.computeBoundingSphere(), os.copy(n.boundingSphere), os.applyMatrix4(r), !1 === t.ray.intersectsSphere(os)) return;
                        if (rs.copy(r).invert(), ss.copy(t.ray).applyMatrix4(rs), null !== n.boundingBox && !1 === ss.intersectsBox(n.boundingBox)) return;
                        let s;
                        if (n.isBufferGeometry) {
                            const r = n.index,
                                o = n.attributes.position,
                                a = n.morphAttributes.position,
                                l = n.morphTargetsRelative,
                                c = n.attributes.uv,
                                h = n.attributes.uv2,
                                u = n.groups,
                                d = n.drawRange;
                            if (null !== r)
                                if (Array.isArray(i))
                                    for (let n = 0, p = u.length; n < p; n++) {
                                        const p = u[n],
                                            m = i[p.materialIndex];
                                        for (let n = Math.max(p.start, d.start), i = Math.min(r.count, Math.min(p.start + p.count, d.start + d.count)); n < i; n += 3) {
                                            const i = r.getX(n),
                                                u = r.getX(n + 1),
                                                d = r.getX(n + 2);
                                            s = ws(this, m, t, ss, o, a, l, c, h, i, u, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, e.push(s))
                                        }
                                    } else
                                        for (let n = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); n < u; n += 3) {
                                            const u = r.getX(n),
                                                d = r.getX(n + 1),
                                                p = r.getX(n + 2);
                                            s = ws(this, i, t, ss, o, a, l, c, h, u, d, p), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                                        } else if (void 0 !== o)
                                            if (Array.isArray(i))
                                                for (let n = 0, r = u.length; n < r; n++) {
                                                    const r = u[n],
                                                        p = i[r.materialIndex];
                                                    for (let n = Math.max(r.start, d.start), i = Math.min(o.count, Math.min(r.start + r.count, d.start + d.count)); n < i; n += 3) s = ws(this, p, t, ss, o, a, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, e.push(s))
                                                } else
                                                    for (let n = Math.max(0, d.start), r = Math.min(o.count, d.start + d.count); n < r; n += 3) s = ws(this, i, t, ss, o, a, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                        } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }

                function ws(t, e, n, i, r, s, o, a, l, c, h, u) {
                    as.fromBufferAttribute(r, c), ls.fromBufferAttribute(r, h), cs.fromBufferAttribute(r, u);
                    const d = t.morphTargetInfluences;
                    if (s && d) {
                        ps.set(0, 0, 0), ms.set(0, 0, 0), fs.set(0, 0, 0);
                        for (let t = 0, e = s.length; t < e; t++) {
                            const e = d[t],
                                n = s[t];
                            0 !== e && (hs.fromBufferAttribute(n, c), us.fromBufferAttribute(n, h), ds.fromBufferAttribute(n, u), o ? (ps.addScaledVector(hs, e), ms.addScaledVector(us, e), fs.addScaledVector(ds, e)) : (ps.addScaledVector(hs.sub(as), e), ms.addScaledVector(us.sub(ls), e), fs.addScaledVector(ds.sub(cs), e)))
                        }
                        as.add(ps), ls.add(ms), cs.add(fs)
                    }
                    t.isSkinnedMesh && (t.boneTransform(c, as), t.boneTransform(h, ls), t.boneTransform(u, cs));
                    const p = function(t, e, n, i, r, s, o, a) {
                        let l;
                        if (l = e.side === f ? i.intersectTriangle(o, s, r, !0, a) : i.intersectTriangle(r, s, o, e.side !== g, a), null === l) return null;
                        _s.copy(a), _s.applyMatrix4(t.matrixWorld);
                        const c = n.ray.origin.distanceTo(_s);
                        return c < n.near || c > n.far ? null : { distance: c, point: _s.clone(), object: t }
                    }(t, e, n, i, as, ls, cs, xs);
                    if (p) {
                        a && (gs.fromBufferAttribute(a, c), vs.fromBufferAttribute(a, h), ys.fromBufferAttribute(a, u), p.uv = Er.getUV(xs, as, ls, cs, gs, vs, ys, new Jn)), l && (gs.fromBufferAttribute(l, c), vs.fromBufferAttribute(l, h), ys.fromBufferAttribute(l, u), p.uv2 = Er.getUV(xs, as, ls, cs, gs, vs, ys, new Jn));
                        const t = { a: c, b: h, c: u, normal: new pi, materialIndex: 0 };
                        Er.getNormal(as, ls, cs, t.normal), p.face = t
                    }
                    return p
                }
                bs.prototype.isMesh = !0;
                class Ms extends is {
                    constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
                        super(), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: n, widthSegments: i, heightSegments: r, depthSegments: s };
                        const o = this;
                        i = Math.floor(i), r = Math.floor(r), s = Math.floor(s);
                        const a = [],
                            l = [],
                            c = [],
                            h = [];
                        let u = 0,
                            d = 0;

                        function p(t, e, n, i, r, s, p, m, f, g, v) {
                            const y = s / f,
                                x = p / g,
                                _ = s / 2,
                                b = p / 2,
                                w = m / 2,
                                M = f + 1,
                                S = g + 1;
                            let T = 0,
                                E = 0;
                            const A = new pi;
                            for (let s = 0; s < S; s++) {
                                const o = s * x - b;
                                for (let a = 0; a < M; a++) {
                                    const u = a * y - _;
                                    A[t] = u * i, A[e] = o * r, A[n] = w, l.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = m > 0 ? 1 : -1, c.push(A.x, A.y, A.z), h.push(a / f), h.push(1 - s / g), T += 1
                                }
                            }
                            for (let t = 0; t < g; t++)
                                for (let e = 0; e < f; e++) {
                                    const n = u + e + M * t,
                                        i = u + e + M * (t + 1),
                                        r = u + (e + 1) + M * (t + 1),
                                        s = u + (e + 1) + M * t;
                                    a.push(n, i, s), a.push(i, r, s), E += 6
                                }
                            o.addGroup(d, E, v), d += E, u += T
                        }
                        p("z", "y", "x", -1, -1, n, e, t, s, r, 0), p("z", "y", "x", 1, -1, n, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, s, 2), p("x", "z", "y", 1, -1, t, n, -e, i, s, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new Yr(l, 3)), this.setAttribute("normal", new Yr(c, 3)), this.setAttribute("uv", new Yr(h, 2))
                    }
                    static fromJSON(t) { return new Ms(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments) }
                }

                function Ss(t) {
                    const e = {};
                    for (const n in t) {
                        e[n] = {};
                        for (const i in t[n]) {
                            const r = t[n][i];
                            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                        }
                    }
                    return e
                }

                function Ts(t) { const e = {}; for (let n = 0; n < t.length; n++) { const i = Ss(t[n]); for (const t in i) e[t] = i[t] } return e }
                const Es = { clone: Ss, merge: Ts };
                class As extends Lr {
                    constructor(t) { super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t)) }
                    copy(t) { return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Ss(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        e.glslVersion = this.glslVersion, e.uniforms = {};
                        for (const n in this.uniforms) {
                            const i = this.uniforms[n].value;
                            i && i.isTexture ? e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid } : i && i.isColor ? e.uniforms[n] = { type: "c", value: i.getHex() } : i && i.isVector2 ? e.uniforms[n] = { type: "v2", value: i.toArray() } : i && i.isVector3 ? e.uniforms[n] = { type: "v3", value: i.toArray() } : i && i.isVector4 ? e.uniforms[n] = { type: "v4", value: i.toArray() } : i && i.isMatrix3 ? e.uniforms[n] = { type: "m3", value: i.toArray() } : i && i.isMatrix4 ? e.uniforms[n] = { type: "m4", value: i.toArray() } : e.uniforms[n] = { value: i }
                        }
                        Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                        const n = {};
                        for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
                        return Object.keys(n).length > 0 && (e.extensions = n), e
                    }
                }
                As.prototype.isShaderMaterial = !0;
                class Ls extends fr {
                    constructor() { super(), this.type = "Camera", this.matrixWorldInverse = new Wi, this.projectionMatrix = new Wi, this.projectionMatrixInverse = new Wi }
                    copy(t, e) { return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this }
                    getWorldDirection(t) { this.updateWorldMatrix(!0, !1); const e = this.matrixWorld.elements; return t.set(-e[8], -e[9], -e[10]).normalize() }
                    updateMatrixWorld(t) { super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert() }
                    updateWorldMatrix(t, e) { super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert() }
                    clone() { return (new this.constructor).copy(this) }
                }
                Ls.prototype.isCamera = !0;
                class Rs extends Ls {
                    constructor(t = 50, e = 1, n = .1, i = 2e3) { super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() }
                    copy(t, e) { return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this }
                    setFocalLength(t) {
                        const e = .5 * this.getFilmHeight() / t;
                        this.fov = 2 * Un * Math.atan(e), this.updateProjectionMatrix()
                    }
                    getFocalLength() { const t = Math.tan(.5 * zn * this.fov); return .5 * this.getFilmHeight() / t }
                    getEffectiveFOV() { return 2 * Un * Math.atan(Math.tan(.5 * zn * this.fov) / this.zoom) }
                    getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) }
                    getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) }
                    setViewOffset(t, e, n, i, r, s) { this.aspect = t / e, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix() }
                    clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }
                    updateProjectionMatrix() {
                        const t = this.near;
                        let e = t * Math.tan(.5 * zn * this.fov) / this.zoom,
                            n = 2 * e,
                            i = this.aspect * n,
                            r = -.5 * i;
                        const s = this.view;
                        if (null !== this.view && this.view.enabled) {
                            const t = s.fullWidth,
                                o = s.fullHeight;
                            r += s.offsetX * i / t, e -= s.offsetY * n / o, i *= s.width / t, n *= s.height / o
                        }
                        const o = this.filmOffset;
                        0 !== o && (r += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(t) { const e = super.toJSON(t); return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e }
                }
                Rs.prototype.isPerspectiveCamera = !0;
                const Cs = 90;
                class Ps extends fr {
                    constructor(t, e, n) {
                        if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                        this.renderTarget = n;
                        const i = new Rs(Cs, 1, t, e);
                        i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new pi(1, 0, 0)), this.add(i);
                        const r = new Rs(Cs, 1, t, e);
                        r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new pi(-1, 0, 0)), this.add(r);
                        const s = new Rs(Cs, 1, t, e);
                        s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new pi(0, 1, 0)), this.add(s);
                        const o = new Rs(Cs, 1, t, e);
                        o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new pi(0, -1, 0)), this.add(o);
                        const a = new Rs(Cs, 1, t, e);
                        a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new pi(0, 0, 1)), this.add(a);
                        const l = new Rs(Cs, 1, t, e);
                        l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new pi(0, 0, -1)), this.add(l)
                    }
                    update(t, e) {
                        null === this.parent && this.updateMatrixWorld();
                        const n = this.renderTarget,
                            [i, r, s, o, a, l] = this.children,
                            c = t.xr.enabled,
                            h = t.getRenderTarget();
                        t.xr.enabled = !1;
                        const u = n.texture.generateMipmaps;
                        n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, o), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = u, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(h), t.xr.enabled = c
                    }
                }
                class Is extends oi {
                    constructor(t, e, n, i, r, s, o, a, l, c) { super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : st, n, i, r, s, o, a, l, c), this.flipY = !1 }
                    get images() { return this.image }
                    set images(t) { this.image = t }
                }
                Is.prototype.isCubeTexture = !0;
                class Ds extends ci {
                    constructor(t, e, n) { Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new Is(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : xt, this.texture._needsFlipEnvMap = !1 }
                    fromEquirectangularTexture(t, e) {
                        this.texture.type = e.type, this.texture.format = zt, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                        const n = { tEquirect: { value: null } },
                            i = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                            r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                            s = new Ms(5, 5, 5),
                            o = new As({ name: "CubemapFromEquirect", uniforms: Ss(n), vertexShader: i, fragmentShader: r, side: f, blending: x });
                        o.uniforms.tEquirect.value = e;
                        const a = new bs(s, o),
                            l = e.minFilter;
                        return e.minFilter === wt && (e.minFilter = xt), new Ps(1, 10, this).update(t, a), e.minFilter = l, a.geometry.dispose(), a.material.dispose(), this
                    }
                    clear(t, e, n, i) {
                        const r = t.getRenderTarget();
                        for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
                        t.setRenderTarget(r)
                    }
                }
                Ds.prototype.isWebGLCubeRenderTarget = !0;
                const Ns = new pi,
                    Bs = new pi,
                    Os = new Kn;
                class Fs {
                    constructor(t = new pi(1, 0, 0), e = 0) { this.normal = t, this.constant = e }
                    set(t, e) { return this.normal.copy(t), this.constant = e, this }
                    setComponents(t, e, n, i) { return this.normal.set(t, e, n), this.constant = i, this }
                    setFromNormalAndCoplanarPoint(t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this }
                    setFromCoplanarPoints(t, e, n) { const i = Ns.subVectors(n, e).cross(Bs.subVectors(t, e)).normalize(); return this.setFromNormalAndCoplanarPoint(i, t), this }
                    copy(t) { return this.normal.copy(t.normal), this.constant = t.constant, this }
                    normalize() { const t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this }
                    negate() { return this.constant *= -1, this.normal.negate(), this }
                    distanceToPoint(t) { return this.normal.dot(t) + this.constant }
                    distanceToSphere(t) { return this.distanceToPoint(t.center) - t.radius }
                    projectPoint(t, e) { return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t) }
                    intersectLine(t, e) {
                        const n = t.delta(Ns),
                            i = this.normal.dot(n);
                        if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                        const r = -(t.start.dot(this.normal) + this.constant) / i;
                        return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start)
                    }
                    intersectsLine(t) {
                        const e = this.distanceToPoint(t.start),
                            n = this.distanceToPoint(t.end);
                        return e < 0 && n > 0 || n < 0 && e > 0
                    }
                    intersectsBox(t) { return t.intersectsPlane(this) }
                    intersectsSphere(t) { return t.intersectsPlane(this) }
                    coplanarPoint(t) { return t.copy(this.normal).multiplyScalar(-this.constant) }
                    applyMatrix4(t, e) {
                        const n = e || Os.getNormalMatrix(t),
                            i = this.coplanarPoint(Ns).applyMatrix4(t),
                            r = this.normal.applyMatrix3(n).normalize();
                        return this.constant = -i.dot(r), this
                    }
                    translate(t) { return this.constant -= t.dot(this.normal), this }
                    equals(t) { return t.normal.equals(this.normal) && t.constant === this.constant }
                    clone() { return (new this.constructor).copy(this) }
                }
                Fs.prototype.isPlane = !0;
                const zs = new Bi,
                    Us = new pi;
                class Hs {
                    constructor(t = new Fs, e = new Fs, n = new Fs, i = new Fs, r = new Fs, s = new Fs) { this.planes = [t, e, n, i, r, s] }
                    set(t, e, n, i, r, s) { const o = this.planes; return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(s), this }
                    copy(t) { const e = this.planes; for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]); return this }
                    setFromProjectionMatrix(t) {
                        const e = this.planes,
                            n = t.elements,
                            i = n[0],
                            r = n[1],
                            s = n[2],
                            o = n[3],
                            a = n[4],
                            l = n[5],
                            c = n[6],
                            h = n[7],
                            u = n[8],
                            d = n[9],
                            p = n[10],
                            m = n[11],
                            f = n[12],
                            g = n[13],
                            v = n[14],
                            y = n[15];
                        return e[0].setComponents(o - i, h - a, m - u, y - f).normalize(), e[1].setComponents(o + i, h + a, m + u, y + f).normalize(), e[2].setComponents(o + r, h + l, m + d, y + g).normalize(), e[3].setComponents(o - r, h - l, m - d, y - g).normalize(), e[4].setComponents(o - s, h - c, m - p, y - v).normalize(), e[5].setComponents(o + s, h + c, m + p, y + v).normalize(), this
                    }
                    intersectsObject(t) { const e = t.geometry; return null === e.boundingSphere && e.computeBoundingSphere(), zs.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(zs) }
                    intersectsSprite(t) { return zs.center.set(0, 0, 0), zs.radius = .7071067811865476, zs.applyMatrix4(t.matrixWorld), this.intersectsSphere(zs) }
                    intersectsSphere(t) {
                        const e = this.planes,
                            n = t.center,
                            i = -t.radius;
                        for (let t = 0; t < 6; t++)
                            if (e[t].distanceToPoint(n) < i) return !1;
                        return !0
                    }
                    intersectsBox(t) { const e = this.planes; for (let n = 0; n < 6; n++) { const i = e[n]; if (Us.x = i.normal.x > 0 ? t.max.x : t.min.x, Us.y = i.normal.y > 0 ? t.max.y : t.min.y, Us.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(Us) < 0) return !1 } return !0 }
                    containsPoint(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++)
                            if (e[n].distanceToPoint(t) < 0) return !1;
                        return !0
                    }
                    clone() { return (new this.constructor).copy(this) }
                }

                function ks() {
                    let t = null,
                        e = !1,
                        n = null,
                        i = null;

                    function r(e, s) { n(e, s), i = t.requestAnimationFrame(r) }
                    return { start: function() {!0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0) }, stop: function() { t.cancelAnimationFrame(i), e = !1 }, setAnimationLoop: function(t) { n = t }, setContext: function(e) { t = e } }
                }

                function Gs(t, e) {
                    const n = e.isWebGL2,
                        i = new WeakMap;
                    return {
                        get: function(t) { return t.isInterleavedBufferAttribute && (t = t.data), i.get(t) },
                        remove: function(e) {
                            e.isInterleavedBufferAttribute && (e = e.data);
                            const n = i.get(e);
                            n && (t.deleteBuffer(n.buffer), i.delete(e))
                        },
                        update: function(e, r) {
                            if (e.isGLBufferAttribute) { const t = i.get(e); return void((!t || t.version < e.version) && i.set(e, { buffer: e.buffer, type: e.type, bytesPerElement: e.elementSize, version: e.version })) }
                            e.isInterleavedBufferAttribute && (e = e.data);
                            const s = i.get(e);
                            void 0 === s ? i.set(e, function(e, i) {
                                const r = e.array,
                                    s = e.usage,
                                    o = t.createBuffer();
                                t.bindBuffer(i, o), t.bufferData(i, r, s), e.onUploadCallback();
                                let a = 5126;
                                return r instanceof Float32Array ? a = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : (r instanceof Uint8Array || r instanceof Uint8ClampedArray) && (a = 5121), { buffer: o, type: a, bytesPerElement: r.BYTES_PER_ELEMENT, version: e.version }
                            }(e, r)) : s.version < e.version && (function(e, i, r) {
                                const s = i.array,
                                    o = i.updateRange;
                                t.bindBuffer(r, e), -1 === o.count ? t.bufferSubData(r, 0, s) : (n ? t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)), o.count = -1)
                            }(s.buffer, e, r), s.version = e.version)
                        }
                    }
                }
                class Vs extends is {
                    constructor(t = 1, e = 1, n = 1, i = 1) {
                        super(), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i };
                        const r = t / 2,
                            s = e / 2,
                            o = Math.floor(n),
                            a = Math.floor(i),
                            l = o + 1,
                            c = a + 1,
                            h = t / o,
                            u = e / a,
                            d = [],
                            p = [],
                            m = [],
                            f = [];
                        for (let t = 0; t < c; t++) {
                            const e = t * u - s;
                            for (let n = 0; n < l; n++) {
                                const i = n * h - r;
                                p.push(i, -e, 0), m.push(0, 0, 1), f.push(n / o), f.push(1 - t / a)
                            }
                        }
                        for (let t = 0; t < a; t++)
                            for (let e = 0; e < o; e++) {
                                const n = e + l * t,
                                    i = e + l * (t + 1),
                                    r = e + 1 + l * (t + 1),
                                    s = e + 1 + l * t;
                                d.push(n, i, s), d.push(i, r, s)
                            }
                        this.setIndex(d), this.setAttribute("position", new Yr(p, 3)), this.setAttribute("normal", new Yr(m, 3)), this.setAttribute("uv", new Yr(f, 2))
                    }
                    static fromJSON(t) { return new Vs(t.width, t.height, t.widthSegments, t.heightSegments) }
                }
                const Ws = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}" },
                    js = { common: { diffuse: { value: new Br(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new Kn }, uv2Transform: { value: new Kn }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new Jn(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Br(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Br(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new Kn } }, sprite: { diffuse: { value: new Br(16777215) }, opacity: { value: 1 }, center: { value: new Jn(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new Kn } } },
                    qs = { basic: { uniforms: Ts([js.common, js.specularmap, js.envmap, js.aomap, js.lightmap, js.fog]), vertexShader: Ws.meshbasic_vert, fragmentShader: Ws.meshbasic_frag }, lambert: { uniforms: Ts([js.common, js.specularmap, js.envmap, js.aomap, js.lightmap, js.emissivemap, js.fog, js.lights, { emissive: { value: new Br(0) } }]), vertexShader: Ws.meshlambert_vert, fragmentShader: Ws.meshlambert_frag }, phong: { uniforms: Ts([js.common, js.specularmap, js.envmap, js.aomap, js.lightmap, js.emissivemap, js.bumpmap, js.normalmap, js.displacementmap, js.fog, js.lights, { emissive: { value: new Br(0) }, specular: { value: new Br(1118481) }, shininess: { value: 30 } }]), vertexShader: Ws.meshphong_vert, fragmentShader: Ws.meshphong_frag }, standard: { uniforms: Ts([js.common, js.envmap, js.aomap, js.lightmap, js.emissivemap, js.bumpmap, js.normalmap, js.displacementmap, js.roughnessmap, js.metalnessmap, js.fog, js.lights, { emissive: { value: new Br(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Ws.meshphysical_vert, fragmentShader: Ws.meshphysical_frag }, toon: { uniforms: Ts([js.common, js.aomap, js.lightmap, js.emissivemap, js.bumpmap, js.normalmap, js.displacementmap, js.gradientmap, js.fog, js.lights, { emissive: { value: new Br(0) } }]), vertexShader: Ws.meshtoon_vert, fragmentShader: Ws.meshtoon_frag }, matcap: { uniforms: Ts([js.common, js.bumpmap, js.normalmap, js.displacementmap, js.fog, { matcap: { value: null } }]), vertexShader: Ws.meshmatcap_vert, fragmentShader: Ws.meshmatcap_frag }, points: { uniforms: Ts([js.points, js.fog]), vertexShader: Ws.points_vert, fragmentShader: Ws.points_frag }, dashed: { uniforms: Ts([js.common, js.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Ws.linedashed_vert, fragmentShader: Ws.linedashed_frag }, depth: { uniforms: Ts([js.common, js.displacementmap]), vertexShader: Ws.depth_vert, fragmentShader: Ws.depth_frag }, normal: { uniforms: Ts([js.common, js.bumpmap, js.normalmap, js.displacementmap, { opacity: { value: 1 } }]), vertexShader: Ws.meshnormal_vert, fragmentShader: Ws.meshnormal_frag }, sprite: { uniforms: Ts([js.sprite, js.fog]), vertexShader: Ws.sprite_vert, fragmentShader: Ws.sprite_frag }, background: { uniforms: { uvTransform: { value: new Kn }, t2D: { value: null } }, vertexShader: Ws.background_vert, fragmentShader: Ws.background_frag }, cube: { uniforms: Ts([js.envmap, { opacity: { value: 1 } }]), vertexShader: Ws.cube_vert, fragmentShader: Ws.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Ws.equirect_vert, fragmentShader: Ws.equirect_frag }, distanceRGBA: { uniforms: Ts([js.common, js.displacementmap, { referencePosition: { value: new pi }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Ws.distanceRGBA_vert, fragmentShader: Ws.distanceRGBA_frag }, shadow: { uniforms: Ts([js.lights, js.fog, { color: { value: new Br(0) }, opacity: { value: 1 } }]), vertexShader: Ws.shadow_vert, fragmentShader: Ws.shadow_frag } };

                function Xs(t, e, n, i, r) {
                    const s = new Br(0);
                    let o, a, l = 0,
                        c = null,
                        h = 0,
                        u = null;

                    function d(t, e) { n.buffers.color.setClear(t.r, t.g, t.b, e, r) }
                    return {
                        getClearColor: function() { return s },
                        setClearColor: function(t, e = 1) { s.set(t), l = e, d(s, l) },
                        getClearAlpha: function() { return l },
                        setClearAlpha: function(t) { l = t, d(s, l) },
                        render: function(n, r) {
                            let p = !1,
                                g = !0 === r.isScene ? r.background : null;
                            g && g.isTexture && (g = e.get(g));
                            const v = t.xr,
                                y = v.getSession && v.getSession();
                            y && "additive" === y.environmentBlendMode && (g = null), null === g ? d(s, l) : g && g.isColor && (d(g, 1), p = !0), (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), g && (g.isCubeTexture || g.mapping === ct) ? (void 0 === a && (a = new bs(new Ms(1, 1, 1), new As({ name: "BackgroundCubeMaterial", uniforms: Ss(qs.cube.uniforms), vertexShader: qs.cube.vertexShader, fragmentShader: qs.cube.fragmentShader, side: f, depthTest: !1, depthWrite: !1, fog: !1 })), a.geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function(t, e, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(a.material, "envMap", { get: function() { return this.uniforms.envMap.value } }), i.update(a)), a.material.uniforms.envMap.value = g, a.material.uniforms.flipEnvMap.value = g.isCubeTexture && !1 === g.isRenderTargetTexture ? -1 : 1, c === g && h === g.version && u === t.toneMapping || (a.material.needsUpdate = !0, c = g, h = g.version, u = t.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null)) : g && g.isTexture && (void 0 === o && (o = new bs(new Vs(2, 2), new As({ name: "BackgroundMaterial", uniforms: Ss(qs.background.uniforms), vertexShader: qs.background.vertexShader, fragmentShader: qs.background.fragmentShader, side: m, depthTest: !1, depthWrite: !1, fog: !1 })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", { get: function() { return this.uniforms.t2D.value } }), i.update(o)), o.material.uniforms.t2D.value = g, !0 === g.matrixAutoUpdate && g.updateMatrix(), o.material.uniforms.uvTransform.value.copy(g.matrix), c === g && h === g.version && u === t.toneMapping || (o.material.needsUpdate = !0, c = g, h = g.version, u = t.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null))
                        }
                    }
                }

                function Ys(t, e, n, i) {
                    const r = t.getParameter(34921),
                        s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                        o = i.isWebGL2 || null !== s,
                        a = {},
                        l = d(null);
                    let c = l;

                    function h(e) { return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e) }

                    function u(e) { return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e) }

                    function d(t) {
                        const e = [],
                            n = [],
                            i = [];
                        for (let t = 0; t < r; t++) e[t] = 0, n[t] = 0, i[t] = 0;
                        return { geometry: null, program: null, wireframe: !1, newAttributes: e, enabledAttributes: n, attributeDivisors: i, object: t, attributes: {}, index: null }
                    }

                    function p() { const t = c.newAttributes; for (let e = 0, n = t.length; e < n; e++) t[e] = 0 }

                    function m(t) { f(t, 0) }

                    function f(n, r) {
                        const s = c.newAttributes,
                            o = c.enabledAttributes,
                            a = c.attributeDivisors;
                        s[n] = 1, 0 === o[n] && (t.enableVertexAttribArray(n), o[n] = 1), a[n] !== r && ((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), a[n] = r)
                    }

                    function g() {
                        const e = c.newAttributes,
                            n = c.enabledAttributes;
                        for (let i = 0, r = n.length; i < r; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0)
                    }

                    function v(e, n, r, s, o, a) {!0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, s, o, a) : t.vertexAttribIPointer(e, n, r, o, a) }

                    function y() { x(), c !== l && (c = l, h(c.object)) }

                    function x() { l.geometry = null, l.program = null, l.wireframe = !1 }
                    return {
                        setup: function(r, l, u, y, x) {
                            let _ = !1;
                            if (o) {
                                const e = function(e, n, r) {
                                    const o = !0 === r.wireframe;
                                    let l = a[e.id];
                                    void 0 === l && (l = {}, a[e.id] = l);
                                    let c = l[n.id];
                                    void 0 === c && (c = {}, l[n.id] = c);
                                    let h = c[o];
                                    return void 0 === h && (h = d(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()), c[o] = h), h
                                }(y, u, l);
                                c !== e && (c = e, h(c.object)), _ = function(t, e) {
                                    const n = c.attributes,
                                        i = t.attributes;
                                    let r = 0;
                                    for (const t in i) {
                                        const e = n[t],
                                            s = i[t];
                                        if (void 0 === e) return !0;
                                        if (e.attribute !== s) return !0;
                                        if (e.data !== s.data) return !0;
                                        r++
                                    }
                                    return c.attributesNum !== r || c.index !== e
                                }(y, x), _ && function(t, e) {
                                    const n = {},
                                        i = t.attributes;
                                    let r = 0;
                                    for (const t in i) {
                                        const e = i[t],
                                            s = {};
                                        s.attribute = e, e.data && (s.data = e.data), n[t] = s, r++
                                    }
                                    c.attributes = n, c.attributesNum = r, c.index = e
                                }(y, x)
                            } else {
                                const t = !0 === l.wireframe;
                                c.geometry === y.id && c.program === u.id && c.wireframe === t || (c.geometry = y.id, c.program = u.id, c.wireframe = t, _ = !0)
                            }!0 === r.isInstancedMesh && (_ = !0), null !== x && n.update(x, 34963), _ && (function(r, s, o, a) {
                                if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                                p();
                                const l = a.attributes,
                                    c = o.getAttributes(),
                                    h = s.defaultAttributeValues;
                                for (const e in c) {
                                    const i = c[e];
                                    if (i.location >= 0) {
                                        let s = l[e];
                                        if (void 0 === s && ("instanceMatrix" === e && r.instanceMatrix && (s = r.instanceMatrix), "instanceColor" === e && r.instanceColor && (s = r.instanceColor)), void 0 !== s) {
                                            const e = s.normalized,
                                                o = s.itemSize,
                                                l = n.get(s);
                                            if (void 0 === l) continue;
                                            const c = l.buffer,
                                                h = l.type,
                                                u = l.bytesPerElement;
                                            if (s.isInterleavedBufferAttribute) {
                                                const n = s.data,
                                                    l = n.stride,
                                                    d = s.offset;
                                                if (n && n.isInstancedInterleavedBuffer) { for (let t = 0; t < i.locationSize; t++) f(i.location + t, n.meshPerAttribute);!0 !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count) } else
                                                    for (let t = 0; t < i.locationSize; t++) m(i.location + t);
                                                t.bindBuffer(34962, c);
                                                for (let t = 0; t < i.locationSize; t++) v(i.location + t, o / i.locationSize, h, e, l * u, (d + o / i.locationSize * t) * u)
                                            } else {
                                                if (s.isInstancedBufferAttribute) { for (let t = 0; t < i.locationSize; t++) f(i.location + t, s.meshPerAttribute);!0 !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count) } else
                                                    for (let t = 0; t < i.locationSize; t++) m(i.location + t);
                                                t.bindBuffer(34962, c);
                                                for (let t = 0; t < i.locationSize; t++) v(i.location + t, o / i.locationSize, h, e, o * u, o / i.locationSize * t * u)
                                            }
                                        } else if (void 0 !== h) {
                                            const n = h[e];
                                            if (void 0 !== n) switch (n.length) {
                                                case 2:
                                                    t.vertexAttrib2fv(i.location, n);
                                                    break;
                                                case 3:
                                                    t.vertexAttrib3fv(i.location, n);
                                                    break;
                                                case 4:
                                                    t.vertexAttrib4fv(i.location, n);
                                                    break;
                                                default:
                                                    t.vertexAttrib1fv(i.location, n)
                                            }
                                        }
                                    }
                                }
                                g()
                            }(r, l, u, y), null !== x && t.bindBuffer(34963, n.get(x).buffer))
                        },
                        reset: y,
                        resetDefaultState: x,
                        dispose: function() {
                            y();
                            for (const t in a) {
                                const e = a[t];
                                for (const t in e) {
                                    const n = e[t];
                                    for (const t in n) u(n[t].object), delete n[t];
                                    delete e[t]
                                }
                                delete a[t]
                            }
                        },
                        releaseStatesOfGeometry: function(t) {
                            if (void 0 === a[t.id]) return;
                            const e = a[t.id];
                            for (const t in e) {
                                const n = e[t];
                                for (const t in n) u(n[t].object), delete n[t];
                                delete e[t]
                            }
                            delete a[t.id]
                        },
                        releaseStatesOfProgram: function(t) {
                            for (const e in a) {
                                const n = a[e];
                                if (void 0 === n[t.id]) continue;
                                const i = n[t.id];
                                for (const t in i) u(i[t].object), delete i[t];
                                delete n[t.id]
                            }
                        },
                        initAttributes: p,
                        enableAttribute: m,
                        disableUnusedAttributes: g
                    }
                }

                function Zs(t, e, n, i) {
                    const r = i.isWebGL2;
                    let s;
                    this.setMode = function(t) { s = t }, this.render = function(e, i) { t.drawArrays(s, e, i), n.update(i, s, 1) }, this.renderInstances = function(i, o, a) {
                        if (0 === a) return;
                        let l, c;
                        if (r) l = t, c = "drawArraysInstanced";
                        else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        l[c](s, i, o, a), n.update(o, s, a)
                    }
                }

                function Js(t, e, n) {
                    let i;

                    function r(e) {
                        if ("highp" === e) {
                            if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                            e = "mediump"
                        }
                        return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                    }
                    const s = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
                    let o = void 0 !== n.precision ? n.precision : "highp";
                    const a = r(o);
                    a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a);
                    const l = s || e.has("WEBGL_draw_buffers"),
                        c = !0 === n.logarithmicDepthBuffer,
                        h = t.getParameter(34930),
                        u = t.getParameter(35660),
                        d = t.getParameter(3379),
                        p = t.getParameter(34076),
                        m = t.getParameter(34921),
                        f = t.getParameter(36347),
                        g = t.getParameter(36348),
                        v = t.getParameter(36349),
                        y = u > 0,
                        x = s || e.has("OES_texture_float");
                    return {
                        isWebGL2: s,
                        drawBuffers: l,
                        getMaxAnisotropy: function() {
                            if (void 0 !== i) return i;
                            if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                                const n = e.get("EXT_texture_filter_anisotropic");
                                i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                            } else i = 0;
                            return i
                        },
                        getMaxPrecision: r,
                        precision: o,
                        logarithmicDepthBuffer: c,
                        maxTextures: h,
                        maxVertexTextures: u,
                        maxTextureSize: d,
                        maxCubemapSize: p,
                        maxAttributes: m,
                        maxVertexUniforms: f,
                        maxVaryings: g,
                        maxFragmentUniforms: v,
                        vertexTextures: y,
                        floatFragmentTextures: x,
                        floatVertexTextures: y && x,
                        maxSamples: s ? t.getParameter(36183) : 0
                    }
                }

                function Ks(t) {
                    const e = this;
                    let n = null,
                        i = 0,
                        r = !1,
                        s = !1;
                    const o = new Fs,
                        a = new Kn,
                        l = { value: null, needsUpdate: !1 };

                    function c() { l.value !== n && (l.value = n, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0 }

                    function h(t, n, i, r) {
                        const s = null !== t ? t.length : 0;
                        let c = null;
                        if (0 !== s) {
                            if (c = l.value, !0 !== r || null === c) {
                                const e = i + 4 * s,
                                    r = n.matrixWorldInverse;
                                a.getNormalMatrix(r), (null === c || c.length < e) && (c = new Float32Array(e));
                                for (let e = 0, n = i; e !== s; ++e, n += 4) o.copy(t[e]).applyMatrix4(r, a), o.normal.toArray(c, n), c[n + 3] = o.constant
                            }
                            l.value = c, l.needsUpdate = !0
                        }
                        return e.numPlanes = s, e.numIntersection = 0, c
                    }
                    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e, s) { const o = 0 !== t.length || e || 0 !== i || r; return r = e, n = h(t, s, 0), i = t.length, o }, this.beginShadows = function() { s = !0, h(null) }, this.endShadows = function() { s = !1, c() }, this.setState = function(e, o, a) {
                        const u = e.clippingPlanes,
                            d = e.clipIntersection,
                            p = e.clipShadows,
                            m = t.get(e);
                        if (!r || null === u || 0 === u.length || s && !p) s ? h(null) : c();
                        else {
                            const t = s ? 0 : i,
                                e = 4 * t;
                            let r = m.clippingState || null;
                            l.value = r, r = h(u, o, e, a);
                            for (let t = 0; t !== e; ++t) r[t] = n[t];
                            m.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                        }
                    }
                }

                function Qs(t) {
                    let e = new WeakMap;

                    function n(t, e) { return e === at ? t.mapping = st : e === lt && (t.mapping = ot), t }

                    function i(t) {
                        const n = t.target;
                        n.removeEventListener("dispose", i);
                        const r = e.get(n);
                        void 0 !== r && (e.delete(n), r.dispose())
                    }
                    return {
                        get: function(r) {
                            if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                                const s = r.mapping;
                                if (s === at || s === lt) {
                                    if (e.has(r)) return n(e.get(r).texture, r.mapping); {
                                        const s = r.image;
                                        if (s && s.height > 0) {
                                            const o = t.getRenderTarget(),
                                                a = new Ds(s.height / 2);
                                            return a.fromEquirectangularTexture(t, r), e.set(r, a), t.setRenderTarget(o), r.addEventListener("dispose", i), n(a.texture, r.mapping)
                                        }
                                        return null
                                    }
                                }
                            }
                            return r
                        },
                        dispose: function() { e = new WeakMap }
                    }
                }
                qs.physical = { uniforms: Ts([qs.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new Jn(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: 0 }, sheenColor: { value: new Br(0) }, sheenColorMap: { value: null }, sheenRoughness: { value: 0 }, sheenRoughnessMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new Jn }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Br(0) }, specularIntensity: { value: 0 }, specularIntensityMap: { value: null }, specularColor: { value: new Br(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: Ws.meshphysical_vert, fragmentShader: Ws.meshphysical_frag };
                class $s extends Ls {
                    constructor(t = -1, e = 1, n = 1, i = -1, r = .1, s = 2e3) { super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix() }
                    copy(t, e) { return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this }
                    setViewOffset(t, e, n, i, r, s) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix() }
                    clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }
                    updateProjectionMatrix() {
                        const t = (this.right - this.left) / (2 * this.zoom),
                            e = (this.top - this.bottom) / (2 * this.zoom),
                            n = (this.right + this.left) / 2,
                            i = (this.top + this.bottom) / 2;
                        let r = n - t,
                            s = n + t,
                            o = i + e,
                            a = i - e;
                        if (null !== this.view && this.view.enabled) {
                            const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                                e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                            r += t * this.view.offsetX, s = r + t * this.view.width, o -= e * this.view.offsetY, a = o - e * this.view.height
                        }
                        this.projectionMatrix.makeOrthographic(r, s, o, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(t) { const e = super.toJSON(t); return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e }
                }
                $s.prototype.isOrthographicCamera = !0;
                class to extends As { constructor(t) { super(t), this.type = "RawShaderMaterial" } }
                to.prototype.isRawShaderMaterial = !0;
                const eo = Math.pow(2, 8),
                    no = [.125, .215, .35, .446, .526, .582],
                    io = 5 + no.length,
                    ro = {
                        [Je]: 0,
                        [Ke]: 1,
                        [$e]: 2,
                        [en]: 3,
                        [nn]: 4,
                        [rn]: 5,
                        [Qe]: 6
                    },
                    so = new $s,
                    { _lodPlanes: oo, _sizeLods: ao, _sigmas: lo } = vo(),
                    co = new Br;
                let ho = null;
                const uo = (1 + Math.sqrt(5)) / 2,
                    po = 1 / uo,
                    mo = [new pi(1, 1, 1), new pi(-1, 1, 1), new pi(1, 1, -1), new pi(-1, 1, -1), new pi(0, uo, po), new pi(0, uo, -po), new pi(po, 0, uo), new pi(-po, 0, uo), new pi(uo, po, 0), new pi(-uo, po, 0)];
                class fo {
                    constructor(t) {
                        this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = function(t) {
                            const e = new Float32Array(20),
                                n = new pi(0, 1, 0);
                            return new to({ name: "SphericalGaussianBlur", defines: { n: 20 }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: e }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: n }, inputEncoding: { value: ro[Je] }, outputEncoding: { value: ro[Je] } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t", blending: x, depthTest: !1, depthWrite: !1 })
                        }(), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
                    }
                    fromScene(t, e = 0, n = .1, i = 100) { ho = this._renderer.getRenderTarget(); const r = this._allocateTargets(); return this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r }
                    fromEquirectangular(t) { return this._fromTexture(t) }
                    fromCubemap(t) { return this._fromTexture(t) }
                    compileCubemapShader() { null === this._cubemapShader && (this._cubemapShader = bo(), this._compileMaterial(this._cubemapShader)) }
                    compileEquirectangularShader() { null === this._equirectShader && (this._equirectShader = _o(), this._compileMaterial(this._equirectShader)) }
                    dispose() { this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose(); for (let t = 0; t < oo.length; t++) oo[t].dispose() }
                    _cleanup(t) { this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(ho), t.scissorTest = !1, xo(t, 0, 0, t.width, t.height) }
                    _fromTexture(t) { ho = this._renderer.getRenderTarget(); const e = this._allocateTargets(t); return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e }
                    _allocateTargets(t) {
                        const e = { magFilter: mt, minFilter: mt, generateMipmaps: !1, type: St, format: kt, encoding: go(t) ? t.encoding : $e, depthBuffer: !1 },
                            n = yo(e);
                        return n.depthBuffer = !t, this._pingPongRenderTarget = yo(e), n
                    }
                    _compileMaterial(t) {
                        const e = new bs(oo[0], t);
                        this._renderer.compile(e, so)
                    }
                    _sceneToCubeUV(t, e, n, i) {
                        const r = new Rs(90, 1, e, n),
                            s = [1, -1, 1, 1, 1, 1],
                            o = [1, 1, 1, -1, -1, -1],
                            a = this._renderer,
                            l = a.autoClear,
                            c = a.outputEncoding,
                            h = a.toneMapping;
                        a.getClearColor(co), a.toneMapping = Q, a.outputEncoding = Je, a.autoClear = !1;
                        const u = new Or({ name: "PMREM.Background", side: f, depthWrite: !1, depthTest: !1 }),
                            d = new bs(new Ms, u);
                        let p = !1;
                        const m = t.background;
                        m ? m.isColor && (u.color.copy(m), t.background = null, p = !0) : (u.color.copy(co), p = !0);
                        for (let e = 0; e < 6; e++) {
                            const n = e % 3;
                            0 == n ? (r.up.set(0, s[e], 0), r.lookAt(o[e], 0, 0)) : 1 == n ? (r.up.set(0, 0, s[e]), r.lookAt(0, o[e], 0)) : (r.up.set(0, s[e], 0), r.lookAt(0, 0, o[e])), xo(i, n * eo, e > 2 ? eo : 0, eo, eo), a.setRenderTarget(i), p && a.render(d, r), a.render(t, r)
                        }
                        d.geometry.dispose(), d.material.dispose(), a.toneMapping = h, a.outputEncoding = c, a.autoClear = l, t.background = m
                    }
                    _setEncoding(t, e) {!0 === this._renderer.capabilities.isWebGL2 && e.format === zt && e.type === St && e.encoding === Ke ? t.value = ro[Je] : t.value = ro[e.encoding] }
                    _textureToCubeUV(t, e) {
                        const n = this._renderer,
                            i = t.mapping === st || t.mapping === ot;
                        i ? null == this._cubemapShader && (this._cubemapShader = bo()) : null == this._equirectShader && (this._equirectShader = _o());
                        const r = i ? this._cubemapShader : this._equirectShader,
                            s = new bs(oo[0], r),
                            o = r.uniforms;
                        o.envMap.value = t, i || o.texelSize.value.set(1 / t.image.width, 1 / t.image.height), this._setEncoding(o.inputEncoding, t), this._setEncoding(o.outputEncoding, e.texture), xo(e, 0, 0, 3 * eo, 2 * eo), n.setRenderTarget(e), n.render(s, so)
                    }
                    _applyPMREM(t) {
                        const e = this._renderer,
                            n = e.autoClear;
                        e.autoClear = !1;
                        for (let e = 1; e < io; e++) {
                            const n = Math.sqrt(lo[e] * lo[e] - lo[e - 1] * lo[e - 1]),
                                i = mo[(e - 1) % mo.length];
                            this._blur(t, e - 1, e, n, i)
                        }
                        e.autoClear = n
                    }
                    _blur(t, e, n, i, r) {
                        const s = this._pingPongRenderTarget;
                        this._halfBlur(t, s, e, n, i, "latitudinal", r), this._halfBlur(s, t, n, n, i, "longitudinal", r)
                    }
                    _halfBlur(t, e, n, i, r, s, o) {
                        const a = this._renderer,
                            l = this._blurMaterial;
                        "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
                        const c = new bs(oo[i], l),
                            h = l.uniforms,
                            u = ao[n] - 1,
                            d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
                            p = r / d,
                            m = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
                        m > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);
                        const f = [];
                        let g = 0;
                        for (let t = 0; t < 20; ++t) {
                            const e = t / p,
                                n = Math.exp(-e * e / 2);
                            f.push(n), 0 == t ? g += n : t < m && (g += 2 * n)
                        }
                        for (let t = 0; t < f.length; t++) f[t] = f[t] / g;
                        h.envMap.value = t.texture, h.samples.value = m, h.weights.value = f, h.latitudinal.value = "latitudinal" === s, o && (h.poleAxis.value = o), h.dTheta.value = d, h.mipInt.value = 8 - n, this._setEncoding(h.inputEncoding, t.texture), this._setEncoding(h.outputEncoding, t.texture);
                        const v = ao[i];
                        xo(e, 3 * Math.max(0, eo - 2 * v), (0 === i ? 0 : 2 * eo) + 2 * v * (i > 4 ? i - 8 + 4 : 0), 3 * v, 2 * v), a.setRenderTarget(e), a.render(c, so)
                    }
                }

                function go(t) { return void 0 !== t && t.type === St && (t.encoding === Je || t.encoding === Ke || t.encoding === Qe) }

                function vo() {
                    const t = [],
                        e = [],
                        n = [];
                    let i = 8;
                    for (let r = 0; r < io; r++) {
                        const s = Math.pow(2, i);
                        e.push(s);
                        let o = 1 / s;
                        r > 4 ? o = no[r - 8 + 4 - 1] : 0 == r && (o = 0), n.push(o);
                        const a = 1 / (s - 1),
                            l = -a / 2,
                            c = 1 + a / 2,
                            h = [l, l, c, l, c, c, l, l, c, c, l, c],
                            u = 6,
                            d = 6,
                            p = 3,
                            m = 2,
                            f = 1,
                            g = new Float32Array(p * d * u),
                            v = new Float32Array(m * d * u),
                            y = new Float32Array(f * d * u);
                        for (let t = 0; t < u; t++) {
                            const e = t % 3 * 2 / 3 - 1,
                                n = t > 2 ? 0 : -1,
                                i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                            g.set(i, p * d * t), v.set(h, m * d * t);
                            const r = [t, t, t, t, t, t];
                            y.set(r, f * d * t)
                        }
                        const x = new is;
                        x.setAttribute("position", new Ur(g, p)), x.setAttribute("uv", new Ur(v, m)), x.setAttribute("faceIndex", new Ur(y, f)), t.push(x), i > 4 && i--
                    }
                    return { _lodPlanes: t, _sizeLods: e, _sigmas: n }
                }

                function yo(t) { const e = new ci(3 * eo, 3 * eo, t); return e.texture.mapping = ct, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e }

                function xo(t, e, n, i, r) { t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r) }

                function _o() { const t = new Jn(1, 1); return new to({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null }, texelSize: { value: t }, inputEncoding: { value: ro[Je] }, outputEncoding: { value: ro[Je] } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t", blending: x, depthTest: !1, depthWrite: !1 }) }

                function bo() { return new to({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, inputEncoding: { value: ro[Je] }, outputEncoding: { value: ro[Je] } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t", blending: x, depthTest: !1, depthWrite: !1 }) }

                function wo(t) {
                    let e = new WeakMap,
                        n = null;

                    function i(t) {
                        const n = t.target;
                        n.removeEventListener("dispose", i);
                        const r = e.get(n);
                        void 0 !== r && (e.delete(n), r.dispose())
                    }
                    return {
                        get: function(r) {
                            if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                                const s = r.mapping,
                                    o = s === at || s === lt,
                                    a = s === st || s === ot;
                                if (o || a) {
                                    if (e.has(r)) return e.get(r).texture; {
                                        const s = r.image;
                                        if (o && s && s.height > 0 || a && s && function(t) { let e = 0; for (let n = 0; n < 6; n++) void 0 !== t[n] && e++; return 6 === e }(s)) {
                                            const s = t.getRenderTarget();
                                            null === n && (n = new fo(t));
                                            const a = o ? n.fromEquirectangular(r) : n.fromCubemap(r);
                                            return e.set(r, a), t.setRenderTarget(s), r.addEventListener("dispose", i), a.texture
                                        }
                                        return null
                                    }
                                }
                            }
                            return r
                        },
                        dispose: function() { e = new WeakMap, null !== n && (n.dispose(), n = null) }
                    }
                }

                function Mo(t) {
                    const e = {};

                    function n(n) {
                        if (void 0 !== e[n]) return e[n];
                        let i;
                        switch (n) {
                            case "WEBGL_depth_texture":
                                i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            default:
                                i = t.getExtension(n)
                        }
                        return e[n] = i, i
                    }
                    return { has: function(t) { return null !== n(t) }, init: function(t) { t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float") }, get: function(t) { const e = n(t); return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e } }
                }

                function So(t, e, n, i) {
                    const r = {},
                        s = new WeakMap;

                    function o(t) {
                        const a = t.target;
                        null !== a.index && e.remove(a.index);
                        for (const t in a.attributes) e.remove(a.attributes[t]);
                        a.removeEventListener("dispose", o), delete r[a.id];
                        const l = s.get(a);
                        l && (e.remove(l), s.delete(a)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
                    }

                    function a(t) {
                        const n = [],
                            i = t.index,
                            r = t.attributes.position;
                        let o = 0;
                        if (null !== i) {
                            const t = i.array;
                            o = i.version;
                            for (let e = 0, i = t.length; e < i; e += 3) {
                                const i = t[e + 0],
                                    r = t[e + 1],
                                    s = t[e + 2];
                                n.push(i, r, r, s, s, i)
                            }
                        } else {
                            const t = r.array;
                            o = r.version;
                            for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                                const t = e + 0,
                                    i = e + 1,
                                    r = e + 2;
                                n.push(t, i, i, r, r, t)
                            }
                        }
                        const a = new(Qn(n) > 65535 ? qr : Wr)(n, 1);
                        a.version = o;
                        const l = s.get(t);
                        l && e.remove(l), s.set(t, a)
                    }
                    return {
                        get: function(t, e) { return !0 === r[e.id] || (e.addEventListener("dispose", o), r[e.id] = !0, n.memory.geometries++), e },
                        update: function(t) { const n = t.attributes; for (const t in n) e.update(n[t], 34962); const i = t.morphAttributes; for (const t in i) { const n = i[t]; for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962) } },
                        getWireframeAttribute: function(t) {
                            const e = s.get(t);
                            if (e) {
                                const n = t.index;
                                null !== n && e.version < n.version && a(t)
                            } else a(t);
                            return s.get(t)
                        }
                    }
                }

                function To(t, e, n, i) {
                    const r = i.isWebGL2;
                    let s, o, a;
                    this.setMode = function(t) { s = t }, this.setIndex = function(t) { o = t.type, a = t.bytesPerElement }, this.render = function(e, i) { t.drawElements(s, i, o, e * a), n.update(i, s, 1) }, this.renderInstances = function(i, l, c) {
                        if (0 === c) return;
                        let h, u;
                        if (r) h = t, u = "drawElementsInstanced";
                        else if (h = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        h[u](s, l, o, i * a, c), n.update(l, s, c)
                    }
                }

                function Eo(t) {
                    const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
                    return {
                        memory: { geometries: 0, textures: 0 },
                        render: e,
                        programs: null,
                        autoReset: !0,
                        reset: function() { e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0 },
                        update: function(t, n, i) {
                            switch (e.calls++, n) {
                                case 4:
                                    e.triangles += i * (t / 3);
                                    break;
                                case 1:
                                    e.lines += i * (t / 2);
                                    break;
                                case 3:
                                    e.lines += i * (t - 1);
                                    break;
                                case 2:
                                    e.lines += i * t;
                                    break;
                                case 0:
                                    e.points += i * t;
                                    break;
                                default:
                                    console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                            }
                        }
                    }
                }
                class Ao extends oi { constructor(t = null, e = 1, n = 1, i = 1) { super(null), this.image = { data: t, width: e, height: n, depth: i }, this.magFilter = mt, this.minFilter = mt, this.wrapR = dt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } }

                function Lo(t, e) { return t[0] - e[0] }

                function Ro(t, e) { return Math.abs(e[1]) - Math.abs(t[1]) }

                function Co(t, e) {
                    let n = 1;
                    const i = e.isInterleavedBufferAttribute ? e.data.array : e.array;
                    i instanceof Int8Array ? n = 127 : i instanceof Int16Array ? n = 32767 : i instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i), t.divideScalar(n)
                }

                function Po(t, e, n) {
                    const i = {},
                        r = new Float32Array(8),
                        s = new WeakMap,
                        o = new pi,
                        a = [];
                    for (let t = 0; t < 8; t++) a[t] = [t, 0];
                    return {
                        update: function(l, c, h, u) {
                            const d = l.morphTargetInfluences;
                            if (!0 === e.isWebGL2) {
                                const i = c.morphAttributes.position.length;
                                let r = s.get(c);
                                if (void 0 === r || r.count !== i) {
                                    void 0 !== r && r.texture.dispose();
                                    const t = void 0 !== c.morphAttributes.normal,
                                        n = c.morphAttributes.position,
                                        a = c.morphAttributes.normal || [],
                                        l = !0 === t ? 2 : 1;
                                    let h = c.attributes.position.count * l,
                                        u = 1;
                                    h > e.maxTextureSize && (u = Math.ceil(h / e.maxTextureSize), h = e.maxTextureSize);
                                    const d = new Float32Array(h * u * 4 * i),
                                        p = new Ao(d, h, u, i);
                                    p.format = zt, p.type = Ct;
                                    const m = 4 * l;
                                    for (let e = 0; e < i; e++) {
                                        const i = n[e],
                                            r = a[e],
                                            s = h * u * 4 * e;
                                        for (let e = 0; e < i.count; e++) {
                                            o.fromBufferAttribute(i, e), !0 === i.normalized && Co(o, i);
                                            const n = e * m;
                                            d[s + n + 0] = o.x, d[s + n + 1] = o.y, d[s + n + 2] = o.z, d[s + n + 3] = 0, !0 === t && (o.fromBufferAttribute(r, e), !0 === r.normalized && Co(o, r), d[s + n + 4] = o.x, d[s + n + 5] = o.y, d[s + n + 6] = o.z, d[s + n + 7] = 0)
                                        }
                                    }
                                    r = { count: i, texture: p, size: new Jn(h, u) }, s.set(c, r)
                                }
                                let a = 0;
                                for (let t = 0; t < d.length; t++) a += d[t];
                                const l = c.morphTargetsRelative ? 1 : 1 - a;
                                u.getUniforms().setValue(t, "morphTargetBaseInfluence", l), u.getUniforms().setValue(t, "morphTargetInfluences", d), u.getUniforms().setValue(t, "morphTargetsTexture", r.texture, n), u.getUniforms().setValue(t, "morphTargetsTextureSize", r.size)
                            } else {
                                const e = void 0 === d ? 0 : d.length;
                                let n = i[c.id];
                                if (void 0 === n || n.length !== e) {
                                    n = [];
                                    for (let t = 0; t < e; t++) n[t] = [t, 0];
                                    i[c.id] = n
                                }
                                for (let t = 0; t < e; t++) {
                                    const e = n[t];
                                    e[0] = t, e[1] = d[t]
                                }
                                n.sort(Ro);
                                for (let t = 0; t < 8; t++) t < e && n[t][1] ? (a[t][0] = n[t][0], a[t][1] = n[t][1]) : (a[t][0] = Number.MAX_SAFE_INTEGER, a[t][1] = 0);
                                a.sort(Lo);
                                const s = c.morphAttributes.position,
                                    o = c.morphAttributes.normal;
                                let l = 0;
                                for (let t = 0; t < 8; t++) {
                                    const e = a[t],
                                        n = e[0],
                                        i = e[1];
                                    n !== Number.MAX_SAFE_INTEGER && i ? (s && c.getAttribute("morphTarget" + t) !== s[n] && c.setAttribute("morphTarget" + t, s[n]), o && c.getAttribute("morphNormal" + t) !== o[n] && c.setAttribute("morphNormal" + t, o[n]), r[t] = i, l += i) : (s && !0 === c.hasAttribute("morphTarget" + t) && c.deleteAttribute("morphTarget" + t), o && !0 === c.hasAttribute("morphNormal" + t) && c.deleteAttribute("morphNormal" + t), r[t] = 0)
                                }
                                const h = c.morphTargetsRelative ? 1 : 1 - l;
                                u.getUniforms().setValue(t, "morphTargetBaseInfluence", h), u.getUniforms().setValue(t, "morphTargetInfluences", r)
                            }
                        }
                    }
                }

                function Io(t, e, n, i) {
                    let r = new WeakMap;

                    function s(t) {
                        const e = t.target;
                        e.removeEventListener("dispose", s), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
                    }
                    return {
                        update: function(t) {
                            const o = i.render.frame,
                                a = t.geometry,
                                l = e.get(t, a);
                            return r.get(l) !== o && (e.update(l), r.set(l, o)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s) && t.addEventListener("dispose", s), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), l
                        },
                        dispose: function() { r = new WeakMap }
                    }
                }
                Ao.prototype.isDataTexture2DArray = !0;
                class Do extends oi { constructor(t = null, e = 1, n = 1, i = 1) { super(null), this.image = { data: t, width: e, height: n, depth: i }, this.magFilter = mt, this.minFilter = mt, this.wrapR = dt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } }
                Do.prototype.isDataTexture3D = !0;
                const No = new oi,
                    Bo = new Ao,
                    Oo = new Do,
                    Fo = new Is,
                    zo = [],
                    Uo = [],
                    Ho = new Float32Array(16),
                    ko = new Float32Array(9),
                    Go = new Float32Array(4);

                function Vo(t, e, n) { const i = t[0]; if (i <= 0 || i > 0) return t; const r = e * n; let s = zo[r]; if (void 0 === s && (s = new Float32Array(r), zo[r] = s), 0 !== e) { i.toArray(s, 0); for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(s, r) } return s }

                function Wo(t, e) {
                    if (t.length !== e.length) return !1;
                    for (let n = 0, i = t.length; n < i; n++)
                        if (t[n] !== e[n]) return !1;
                    return !0
                }

                function jo(t, e) { for (let n = 0, i = e.length; n < i; n++) t[n] = e[n] }

                function qo(t, e) {
                    let n = Uo[e];
                    void 0 === n && (n = new Int32Array(e), Uo[e] = n);
                    for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
                    return n
                }

                function Xo(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
                }

                function Yo(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                    else {
                        if (Wo(n, e)) return;
                        t.uniform2fv(this.addr, e), jo(n, e)
                    }
                }

                function Zo(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                    else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
                    else {
                        if (Wo(n, e)) return;
                        t.uniform3fv(this.addr, e), jo(n, e)
                    }
                }

                function Jo(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                    else {
                        if (Wo(n, e)) return;
                        t.uniform4fv(this.addr, e), jo(n, e)
                    }
                }

                function Ko(t, e) {
                    const n = this.cache,
                        i = e.elements;
                    if (void 0 === i) {
                        if (Wo(n, e)) return;
                        t.uniformMatrix2fv(this.addr, !1, e), jo(n, e)
                    } else {
                        if (Wo(n, i)) return;
                        Go.set(i), t.uniformMatrix2fv(this.addr, !1, Go), jo(n, i)
                    }
                }

                function Qo(t, e) {
                    const n = this.cache,
                        i = e.elements;
                    if (void 0 === i) {
                        if (Wo(n, e)) return;
                        t.uniformMatrix3fv(this.addr, !1, e), jo(n, e)
                    } else {
                        if (Wo(n, i)) return;
                        ko.set(i), t.uniformMatrix3fv(this.addr, !1, ko), jo(n, i)
                    }
                }

                function $o(t, e) {
                    const n = this.cache,
                        i = e.elements;
                    if (void 0 === i) {
                        if (Wo(n, e)) return;
                        t.uniformMatrix4fv(this.addr, !1, e), jo(n, e)
                    } else {
                        if (Wo(n, i)) return;
                        Ho.set(i), t.uniformMatrix4fv(this.addr, !1, Ho), jo(n, i)
                    }
                }

                function ta(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
                }

                function ea(t, e) {
                    const n = this.cache;
                    Wo(n, e) || (t.uniform2iv(this.addr, e), jo(n, e))
                }

                function na(t, e) {
                    const n = this.cache;
                    Wo(n, e) || (t.uniform3iv(this.addr, e), jo(n, e))
                }

                function ia(t, e) {
                    const n = this.cache;
                    Wo(n, e) || (t.uniform4iv(this.addr, e), jo(n, e))
                }

                function ra(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
                }

                function sa(t, e) {
                    const n = this.cache;
                    Wo(n, e) || (t.uniform2uiv(this.addr, e), jo(n, e))
                }

                function oa(t, e) {
                    const n = this.cache;
                    Wo(n, e) || (t.uniform3uiv(this.addr, e), jo(n, e))
                }

                function aa(t, e) {
                    const n = this.cache;
                    Wo(n, e) || (t.uniform4uiv(this.addr, e), jo(n, e))
                }

                function la(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || No, r)
                }

                function ca(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || Oo, r)
                }

                function ha(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || Fo, r)
                }

                function ua(t, e, n) {
                    const i = this.cache,
                        r = n.allocateTextureUnit();
                    i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || Bo, r)
                }

                function da(t, e) { t.uniform1fv(this.addr, e) }

                function pa(t, e) {
                    const n = Vo(e, this.size, 2);
                    t.uniform2fv(this.addr, n)
                }

                function ma(t, e) {
                    const n = Vo(e, this.size, 3);
                    t.uniform3fv(this.addr, n)
                }

                function fa(t, e) {
                    const n = Vo(e, this.size, 4);
                    t.uniform4fv(this.addr, n)
                }

                function ga(t, e) {
                    const n = Vo(e, this.size, 4);
                    t.uniformMatrix2fv(this.addr, !1, n)
                }

                function va(t, e) {
                    const n = Vo(e, this.size, 9);
                    t.uniformMatrix3fv(this.addr, !1, n)
                }

                function ya(t, e) {
                    const n = Vo(e, this.size, 16);
                    t.uniformMatrix4fv(this.addr, !1, n)
                }

                function xa(t, e) { t.uniform1iv(this.addr, e) }

                function _a(t, e) { t.uniform2iv(this.addr, e) }

                function ba(t, e) { t.uniform3iv(this.addr, e) }

                function wa(t, e) { t.uniform4iv(this.addr, e) }

                function Ma(t, e) { t.uniform1uiv(this.addr, e) }

                function Sa(t, e) { t.uniform2uiv(this.addr, e) }

                function Ta(t, e) { t.uniform3uiv(this.addr, e) }

                function Ea(t, e) { t.uniform4uiv(this.addr, e) }

                function Aa(t, e, n) {
                    const i = e.length,
                        r = qo(n, i);
                    t.uniform1iv(this.addr, r);
                    for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || No, r[t])
                }

                function La(t, e, n) {
                    const i = e.length,
                        r = qo(n, i);
                    t.uniform1iv(this.addr, r);
                    for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || Fo, r[t])
                }

                function Ra(t, e, n) {
                    this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                        switch (t) {
                            case 5126:
                                return Xo;
                            case 35664:
                                return Yo;
                            case 35665:
                                return Zo;
                            case 35666:
                                return Jo;
                            case 35674:
                                return Ko;
                            case 35675:
                                return Qo;
                            case 35676:
                                return $o;
                            case 5124:
                            case 35670:
                                return ta;
                            case 35667:
                            case 35671:
                                return ea;
                            case 35668:
                            case 35672:
                                return na;
                            case 35669:
                            case 35673:
                                return ia;
                            case 5125:
                                return ra;
                            case 36294:
                                return sa;
                            case 36295:
                                return oa;
                            case 36296:
                                return aa;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return la;
                            case 35679:
                            case 36299:
                            case 36307:
                                return ca;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return ha;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return ua
                        }
                    }(e.type)
                }

                function Ca(t, e, n) {
                    this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                        switch (t) {
                            case 5126:
                                return da;
                            case 35664:
                                return pa;
                            case 35665:
                                return ma;
                            case 35666:
                                return fa;
                            case 35674:
                                return ga;
                            case 35675:
                                return va;
                            case 35676:
                                return ya;
                            case 5124:
                            case 35670:
                                return xa;
                            case 35667:
                            case 35671:
                                return _a;
                            case 35668:
                            case 35672:
                                return ba;
                            case 35669:
                            case 35673:
                                return wa;
                            case 5125:
                                return Ma;
                            case 36294:
                                return Sa;
                            case 36295:
                                return Ta;
                            case 36296:
                                return Ea;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return Aa;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return La
                        }
                    }(e.type)
                }

                function Pa(t) { this.id = t, this.seq = [], this.map = {} }
                Ca.prototype.updateCache = function(t) {
                    const e = this.cache;
                    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), jo(e, t)
                }, Pa.prototype.setValue = function(t, e, n) {
                    const i = this.seq;
                    for (let r = 0, s = i.length; r !== s; ++r) {
                        const s = i[r];
                        s.setValue(t, e[s.id], n)
                    }
                };
                const Ia = /(\w+)(\])?(\[|\.)?/g;

                function Da(t, e) { t.seq.push(e), t.map[e.id] = e }

                function Na(t, e, n) {
                    const i = t.name,
                        r = i.length;
                    for (Ia.lastIndex = 0;;) {
                        const s = Ia.exec(i),
                            o = Ia.lastIndex;
                        let a = s[1];
                        const l = "]" === s[2],
                            c = s[3];
                        if (l && (a |= 0), void 0 === c || "[" === c && o + 2 === r) { Da(n, void 0 === c ? new Ra(a, t, e) : new Ca(a, t, e)); break } {
                            let t = n.map[a];
                            void 0 === t && (t = new Pa(a), Da(n, t)), n = t
                        }
                    }
                }

                function Ba(t, e) {
                    this.seq = [], this.map = {};
                    const n = t.getProgramParameter(e, 35718);
                    for (let i = 0; i < n; ++i) {
                        const n = t.getActiveUniform(e, i);
                        Na(n, t.getUniformLocation(e, n.name), this)
                    }
                }

                function Oa(t, e, n) { const i = t.createShader(e); return t.shaderSource(i, n), t.compileShader(i), i }
                Ba.prototype.setValue = function(t, e, n, i) {
                    const r = this.map[e];
                    void 0 !== r && r.setValue(t, n, i)
                }, Ba.prototype.setOptional = function(t, e, n) {
                    const i = e[n];
                    void 0 !== i && this.setValue(t, n, i)
                }, Ba.upload = function(t, e, n, i) {
                    for (let r = 0, s = e.length; r !== s; ++r) {
                        const s = e[r],
                            o = n[s.id];
                        !1 !== o.needsUpdate && s.setValue(t, o.value, i)
                    }
                }, Ba.seqWithValue = function(t, e) {
                    const n = [];
                    for (let i = 0, r = t.length; i !== r; ++i) {
                        const r = t[i];
                        r.id in e && n.push(r)
                    }
                    return n
                };
                let Fa = 0;

                function za(t) {
                    switch (t) {
                        case Je:
                            return ["Linear", "( value )"];
                        case Ke:
                            return ["sRGB", "( value )"];
                        case $e:
                            return ["RGBE", "( value )"];
                        case en:
                            return ["RGBM", "( value, 7.0 )"];
                        case nn:
                            return ["RGBM", "( value, 16.0 )"];
                        case rn:
                            return ["RGBD", "( value, 256.0 )"];
                        case Qe:
                            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                        case tn:
                            return ["LogLuv", "( value )"];
                        default:
                            return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
                    }
                }

                function Ua(t, e, n) {
                    const i = t.getShaderParameter(e, 35713),
                        r = t.getShaderInfoLog(e).trim();
                    return i && "" === r ? "" : n.toUpperCase() + "\n\n" + r + "\n\n" + function(t) { const e = t.split("\n"); for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t]; return e.join("\n") }(t.getShaderSource(e))
                }

                function Ha(t, e) { const n = za(e); return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }" }

                function ka(t, e) { const n = za(e); return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }" }

                function Ga(t, e) {
                    let n;
                    switch (e) {
                        case $:
                            n = "Linear";
                            break;
                        case tt:
                            n = "Reinhard";
                            break;
                        case et:
                            n = "OptimizedCineon";
                            break;
                        case nt:
                            n = "ACESFilmic";
                            break;
                        case it:
                            n = "Custom";
                            break;
                        default:
                            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
                    }
                    return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                }

                function Va(t) { return "" !== t }

                function Wa(t, e) { return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) }

                function ja(t, e) { return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) }
                const qa = /^[ \t]*#include +<([\w\d./]+)>/gm;

                function Xa(t) { return t.replace(qa, Ya) }

                function Ya(t, e) { const n = Ws[e]; if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">"); return Xa(n) }
                const Za = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                    Ja = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

                function Ka(t) { return t.replace(Ja, $a).replace(Za, Qa) }

                function Qa(t, e, n, i) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), $a(0, e, n, i) }

                function $a(t, e, n, i) { let r = ""; for (let t = parseInt(e); t < parseInt(n); t++) r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t); return r }

                function tl(t) { let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;"; return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e }

                function el(t, e, n, i) {
                    const r = t.getContext(),
                        s = n.defines;
                    let o = n.vertexShader,
                        a = n.fragmentShader;
                    const l = function(t) { let e = "SHADOWMAP_TYPE_BASIC"; return t.shadowMapType === u ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === d ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === p && (e = "SHADOWMAP_TYPE_VSM"), e }(n),
                        c = function(t) {
                            let e = "ENVMAP_TYPE_CUBE";
                            if (t.envMap) switch (t.envMapMode) {
                                case st:
                                case ot:
                                    e = "ENVMAP_TYPE_CUBE";
                                    break;
                                case ct:
                                case ht:
                                    e = "ENVMAP_TYPE_CUBE_UV"
                            }
                            return e
                        }(n),
                        h = function(t) {
                            let e = "ENVMAP_MODE_REFLECTION";
                            if (t.envMap) switch (t.envMapMode) {
                                case ot:
                                case ht:
                                    e = "ENVMAP_MODE_REFRACTION"
                            }
                            return e
                        }(n),
                        m = function(t) {
                            let e = "ENVMAP_BLENDING_NONE";
                            if (t.envMap) switch (t.combine) {
                                case Z:
                                    e = "ENVMAP_BLENDING_MULTIPLY";
                                    break;
                                case J:
                                    e = "ENVMAP_BLENDING_MIX";
                                    break;
                                case K:
                                    e = "ENVMAP_BLENDING_ADD"
                            }
                            return e
                        }(n),
                        f = t.gammaFactor > 0 ? t.gammaFactor : 1,
                        g = n.isWebGL2 ? "" : function(t) { return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Va).join("\n") }(n),
                        v = function(t) { const e = []; for (const n in t) { const i = t[n];!1 !== i && e.push("#define " + n + " " + i) } return e.join("\n") }(s),
                        y = r.createProgram();
                    let x, _, b = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                    n.isRawShaderMaterial ? (x = [v].filter(Va).join("\n"), x.length > 0 && (x += "\n"), _ = [g, v].filter(Va).join("\n"), _.length > 0 && (_ += "\n")) : (x = [tl(n), "#define SHADER_NAME " + n.shaderName, v, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + f, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Va).join("\n"), _ = [g, tl(n), "#define SHADER_NAME " + n.shaderName, v, "#define GAMMA_FACTOR " + f, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== Q ? "#define TONE_MAPPING" : "", n.toneMapping !== Q ? Ws.tonemapping_pars_fragment : "", n.toneMapping !== Q ? Ga("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.format === Ft ? "#define OPAQUE" : "", Ws.encodings_pars_fragment, n.map ? Ha("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Ha("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? Ha("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? Ha("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.specularColorMap ? Ha("specularColorMapTexelToLinear", n.specularColorMapEncoding) : "", n.sheenColorMap ? Ha("sheenColorMapTexelToLinear", n.sheenColorMapEncoding) : "", n.lightMap ? Ha("lightMapTexelToLinear", n.lightMapEncoding) : "", ka("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Va).join("\n")), o = Xa(o), o = Wa(o, n), o = ja(o, n), a = Xa(a), a = Wa(a, n), a = ja(a, n), o = Ka(o), a = Ka(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (b = "#version 300 es\n", x = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + x, _ = ["#define varying in", n.glslVersion === Bn ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === Bn ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + _);
                    const w = b + _ + a,
                        M = Oa(r, 35633, b + x + o),
                        S = Oa(r, 35632, w);
                    if (r.attachShader(y, M), r.attachShader(y, S), void 0 !== n.index0AttributeName ? r.bindAttribLocation(y, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(y, 0, "position"), r.linkProgram(y), t.debug.checkShaderErrors) {
                        const t = r.getProgramInfoLog(y).trim(),
                            e = r.getShaderInfoLog(M).trim(),
                            n = r.getShaderInfoLog(S).trim();
                        let i = !0,
                            s = !0;
                        if (!1 === r.getProgramParameter(y, 35714)) {
                            i = !1;
                            const e = Ua(r, M, "vertex"),
                                n = Ua(r, S, "fragment");
                            console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(y, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n)
                        } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== n || (s = !1);
                        s && (this.diagnostics = { runnable: i, programLog: t, vertexShader: { log: e, prefix: x }, fragmentShader: { log: n, prefix: _ } })
                    }
                    let T, E;
                    return r.deleteShader(M), r.deleteShader(S), this.getUniforms = function() { return void 0 === T && (T = new Ba(r, y)), T }, this.getAttributes = function() {
                        return void 0 === E && (E = function(t, e) {
                            const n = {},
                                i = t.getProgramParameter(e, 35721);
                            for (let r = 0; r < i; r++) {
                                const i = t.getActiveAttrib(e, r),
                                    s = i.name;
                                let o = 1;
                                35674 === i.type && (o = 2), 35675 === i.type && (o = 3), 35676 === i.type && (o = 4), n[s] = { type: i.type, location: t.getAttribLocation(e, s), locationSize: o }
                            }
                            return n
                        }(r, y)), E
                    }, this.destroy = function() { i.releaseStatesOfProgram(this), r.deleteProgram(y), this.program = void 0 }, this.name = n.shaderName, this.id = Fa++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = M, this.fragmentShader = S, this
                }

                function nl(t, e, n, i, r, s, o) {
                    const a = [],
                        l = r.isWebGL2,
                        c = r.logarithmicDepthBuffer,
                        h = r.floatVertexTextures,
                        u = r.maxVertexUniforms,
                        d = r.vertexTextures;
                    let p = r.precision;
                    const m = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" },
                        v = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoat", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", , "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "alphaTest", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "morphTargetsCount", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "format", "specularIntensityMap", "specularColorMap", "specularColorMapEncoding", "transmission", "transmissionMap", "thicknessMap", "sheen", "sheenColorMap", "sheenColorMapEncoding", "sheenRoughnessMap"];

                    function y(t) { let e; return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = Je, l && t && t.isTexture && t.format === zt && t.type === St && t.encoding === Ke && (e = Je), e }
                    return {
                        getParameters: function(s, a, v, x, _) {
                            const b = x.fog,
                                w = s.isMeshStandardMaterial ? x.environment : null,
                                M = (s.isMeshStandardMaterial ? n : e).get(s.envMap || w),
                                S = m[s.type],
                                T = _.isSkinnedMesh ? function(t) {
                                    const e = t.skeleton.bones;
                                    if (h) return 1024; {
                                        const t = u,
                                            n = Math.floor((t - 20) / 4),
                                            i = Math.min(n, e.length);
                                        return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i
                                    }
                                }(_) : 0;
                            let E, A;
                            if (null !== s.precision && (p = r.getMaxPrecision(s.precision), p !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", p, "instead.")), S) {
                                const t = qs[S];
                                E = t.vertexShader, A = t.fragmentShader
                            } else E = s.vertexShader, A = s.fragmentShader;
                            const L = t.getRenderTarget(),
                                R = s.alphaTest > 0,
                                C = s.clearcoat > 0;
                            return { isWebGL2: l, shaderID: S, shaderName: s.type, vertexShader: E, fragmentShader: A, defines: s.defines, isRawShaderMaterial: !0 === s.isRawShaderMaterial, glslVersion: s.glslVersion, precision: p, instancing: !0 === _.isInstancedMesh, instancingColor: !0 === _.isInstancedMesh && null !== _.instanceColor, supportsVertexTextures: d, outputEncoding: null !== L ? y(L.texture) : t.outputEncoding, map: !!s.map, mapEncoding: y(s.map), matcap: !!s.matcap, matcapEncoding: y(s.matcap), envMap: !!M, envMapMode: M && M.mapping, envMapEncoding: y(M), envMapCubeUV: !!M && (M.mapping === ct || M.mapping === ht), lightMap: !!s.lightMap, lightMapEncoding: y(s.lightMap), aoMap: !!s.aoMap, emissiveMap: !!s.emissiveMap, emissiveMapEncoding: y(s.emissiveMap), bumpMap: !!s.bumpMap, normalMap: !!s.normalMap, objectSpaceNormalMap: s.normalMapType === ln, tangentSpaceNormalMap: s.normalMapType === an, clearcoat: C, clearcoatMap: C && !!s.clearcoatMap, clearcoatRoughnessMap: C && !!s.clearcoatRoughnessMap, clearcoatNormalMap: C && !!s.clearcoatNormalMap, displacementMap: !!s.displacementMap, roughnessMap: !!s.roughnessMap, metalnessMap: !!s.metalnessMap, specularMap: !!s.specularMap, specularIntensityMap: !!s.specularIntensityMap, specularColorMap: !!s.specularColorMap, specularColorMapEncoding: y(s.specularColorMap), alphaMap: !!s.alphaMap, alphaTest: R, gradientMap: !!s.gradientMap, sheen: s.sheen > 0, sheenColorMap: !!s.sheenColorMap, sheenColorMapEncoding: y(s.sheenColorMap), sheenRoughnessMap: !!s.sheenRoughnessMap, transmission: s.transmission > 0, transmissionMap: !!s.transmissionMap, thicknessMap: !!s.thicknessMap, combine: s.combine, vertexTangents: !!s.normalMap && !!_.geometry && !!_.geometry.attributes.tangent, vertexColors: s.vertexColors, vertexAlphas: !0 === s.vertexColors && !!_.geometry && !!_.geometry.attributes.color && 4 === _.geometry.attributes.color.itemSize, vertexUvs: !!s.map || !!s.bumpMap || !!s.normalMap || !!s.specularMap || !!s.alphaMap || !!s.emissiveMap || !!s.roughnessMap || !!s.metalnessMap || !!s.clearcoatMap || !!s.clearcoatRoughnessMap || !!s.clearcoatNormalMap || !!s.displacementMap || !!s.transmissionMap || !!s.thicknessMap || !!s.specularIntensityMap || !!s.specularColorMap || !!s.sheenColorMap || s.sheenRoughnessMap, uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || !!s.sheen > 0 || s.sheenColorMap || s.sheenRoughnessMap || !s.displacementMap), fog: !!b, useFog: s.fog, fogExp2: b && b.isFogExp2, flatShading: !!s.flatShading, sizeAttenuation: s.sizeAttenuation, logarithmicDepthBuffer: c, skinning: !0 === _.isSkinnedMesh && T > 0, maxBones: T, useVertexTexture: h, morphTargets: !!_.geometry && !!_.geometry.morphAttributes.position, morphNormals: !!_.geometry && !!_.geometry.morphAttributes.normal, morphTargetsCount: _.geometry && _.geometry.morphAttributes.position ? _.geometry.morphAttributes.position.length : 0, numDirLights: a.directional.length, numPointLights: a.point.length, numSpotLights: a.spot.length, numRectAreaLights: a.rectArea.length, numHemiLights: a.hemi.length, numDirLightShadows: a.directionalShadowMap.length, numPointLightShadows: a.pointShadowMap.length, numSpotLightShadows: a.spotShadowMap.length, numClippingPlanes: o.numPlanes, numClipIntersection: o.numIntersection, format: s.format, dithering: s.dithering, shadowMapEnabled: t.shadowMap.enabled && v.length > 0, shadowMapType: t.shadowMap.type, toneMapping: s.toneMapped ? t.toneMapping : Q, physicallyCorrectLights: t.physicallyCorrectLights, premultipliedAlpha: s.premultipliedAlpha, doubleSided: s.side === g, flipSided: s.side === f, depthPacking: void 0 !== s.depthPacking && s.depthPacking, index0AttributeName: s.index0AttributeName, extensionDerivatives: s.extensions && s.extensions.derivatives, extensionFragDepth: s.extensions && s.extensions.fragDepth, extensionDrawBuffers: s.extensions && s.extensions.drawBuffers, extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD, rendererExtensionFragDepth: l || i.has("EXT_frag_depth"), rendererExtensionDrawBuffers: l || i.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: l || i.has("EXT_shader_texture_lod"), customProgramCacheKey: s.customProgramCacheKey() }
                        },
                        getProgramCacheKey: function(e) {
                            const n = [];
                            if (e.shaderID ? n.push(e.shaderID) : (n.push(ni(e.fragmentShader)), n.push(ni(e.vertexShader))), void 0 !== e.defines)
                                for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                            if (!1 === e.isRawShaderMaterial) {
                                for (let t = 0; t < v.length; t++) n.push(e[v[t]]);
                                n.push(t.outputEncoding), n.push(t.gammaFactor)
                            }
                            return n.push(e.customProgramCacheKey), n.join()
                        },
                        getUniforms: function(t) {
                            const e = m[t.type];
                            let n;
                            if (e) {
                                const t = qs[e];
                                n = Es.clone(t.uniforms)
                            } else n = t.uniforms;
                            return n
                        },
                        acquireProgram: function(e, n) { let i; for (let t = 0, e = a.length; t < e; t++) { const e = a[t]; if (e.cacheKey === n) { i = e, ++i.usedTimes; break } } return void 0 === i && (i = new el(t, n, e, s), a.push(i)), i },
                        releaseProgram: function(t) {
                            if (0 == --t.usedTimes) {
                                const e = a.indexOf(t);
                                a[e] = a[a.length - 1], a.pop(), t.destroy()
                            }
                        },
                        programs: a
                    }
                }

                function il() { let t = new WeakMap; return { get: function(e) { let n = t.get(e); return void 0 === n && (n = {}, t.set(e, n)), n }, remove: function(e) { t.delete(e) }, update: function(e, n, i) { t.get(e)[n] = i }, dispose: function() { t = new WeakMap } } }

                function rl(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id }

                function sl(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id }

                function ol(t) {
                    const e = [];
                    let n = 0;
                    const i = [],
                        r = [],
                        s = [],
                        o = { id: -1 };

                    function a(i, r, s, a, l, c) { let h = e[n]; const u = t.get(s); return void 0 === h ? (h = { id: i.id, object: i, geometry: r, material: s, program: u.program || o, groupOrder: a, renderOrder: i.renderOrder, z: l, group: c }, e[n] = h) : (h.id = i.id, h.object = i, h.geometry = r, h.material = s, h.program = u.program || o, h.groupOrder = a, h.renderOrder = i.renderOrder, h.z = l, h.group = c), n++, h }
                    return {
                        opaque: i,
                        transmissive: r,
                        transparent: s,
                        init: function() { n = 0, i.length = 0, r.length = 0, s.length = 0 },
                        push: function(t, e, n, o, l, c) {
                            const h = a(t, e, n, o, l, c);
                            n.transmission > 0 ? r.push(h) : !0 === n.transparent ? s.push(h) : i.push(h)
                        },
                        unshift: function(t, e, n, o, l, c) {
                            const h = a(t, e, n, o, l, c);
                            n.transmission > 0 ? r.unshift(h) : !0 === n.transparent ? s.unshift(h) : i.unshift(h)
                        },
                        finish: function() {
                            for (let t = n, i = e.length; t < i; t++) {
                                const n = e[t];
                                if (null === n.id) break;
                                n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
                            }
                        },
                        sort: function(t, e) { i.length > 1 && i.sort(t || rl), r.length > 1 && r.sort(e || sl), s.length > 1 && s.sort(e || sl) }
                    }
                }

                function al(t) { let e = new WeakMap; return { get: function(n, i) { let r; return !1 === e.has(n) ? (r = new ol(t), e.set(n, [r])) : i >= e.get(n).length ? (r = new ol(t), e.get(n).push(r)) : r = e.get(n)[i], r }, dispose: function() { e = new WeakMap } } }

                function ll() {
                    const t = {};
                    return {
                        get: function(e) {
                            if (void 0 !== t[e.id]) return t[e.id];
                            let n;
                            switch (e.type) {
                                case "DirectionalLight":
                                    n = { direction: new pi, color: new Br };
                                    break;
                                case "SpotLight":
                                    n = { position: new pi, direction: new pi, color: new Br, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
                                    break;
                                case "PointLight":
                                    n = { position: new pi, color: new Br, distance: 0, decay: 0 };
                                    break;
                                case "HemisphereLight":
                                    n = { direction: new pi, skyColor: new Br, groundColor: new Br };
                                    break;
                                case "RectAreaLight":
                                    n = { color: new Br, position: new pi, halfWidth: new pi, halfHeight: new pi }
                            }
                            return t[e.id] = n, n
                        }
                    }
                }
                let cl = 0;

                function hl(t, e) { return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0) }

                function ul(t, e) {
                    const n = new ll,
                        i = function() {
                            const t = {};
                            return {
                                get: function(e) {
                                    if (void 0 !== t[e.id]) return t[e.id];
                                    let n;
                                    switch (e.type) {
                                        case "DirectionalLight":
                                        case "SpotLight":
                                            n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Jn };
                                            break;
                                        case "PointLight":
                                            n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Jn, shadowCameraNear: 1, shadowCameraFar: 1e3 }
                                    }
                                    return t[e.id] = n, n
                                }
                            }
                        }(),
                        r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] };
                    for (let t = 0; t < 9; t++) r.probe.push(new pi);
                    const s = new pi,
                        o = new Wi,
                        a = new Wi;
                    return {
                        setup: function(s, o) {
                            let a = 0,
                                l = 0,
                                c = 0;
                            for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                            let h = 0,
                                u = 0,
                                d = 0,
                                p = 0,
                                m = 0,
                                f = 0,
                                g = 0,
                                v = 0;
                            s.sort(hl);
                            const y = !0 !== o ? Math.PI : 1;
                            for (let t = 0, e = s.length; t < e; t++) {
                                const e = s[t],
                                    o = e.color,
                                    x = e.intensity,
                                    _ = e.distance,
                                    b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                                if (e.isAmbientLight) a += o.r * x * y, l += o.g * x * y, c += o.b * x * y;
                                else if (e.isLightProbe)
                                    for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], x);
                                else if (e.isDirectionalLight) {
                                    const t = n.get(e);
                                    if (t.color.copy(e.color).multiplyScalar(e.intensity * y), e.castShadow) {
                                        const t = e.shadow,
                                            n = i.get(e);
                                        n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.directionalShadow[h] = n, r.directionalShadowMap[h] = b, r.directionalShadowMatrix[h] = e.shadow.matrix, f++
                                    }
                                    r.directional[h] = t, h++
                                } else if (e.isSpotLight) {
                                    const t = n.get(e);
                                    if (t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(o).multiplyScalar(x * y), t.distance = _, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) {
                                        const t = e.shadow,
                                            n = i.get(e);
                                        n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.spotShadow[d] = n, r.spotShadowMap[d] = b, r.spotShadowMatrix[d] = e.shadow.matrix, v++
                                    }
                                    r.spot[d] = t, d++
                                } else if (e.isRectAreaLight) {
                                    const t = n.get(e);
                                    t.color.copy(o).multiplyScalar(x), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), r.rectArea[p] = t, p++
                                } else if (e.isPointLight) {
                                    const t = n.get(e);
                                    if (t.color.copy(e.color).multiplyScalar(e.intensity * y), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                                        const t = e.shadow,
                                            n = i.get(e);
                                        n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, r.pointShadow[u] = n, r.pointShadowMap[u] = b, r.pointShadowMatrix[u] = e.shadow.matrix, g++
                                    }
                                    r.point[u] = t, u++
                                } else if (e.isHemisphereLight) {
                                    const t = n.get(e);
                                    t.skyColor.copy(e.color).multiplyScalar(x * y), t.groundColor.copy(e.groundColor).multiplyScalar(x * y), r.hemi[m] = t, m++
                                }
                            }
                            p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = js.LTC_FLOAT_1, r.rectAreaLTC2 = js.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = js.LTC_HALF_1, r.rectAreaLTC2 = js.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = a, r.ambient[1] = l, r.ambient[2] = c;
                            const x = r.hash;
                            x.directionalLength === h && x.pointLength === u && x.spotLength === d && x.rectAreaLength === p && x.hemiLength === m && x.numDirectionalShadows === f && x.numPointShadows === g && x.numSpotShadows === v || (r.directional.length = h, r.spot.length = d, r.rectArea.length = p, r.point.length = u, r.hemi.length = m, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = v, x.directionalLength = h, x.pointLength = u, x.spotLength = d, x.rectAreaLength = p, x.hemiLength = m, x.numDirectionalShadows = f, x.numPointShadows = g, x.numSpotShadows = v, r.version = cl++)
                        },
                        setupView: function(t, e) {
                            let n = 0,
                                i = 0,
                                l = 0,
                                c = 0,
                                h = 0;
                            const u = e.matrixWorldInverse;
                            for (let e = 0, d = t.length; e < d; e++) {
                                const d = t[e];
                                if (d.isDirectionalLight) {
                                    const t = r.directional[n];
                                    t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(u), n++
                                } else if (d.isSpotLight) {
                                    const t = r.spot[l];
                                    t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(u), l++
                                } else if (d.isRectAreaLight) {
                                    const t = r.rectArea[c];
                                    t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), a.identity(), o.copy(d.matrixWorld), o.premultiply(u), a.extractRotation(o), t.halfWidth.set(.5 * d.width, 0, 0), t.halfHeight.set(0, .5 * d.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), c++
                                } else if (d.isPointLight) {
                                    const t = r.point[i];
                                    t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), i++
                                } else if (d.isHemisphereLight) {
                                    const t = r.hemi[h];
                                    t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(u), t.direction.normalize(), h++
                                }
                            }
                        },
                        state: r
                    }
                }

                function dl(t, e) {
                    const n = new ul(t, e),
                        i = [],
                        r = [];
                    return { init: function() { i.length = 0, r.length = 0 }, state: { lightsArray: i, shadowsArray: r, lights: n }, setupLights: function(t) { n.setup(i, t) }, setupLightsView: function(t) { n.setupView(i, t) }, pushLight: function(t) { i.push(t) }, pushShadow: function(t) { r.push(t) } }
                }

                function pl(t, e) { let n = new WeakMap; return { get: function(i, r = 0) { let s; return !1 === n.has(i) ? (s = new dl(t, e), n.set(i, [s])) : r >= n.get(i).length ? (s = new dl(t, e), n.get(i).push(s)) : s = n.get(i)[r], s }, dispose: function() { n = new WeakMap } } }
                class ml extends Lr {
                    constructor(t) { super(), this.type = "MeshDepthMaterial", this.depthPacking = sn, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this }
                }
                ml.prototype.isMeshDepthMaterial = !0;
                class fl extends Lr {
                    constructor(t) { super(), this.type = "MeshDistanceMaterial", this.referencePosition = new pi, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this }
                }

                function gl(t, e, n) {
                    let i = new Hs;
                    const r = new Jn,
                        s = new Jn,
                        o = new li,
                        a = new ml({ depthPacking: on }),
                        l = new fl,
                        c = {},
                        h = n.maxTextureSize,
                        d = { 0: f, 1: m, 2: g },
                        v = new As({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Jn }, radius: { value: 4 } }, vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }),
                        y = v.clone();
                    y.defines.HORIZONTAL_PASS = 1;
                    const _ = new is;
                    _.setAttribute("position", new Ur(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                    const b = new bs(_, v),
                        w = this;

                    function M(n, i) {
                        const r = e.update(b);
                        v.defines.VSM_SAMPLES !== n.blurSamples && (v.defines.VSM_SAMPLES = n.blurSamples, y.defines.VSM_SAMPLES = n.blurSamples, v.needsUpdate = !0, y.needsUpdate = !0), v.uniforms.shadow_pass.value = n.map.texture, v.uniforms.resolution.value = n.mapSize, v.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, v, b, null), y.uniforms.shadow_pass.value = n.mapPass.texture, y.uniforms.resolution.value = n.mapSize, y.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, y, b, null)
                    }

                    function S(e, n, i, r, s, o, h) {
                        let u = null;
                        const m = !0 === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
                        if (u = void 0 !== m ? m : !0 === r.isPointLight ? l : a, t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
                            const t = u.uuid,
                                e = i.uuid;
                            let n = c[t];
                            void 0 === n && (n = {}, c[t] = n);
                            let r = n[e];
                            void 0 === r && (r = u.clone(), n[e] = r), u = r
                        }
                        return u.visible = i.visible, u.wireframe = i.wireframe, u.side = h === p ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : d[i.side], u.alphaMap = i.alphaMap, u.alphaTest = i.alphaTest, u.clipShadows = i.clipShadows, u.clippingPlanes = i.clippingPlanes, u.clipIntersection = i.clipIntersection, u.displacementMap = i.displacementMap, u.displacementScale = i.displacementScale, u.displacementBias = i.displacementBias, u.wireframeLinewidth = i.wireframeLinewidth, u.linewidth = i.linewidth, !0 === r.isPointLight && !0 === u.isMeshDistanceMaterial && (u.referencePosition.setFromMatrixPosition(r.matrixWorld), u.nearDistance = s, u.farDistance = o), u
                    }

                    function T(n, r, s, o, a) {
                        if (!1 === n.visible) return;
                        if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && a === p) && (!n.frustumCulled || i.intersectsObject(n))) {
                            n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                            const i = e.update(n),
                                r = n.material;
                            if (Array.isArray(r)) {
                                const e = i.groups;
                                for (let l = 0, c = e.length; l < c; l++) {
                                    const c = e[l],
                                        h = r[c.materialIndex];
                                    if (h && h.visible) {
                                        const e = S(n, 0, h, o, s.near, s.far, a);
                                        t.renderBufferDirect(s, null, i, e, n, c)
                                    }
                                }
                            } else if (r.visible) {
                                const e = S(n, 0, r, o, s.near, s.far, a);
                                t.renderBufferDirect(s, null, i, e, n, null)
                            }
                        }
                        const l = n.children;
                        for (let t = 0, e = l.length; t < e; t++) T(l[t], r, s, o, a)
                    }
                    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = u, this.render = function(e, n, a) {
                        if (!1 === w.enabled) return;
                        if (!1 === w.autoUpdate && !1 === w.needsUpdate) return;
                        if (0 === e.length) return;
                        const l = t.getRenderTarget(),
                            c = t.getActiveCubeFace(),
                            u = t.getActiveMipmapLevel(),
                            d = t.state;
                        d.setBlending(x), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                        for (let l = 0, c = e.length; l < c; l++) {
                            const c = e[l],
                                u = c.shadow;
                            if (void 0 === u) { console.warn("THREE.WebGLShadowMap:", c, "has no shadow."); continue }
                            if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
                            r.copy(u.mapSize);
                            const m = u.getFrameExtents();
                            if (r.multiply(m), s.copy(u.mapSize), (r.x > h || r.y > h) && (r.x > h && (s.x = Math.floor(h / m.x), r.x = s.x * m.x, u.mapSize.x = s.x), r.y > h && (s.y = Math.floor(h / m.y), r.y = s.y * m.y, u.mapSize.y = s.y)), null === u.map && !u.isPointLightShadow && this.type === p) {
                                const t = { minFilter: xt, magFilter: xt, format: zt };
                                u.map = new ci(r.x, r.y, t), u.map.texture.name = c.name + ".shadowMap", u.mapPass = new ci(r.x, r.y, t), u.camera.updateProjectionMatrix()
                            }
                            if (null === u.map) {
                                const t = { minFilter: mt, magFilter: mt, format: zt };
                                u.map = new ci(r.x, r.y, t), u.map.texture.name = c.name + ".shadowMap", u.camera.updateProjectionMatrix()
                            }
                            t.setRenderTarget(u.map), t.clear();
                            const f = u.getViewportCount();
                            for (let t = 0; t < f; t++) {
                                const e = u.getViewport(t);
                                o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), d.viewport(o), u.updateMatrices(c, t), i = u.getFrustum(), T(n, a, u.camera, c, this.type)
                            }
                            u.isPointLightShadow || this.type !== p || M(u, a), u.needsUpdate = !1
                        }
                        w.needsUpdate = !1, t.setRenderTarget(l, c, u)
                    }
                }

                function vl(t, e, n) {
                    const i = n.isWebGL2,
                        r = new function() { let e = !1; const n = new li; let i = null; const r = new li(0, 0, 0, 0); return { setMask: function(n) { i === n || e || (t.colorMask(n, n, n, n), i = n) }, setLocked: function(t) { e = t }, setClear: function(e, i, s, o, a) {!0 === a && (e *= o, i *= o, s *= o), n.set(e, i, s, o), !1 === r.equals(n) && (t.clearColor(e, i, s, o), r.copy(n)) }, reset: function() { e = !1, i = null, r.set(-1, 0, 0, 0) } } },
                        s = new function() {
                            let e = !1,
                                n = null,
                                i = null,
                                r = null;
                            return {
                                setTest: function(t) { t ? yt(2929) : xt(2929) },
                                setMask: function(i) { n === i || e || (t.depthMask(i), n = i) },
                                setFunc: function(e) {
                                    if (i !== e) {
                                        if (e) switch (e) {
                                            case k:
                                                t.depthFunc(512);
                                                break;
                                            case G:
                                                t.depthFunc(519);
                                                break;
                                            case V:
                                                t.depthFunc(513);
                                                break;
                                            case W:
                                                t.depthFunc(515);
                                                break;
                                            case j:
                                                t.depthFunc(514);
                                                break;
                                            case q:
                                                t.depthFunc(518);
                                                break;
                                            case X:
                                                t.depthFunc(516);
                                                break;
                                            case Y:
                                                t.depthFunc(517);
                                                break;
                                            default:
                                                t.depthFunc(515)
                                        } else t.depthFunc(515);
                                        i = e
                                    }
                                },
                                setLocked: function(t) { e = t },
                                setClear: function(e) { r !== e && (t.clearDepth(e), r = e) },
                                reset: function() { e = !1, n = null, i = null, r = null }
                            }
                        },
                        c = new function() {
                            let e = !1,
                                n = null,
                                i = null,
                                r = null,
                                s = null,
                                o = null,
                                a = null,
                                l = null,
                                c = null;
                            return { setTest: function(t) { e || (t ? yt(2960) : xt(2960)) }, setMask: function(i) { n === i || e || (t.stencilMask(i), n = i) }, setFunc: function(e, n, o) { i === e && r === n && s === o || (t.stencilFunc(e, n, o), i = e, r = n, s = o) }, setOp: function(e, n, i) { o === e && a === n && l === i || (t.stencilOp(e, n, i), o = e, a = n, l = i) }, setLocked: function(t) { e = t }, setClear: function(e) { c !== e && (t.clearStencil(e), c = e) }, reset: function() { e = !1, n = null, i = null, r = null, s = null, o = null, a = null, l = null, c = null } }
                        };
                    let h = {},
                        u = null,
                        d = {},
                        p = null,
                        m = !1,
                        v = null,
                        y = null,
                        Z = null,
                        J = null,
                        K = null,
                        Q = null,
                        $ = null,
                        tt = !1,
                        et = null,
                        nt = null,
                        it = null,
                        rt = null,
                        st = null;
                    const ot = t.getParameter(35661);
                    let at = !1,
                        lt = 0;
                    const ct = t.getParameter(7938); - 1 !== ct.indexOf("WebGL") ? (lt = parseFloat(/^WebGL (\d)/.exec(ct)[1]), at = lt >= 1) : -1 !== ct.indexOf("OpenGL ES") && (lt = parseFloat(/^OpenGL ES (\d)/.exec(ct)[1]), at = lt >= 2);
                    let ht = null,
                        ut = {};
                    const dt = t.getParameter(3088),
                        pt = t.getParameter(2978),
                        mt = (new li).fromArray(dt),
                        ft = (new li).fromArray(pt);

                    function gt(e, n, i) {
                        const r = new Uint8Array(4),
                            s = t.createTexture();
                        t.bindTexture(e, s), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                        for (let e = 0; e < i; e++) t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
                        return s
                    }
                    const vt = {};

                    function yt(e) {!0 !== h[e] && (t.enable(e), h[e] = !0) }

                    function xt(e) {!1 !== h[e] && (t.disable(e), h[e] = !1) }
                    vt[3553] = gt(3553, 3553, 1), vt[34067] = gt(34067, 34069, 6), r.setClear(0, 0, 0, 1), s.setClear(1), c.setClear(0), yt(2929), s.setFunc(W), Mt(!1), St(a), yt(2884), wt(x);
                    const _t = {
                        [T]: 32774,
                        [E]: 32778,
                        [A]: 32779
                    };
                    if (i) _t[L] = 32775, _t[R] = 32776;
                    else {
                        const t = e.get("EXT_blend_minmax");
                        null !== t && (_t[L] = t.MIN_EXT, _t[R] = t.MAX_EXT)
                    }
                    const bt = {
                        [C]: 0,
                        [P]: 1,
                        [I]: 768,
                        [N]: 770,
                        [H]: 776,
                        [z]: 774,
                        [O]: 772,
                        [D]: 769,
                        [B]: 771,
                        [U]: 775,
                        [F]: 773
                    };

                    function wt(e, n, i, r, s, o, a, l) {
                        if (e !== x) {
                            if (!1 === m && (yt(3042), m = !0), e === S) s = s || n, o = o || i, a = a || r, n === y && s === K || (t.blendEquationSeparate(_t[n], _t[s]), y = n, K = s), i === Z && r === J && o === Q && a === $ || (t.blendFuncSeparate(bt[i], bt[r], bt[o], bt[a]), Z = i, J = r, Q = o, $ = a), v = e, tt = null;
                            else if (e !== v || l !== tt) {
                                if (y === T && K === T || (t.blendEquation(32774), y = T, K = T), l) switch (e) {
                                    case _:
                                        t.blendFuncSeparate(1, 771, 1, 771);
                                        break;
                                    case b:
                                        t.blendFunc(1, 1);
                                        break;
                                    case w:
                                        t.blendFuncSeparate(0, 0, 769, 771);
                                        break;
                                    case M:
                                        t.blendFuncSeparate(0, 768, 0, 770);
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", e)
                                } else switch (e) {
                                    case _:
                                        t.blendFuncSeparate(770, 771, 1, 771);
                                        break;
                                    case b:
                                        t.blendFunc(770, 1);
                                        break;
                                    case w:
                                        t.blendFunc(0, 769);
                                        break;
                                    case M:
                                        t.blendFunc(0, 768);
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", e)
                                }
                                Z = null, J = null, Q = null, $ = null, v = e, tt = l
                            }
                        } else !0 === m && (xt(3042), m = !1)
                    }

                    function Mt(e) { et !== e && (e ? t.frontFace(2304) : t.frontFace(2305), et = e) }

                    function St(e) { e !== o ? (yt(2884), e !== nt && (e === a ? t.cullFace(1029) : e === l ? t.cullFace(1028) : t.cullFace(1032))) : xt(2884), nt = e }

                    function Tt(e, n, i) { e ? (yt(32823), rt === n && st === i || (t.polygonOffset(n, i), rt = n, st = i)) : xt(32823) }

                    function Et(e) { void 0 === e && (e = 33984 + ot - 1), ht !== e && (t.activeTexture(e), ht = e) }
                    return {
                        buffers: { color: r, depth: s, stencil: c },
                        enable: yt,
                        disable: xt,
                        bindFramebuffer: function(e, n) { return null === n && null !== u && (n = u), d[e] !== n && (t.bindFramebuffer(e, n), d[e] = n, i && (36009 === e && (d[36160] = n), 36160 === e && (d[36009] = n)), !0) },
                        bindXRFramebuffer: function(e) { e !== u && (t.bindFramebuffer(36160, e), u = e) },
                        useProgram: function(e) { return p !== e && (t.useProgram(e), p = e, !0) },
                        setBlending: wt,
                        setMaterial: function(t, e) {
                            t.side === g ? xt(2884) : yt(2884);
                            let n = t.side === f;
                            e && (n = !n), Mt(n), t.blending === _ && !1 === t.transparent ? wt(x) : wt(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), r.setMask(t.colorWrite);
                            const i = t.stencilWrite;
                            c.setTest(i), i && (c.setMask(t.stencilWriteMask), c.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), c.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), Tt(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? yt(32926) : xt(32926)
                        },
                        setFlipSided: Mt,
                        setCullFace: St,
                        setLineWidth: function(e) { e !== it && (at && t.lineWidth(e), it = e) },
                        setPolygonOffset: Tt,
                        setScissorTest: function(t) { t ? yt(3089) : xt(3089) },
                        activeTexture: Et,
                        bindTexture: function(e, n) {
                            null === ht && Et();
                            let i = ut[ht];
                            void 0 === i && (i = { type: void 0, texture: void 0 }, ut[ht] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || vt[e]), i.type = e, i.texture = n)
                        },
                        unbindTexture: function() {
                            const e = ut[ht];
                            void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                        },
                        compressedTexImage2D: function() { try { t.compressedTexImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } },
                        texImage2D: function() { try { t.texImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } },
                        texImage3D: function() { try { t.texImage3D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } },
                        scissor: function(e) {!1 === mt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), mt.copy(e)) },
                        viewport: function(e) {!1 === ft.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), ft.copy(e)) },
                        reset: function() { t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === i && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), h = {}, ht = null, ut = {}, u = null, d = {}, p = null, m = !1, v = null, y = null, Z = null, J = null, K = null, Q = null, $ = null, tt = !1, et = null, nt = null, it = null, rt = null, st = null, mt.set(0, 0, t.canvas.width, t.canvas.height), ft.set(0, 0, t.canvas.width, t.canvas.height), r.reset(), s.reset(), c.reset() }
                    }
                }

                function yl(t, e, n, i, r, s, o) {
                    const a = r.isWebGL2,
                        l = r.maxTextures,
                        c = r.maxCubemapSize,
                        h = r.maxTextureSize,
                        u = r.maxSamples,
                        d = new WeakMap;
                    let p, m = !1;
                    try { m = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (t) {}

                    function f(t, e) { return m ? new OffscreenCanvas(t, e) : ei("canvas") }

                    function g(t, e, n, i) {
                        let r = 1;
                        if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                            if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                                const i = e ? Yn : Math.floor,
                                    s = i(r * t.width),
                                    o = i(r * t.height);
                                void 0 === p && (p = f(s, o));
                                const a = n ? f(s, o) : p;
                                return a.width = s, a.height = o, a.getContext("2d").drawImage(t, 0, 0, s, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + o + ")."), a
                            }
                            return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                        }
                        return t
                    }

                    function v(t) { return qn(t.width) && qn(t.height) }

                    function y(t, e) { return t.generateMipmaps && e && t.minFilter !== mt && t.minFilter !== xt }

                    function x(e, n, r, s, o = 1) { t.generateMipmap(e), i.get(n).__maxMipLevel = Math.log2(Math.max(r, s, o)) }

                    function _(n, i, r, s) {
                        if (!1 === a) return i;
                        if (null !== n) {
                            if (void 0 !== t[n]) return t[n];
                            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                        }
                        let o = i;
                        return 6403 === i && (5126 === r && (o = 33326), 5131 === r && (o = 33325), 5121 === r && (o = 33321)), 6407 === i && (5126 === r && (o = 34837), 5131 === r && (o = 34843), 5121 === r && (o = 32849)), 6408 === i && (5126 === r && (o = 34836), 5131 === r && (o = 34842), 5121 === r && (o = s === Ke ? 35907 : 32856)), 33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"), o
                    }

                    function b(t) { return t === mt || t === ft || t === vt ? 9728 : 9729 }

                    function w(e) {
                        const n = e.target;
                        n.removeEventListener("dispose", w),
                            function(e) {
                                const n = i.get(e);
                                void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture), i.remove(e))
                            }(n), n.isVideoTexture && d.delete(n), o.memory.textures--
                    }

                    function M(e) {
                        const n = e.target;
                        n.removeEventListener("dispose", M),
                            function(e) {
                                const n = e.texture,
                                    r = i.get(e),
                                    s = i.get(n);
                                if (e) {
                                    if (void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture), o.memory.textures--), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)
                                        for (let e = 0; e < 6; e++) t.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                                    else t.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                                    if (e.isWebGLMultipleRenderTargets)
                                        for (let e = 0, r = n.length; e < r; e++) {
                                            const r = i.get(n[e]);
                                            r.__webglTexture && (t.deleteTexture(r.__webglTexture), o.memory.textures--), i.remove(n[e])
                                        }
                                    i.remove(n), i.remove(e)
                                }
                            }(n)
                    }
                    let S = 0;

                    function T(t, e) {
                        const r = i.get(t);
                        if (t.isVideoTexture && function(t) {
                                const e = o.render.frame;
                                d.get(t) !== e && (d.set(t, e), t.update())
                            }(t), t.version > 0 && r.__version !== t.version) {
                            const n = t.image;
                            if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                            else {
                                if (!1 !== n.complete) return void P(r, t, e);
                                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                            }
                        }
                        n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture)
                    }

                    function E(e, r) {
                        const o = i.get(e);
                        e.version > 0 && o.__version !== e.version ? function(e, i, r) {
                            if (6 !== i.image.length) return;
                            C(e, i), n.activeTexture(33984 + r), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
                            const o = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
                                l = i.image[0] && i.image[0].isDataTexture,
                                h = [];
                            for (let t = 0; t < 6; t++) h[t] = o || l ? l ? i.image[t].image : i.image[t] : g(i.image[t], !1, !0, c);
                            const u = h[0],
                                d = v(u) || a,
                                p = s.convert(i.format),
                                m = s.convert(i.type),
                                f = _(i.internalFormat, p, m, i.encoding);
                            let b;
                            if (R(34067, i, d), o) {
                                for (let t = 0; t < 6; t++) {
                                    b = h[t].mipmaps;
                                    for (let e = 0; e < b.length; e++) {
                                        const r = b[e];
                                        i.format !== zt && i.format !== Ft ? null !== p ? n.compressedTexImage2D(34069 + t, e, f, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, e, f, r.width, r.height, 0, p, m, r.data)
                                    }
                                }
                                e.__maxMipLevel = b.length - 1
                            } else {
                                b = i.mipmaps;
                                for (let t = 0; t < 6; t++)
                                    if (l) {
                                        n.texImage2D(34069 + t, 0, f, h[t].width, h[t].height, 0, p, m, h[t].data);
                                        for (let e = 0; e < b.length; e++) {
                                            const i = b[e].image[t].image;
                                            n.texImage2D(34069 + t, e + 1, f, i.width, i.height, 0, p, m, i.data)
                                        }
                                    } else {
                                        n.texImage2D(34069 + t, 0, f, p, m, h[t]);
                                        for (let e = 0; e < b.length; e++) {
                                            const i = b[e];
                                            n.texImage2D(34069 + t, e + 1, f, p, m, i.image[t])
                                        }
                                    }
                                e.__maxMipLevel = b.length
                            }
                            y(i, d) && x(34067, i, u.width, u.height), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                        }(o, e, r) : (n.activeTexture(33984 + r), n.bindTexture(34067, o.__webglTexture))
                    }
                    const A = {
                            [ut]: 10497,
                            [dt]: 33071,
                            [pt]: 33648
                        },
                        L = {
                            [mt]: 9728,
                            [ft]: 9984,
                            [vt]: 9986,
                            [xt]: 9729,
                            [_t]: 9985,
                            [wt]: 9987
                        };

                    function R(n, s, o) {
                        if (o ? (t.texParameteri(n, 10242, A[s.wrapS]), t.texParameteri(n, 10243, A[s.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, A[s.wrapR]), t.texParameteri(n, 10240, L[s.magFilter]), t.texParameteri(n, 10241, L[s.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), s.wrapS === dt && s.wrapT === dt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, b(s.magFilter)), t.texParameteri(n, 10241, b(s.minFilter)), s.minFilter !== mt && s.minFilter !== xt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
                            const o = e.get("EXT_texture_filter_anisotropic");
                            if (s.type === Ct && !1 === e.has("OES_texture_float_linear")) return;
                            if (!1 === a && s.type === Pt && !1 === e.has("OES_texture_half_float_linear")) return;
                            (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy)
                        }
                    }

                    function C(e, n) { void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", w), e.__webglTexture = t.createTexture(), o.memory.textures++) }

                    function P(e, i, r) {
                        let o = 3553;
                        i.isDataTexture2DArray && (o = 35866), i.isDataTexture3D && (o = 32879), C(e, i), n.activeTexture(33984 + r), n.bindTexture(o, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
                        const l = function(t) { return !a && (t.wrapS !== dt || t.wrapT !== dt || t.minFilter !== mt && t.minFilter !== xt) }(i) && !1 === v(i.image),
                            c = g(i.image, l, !1, h),
                            u = v(c) || a,
                            d = s.convert(i.format);
                        let p, m = s.convert(i.type),
                            f = _(i.internalFormat, d, m, i.encoding);
                        R(o, i, u);
                        const b = i.mipmaps;
                        if (i.isDepthTexture) f = 6402, a ? f = i.type === Ct ? 36012 : i.type === Rt ? 33190 : i.type === Bt ? 35056 : 33189 : i.type === Ct && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === Gt && 6402 === f && i.type !== At && i.type !== Rt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = At, m = s.convert(i.type)), i.format === Vt && 6402 === f && (f = 34041, i.type !== Bt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = Bt, m = s.convert(i.type))), n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, null);
                        else if (i.isDataTexture)
                            if (b.length > 0 && u) {
                                for (let t = 0, e = b.length; t < e; t++) p = b[t], n.texImage2D(3553, t, f, p.width, p.height, 0, d, m, p.data);
                                i.generateMipmaps = !1, e.__maxMipLevel = b.length - 1
                            } else n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, c.data), e.__maxMipLevel = 0;
                        else if (i.isCompressedTexture) {
                            for (let t = 0, e = b.length; t < e; t++) p = b[t], i.format !== zt && i.format !== Ft ? null !== d ? n.compressedTexImage2D(3553, t, f, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, f, p.width, p.height, 0, d, m, p.data);
                            e.__maxMipLevel = b.length - 1
                        } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, f, c.width, c.height, c.depth, 0, d, m, c.data), e.__maxMipLevel = 0;
                        else if (i.isDataTexture3D) n.texImage3D(32879, 0, f, c.width, c.height, c.depth, 0, d, m, c.data), e.__maxMipLevel = 0;
                        else if (b.length > 0 && u) {
                            for (let t = 0, e = b.length; t < e; t++) p = b[t], n.texImage2D(3553, t, f, d, m, p);
                            i.generateMipmaps = !1, e.__maxMipLevel = b.length - 1
                        } else n.texImage2D(3553, 0, f, d, m, c), e.__maxMipLevel = 0;
                        y(i, u) && x(o, i, c.width, c.height), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                    }

                    function I(e, r, o, a, l) {
                        const c = s.convert(o.format),
                            h = s.convert(o.type),
                            u = _(o.internalFormat, c, h, o.encoding);
                        32879 === l || 35866 === l ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null), n.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, a, l, i.get(o).__webglTexture, 0), n.bindFramebuffer(36160, null)
                    }

                    function D(e, n, i) {
                        if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                            let r = 33189;
                            if (i) {
                                const e = n.depthTexture;
                                e && e.isDepthTexture && (e.type === Ct ? r = 36012 : e.type === Rt && (r = 33190));
                                const i = N(n);
                                t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                            } else t.renderbufferStorage(36161, r, n.width, n.height);
                            t.framebufferRenderbuffer(36160, 36096, 36161, e)
                        } else if (n.depthBuffer && n.stencilBuffer) {
                            if (i) {
                                const e = N(n);
                                t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height)
                            } else t.renderbufferStorage(36161, 34041, n.width, n.height);
                            t.framebufferRenderbuffer(36160, 33306, 36161, e)
                        } else {
                            const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
                                r = s.convert(e.format),
                                o = s.convert(e.type),
                                a = _(e.internalFormat, r, o, e.encoding);
                            if (i) {
                                const e = N(n);
                                t.renderbufferStorageMultisample(36161, e, a, n.width, n.height)
                            } else t.renderbufferStorage(36161, a, n.width, n.height)
                        }
                        t.bindRenderbuffer(36161, null)
                    }

                    function N(t) { return a && t.isWebGLMultisampleRenderTarget ? Math.min(u, t.samples) : 0 }
                    let B = !1,
                        O = !1;
                    this.allocateTextureUnit = function() { const t = S; return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), S += 1, t }, this.resetTextureUnits = function() { S = 0 }, this.setTexture2D = T, this.setTexture2DArray = function(t, e) {
                        const r = i.get(t);
                        t.version > 0 && r.__version !== t.version ? P(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture))
                    }, this.setTexture3D = function(t, e) {
                        const r = i.get(t);
                        t.version > 0 && r.__version !== t.version ? P(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture))
                    }, this.setTextureCube = E, this.setupRenderTarget = function(e) {
                        const l = e.texture,
                            c = i.get(e),
                            h = i.get(l);
                        e.addEventListener("dispose", M), !0 !== e.isWebGLMultipleRenderTargets && (h.__webglTexture = t.createTexture(), h.__version = l.version, o.memory.textures++);
                        const u = !0 === e.isWebGLCubeRenderTarget,
                            d = !0 === e.isWebGLMultipleRenderTargets,
                            p = !0 === e.isWebGLMultisampleRenderTarget,
                            m = l.isDataTexture3D || l.isDataTexture2DArray,
                            f = v(e) || a;
                        if (!a || l.format !== Ft || l.type !== Ct && l.type !== Pt || (l.format = zt, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), u) { c.__webglFramebuffer = []; for (let e = 0; e < 6; e++) c.__webglFramebuffer[e] = t.createFramebuffer() } else if (c.__webglFramebuffer = t.createFramebuffer(), d)
                            if (r.drawBuffers) {
                                const n = e.texture;
                                for (let e = 0, r = n.length; e < r; e++) {
                                    const r = i.get(n[e]);
                                    void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(), o.memory.textures++)
                                }
                            } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                        else if (p)
                            if (a) {
                                c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
                                const i = s.convert(l.format),
                                    r = s.convert(l.type),
                                    o = _(l.internalFormat, i, r, l.encoding),
                                    a = N(e);
                                t.renderbufferStorageMultisample(36161, a, o, e.width, e.height), n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), D(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null)
                            } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                        if (u) {
                            n.bindTexture(34067, h.__webglTexture), R(34067, l, f);
                            for (let t = 0; t < 6; t++) I(c.__webglFramebuffer[t], e, l, 36064, 34069 + t);
                            y(l, f) && x(34067, l, e.width, e.height), n.unbindTexture()
                        } else if (d) {
                            const t = e.texture;
                            for (let r = 0, s = t.length; r < s; r++) {
                                const s = t[r],
                                    o = i.get(s);
                                n.bindTexture(3553, o.__webglTexture), R(3553, s, f), I(c.__webglFramebuffer, e, s, 36064 + r, 3553), y(s, f) && x(3553, s, e.width, e.height)
                            }
                            n.unbindTexture()
                        } else {
                            let t = 3553;
                            m && (a ? t = l.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), n.bindTexture(t, h.__webglTexture), R(t, l, f), I(c.__webglFramebuffer, e, l, 36064, t), y(l, f) && x(t, l, e.width, e.height, e.depth), n.unbindTexture()
                        }
                        e.depthBuffer && function(e) {
                            const r = i.get(e),
                                s = !0 === e.isWebGLCubeRenderTarget;
                            if (e.depthTexture) {
                                if (s) throw new Error("target.depthTexture not supported in Cube render targets");
                                ! function(e, r) {
                                    if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                                    if (n.bindFramebuffer(36160, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                                    i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), T(r.depthTexture, 0);
                                    const s = i.get(r.depthTexture).__webglTexture;
                                    if (r.depthTexture.format === Gt) t.framebufferTexture2D(36160, 36096, 3553, s, 0);
                                    else {
                                        if (r.depthTexture.format !== Vt) throw new Error("Unknown depthTexture format");
                                        t.framebufferTexture2D(36160, 33306, 3553, s, 0)
                                    }
                                }(r.__webglFramebuffer, e)
                            } else if (s) { r.__webglDepthbuffer = []; for (let i = 0; i < 6; i++) n.bindFramebuffer(36160, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = t.createRenderbuffer(), D(r.__webglDepthbuffer[i], e, !1) } else n.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), D(r.__webglDepthbuffer, e, !1);
                            n.bindFramebuffer(36160, null)
                        }(e)
                    }, this.updateRenderTargetMipmap = function(t) {
                        const e = v(t) || a,
                            r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                        for (let s = 0, o = r.length; s < o; s++) {
                            const o = r[s];
                            if (y(o, e)) {
                                const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                                    r = i.get(o).__webglTexture;
                                n.bindTexture(e, r), x(e, o, t.width, t.height), n.unbindTexture()
                            }
                        }
                    }, this.updateMultisampleRenderTarget = function(e) {
                        if (e.isWebGLMultisampleRenderTarget)
                            if (a) {
                                const r = e.width,
                                    s = e.height;
                                let o = 16384;
                                e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024);
                                const a = i.get(e);
                                n.bindFramebuffer(36008, a.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, a.__webglFramebuffer), t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, o, 9728), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, a.__webglMultisampledFramebuffer)
                            } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                    }, this.safeSetTexture2D = function(t, e) { t && t.isWebGLRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), B = !0), t = t.texture), T(t, e) }, this.safeSetTextureCube = function(t, e) { t && t.isWebGLCubeRenderTarget && (!1 === O && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), O = !0), t = t.texture), E(t, e) }
                }

                function xl(t, e, n) { const i = n.isWebGL2; return { convert: function(t) { let n; if (t === St) return 5121; if (t === It) return 32819; if (t === Dt) return 32820; if (t === Nt) return 33635; if (t === Tt) return 5120; if (t === Et) return 5122; if (t === At) return 5123; if (t === Lt) return 5124; if (t === Rt) return 5125; if (t === Ct) return 5126; if (t === Pt) return i ? 5131 : (n = e.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null); if (t === Ot) return 6406; if (t === Ft) return 6407; if (t === zt) return 6408; if (t === Ut) return 6409; if (t === Ht) return 6410; if (t === Gt) return 6402; if (t === Vt) return 34041; if (t === Wt) return 6403; if (t === jt) return 36244; if (t === qt) return 33319; if (t === Xt) return 33320; if (t === Yt) return 36248; if (t === Zt) return 36249; if (t === Jt || t === Kt || t === Qt || t === $t) { if (n = e.get("WEBGL_compressed_texture_s3tc"), null === n) return null; if (t === Jt) return n.COMPRESSED_RGB_S3TC_DXT1_EXT; if (t === Kt) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (t === Qt) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (t === $t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (t === te || t === ee || t === ne || t === ie) { if (n = e.get("WEBGL_compressed_texture_pvrtc"), null === n) return null; if (t === te) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (t === ee) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (t === ne) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (t === ie) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (t === re) return n = e.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null; if ((t === se || t === oe) && (n = e.get("WEBGL_compressed_texture_etc"), null !== n)) { if (t === se) return n.COMPRESSED_RGB8_ETC2; if (t === oe) return n.COMPRESSED_RGBA8_ETC2_EAC } return t === ae || t === le || t === ce || t === he || t === ue || t === de || t === pe || t === me || t === fe || t === ge || t === ve || t === ye || t === xe || t === _e || t === we || t === Me || t === Se || t === Te || t === Ee || t === Ae || t === Le || t === Re || t === Ce || t === Pe || t === Ie || t === De || t === Ne || t === Be ? (n = e.get("WEBGL_compressed_texture_astc"), null !== n ? t : null) : t === be ? (n = e.get("EXT_texture_compression_bptc"), null !== n ? t : null) : t === Bt ? i ? 34042 : (n = e.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0 } } }
                fl.prototype.isMeshDistanceMaterial = !0;
                class _l extends Rs { constructor(t = []) { super(), this.cameras = t } }
                _l.prototype.isArrayCamera = !0;
                class bl extends fr { constructor() { super(), this.type = "Group" } }
                bl.prototype.isGroup = !0;
                const wl = { type: "move" };
                class Ml {
                    constructor() { this._targetRay = null, this._grip = null, this._hand = null }
                    getHandSpace() { return null === this._hand && (this._hand = new bl, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand }
                    getTargetRaySpace() { return null === this._targetRay && (this._targetRay = new bl, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new pi, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new pi), this._targetRay }
                    getGripSpace() { return null === this._grip && (this._grip = new bl, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new pi, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new pi), this._grip }
                    dispatchEvent(t) { return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this }
                    disconnect(t) { return this.dispatchEvent({ type: "disconnected", data: t }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this }
                    update(t, e, n) {
                        let i = null,
                            r = null,
                            s = null;
                        const o = this._targetRay,
                            a = this._grip,
                            l = this._hand;
                        if (t && "visible-blurred" !== e.session.visibilityState)
                            if (null !== o && (i = e.getPose(t.targetRaySpace, n), null !== i && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(wl))), l && t.hand) {
                                s = !0;
                                for (const i of t.hand.values()) {
                                    const t = e.getJointPose(i, n);
                                    if (void 0 === l.joints[i.jointName]) {
                                        const t = new bl;
                                        t.matrixAutoUpdate = !1, t.visible = !1, l.joints[i.jointName] = t, l.add(t)
                                    }
                                    const r = l.joints[i.jointName];
                                    null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = t.radius), r.visible = null !== t
                                }
                                const i = l.joints["index-finger-tip"],
                                    r = l.joints["thumb-tip"],
                                    o = i.position.distanceTo(r.position),
                                    a = .02,
                                    c = .005;
                                l.inputState.pinching && o > a + c ? (l.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this })) : !l.inputState.pinching && o <= a - c && (l.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this }))
                            } else null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1));
                        return null !== o && (o.visible = null !== i), null !== a && (a.visible = null !== r), null !== l && (l.visible = null !== s), this
                    }
                }
                class Sl extends On {
                    constructor(t, e) {
                        super();
                        const n = this,
                            i = t.state;
                        let r = null,
                            s = 1,
                            o = null,
                            a = "local-floor",
                            l = null,
                            c = null,
                            h = null,
                            u = null,
                            d = null,
                            p = !1,
                            m = null,
                            f = null,
                            g = null,
                            v = null,
                            y = null,
                            x = null;
                        const _ = [],
                            b = new Map,
                            w = new Rs;
                        w.layers.enable(1), w.viewport = new li;
                        const M = new Rs;
                        M.layers.enable(2), M.viewport = new li;
                        const S = [w, M],
                            T = new _l;
                        T.layers.enable(1), T.layers.enable(2);
                        let E = null,
                            A = null;

                        function L(t) {
                            const e = b.get(t.inputSource);
                            e && e.dispatchEvent({ type: t.type, data: t.inputSource })
                        }

                        function R() { b.forEach((function(t, e) { t.disconnect(e) })), b.clear(), E = null, A = null, i.bindXRFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), h && e.deleteFramebuffer(h), m && e.deleteFramebuffer(m), f && e.deleteRenderbuffer(f), g && e.deleteRenderbuffer(g), h = null, m = null, f = null, g = null, d = null, u = null, c = null, r = null, B.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" }) }

                        function C(t) {
                            const e = r.inputSources;
                            for (let t = 0; t < _.length; t++) b.set(e[t], _[t]);
                            for (let e = 0; e < t.removed.length; e++) {
                                const n = t.removed[e],
                                    i = b.get(n);
                                i && (i.dispatchEvent({ type: "disconnected", data: n }), b.delete(n))
                            }
                            for (let e = 0; e < t.added.length; e++) {
                                const n = t.added[e],
                                    i = b.get(n);
                                i && i.dispatchEvent({ type: "connected", data: n })
                            }
                        }
                        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(t) { let e = _[t]; return void 0 === e && (e = new Ml, _[t] = e), e.getTargetRaySpace() }, this.getControllerGrip = function(t) { let e = _[t]; return void 0 === e && (e = new Ml, _[t] = e), e.getGripSpace() }, this.getHand = function(t) { let e = _[t]; return void 0 === e && (e = new Ml, _[t] = e), e.getHandSpace() }, this.setFramebufferScaleFactor = function(t) { s = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function(t) { a = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function() { return o }, this.getBaseLayer = function() { return null !== u ? u : d }, this.getBinding = function() { return c }, this.getFrame = function() { return v }, this.getSession = function() { return r }, this.setSession = async function(t) {
                            if (r = t, null !== r) {
                                r.addEventListener("select", L), r.addEventListener("selectstart", L), r.addEventListener("selectend", L), r.addEventListener("squeeze", L), r.addEventListener("squeezestart", L), r.addEventListener("squeezeend", L), r.addEventListener("end", R), r.addEventListener("inputsourceschange", C);
                                const t = e.getContextAttributes();
                                if (!0 !== t.xrCompatible && await e.makeXRCompatible(), void 0 === r.renderState.layers) {
                                    const n = { antialias: t.antialias, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: s };
                                    d = new XRWebGLLayer(r, e, n), r.updateRenderState({ baseLayer: d })
                                } else if (e instanceof WebGLRenderingContext) {
                                    const n = { antialias: !0, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: s };
                                    d = new XRWebGLLayer(r, e, n), r.updateRenderState({ layers: [d] })
                                } else {
                                    p = t.antialias;
                                    let n = null;
                                    t.depth && (x = 256, t.stencil && (x |= 1024), y = t.stencil ? 33306 : 36096, n = t.stencil ? 35056 : 33190);
                                    const o = { colorFormat: t.alpha ? 32856 : 32849, depthFormat: n, scaleFactor: s };
                                    c = new XRWebGLBinding(r, e), u = c.createProjectionLayer(o), h = e.createFramebuffer(), r.updateRenderState({ layers: [u] }), p && (m = e.createFramebuffer(), f = e.createRenderbuffer(), e.bindRenderbuffer(36161, f), e.renderbufferStorageMultisample(36161, 4, 32856, u.textureWidth, u.textureHeight), i.bindFramebuffer(36160, m), e.framebufferRenderbuffer(36160, 36064, 36161, f), e.bindRenderbuffer(36161, null), null !== n && (g = e.createRenderbuffer(), e.bindRenderbuffer(36161, g), e.renderbufferStorageMultisample(36161, 4, n, u.textureWidth, u.textureHeight), e.framebufferRenderbuffer(36160, y, 36161, g), e.bindRenderbuffer(36161, null)), i.bindFramebuffer(36160, null))
                                }
                                o = await r.requestReferenceSpace(a), B.setContext(r), B.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" })
                            }
                        };
                        const P = new pi,
                            I = new pi;

                        function D(t, e) { null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert() }
                        this.updateCamera = function(t) {
                            if (null === r) return;
                            T.near = M.near = w.near = t.near, T.far = M.far = w.far = t.far, E === T.near && A === T.far || (r.updateRenderState({ depthNear: T.near, depthFar: T.far }), E = T.near, A = T.far);
                            const e = t.parent,
                                n = T.cameras;
                            D(T, e);
                            for (let t = 0; t < n.length; t++) D(n[t], e);
                            T.matrixWorld.decompose(T.position, T.quaternion, T.scale), t.position.copy(T.position), t.quaternion.copy(T.quaternion), t.scale.copy(T.scale), t.matrix.copy(T.matrix), t.matrixWorld.copy(T.matrixWorld);
                            const i = t.children;
                            for (let t = 0, e = i.length; t < e; t++) i[t].updateMatrixWorld(!0);
                            2 === n.length ? function(t, e, n) {
                                P.setFromMatrixPosition(e.matrixWorld), I.setFromMatrixPosition(n.matrixWorld);
                                const i = P.distanceTo(I),
                                    r = e.projectionMatrix.elements,
                                    s = n.projectionMatrix.elements,
                                    o = r[14] / (r[10] - 1),
                                    a = r[14] / (r[10] + 1),
                                    l = (r[9] + 1) / r[5],
                                    c = (r[9] - 1) / r[5],
                                    h = (r[8] - 1) / r[0],
                                    u = (s[8] + 1) / s[0],
                                    d = o * h,
                                    p = o * u,
                                    m = i / (-h + u),
                                    f = m * -h;
                                e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(f), t.translateZ(m), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                                const g = o + m,
                                    v = a + m,
                                    y = d - f,
                                    x = p + (i - f),
                                    _ = l * a / v * g,
                                    b = c * a / v * g;
                                t.projectionMatrix.makePerspective(y, x, _, b, g, v)
                            }(T, w, M) : T.projectionMatrix.copy(w.projectionMatrix)
                        }, this.getCamera = function() { return T }, this.getFoveation = function() { return null !== u ? u.fixedFoveation : null !== d ? d.fixedFoveation : void 0 }, this.setFoveation = function(t) { null !== u && (u.fixedFoveation = t), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t) };
                        let N = null;
                        const B = new ks;
                        B.setAnimationLoop((function(t, n) {
                            if (l = n.getViewerPose(o), v = n, null !== l) {
                                const t = l.views;
                                null !== d && i.bindXRFramebuffer(d.framebuffer);
                                let n = !1;
                                t.length !== T.cameras.length && (T.cameras.length = 0, n = !0);
                                for (let r = 0; r < t.length; r++) {
                                    const s = t[r];
                                    let o = null;
                                    if (null !== d) o = d.getViewport(s);
                                    else {
                                        const t = c.getViewSubImage(u, s);
                                        i.bindXRFramebuffer(h), void 0 !== t.depthStencilTexture && e.framebufferTexture2D(36160, y, 3553, t.depthStencilTexture, 0), e.framebufferTexture2D(36160, 36064, 3553, t.colorTexture, 0), o = t.viewport
                                    }
                                    const a = S[r];
                                    a.matrix.fromArray(s.transform.matrix), a.projectionMatrix.fromArray(s.projectionMatrix), a.viewport.set(o.x, o.y, o.width, o.height), 0 === r && T.matrix.copy(a.matrix), !0 === n && T.cameras.push(a)
                                }
                                p && (i.bindXRFramebuffer(m), null !== x && e.clear(x))
                            }
                            const s = r.inputSources;
                            for (let t = 0; t < _.length; t++) {
                                const e = _[t],
                                    i = s[t];
                                e.update(i, n, o)
                            }
                            if (N && N(t, n), p) {
                                const t = u.textureWidth,
                                    n = u.textureHeight;
                                i.bindFramebuffer(36008, m), i.bindFramebuffer(36009, h), e.invalidateFramebuffer(36008, [y]), e.invalidateFramebuffer(36009, [y]), e.blitFramebuffer(0, 0, t, n, 0, 0, t, n, 16384, 9728), e.invalidateFramebuffer(36008, [36064]), i.bindFramebuffer(36008, null), i.bindFramebuffer(36009, null), i.bindFramebuffer(36160, m)
                            }
                            v = null
                        })), this.setAnimationLoop = function(t) { N = t }, this.dispose = function() {}
                    }
                }

                function Tl(t) {
                    function e(e, n) {
                        e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap), n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);
                        const i = t.get(n).envMap;
                        if (i) {
                            e.envMap.value = i, e.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = n.reflectivity, e.ior.value = n.ior, e.refractionRatio.value = n.refractionRatio;
                            const r = t.get(i).__maxMipLevel;
                            void 0 !== r && (e.maxMipLevel.value = r)
                        }
                        let r, s;
                        n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? r = n.clearcoatRoughnessMap : n.specularIntensityMap ? r = n.specularIntensityMap : n.specularColorMap ? r = n.specularColorMap : n.transmissionMap ? r = n.transmissionMap : n.thicknessMap ? r = n.thicknessMap : n.sheenColorMap ? r = n.sheenColorMap : n.sheenRoughnessMap && (r = n.sheenRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uv2Transform.value.copy(s.matrix))
                    }

                    function n(e, n) { e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, n.side === f && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), n.side === f && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity) }
                    return {
                        refreshFogUniforms: function(t, e) { t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density) },
                        refreshMaterialUniforms: function(t, i, r, s, o) {
                            i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i), function(t, e) { e.emissiveMap && (t.emissiveMap.value = e.emissiveMap) }(t, i)) : i.isMeshToonMaterial ? (e(t, i), function(t, e) { e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === f && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === f && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshPhongMaterial ? (e(t, i), function(t, e) { t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === f && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === f && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshStandardMaterial ? (e(t, i), i.isMeshPhysicalMaterial ? function(t, e, i) { n(t, e), t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap)), e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === f && t.clearcoatNormalScale.value.negate())), e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)), t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap) }(t, i, o) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i), function(t, e) { e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === f && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === f && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshDepthMaterial ? (e(t, i), function(t, e) { e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i), function(t, e) { e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance }(t, i)) : i.isMeshNormalMaterial ? (e(t, i), function(t, e) { e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === f && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === f && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isLineBasicMaterial ? (function(t, e) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity }(t, i), i.isLineDashedMaterial && function(t, e) { t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale }(t, i)) : i.isPointsMaterial ? function(t, e, n, i) {
                                let r;
                                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest), e.map ? r = e.map : e.alphaMap && (r = e.alphaMap), void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
                            }(t, i, r, s) : i.isSpriteMaterial ? function(t, e) {
                                let n;
                                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest), e.map ? n = e.map : e.alphaMap && (n = e.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                            }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                        }
                    }
                }

                function El(t = {}) {
                    const e = void 0 !== t.canvas ? t.canvas : function() { const t = ei("canvas"); return t.style.display = "block", t }(),
                        n = void 0 !== t.context ? t.context : null,
                        i = void 0 !== t.alpha && t.alpha,
                        r = void 0 === t.depth || t.depth,
                        s = void 0 === t.stencil || t.stencil,
                        o = void 0 !== t.antialias && t.antialias,
                        a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                        l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                        c = void 0 !== t.powerPreference ? t.powerPreference : "default",
                        h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
                    let u = null,
                        d = null;
                    const p = [],
                        v = [];
                    this.domElement = e, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = Je, this.physicallyCorrectLights = !1, this.toneMapping = Q, this.toneMappingExposure = 1;
                    const y = this;
                    let x = !1,
                        _ = 0,
                        b = 0,
                        w = null,
                        M = -1,
                        S = null;
                    const T = new li,
                        E = new li;
                    let A = null,
                        L = e.width,
                        R = e.height,
                        C = 1,
                        P = null,
                        I = null;
                    const D = new li(0, 0, L, R),
                        N = new li(0, 0, L, R);
                    let B = !1;
                    const O = [],
                        F = new Hs;
                    let z = !1,
                        U = !1,
                        H = null;
                    const k = new Wi,
                        G = new pi,
                        V = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };

                    function W() { return null === w ? C : 1 }
                    let j, q, X, Y, Z, J, K, $, tt, et, nt, it, rt, st, ot, at, lt, ct, ht, ut, pt, ft, gt, vt = n;

                    function yt(t, n) {
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i],
                                s = e.getContext(r, n);
                            if (null !== s) return s
                        }
                        return null
                    }
                    try {
                        const t = { alpha: i, depth: r, stencil: s, antialias: o, premultipliedAlpha: a, preserveDrawingBuffer: l, powerPreference: c, failIfMajorPerformanceCaveat: h };
                        if (e.addEventListener("webglcontextlost", bt, !1), e.addEventListener("webglcontextrestored", Mt, !1), null === vt) { const e = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === y.isWebGL1Renderer && e.shift(), vt = yt(e, t), null === vt) throw yt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") }
                        void 0 === vt.getShaderPrecisionFormat && (vt.getShaderPrecisionFormat = function() { return { rangeMin: 1, rangeMax: 1, precision: 1 } })
                    } catch (t) { throw console.error("THREE.WebGLRenderer: " + t.message), t }

                    function xt() { j = new Mo(vt), q = new Js(vt, j, t), j.init(q), ft = new xl(vt, j, q), X = new vl(vt, j, q), O[0] = 1029, Y = new Eo(vt), Z = new il, J = new yl(vt, j, X, Z, q, ft, Y), K = new Qs(y), $ = new wo(y), tt = new Gs(vt, q), gt = new Ys(vt, j, tt, q), et = new So(vt, tt, Y, gt), nt = new Io(vt, et, tt, Y), ht = new Po(vt, q, J), at = new Ks(Z), it = new nl(y, K, $, j, q, gt, at), rt = new Tl(Z), st = new al(Z), ot = new pl(j, q), ct = new Xs(y, K, X, nt, a), lt = new gl(y, nt, q), ut = new Zs(vt, j, Y, q), pt = new To(vt, j, Y, q), Y.programs = it.programs, y.capabilities = q, y.extensions = j, y.properties = Z, y.renderLists = st, y.shadowMap = lt, y.state = X, y.info = Y }
                    xt();
                    const _t = new Sl(y, vt);

                    function bt(t) { t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = !0 }

                    function Mt() {
                        console.log("THREE.WebGLRenderer: Context Restored."), x = !1;
                        const t = Y.autoReset,
                            e = lt.enabled,
                            n = lt.autoUpdate,
                            i = lt.needsUpdate,
                            r = lt.type;
                        xt(), Y.autoReset = t, lt.enabled = e, lt.autoUpdate = n, lt.needsUpdate = i, lt.type = r
                    }

                    function Tt(t) {
                        const e = t.target;
                        e.removeEventListener("dispose", Tt),
                            function(t) {
                                (function(t) {
                                    const e = Z.get(t).programs;
                                    void 0 !== e && e.forEach((function(t) { it.releaseProgram(t) }))
                                })(t), Z.remove(t)
                            }(e)
                    }
                    this.xr = _t, this.getContext = function() { return vt }, this.getContextAttributes = function() { return vt.getContextAttributes() }, this.forceContextLoss = function() {
                        const t = j.get("WEBGL_lose_context");
                        t && t.loseContext()
                    }, this.forceContextRestore = function() {
                        const t = j.get("WEBGL_lose_context");
                        t && t.restoreContext()
                    }, this.getPixelRatio = function() { return C }, this.setPixelRatio = function(t) { void 0 !== t && (C = t, this.setSize(L, R, !1)) }, this.getSize = function(t) { return t.set(L, R) }, this.setSize = function(t, n, i) { _t.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (L = t, R = n, e.width = Math.floor(t * C), e.height = Math.floor(n * C), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n)) }, this.getDrawingBufferSize = function(t) { return t.set(L * C, R * C).floor() }, this.setDrawingBufferSize = function(t, n, i) { L = t, R = n, C = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n) }, this.getCurrentViewport = function(t) { return t.copy(T) }, this.getViewport = function(t) { return t.copy(D) }, this.setViewport = function(t, e, n, i) { t.isVector4 ? D.set(t.x, t.y, t.z, t.w) : D.set(t, e, n, i), X.viewport(T.copy(D).multiplyScalar(C).floor()) }, this.getScissor = function(t) { return t.copy(N) }, this.setScissor = function(t, e, n, i) { t.isVector4 ? N.set(t.x, t.y, t.z, t.w) : N.set(t, e, n, i), X.scissor(E.copy(N).multiplyScalar(C).floor()) }, this.getScissorTest = function() { return B }, this.setScissorTest = function(t) { X.setScissorTest(B = t) }, this.setOpaqueSort = function(t) { P = t }, this.setTransparentSort = function(t) { I = t }, this.getClearColor = function(t) { return t.copy(ct.getClearColor()) }, this.setClearColor = function() { ct.setClearColor.apply(ct, arguments) }, this.getClearAlpha = function() { return ct.getClearAlpha() }, this.setClearAlpha = function() { ct.setClearAlpha.apply(ct, arguments) }, this.clear = function(t, e, n) {
                        let i = 0;
                        (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), vt.clear(i)
                    }, this.clearColor = function() { this.clear(!0, !1, !1) }, this.clearDepth = function() { this.clear(!1, !0, !1) }, this.clearStencil = function() { this.clear(!1, !1, !0) }, this.dispose = function() { e.removeEventListener("webglcontextlost", bt, !1), e.removeEventListener("webglcontextrestored", Mt, !1), st.dispose(), ot.dispose(), Z.dispose(), K.dispose(), $.dispose(), nt.dispose(), gt.dispose(), _t.dispose(), _t.removeEventListener("sessionstart", At), _t.removeEventListener("sessionend", Lt), H && (H.dispose(), H = null), Rt.stop() }, this.renderBufferDirect = function(t, e, n, i, r, s) {
                        null === e && (e = V);
                        const o = r.isMesh && r.matrixWorld.determinant() < 0,
                            a = function(t, e, n, i, r) {
                                !0 !== e.isScene && (e = V), J.resetTextureUnits();
                                const s = e.fog,
                                    o = i.isMeshStandardMaterial ? e.environment : null,
                                    a = null === w ? y.outputEncoding : w.texture.encoding,
                                    l = (i.isMeshStandardMaterial ? $ : K).get(i.envMap || o),
                                    c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                                    h = !!i.normalMap && !!n.attributes.tangent,
                                    u = !!n.morphAttributes.position,
                                    p = !!n.morphAttributes.normal,
                                    m = n.morphAttributes.position ? n.morphAttributes.position.length : 0,
                                    f = Z.get(i),
                                    g = d.state.lights;
                                if (!0 === z && (!0 === U || t !== S)) {
                                    const e = t === S && i.id === M;
                                    at.setState(i, t, e)
                                }
                                let v = !1;
                                i.version === f.__version ? f.needsLights && f.lightsStateVersion !== g.state.version || f.outputEncoding !== a || r.isInstancedMesh && !1 === f.instancing ? v = !0 : r.isInstancedMesh || !0 !== f.instancing ? r.isSkinnedMesh && !1 === f.skinning ? v = !0 : r.isSkinnedMesh || !0 !== f.skinning ? f.envMap !== l || i.fog && f.fog !== s ? v = !0 : void 0 === f.numClippingPlanes || f.numClippingPlanes === at.numPlanes && f.numIntersection === at.numIntersection ? (f.vertexAlphas !== c || f.vertexTangents !== h || f.morphTargets !== u || f.morphNormals !== p || !0 === q.isWebGL2 && f.morphTargetsCount !== m) && (v = !0) : v = !0 : v = !0 : v = !0 : (v = !0, f.__version = i.version);
                                let x = f.currentProgram;
                                !0 === v && (x = Ot(i, e, r));
                                let _ = !1,
                                    b = !1,
                                    T = !1;
                                const E = x.getUniforms(),
                                    A = f.uniforms;
                                if (X.useProgram(x.program) && (_ = !0, b = !0, T = !0), i.id !== M && (M = i.id, b = !0), _ || S !== t) {
                                    if (E.setValue(vt, "projectionMatrix", t.projectionMatrix), q.logarithmicDepthBuffer && E.setValue(vt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), S !== t && (S = t, b = !0, T = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
                                        const e = E.map.cameraPosition;
                                        void 0 !== e && e.setValue(vt, G.setFromMatrixPosition(t.matrixWorld))
                                    }(i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && E.setValue(vt, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && E.setValue(vt, "viewMatrix", t.matrixWorldInverse)
                                }
                                if (r.isSkinnedMesh) {
                                    E.setOptional(vt, r, "bindMatrix"), E.setOptional(vt, r, "bindMatrixInverse");
                                    const t = r.skeleton;
                                    t && (q.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), E.setValue(vt, "boneTexture", t.boneTexture, J), E.setValue(vt, "boneTextureSize", t.boneTextureSize)) : E.setOptional(vt, t, "boneMatrices"))
                                }
                                var L, P;
                                return !n || void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || ht.update(r, n, i, x), (b || f.receiveShadow !== r.receiveShadow) && (f.receiveShadow = r.receiveShadow, E.setValue(vt, "receiveShadow", r.receiveShadow)), b && (E.setValue(vt, "toneMappingExposure", y.toneMappingExposure), f.needsLights && (P = T, (L = A).ambientLightColor.needsUpdate = P, L.lightProbe.needsUpdate = P, L.directionalLights.needsUpdate = P, L.directionalLightShadows.needsUpdate = P, L.pointLights.needsUpdate = P, L.pointLightShadows.needsUpdate = P, L.spotLights.needsUpdate = P, L.spotLightShadows.needsUpdate = P, L.rectAreaLights.needsUpdate = P, L.hemisphereLights.needsUpdate = P), s && i.fog && rt.refreshFogUniforms(A, s), rt.refreshMaterialUniforms(A, i, C, R, H), Ba.upload(vt, f.uniformsList, A, J)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Ba.upload(vt, f.uniformsList, A, J), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && E.setValue(vt, "center", r.center), E.setValue(vt, "modelViewMatrix", r.modelViewMatrix), E.setValue(vt, "normalMatrix", r.normalMatrix), E.setValue(vt, "modelMatrix", r.matrixWorld), x
                            }(t, e, n, i, r);
                        X.setMaterial(i, o);
                        let l = n.index;
                        const c = n.attributes.position;
                        if (null === l) { if (void 0 === c || 0 === c.count) return } else if (0 === l.count) return;
                        let h, u = 1;
                        !0 === i.wireframe && (l = et.getWireframeAttribute(n), u = 2), gt.setup(r, i, a, n, l);
                        let p = ut;
                        null !== l && (h = tt.get(l), p = pt, p.setIndex(h));
                        const m = null !== l ? l.count : c.count,
                            f = n.drawRange.start * u,
                            g = n.drawRange.count * u,
                            v = null !== s ? s.start * u : 0,
                            x = null !== s ? s.count * u : 1 / 0,
                            _ = Math.max(f, v),
                            b = Math.min(m, f + g, v + x) - 1,
                            T = Math.max(0, b - _ + 1);
                        if (0 !== T) {
                            if (r.isMesh) !0 === i.wireframe ? (X.setLineWidth(i.wireframeLinewidth * W()), p.setMode(1)) : p.setMode(4);
                            else if (r.isLine) {
                                let t = i.linewidth;
                                void 0 === t && (t = 1), X.setLineWidth(t * W()), r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3)
                            } else r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
                            if (r.isInstancedMesh) p.renderInstances(_, T, r.count);
                            else if (n.isInstancedBufferGeometry) {
                                const t = Math.min(n.instanceCount, n._maxInstanceCount);
                                p.renderInstances(_, T, t)
                            } else p.render(_, T)
                        }
                    }, this.compile = function(t, e) {
                        d = ot.get(t), d.init(), v.push(d), t.traverseVisible((function(t) { t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t)) })), d.setupLights(y.physicallyCorrectLights), t.traverse((function(e) {
                            const n = e.material;
                            if (n)
                                if (Array.isArray(n))
                                    for (let i = 0; i < n.length; i++) Ot(n[i], t, e);
                                else Ot(n, t, e)
                        })), v.pop(), d = null
                    };
                    let Et = null;

                    function At() { Rt.stop() }

                    function Lt() { Rt.start() }
                    const Rt = new ks;

                    function It(t, e, n, i) {
                        if (!1 === t.visible) return;
                        if (t.layers.test(e.layers))
                            if (t.isGroup) n = t.renderOrder;
                            else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                        else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
                        else if (t.isSprite) {
                            if (!t.frustumCulled || F.intersectsSprite(t)) {
                                i && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(k);
                                const e = nt.update(t),
                                    r = t.material;
                                r.visible && u.push(t, e, r, n, G.z, null)
                            }
                        } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== Y.render.frame && (t.skeleton.update(), t.skeleton.frame = Y.render.frame), !t.frustumCulled || F.intersectsObject(t))) {
                            i && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(k);
                            const e = nt.update(t),
                                r = t.material;
                            if (Array.isArray(r)) {
                                const i = e.groups;
                                for (let s = 0, o = i.length; s < o; s++) {
                                    const o = i[s],
                                        a = r[o.materialIndex];
                                    a && a.visible && u.push(t, e, a, n, G.z, o)
                                }
                            } else r.visible && u.push(t, e, r, n, G.z, null)
                        }
                        const r = t.children;
                        for (let t = 0, s = r.length; t < s; t++) It(r[t], e, n, i)
                    }

                    function Dt(t, e, n, i) {
                        const r = t.opaque,
                            s = t.transmissive,
                            a = t.transparent;
                        d.setupLightsView(n), s.length > 0 && function(t, e, n) {
                            if (null === H) {
                                const t = !0 === o && !0 === q.isWebGL2;
                                H = new(t ? ui : ci)(1024, 1024, { generateMipmaps: !0, type: null !== ft.convert(Pt) ? Pt : St, minFilter: wt, magFilter: mt, wrapS: dt, wrapT: dt })
                            }
                            const i = y.getRenderTarget();
                            y.setRenderTarget(H), y.clear();
                            const r = y.toneMapping;
                            y.toneMapping = Q, Nt(t, e, n), y.toneMapping = r, J.updateMultisampleRenderTarget(H), J.updateRenderTargetMipmap(H), y.setRenderTarget(i)
                        }(r, e, n), i && X.viewport(T.copy(i)), r.length > 0 && Nt(r, e, n), s.length > 0 && Nt(s, e, n), a.length > 0 && Nt(a, e, n)
                    }

                    function Nt(t, e, n) {
                        const i = !0 === e.isScene ? e.overrideMaterial : null;
                        for (let r = 0, s = t.length; r < s; r++) {
                            const s = t[r],
                                o = s.object,
                                a = s.geometry,
                                l = null === i ? s.material : i,
                                c = s.group;
                            o.layers.test(n.layers) && Bt(o, e, n, a, l, c)
                        }
                    }

                    function Bt(t, e, n, i, r, s) { t.onBeforeRender(y, e, n, i, r, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(y, e, n, i, t, s), !0 === r.transparent && r.side === g ? (r.side = f, r.needsUpdate = !0, y.renderBufferDirect(n, e, i, r, t, s), r.side = m, r.needsUpdate = !0, y.renderBufferDirect(n, e, i, r, t, s), r.side = g) : y.renderBufferDirect(n, e, i, r, t, s), t.onAfterRender(y, e, n, i, r, s) }

                    function Ot(t, e, n) {
                        !0 !== e.isScene && (e = V);
                        const i = Z.get(t),
                            r = d.state.lights,
                            s = d.state.shadowsArray,
                            o = r.state.version,
                            a = it.getParameters(t, r.state, s, e, n),
                            l = it.getProgramCacheKey(a);
                        let c = i.programs;
                        i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = (t.isMeshStandardMaterial ? $ : K).get(t.envMap || i.environment), void 0 === c && (t.addEventListener("dispose", Tt), c = new Map, i.programs = c);
                        let h = c.get(l);
                        if (void 0 !== h) { if (i.currentProgram === h && i.lightsStateVersion === o) return Ft(t, a), h } else a.uniforms = it.getUniforms(t), t.onBuild(n, a, y), t.onBeforeCompile(a, y), h = it.acquireProgram(a, l), c.set(l, h), i.uniforms = a.uniforms;
                        const u = i.uniforms;
                        (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = at.uniform), Ft(t, a), i.needsLights = function(t) { return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights }(t), i.lightsStateVersion = o, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
                        const p = h.getUniforms(),
                            m = Ba.seqWithValue(p.seq, u);
                        return i.currentProgram = h, i.uniformsList = m, h
                    }

                    function Ft(t, e) {
                        const n = Z.get(t);
                        n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents
                    }
                    Rt.setAnimationLoop((function(t) { Et && Et(t) })), "undefined" != typeof window && Rt.setContext(window), this.setAnimationLoop = function(t) { Et = t, _t.setAnimationLoop(t), null === t ? Rt.stop() : Rt.start() }, _t.addEventListener("sessionstart", At), _t.addEventListener("sessionend", Lt), this.render = function(t, e) {
                        if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                        if (!0 === x) return;
                        !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === _t.enabled && !0 === _t.isPresenting && (!0 === _t.cameraAutoUpdate && _t.updateCamera(e), e = _t.getCamera()), !0 === t.isScene && t.onBeforeRender(y, t, e, w), d = ot.get(t, v.length), d.init(), v.push(d), k.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), F.setFromProjectionMatrix(k), U = this.localClippingEnabled, z = at.init(this.clippingPlanes, U, e), u = st.get(t, p.length), u.init(), p.push(u), It(t, e, 0, y.sortObjects), u.finish(), !0 === y.sortObjects && u.sort(P, I), !0 === z && at.beginShadows();
                        const n = d.state.shadowsArray;
                        if (lt.render(n, t, e), !0 === z && at.endShadows(), !0 === this.info.autoReset && this.info.reset(), ct.render(u, t), d.setupLights(y.physicallyCorrectLights), e.isArrayCamera) {
                            const n = e.cameras;
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = n[e];
                                Dt(u, t, i, i.viewport)
                            }
                        } else Dt(u, t, e);
                        null !== w && (J.updateMultisampleRenderTarget(w), J.updateRenderTargetMipmap(w)), !0 === t.isScene && t.onAfterRender(y, t, e), X.buffers.depth.setTest(!0), X.buffers.depth.setMask(!0), X.buffers.color.setMask(!0), X.setPolygonOffset(!1), gt.resetDefaultState(), M = -1, S = null, v.pop(), d = v.length > 0 ? v[v.length - 1] : null, p.pop(), u = p.length > 0 ? p[p.length - 1] : null
                    }, this.getActiveCubeFace = function() { return _ }, this.getActiveMipmapLevel = function() { return b }, this.getRenderTarget = function() { return w }, this.setRenderTarget = function(t, e = 0, n = 0) {
                        w = t, _ = e, b = n, t && void 0 === Z.get(t).__webglFramebuffer && J.setupRenderTarget(t);
                        let i = null,
                            r = !1,
                            s = !1;
                        if (t) {
                            const n = t.texture;
                            (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);
                            const o = Z.get(t).__webglFramebuffer;
                            t.isWebGLCubeRenderTarget ? (i = o[e], r = !0) : i = t.isWebGLMultisampleRenderTarget ? Z.get(t).__webglMultisampledFramebuffer : o, T.copy(t.viewport), E.copy(t.scissor), A = t.scissorTest
                        } else T.copy(D).multiplyScalar(C).floor(), E.copy(N).multiplyScalar(C).floor(), A = B;
                        if (X.bindFramebuffer(36160, i) && q.drawBuffers) {
                            let e = !1;
                            if (t)
                                if (t.isWebGLMultipleRenderTargets) {
                                    const n = t.texture;
                                    if (O.length !== n.length || 36064 !== O[0]) {
                                        for (let t = 0, e = n.length; t < e; t++) O[t] = 36064 + t;
                                        O.length = n.length, e = !0
                                    }
                                } else 1 === O.length && 36064 === O[0] || (O[0] = 36064, O.length = 1, e = !0);
                            else 1 === O.length && 1029 === O[0] || (O[0] = 1029, O.length = 1, e = !0);
                            e && (q.isWebGL2 ? vt.drawBuffers(O) : j.get("WEBGL_draw_buffers").drawBuffersWEBGL(O))
                        }
                        if (X.viewport(T), X.scissor(E), X.setScissorTest(A), r) {
                            const i = Z.get(t.texture);
                            vt.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
                        } else if (s) {
                            const i = Z.get(t.texture),
                                r = e || 0;
                            vt.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
                        }
                        M = -1
                    }, this.readRenderTargetPixels = function(t, e, n, i, r, s, o) {
                        if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                        let a = Z.get(t).__webglFramebuffer;
                        if (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) {
                            X.bindFramebuffer(36160, a);
                            try {
                                const o = t.texture,
                                    a = o.format,
                                    l = o.type;
                                if (a !== zt && ft.convert(a) !== vt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                const c = l === Pt && (j.has("EXT_color_buffer_half_float") || q.isWebGL2 && j.has("EXT_color_buffer_float"));
                                if (!(l === St || ft.convert(l) === vt.getParameter(35738) || l === Ct && (q.isWebGL2 || j.has("OES_texture_float") || j.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                36053 === vt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && vt.readPixels(e, n, i, r, ft.convert(a), ft.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            } finally {
                                const t = null !== w ? Z.get(w).__webglFramebuffer : null;
                                X.bindFramebuffer(36160, t)
                            }
                        }
                    }, this.copyFramebufferToTexture = function(t, e, n = 0) {
                        const i = Math.pow(2, -n),
                            r = Math.floor(e.image.width * i),
                            s = Math.floor(e.image.height * i);
                        let o = ft.convert(e.format);
                        q.isWebGL2 && (6407 === o && (o = 32849), 6408 === o && (o = 32856)), J.setTexture2D(e, 0), vt.copyTexImage2D(3553, n, o, t.x, t.y, r, s, 0), X.unbindTexture()
                    }, this.copyTextureToTexture = function(t, e, n, i = 0) {
                        const r = e.image.width,
                            s = e.image.height,
                            o = ft.convert(n.format),
                            a = ft.convert(n.type);
                        J.setTexture2D(n, 0), vt.pixelStorei(37440, n.flipY), vt.pixelStorei(37441, n.premultiplyAlpha), vt.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? vt.texSubImage2D(3553, i, t.x, t.y, r, s, o, a, e.image.data) : e.isCompressedTexture ? vt.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : vt.texSubImage2D(3553, i, t.x, t.y, o, a, e.image), 0 === i && n.generateMipmaps && vt.generateMipmap(3553), X.unbindTexture()
                    }, this.copyTextureToTexture3D = function(t, e, n, i, r = 0) {
                        if (y.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                        const s = t.max.x - t.min.x + 1,
                            o = t.max.y - t.min.y + 1,
                            a = t.max.z - t.min.z + 1,
                            l = ft.convert(i.format),
                            c = ft.convert(i.type);
                        let h;
                        if (i.isDataTexture3D) J.setTexture3D(i, 0), h = 32879;
                        else {
                            if (!i.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                            J.setTexture2DArray(i, 0), h = 35866
                        }
                        vt.pixelStorei(37440, i.flipY), vt.pixelStorei(37441, i.premultiplyAlpha), vt.pixelStorei(3317, i.unpackAlignment);
                        const u = vt.getParameter(3314),
                            d = vt.getParameter(32878),
                            p = vt.getParameter(3316),
                            m = vt.getParameter(3315),
                            f = vt.getParameter(32877),
                            g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                        vt.pixelStorei(3314, g.width), vt.pixelStorei(32878, g.height), vt.pixelStorei(3316, t.min.x), vt.pixelStorei(3315, t.min.y), vt.pixelStorei(32877, t.min.z), n.isDataTexture || n.isDataTexture3D ? vt.texSubImage3D(h, r, e.x, e.y, e.z, s, o, a, l, c, g.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), vt.compressedTexSubImage3D(h, r, e.x, e.y, e.z, s, o, a, l, g.data)) : vt.texSubImage3D(h, r, e.x, e.y, e.z, s, o, a, l, c, g), vt.pixelStorei(3314, u), vt.pixelStorei(32878, d), vt.pixelStorei(3316, p), vt.pixelStorei(3315, m), vt.pixelStorei(32877, f), 0 === r && i.generateMipmaps && vt.generateMipmap(h), X.unbindTexture()
                    }, this.initTexture = function(t) { J.setTexture2D(t, 0), X.unbindTexture() }, this.resetState = function() { _ = 0, b = 0, w = null, X.reset(), gt.reset() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }))
                }
                El.prototype.isWebGLRenderer = !0;
                class Al extends El {}
                Al.prototype.isWebGL1Renderer = !0;
                class Ll {
                    constructor(t, e = 25e-5) { this.name = "", this.color = new Br(t), this.density = e }
                    clone() { return new Ll(this.color, this.density) }
                    toJSON() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } }
                }
                Ll.prototype.isFogExp2 = !0;
                class Rl {
                    constructor(t, e = 1, n = 1e3) { this.name = "", this.color = new Br(t), this.near = e, this.far = n }
                    clone() { return new Rl(this.color, this.near, this.far) }
                    toJSON() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } }
                }
                Rl.prototype.isFog = !0;
                class Cl extends fr {
                    constructor() { super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) }
                    copy(t, e) { return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this }
                    toJSON(t) { const e = super.toJSON(t); return null !== this.fog && (e.object.fog = this.fog.toJSON()), e }
                }
                Cl.prototype.isScene = !0;
                class Pl {
                    constructor(t, e) { this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = Tn, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Gn() }
                    onUploadCallback() {}
                    set needsUpdate(t) {!0 === t && this.version++ }
                    setUsage(t) { return this.usage = t, this }
                    copy(t) { return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this }
                    copyAt(t, e, n) { t *= this.stride, n *= e.stride; for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i]; return this }
                    set(t, e = 0) { return this.array.set(t, e), this }
                    clone(t) {
                        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Gn()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                        const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                            n = new this.constructor(e, this.stride);
                        return n.setUsage(this.usage), n
                    }
                    onUpload(t) { return this.onUploadCallback = t, this }
                    toJSON(t) { return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Gn()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } }
                }
                Pl.prototype.isInterleavedBuffer = !0;
                const Il = new pi;
                class Dl {
                    constructor(t, e, n, i = !1) { this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i }
                    get count() { return this.data.count }
                    get array() { return this.data.array }
                    set needsUpdate(t) { this.data.needsUpdate = t }
                    applyMatrix4(t) { for (let e = 0, n = this.data.count; e < n; e++) Il.x = this.getX(e), Il.y = this.getY(e), Il.z = this.getZ(e), Il.applyMatrix4(t), this.setXYZ(e, Il.x, Il.y, Il.z); return this }
                    applyNormalMatrix(t) { for (let e = 0, n = this.count; e < n; e++) Il.x = this.getX(e), Il.y = this.getY(e), Il.z = this.getZ(e), Il.applyNormalMatrix(t), this.setXYZ(e, Il.x, Il.y, Il.z); return this }
                    transformDirection(t) { for (let e = 0, n = this.count; e < n; e++) Il.x = this.getX(e), Il.y = this.getY(e), Il.z = this.getZ(e), Il.transformDirection(t), this.setXYZ(e, Il.x, Il.y, Il.z); return this }
                    setX(t, e) { return this.data.array[t * this.data.stride + this.offset] = e, this }
                    setY(t, e) { return this.data.array[t * this.data.stride + this.offset + 1] = e, this }
                    setZ(t, e) { return this.data.array[t * this.data.stride + this.offset + 2] = e, this }
                    setW(t, e) { return this.data.array[t * this.data.stride + this.offset + 3] = e, this }
                    getX(t) { return this.data.array[t * this.data.stride + this.offset] }
                    getY(t) { return this.data.array[t * this.data.stride + this.offset + 1] }
                    getZ(t) { return this.data.array[t * this.data.stride + this.offset + 2] }
                    getW(t) { return this.data.array[t * this.data.stride + this.offset + 3] }
                    setXY(t, e, n) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this }
                    setXYZ(t, e, n, i) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this }
                    setXYZW(t, e, n, i, r) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this }
                    clone(t) { if (void 0 === t) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { const n = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e]) } return new Ur(new this.array.constructor(t), this.itemSize, this.normalized) } return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new Dl(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) }
                    toJSON(t) { if (void 0 === t) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { const n = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized } } return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } }
                }
                Dl.prototype.isInterleavedBufferAttribute = !0;
                class Nl extends Lr {
                    constructor(t) { super(), this.type = "SpriteMaterial", this.color = new Br(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this }
                }
                let Bl;
                Nl.prototype.isSpriteMaterial = !0;
                const Ol = new pi,
                    Fl = new pi,
                    zl = new pi,
                    Ul = new Jn,
                    Hl = new Jn,
                    kl = new Wi,
                    Gl = new pi,
                    Vl = new pi,
                    Wl = new pi,
                    jl = new Jn,
                    ql = new Jn,
                    Xl = new Jn;
                class Yl extends fr {
                    constructor(t) {
                        if (super(), this.type = "Sprite", void 0 === Bl) {
                            Bl = new is;
                            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                                e = new Pl(t, 5);
                            Bl.setIndex([0, 1, 2, 0, 2, 3]), Bl.setAttribute("position", new Dl(e, 3, 0, !1)), Bl.setAttribute("uv", new Dl(e, 2, 3, !1))
                        }
                        this.geometry = Bl, this.material = void 0 !== t ? t : new Nl, this.center = new Jn(.5, .5)
                    }
                    raycast(t, e) {
                        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Fl.setFromMatrixScale(this.matrixWorld), kl.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), zl.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Fl.multiplyScalar(-zl.z);
                        const n = this.material.rotation;
                        let i, r;
                        0 !== n && (r = Math.cos(n), i = Math.sin(n));
                        const s = this.center;
                        Zl(Gl.set(-.5, -.5, 0), zl, s, Fl, i, r), Zl(Vl.set(.5, -.5, 0), zl, s, Fl, i, r), Zl(Wl.set(.5, .5, 0), zl, s, Fl, i, r), jl.set(0, 0), ql.set(1, 0), Xl.set(1, 1);
                        let o = t.ray.intersectTriangle(Gl, Vl, Wl, !1, Ol);
                        if (null === o && (Zl(Vl.set(-.5, .5, 0), zl, s, Fl, i, r), ql.set(0, 1), o = t.ray.intersectTriangle(Gl, Wl, Vl, !1, Ol), null === o)) return;
                        const a = t.ray.origin.distanceTo(Ol);
                        a < t.near || a > t.far || e.push({ distance: a, point: Ol.clone(), uv: Er.getUV(Ol, Gl, Vl, Wl, jl, ql, Xl, new Jn), face: null, object: this })
                    }
                    copy(t) { return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this }
                }

                function Zl(t, e, n, i, r, s) { Ul.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (Hl.x = s * Ul.x - r * Ul.y, Hl.y = r * Ul.x + s * Ul.y) : Hl.copy(Ul), t.copy(e), t.x += Hl.x, t.y += Hl.y, t.applyMatrix4(kl) }
                Yl.prototype.isSprite = !0;
                const Jl = new pi,
                    Kl = new pi;
                class Ql extends fr {
                    constructor() { super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }), this.autoUpdate = !0 }
                    copy(t) {
                        super.copy(t, !1);
                        const e = t.levels;
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            this.addLevel(n.object.clone(), n.distance)
                        }
                        return this.autoUpdate = t.autoUpdate, this
                    }
                    addLevel(t, e = 0) { e = Math.abs(e); const n = this.levels; let i; for (i = 0; i < n.length && !(e < n[i].distance); i++); return n.splice(i, 0, { distance: e, object: t }), this.add(t), this }
                    getCurrentLevel() { return this._currentLevel }
                    getObjectForDistance(t) { const e = this.levels; if (e.length > 0) { let n, i; for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++); return e[n - 1].object } return null }
                    raycast(t, e) {
                        if (this.levels.length > 0) {
                            Jl.setFromMatrixPosition(this.matrixWorld);
                            const n = t.ray.origin.distanceTo(Jl);
                            this.getObjectForDistance(n).raycast(t, e)
                        }
                    }
                    update(t) { const e = this.levels; if (e.length > 1) { Jl.setFromMatrixPosition(t.matrixWorld), Kl.setFromMatrixPosition(this.matrixWorld); const n = Jl.distanceTo(Kl) / t.zoom; let i, r; for (e[0].object.visible = !0, i = 1, r = e.length; i < r && n >= e[i].distance; i++) e[i - 1].object.visible = !1, e[i].object.visible = !0; for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1 } }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = [];
                        const n = this.levels;
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            e.object.levels.push({ object: i.object.uuid, distance: i.distance })
                        }
                        return e
                    }
                }
                const $l = new pi,
                    tc = new li,
                    ec = new li,
                    nc = new pi,
                    ic = new Wi;
                class rc extends bs {
                    constructor(t, e) { super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Wi, this.bindMatrixInverse = new Wi }
                    copy(t) { return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this }
                    bind(t, e) { this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert() }
                    pose() { this.skeleton.pose() }
                    normalizeSkinWeights() {
                        const t = new li,
                            e = this.geometry.attributes.skinWeight;
                        for (let n = 0, i = e.count; n < i; n++) {
                            t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                            const i = 1 / t.manhattanLength();
                            i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                        }
                    }
                    updateMatrixWorld(t) { super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) }
                    boneTransform(t, e) {
                        const n = this.skeleton,
                            i = this.geometry;
                        tc.fromBufferAttribute(i.attributes.skinIndex, t), ec.fromBufferAttribute(i.attributes.skinWeight, t), $l.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                        for (let t = 0; t < 4; t++) {
                            const i = ec.getComponent(t);
                            if (0 !== i) {
                                const r = tc.getComponent(t);
                                ic.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(nc.copy($l).applyMatrix4(ic), i)
                            }
                        }
                        return e.applyMatrix4(this.bindMatrixInverse)
                    }
                }
                rc.prototype.isSkinnedMesh = !0;
                class sc extends fr { constructor() { super(), this.type = "Bone" } }
                sc.prototype.isBone = !0;
                class oc extends oi { constructor(t = null, e = 1, n = 1, i, r, s, o, a, l = mt, c = mt, h, u) { super(null, s, o, a, l, c, i, r, h, u), this.image = { data: t, width: e, height: n }, this.magFilter = l, this.minFilter = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } }
                oc.prototype.isDataTexture = !0;
                const ac = new Wi,
                    lc = new Wi;
                class cc {
                    constructor(t = [], e = []) { this.uuid = Gn(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init() }
                    init() {
                        const t = this.bones,
                            e = this.boneInverses;
                        if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();
                        else if (t.length !== e.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Wi) }
                    }
                    calculateInverses() {
                        this.boneInverses.length = 0;
                        for (let t = 0, e = this.bones.length; t < e; t++) {
                            const e = new Wi;
                            this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
                        }
                    }
                    pose() {
                        for (let t = 0, e = this.bones.length; t < e; t++) {
                            const e = this.bones[t];
                            e && e.matrixWorld.copy(this.boneInverses[t]).invert()
                        }
                        for (let t = 0, e = this.bones.length; t < e; t++) {
                            const e = this.bones[t];
                            e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                        }
                    }
                    update() {
                        const t = this.bones,
                            e = this.boneInverses,
                            n = this.boneMatrices,
                            i = this.boneTexture;
                        for (let i = 0, r = t.length; i < r; i++) {
                            const r = t[i] ? t[i].matrixWorld : lc;
                            ac.multiplyMatrices(r, e[i]), ac.toArray(n, 16 * i)
                        }
                        null !== i && (i.needsUpdate = !0)
                    }
                    clone() { return new cc(this.bones, this.boneInverses) }
                    computeBoneTexture() {
                        let t = Math.sqrt(4 * this.bones.length);
                        t = Xn(t), t = Math.max(t, 4);
                        const e = new Float32Array(t * t * 4);
                        e.set(this.boneMatrices);
                        const n = new oc(e, t, t, zt, Ct);
                        return this.boneMatrices = e, this.boneTexture = n, this.boneTextureSize = t, this
                    }
                    getBoneByName(t) { for (let e = 0, n = this.bones.length; e < n; e++) { const n = this.bones[e]; if (n.name === t) return n } }
                    dispose() { null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null) }
                    fromJSON(t, e) {
                        this.uuid = t.uuid;
                        for (let n = 0, i = t.bones.length; n < i; n++) {
                            const i = t.bones[n];
                            let r = e[i];
                            void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i), r = new sc), this.bones.push(r), this.boneInverses.push((new Wi).fromArray(t.boneInverses[n]))
                        }
                        return this.init(), this
                    }
                    toJSON() {
                        const t = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
                        t.uuid = this.uuid;
                        const e = this.bones,
                            n = this.boneInverses;
                        for (let i = 0, r = e.length; i < r; i++) {
                            const r = e[i];
                            t.bones.push(r.uuid);
                            const s = n[i];
                            t.boneInverses.push(s.toArray())
                        }
                        return t
                    }
                }
                class hc extends Ur {
                    constructor(t, e, n, i = 1) { "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, n), this.meshPerAttribute = i }
                    copy(t) { return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this }
                    toJSON() { const t = super.toJSON(); return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t }
                }
                hc.prototype.isInstancedBufferAttribute = !0;
                const uc = new Wi,
                    dc = new Wi,
                    pc = [],
                    mc = new bs;
                class fc extends bs {
                    constructor(t, e, n) { super(t, e), this.instanceMatrix = new hc(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1 }
                    copy(t) { return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this }
                    getColorAt(t, e) { e.fromArray(this.instanceColor.array, 3 * t) }
                    getMatrixAt(t, e) { e.fromArray(this.instanceMatrix.array, 16 * t) }
                    raycast(t, e) {
                        const n = this.matrixWorld,
                            i = this.count;
                        if (mc.geometry = this.geometry, mc.material = this.material, void 0 !== mc.material)
                            for (let r = 0; r < i; r++) {
                                this.getMatrixAt(r, uc), dc.multiplyMatrices(n, uc), mc.matrixWorld = dc, mc.raycast(t, pc);
                                for (let t = 0, n = pc.length; t < n; t++) {
                                    const n = pc[t];
                                    n.instanceId = r, n.object = this, e.push(n)
                                }
                                pc.length = 0
                            }
                    }
                    setColorAt(t, e) { null === this.instanceColor && (this.instanceColor = new hc(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t) }
                    setMatrixAt(t, e) { e.toArray(this.instanceMatrix.array, 16 * t) }
                    updateMorphTargets() {}
                    dispose() { this.dispatchEvent({ type: "dispose" }) }
                }
                fc.prototype.isInstancedMesh = !0;
                class gc extends Lr {
                    constructor(t) { super(), this.type = "LineBasicMaterial", this.color = new Br(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this }
                }
                gc.prototype.isLineBasicMaterial = !0;
                const vc = new pi,
                    yc = new pi,
                    xc = new Wi,
                    _c = new Vi,
                    bc = new Bi;
                class wc extends fr {
                    constructor(t = new is, e = new gc) { super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets() }
                    copy(t) { return super.copy(t), this.material = t.material, this.geometry = t.geometry, this }
                    computeLineDistances() {
                        const t = this.geometry;
                        if (t.isBufferGeometry)
                            if (null === t.index) {
                                const e = t.attributes.position,
                                    n = [0];
                                for (let t = 1, i = e.count; t < i; t++) vc.fromBufferAttribute(e, t - 1), yc.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += vc.distanceTo(yc);
                                t.setAttribute("lineDistance", new Yr(n, 1))
                            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                        return this
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            i = this.matrixWorld,
                            r = t.params.Line.threshold,
                            s = n.drawRange;
                        if (null === n.boundingSphere && n.computeBoundingSphere(), bc.copy(n.boundingSphere), bc.applyMatrix4(i), bc.radius += r, !1 === t.ray.intersectsSphere(bc)) return;
                        xc.copy(i).invert(), _c.copy(t.ray).applyMatrix4(xc);
                        const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            a = o * o,
                            l = new pi,
                            c = new pi,
                            h = new pi,
                            u = new pi,
                            d = this.isLineSegments ? 2 : 1;
                        if (n.isBufferGeometry) {
                            const i = n.index,
                                r = n.attributes.position;
                            if (null !== i)
                                for (let n = Math.max(0, s.start), o = Math.min(i.count, s.start + s.count) - 1; n < o; n += d) {
                                    const s = i.getX(n),
                                        o = i.getX(n + 1);
                                    if (l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, o), _c.distanceSqToSegment(l, c, u, h) > a) continue;
                                    u.applyMatrix4(this.matrixWorld);
                                    const d = t.ray.origin.distanceTo(u);
                                    d < t.near || d > t.far || e.push({ distance: d, point: h.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this })
                                } else
                                    for (let n = Math.max(0, s.start), i = Math.min(r.count, s.start + s.count) - 1; n < i; n += d) {
                                        if (l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1), _c.distanceSqToSegment(l, c, u, h) > a) continue;
                                        u.applyMatrix4(this.matrixWorld);
                                        const i = t.ray.origin.distanceTo(u);
                                        i < t.near || i > t.far || e.push({ distance: i, point: h.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this })
                                    }
                        } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                    updateMorphTargets() {
                        const t = this.geometry;
                        if (t.isBufferGeometry) {
                            const e = t.morphAttributes,
                                n = Object.keys(e);
                            if (n.length > 0) {
                                const t = e[n[0]];
                                if (void 0 !== t) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let e = 0, n = t.length; e < n; e++) {
                                        const n = t[e].name || String(e);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                    }
                                }
                            }
                        } else {
                            const e = t.morphTargets;
                            void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                        }
                    }
                }
                wc.prototype.isLine = !0;
                const Mc = new pi,
                    Sc = new pi;
                class Tc extends wc {
                    constructor(t, e) { super(t, e), this.type = "LineSegments" }
                    computeLineDistances() {
                        const t = this.geometry;
                        if (t.isBufferGeometry)
                            if (null === t.index) {
                                const e = t.attributes.position,
                                    n = [];
                                for (let t = 0, i = e.count; t < i; t += 2) Mc.fromBufferAttribute(e, t), Sc.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + Mc.distanceTo(Sc);
                                t.setAttribute("lineDistance", new Yr(n, 1))
                            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                        return this
                    }
                }
                Tc.prototype.isLineSegments = !0;
                class Ec extends wc { constructor(t, e) { super(t, e), this.type = "LineLoop" } }
                Ec.prototype.isLineLoop = !0;
                class Ac extends Lr {
                    constructor(t) { super(), this.type = "PointsMaterial", this.color = new Br(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this }
                }
                Ac.prototype.isPointsMaterial = !0;
                const Lc = new Wi,
                    Rc = new Vi,
                    Cc = new Bi,
                    Pc = new pi;
                class Ic extends fr {
                    constructor(t = new is, e = new Ac) { super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets() }
                    copy(t) { return super.copy(t), this.material = t.material, this.geometry = t.geometry, this }
                    raycast(t, e) {
                        const n = this.geometry,
                            i = this.matrixWorld,
                            r = t.params.Points.threshold,
                            s = n.drawRange;
                        if (null === n.boundingSphere && n.computeBoundingSphere(), Cc.copy(n.boundingSphere), Cc.applyMatrix4(i), Cc.radius += r, !1 === t.ray.intersectsSphere(Cc)) return;
                        Lc.copy(i).invert(), Rc.copy(t.ray).applyMatrix4(Lc);
                        const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            a = o * o;
                        if (n.isBufferGeometry) {
                            const r = n.index,
                                o = n.attributes.position;
                            if (null !== r)
                                for (let n = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); n < l; n++) {
                                    const s = r.getX(n);
                                    Pc.fromBufferAttribute(o, s), Dc(Pc, s, a, i, t, e, this)
                                } else
                                    for (let n = Math.max(0, s.start), r = Math.min(o.count, s.start + s.count); n < r; n++) Pc.fromBufferAttribute(o, n), Dc(Pc, n, a, i, t, e, this)
                        } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                    updateMorphTargets() {
                        const t = this.geometry;
                        if (t.isBufferGeometry) {
                            const e = t.morphAttributes,
                                n = Object.keys(e);
                            if (n.length > 0) {
                                const t = e[n[0]];
                                if (void 0 !== t) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let e = 0, n = t.length; e < n; e++) {
                                        const n = t[e].name || String(e);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                    }
                                }
                            }
                        } else {
                            const e = t.morphTargets;
                            void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                        }
                    }
                }

                function Dc(t, e, n, i, r, s, o) {
                    const a = Rc.distanceSqToPoint(t);
                    if (a < n) {
                        const n = new pi;
                        Rc.closestPointToPoint(t, n), n.applyMatrix4(i);
                        const l = r.ray.origin.distanceTo(n);
                        if (l < r.near || l > r.far) return;
                        s.push({ distance: l, distanceToRay: Math.sqrt(a), point: n, index: e, face: null, object: o })
                    }
                }
                Ic.prototype.isPoints = !0;
                class Nc extends oi {
                    constructor(t, e, n, i, r, s, o, a, l) { super(t, e, n, i, r, s, o, a, l), this.format = void 0 !== o ? o : Ft, this.minFilter = void 0 !== s ? s : xt, this.magFilter = void 0 !== r ? r : xt, this.generateMipmaps = !1; const c = this; "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() { c.needsUpdate = !0, t.requestVideoFrameCallback(e) })) }
                    clone() { return new this.constructor(this.image).copy(this) }
                    update() { const t = this.image;!1 == "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0) }
                }
                Nc.prototype.isVideoTexture = !0;
                class Bc extends oi { constructor(t, e, n, i, r, s, o, a, l, c, h, u) { super(null, s, o, a, l, c, i, r, h, u), this.image = { width: e, height: n }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1 } }
                Bc.prototype.isCompressedTexture = !0;
                class Oc extends oi { constructor(t, e, n, i, r, s, o, a, l) { super(t, e, n, i, r, s, o, a, l), this.needsUpdate = !0 } }
                Oc.prototype.isCanvasTexture = !0;
                class Fc extends oi {
                    constructor(t, e, n, i, r, s, o, a, l, c) {
                        if ((c = void 0 !== c ? c : Gt) !== Gt && c !== Vt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                        void 0 === n && c === Gt && (n = At), void 0 === n && c === Vt && (n = Bt), super(null, i, r, s, o, a, c, n, l), this.image = { width: t, height: e }, this.magFilter = void 0 !== o ? o : mt, this.minFilter = void 0 !== a ? a : mt, this.flipY = !1, this.generateMipmaps = !1
                    }
                }
                Fc.prototype.isDepthTexture = !0;
                class zc extends is {
                    constructor(t = 1, e = 8, n = 0, i = 2 * Math.PI) {
                        super(), this.type = "CircleGeometry", this.parameters = { radius: t, segments: e, thetaStart: n, thetaLength: i }, e = Math.max(3, e);
                        const r = [],
                            s = [],
                            o = [],
                            a = [],
                            l = new pi,
                            c = new Jn;
                        s.push(0, 0, 0), o.push(0, 0, 1), a.push(.5, .5);
                        for (let r = 0, h = 3; r <= e; r++, h += 3) {
                            const u = n + r / e * i;
                            l.x = t * Math.cos(u), l.y = t * Math.sin(u), s.push(l.x, l.y, l.z), o.push(0, 0, 1), c.x = (s[h] / t + 1) / 2, c.y = (s[h + 1] / t + 1) / 2, a.push(c.x, c.y)
                        }
                        for (let t = 1; t <= e; t++) r.push(t, t + 1, 0);
                        this.setIndex(r), this.setAttribute("position", new Yr(s, 3)), this.setAttribute("normal", new Yr(o, 3)), this.setAttribute("uv", new Yr(a, 2))
                    }
                    static fromJSON(t) { return new zc(t.radius, t.segments, t.thetaStart, t.thetaLength) }
                }
                class Uc extends is {
                    constructor(t = 1, e = 1, n = 1, i = 8, r = 1, s = !1, o = 0, a = 2 * Math.PI) {
                        super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: n, radialSegments: i, heightSegments: r, openEnded: s, thetaStart: o, thetaLength: a };
                        const l = this;
                        i = Math.floor(i), r = Math.floor(r);
                        const c = [],
                            h = [],
                            u = [],
                            d = [];
                        let p = 0;
                        const m = [],
                            f = n / 2;
                        let g = 0;

                        function v(n) {
                            const r = p,
                                s = new Jn,
                                m = new pi;
                            let v = 0;
                            const y = !0 === n ? t : e,
                                x = !0 === n ? 1 : -1;
                            for (let t = 1; t <= i; t++) h.push(0, f * x, 0), u.push(0, x, 0), d.push(.5, .5), p++;
                            const _ = p;
                            for (let t = 0; t <= i; t++) {
                                const e = t / i * a + o,
                                    n = Math.cos(e),
                                    r = Math.sin(e);
                                m.x = y * r, m.y = f * x, m.z = y * n, h.push(m.x, m.y, m.z), u.push(0, x, 0), s.x = .5 * n + .5, s.y = .5 * r * x + .5, d.push(s.x, s.y), p++
                            }
                            for (let t = 0; t < i; t++) {
                                const e = r + t,
                                    i = _ + t;
                                !0 === n ? c.push(i, i + 1, e) : c.push(i + 1, i, e), v += 3
                            }
                            l.addGroup(g, v, !0 === n ? 1 : 2), g += v
                        }! function() {
                            const s = new pi,
                                v = new pi;
                            let y = 0;
                            const x = (e - t) / n;
                            for (let l = 0; l <= r; l++) {
                                const c = [],
                                    g = l / r,
                                    y = g * (e - t) + t;
                                for (let t = 0; t <= i; t++) {
                                    const e = t / i,
                                        r = e * a + o,
                                        l = Math.sin(r),
                                        m = Math.cos(r);
                                    v.x = y * l, v.y = -g * n + f, v.z = y * m, h.push(v.x, v.y, v.z), s.set(l, x, m).normalize(), u.push(s.x, s.y, s.z), d.push(e, 1 - g), c.push(p++)
                                }
                                m.push(c)
                            }
                            for (let t = 0; t < i; t++)
                                for (let e = 0; e < r; e++) {
                                    const n = m[e][t],
                                        i = m[e + 1][t],
                                        r = m[e + 1][t + 1],
                                        s = m[e][t + 1];
                                    c.push(n, i, s), c.push(i, r, s), y += 6
                                }
                            l.addGroup(g, y, 0), g += y
                        }(), !1 === s && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(c), this.setAttribute("position", new Yr(h, 3)), this.setAttribute("normal", new Yr(u, 3)), this.setAttribute("uv", new Yr(d, 2))
                    }
                    static fromJSON(t) { return new Uc(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength) }
                }
                class Hc extends Uc {
                    constructor(t = 1, e = 1, n = 8, i = 1, r = !1, s = 0, o = 2 * Math.PI) { super(0, t, e, n, i, r, s, o), this.type = "ConeGeometry", this.parameters = { radius: t, height: e, radialSegments: n, heightSegments: i, openEnded: r, thetaStart: s, thetaLength: o } }
                    static fromJSON(t) { return new Hc(t.radius, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength) }
                }
                class kc extends is {
                    constructor(t = [], e = [], n = 1, i = 0) {
                        super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: t, indices: e, radius: n, detail: i };
                        const r = [],
                            s = [];

                        function o(t, e, n, i) {
                            const r = i + 1,
                                s = [];
                            for (let i = 0; i <= r; i++) {
                                s[i] = [];
                                const o = t.clone().lerp(n, i / r),
                                    a = e.clone().lerp(n, i / r),
                                    l = r - i;
                                for (let t = 0; t <= l; t++) s[i][t] = 0 === t && i === r ? o : o.clone().lerp(a, t / l)
                            }
                            for (let t = 0; t < r; t++)
                                for (let e = 0; e < 2 * (r - t) - 1; e++) {
                                    const n = Math.floor(e / 2);
                                    e % 2 == 0 ? (a(s[t][n + 1]), a(s[t + 1][n]), a(s[t][n])) : (a(s[t][n + 1]), a(s[t + 1][n + 1]), a(s[t + 1][n]))
                                }
                        }

                        function a(t) { r.push(t.x, t.y, t.z) }

                        function l(e, n) {
                            const i = 3 * e;
                            n.x = t[i + 0], n.y = t[i + 1], n.z = t[i + 2]
                        }

                        function c(t, e, n, i) { i < 0 && 1 === t.x && (s[e] = t.x - 1), 0 === n.x && 0 === n.z && (s[e] = i / 2 / Math.PI + .5) }

                        function h(t) { return Math.atan2(t.z, -t.x) }! function(t) {
                            const n = new pi,
                                i = new pi,
                                r = new pi;
                            for (let s = 0; s < e.length; s += 3) l(e[s + 0], n), l(e[s + 1], i), l(e[s + 2], r), o(n, i, r, t)
                        }(i),
                        function(t) { const e = new pi; for (let n = 0; n < r.length; n += 3) e.x = r[n + 0], e.y = r[n + 1], e.z = r[n + 2], e.normalize().multiplyScalar(t), r[n + 0] = e.x, r[n + 1] = e.y, r[n + 2] = e.z }(n),
                        function() {
                            const t = new pi;
                            for (let n = 0; n < r.length; n += 3) {
                                t.x = r[n + 0], t.y = r[n + 1], t.z = r[n + 2];
                                const i = h(t) / 2 / Math.PI + .5,
                                    o = (e = t, Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5);
                                s.push(i, 1 - o)
                            }
                            var e;
                            (function() {
                                const t = new pi,
                                    e = new pi,
                                    n = new pi,
                                    i = new pi,
                                    o = new Jn,
                                    a = new Jn,
                                    l = new Jn;
                                for (let u = 0, d = 0; u < r.length; u += 9, d += 6) {
                                    t.set(r[u + 0], r[u + 1], r[u + 2]), e.set(r[u + 3], r[u + 4], r[u + 5]), n.set(r[u + 6], r[u + 7], r[u + 8]), o.set(s[d + 0], s[d + 1]), a.set(s[d + 2], s[d + 3]), l.set(s[d + 4], s[d + 5]), i.copy(t).add(e).add(n).divideScalar(3);
                                    const p = h(i);
                                    c(o, d + 0, t, p), c(a, d + 2, e, p), c(l, d + 4, n, p)
                                }
                            })(),
                            function() {
                                for (let t = 0; t < s.length; t += 6) {
                                    const e = s[t + 0],
                                        n = s[t + 2],
                                        i = s[t + 4],
                                        r = Math.max(e, n, i),
                                        o = Math.min(e, n, i);
                                    r > .9 && o < .1 && (e < .2 && (s[t + 0] += 1), n < .2 && (s[t + 2] += 1), i < .2 && (s[t + 4] += 1))
                                }
                            }()
                        }(), this.setAttribute("position", new Yr(r, 3)), this.setAttribute("normal", new Yr(r.slice(), 3)), this.setAttribute("uv", new Yr(s, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals()
                    }
                    static fromJSON(t) { return new kc(t.vertices, t.indices, t.radius, t.details) }
                }
                class Gc extends kc {
                    constructor(t = 1, e = 0) {
                        const n = (1 + Math.sqrt(5)) / 2,
                            i = 1 / n;
                        super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronGeometry", this.parameters = { radius: t, detail: e }
                    }
                    static fromJSON(t) { return new Gc(t.radius, t.detail) }
                }
                const Vc = new pi,
                    Wc = new pi,
                    jc = new pi,
                    qc = new Er;
                class Xc extends is {
                    constructor(t = null, e = 1) {
                        if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: t, thresholdAngle: e }, null !== t) {
                            const n = 4,
                                i = Math.pow(10, n),
                                r = Math.cos(zn * e),
                                s = t.getIndex(),
                                o = t.getAttribute("position"),
                                a = s ? s.count : o.count,
                                l = [0, 0, 0],
                                c = ["a", "b", "c"],
                                h = new Array(3),
                                u = {},
                                d = [];
                            for (let t = 0; t < a; t += 3) {
                                s ? (l[0] = s.getX(t), l[1] = s.getX(t + 1), l[2] = s.getX(t + 2)) : (l[0] = t, l[1] = t + 1, l[2] = t + 2);
                                const { a: e, b: n, c: a } = qc;
                                if (e.fromBufferAttribute(o, l[0]), n.fromBufferAttribute(o, l[1]), a.fromBufferAttribute(o, l[2]), qc.getNormal(jc), h[0] = `${Math.round(e.x*i)},${Math.round(e.y*i)},${Math.round(e.z*i)}`, h[1] = `${Math.round(n.x*i)},${Math.round(n.y*i)},${Math.round(n.z*i)}`, h[2] = `${Math.round(a.x*i)},${Math.round(a.y*i)},${Math.round(a.z*i)}`, h[0] !== h[1] && h[1] !== h[2] && h[2] !== h[0])
                                    for (let t = 0; t < 3; t++) {
                                        const e = (t + 1) % 3,
                                            n = h[t],
                                            i = h[e],
                                            s = qc[c[t]],
                                            o = qc[c[e]],
                                            a = `${n}_${i}`,
                                            p = `${i}_${n}`;
                                        p in u && u[p] ? (jc.dot(u[p].normal) <= r && (d.push(s.x, s.y, s.z), d.push(o.x, o.y, o.z)), u[p] = null) : a in u || (u[a] = { index0: l[t], index1: l[e], normal: jc.clone() })
                                    }
                            }
                            for (const t in u)
                                if (u[t]) {
                                    const { index0: e, index1: n } = u[t];
                                    Vc.fromBufferAttribute(o, e), Wc.fromBufferAttribute(o, n), d.push(Vc.x, Vc.y, Vc.z), d.push(Wc.x, Wc.y, Wc.z)
                                }
                            this.setAttribute("position", new Yr(d, 3))
                        }
                    }
                }
                class Yc {
                    constructor() { this.type = "Curve", this.arcLengthDivisions = 200 }
                    getPoint() { return console.warn("THREE.Curve: .getPoint() not implemented."), null }
                    getPointAt(t, e) { const n = this.getUtoTmapping(t); return this.getPoint(n, e) }
                    getPoints(t = 5) { const e = []; for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t)); return e }
                    getSpacedPoints(t = 5) { const e = []; for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t)); return e }
                    getLength() { const t = this.getLengths(); return t[t.length - 1] }
                    getLengths(t = this.arcLengthDivisions) {
                        if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                        this.needsUpdate = !1;
                        const e = [];
                        let n, i = this.getPoint(0),
                            r = 0;
                        e.push(0);
                        for (let s = 1; s <= t; s++) n = this.getPoint(s / t), r += n.distanceTo(i), e.push(r), i = n;
                        return this.cacheArcLengths = e, e
                    }
                    updateArcLengths() { this.needsUpdate = !0, this.getLengths() }
                    getUtoTmapping(t, e) {
                        const n = this.getLengths();
                        let i = 0;
                        const r = n.length;
                        let s;
                        s = e || t * n[r - 1];
                        let o, a = 0,
                            l = r - 1;
                        for (; a <= l;)
                            if (i = Math.floor(a + (l - a) / 2), o = n[i] - s, o < 0) a = i + 1;
                            else {
                                if (!(o > 0)) { l = i; break }
                                l = i - 1
                            }
                        if (i = l, n[i] === s) return i / (r - 1);
                        const c = n[i];
                        return (i + (s - c) / (n[i + 1] - c)) / (r - 1)
                    }
                    getTangent(t, e) {
                        const n = 1e-4;
                        let i = t - n,
                            r = t + n;
                        i < 0 && (i = 0), r > 1 && (r = 1);
                        const s = this.getPoint(i),
                            o = this.getPoint(r),
                            a = e || (s.isVector2 ? new Jn : new pi);
                        return a.copy(o).sub(s).normalize(), a
                    }
                    getTangentAt(t, e) { const n = this.getUtoTmapping(t); return this.getTangent(n, e) }
                    computeFrenetFrames(t, e) {
                        const n = new pi,
                            i = [],
                            r = [],
                            s = [],
                            o = new pi,
                            a = new Wi;
                        for (let e = 0; e <= t; e++) {
                            const n = e / t;
                            i[e] = this.getTangentAt(n, new pi)
                        }
                        r[0] = new pi, s[0] = new pi;
                        let l = Number.MAX_VALUE;
                        const c = Math.abs(i[0].x),
                            h = Math.abs(i[0].y),
                            u = Math.abs(i[0].z);
                        c <= l && (l = c, n.set(1, 0, 0)), h <= l && (l = h, n.set(0, 1, 0)), u <= l && n.set(0, 0, 1), o.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], o), s[0].crossVectors(i[0], r[0]);
                        for (let e = 1; e <= t; e++) {
                            if (r[e] = r[e - 1].clone(), s[e] = s[e - 1].clone(), o.crossVectors(i[e - 1], i[e]), o.length() > Number.EPSILON) {
                                o.normalize();
                                const t = Math.acos(Vn(i[e - 1].dot(i[e]), -1, 1));
                                r[e].applyMatrix4(a.makeRotationAxis(o, t))
                            }
                            s[e].crossVectors(i[e], r[e])
                        }
                        if (!0 === e) {
                            let e = Math.acos(Vn(r[0].dot(r[t]), -1, 1));
                            e /= t, i[0].dot(o.crossVectors(r[0], r[t])) > 0 && (e = -e);
                            for (let n = 1; n <= t; n++) r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)), s[n].crossVectors(i[n], r[n])
                        }
                        return { tangents: i, normals: r, binormals: s }
                    }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { return this.arcLengthDivisions = t.arcLengthDivisions, this }
                    toJSON() { const t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t }
                    fromJSON(t) { return this.arcLengthDivisions = t.arcLengthDivisions, this }
                }
                class Zc extends Yc {
                    constructor(t = 0, e = 0, n = 1, i = 1, r = 0, s = 2 * Math.PI, o = !1, a = 0) { super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = o, this.aRotation = a }
                    getPoint(t, e) {
                        const n = e || new Jn,
                            i = 2 * Math.PI;
                        let r = this.aEndAngle - this.aStartAngle;
                        const s = Math.abs(r) < Number.EPSILON;
                        for (; r < 0;) r += i;
                        for (; r > i;) r -= i;
                        r < Number.EPSILON && (r = s ? 0 : i), !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i);
                        const o = this.aStartAngle + t * r;
                        let a = this.aX + this.xRadius * Math.cos(o),
                            l = this.aY + this.yRadius * Math.sin(o);
                        if (0 !== this.aRotation) {
                            const t = Math.cos(this.aRotation),
                                e = Math.sin(this.aRotation),
                                n = a - this.aX,
                                i = l - this.aY;
                            a = n * t - i * e + this.aX, l = n * e + i * t + this.aY
                        }
                        return n.set(a, l)
                    }
                    copy(t) { return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }
                    toJSON() { const t = super.toJSON(); return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t }
                    fromJSON(t) { return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }
                }
                Zc.prototype.isEllipseCurve = !0;
                class Jc extends Zc { constructor(t, e, n, i, r, s) { super(t, e, n, n, i, r, s), this.type = "ArcCurve" } }

                function Kc() {
                    let t = 0,
                        e = 0,
                        n = 0,
                        i = 0;

                    function r(r, s, o, a) { t = r, e = o, n = -3 * r + 3 * s - 2 * o - a, i = 2 * r - 2 * s + o + a }
                    return {
                        initCatmullRom: function(t, e, n, i, s) { r(e, n, s * (n - t), s * (i - e)) },
                        initNonuniformCatmullRom: function(t, e, n, i, s, o, a) {
                            let l = (e - t) / s - (n - t) / (s + o) + (n - e) / o,
                                c = (n - e) / o - (i - e) / (o + a) + (i - n) / a;
                            l *= o, c *= o, r(e, n, l, c)
                        },
                        calc: function(r) { const s = r * r; return t + e * r + n * s + i * (s * r) }
                    }
                }
                Jc.prototype.isArcCurve = !0;
                const Qc = new pi,
                    $c = new Kc,
                    th = new Kc,
                    eh = new Kc;
                class nh extends Yc {
                    constructor(t = [], e = !1, n = "centripetal", i = .5) { super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = i }
                    getPoint(t, e = new pi) {
                        const n = e,
                            i = this.points,
                            r = i.length,
                            s = (r - (this.closed ? 0 : 1)) * t;
                        let o, a, l = Math.floor(s),
                            c = s - l;
                        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? o = i[(l - 1) % r] : (Qc.subVectors(i[0], i[1]).add(i[0]), o = Qc);
                        const h = i[l % r],
                            u = i[(l + 1) % r];
                        if (this.closed || l + 2 < r ? a = i[(l + 2) % r] : (Qc.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), a = Qc), "centripetal" === this.curveType || "chordal" === this.curveType) {
                            const t = "chordal" === this.curveType ? .5 : .25;
                            let e = Math.pow(o.distanceToSquared(h), t),
                                n = Math.pow(h.distanceToSquared(u), t),
                                i = Math.pow(u.distanceToSquared(a), t);
                            n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), $c.initNonuniformCatmullRom(o.x, h.x, u.x, a.x, e, n, i), th.initNonuniformCatmullRom(o.y, h.y, u.y, a.y, e, n, i), eh.initNonuniformCatmullRom(o.z, h.z, u.z, a.z, e, n, i)
                        } else "catmullrom" === this.curveType && ($c.initCatmullRom(o.x, h.x, u.x, a.x, this.tension), th.initCatmullRom(o.y, h.y, u.y, a.y, this.tension), eh.initCatmullRom(o.z, h.z, u.z, a.z, this.tension));
                        return n.set($c.calc(c), th.calc(c), eh.calc(c)), n
                    }
                    copy(t) {
                        super.copy(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push(n.clone())
                        }
                        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.points = [];
                        for (let e = 0, n = this.points.length; e < n; e++) {
                            const n = this.points[e];
                            t.points.push(n.toArray())
                        }
                        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push((new pi).fromArray(n))
                        }
                        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                    }
                }

                function ih(t, e, n, i, r) {
                    const s = .5 * (i - e),
                        o = .5 * (r - n),
                        a = t * t;
                    return (2 * n - 2 * i + s + o) * (t * a) + (-3 * n + 3 * i - 2 * s - o) * a + s * t + n
                }

                function rh(t, e, n, i) { return function(t, e) { const n = 1 - t; return n * n * e }(t, e) + function(t, e) { return 2 * (1 - t) * t * e }(t, n) + function(t, e) { return t * t * e }(t, i) }

                function sh(t, e, n, i, r) { return function(t, e) { const n = 1 - t; return n * n * n * e }(t, e) + function(t, e) { const n = 1 - t; return 3 * n * n * t * e }(t, n) + function(t, e) { return 3 * (1 - t) * t * t * e }(t, i) + function(t, e) { return t * t * t * e }(t, r) }
                nh.prototype.isCatmullRomCurve3 = !0;
                class oh extends Yc {
                    constructor(t = new Jn, e = new Jn, n = new Jn, i = new Jn) { super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i }
                    getPoint(t, e = new Jn) {
                        const n = e,
                            i = this.v0,
                            r = this.v1,
                            s = this.v2,
                            o = this.v3;
                        return n.set(sh(t, i.x, r.x, s.x, o.x), sh(t, i.y, r.y, s.y, o.y)), n
                    }
                    copy(t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }
                    toJSON() { const t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }
                }
                oh.prototype.isCubicBezierCurve = !0;
                class ah extends Yc {
                    constructor(t = new pi, e = new pi, n = new pi, i = new pi) { super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i }
                    getPoint(t, e = new pi) {
                        const n = e,
                            i = this.v0,
                            r = this.v1,
                            s = this.v2,
                            o = this.v3;
                        return n.set(sh(t, i.x, r.x, s.x, o.x), sh(t, i.y, r.y, s.y, o.y), sh(t, i.z, r.z, s.z, o.z)), n
                    }
                    copy(t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }
                    toJSON() { const t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }
                }
                ah.prototype.isCubicBezierCurve3 = !0;
                class lh extends Yc {
                    constructor(t = new Jn, e = new Jn) { super(), this.type = "LineCurve", this.v1 = t, this.v2 = e }
                    getPoint(t, e = new Jn) { const n = e; return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n }
                    getPointAt(t, e) { return this.getPoint(t, e) }
                    getTangent(t, e) { const n = e || new Jn; return n.copy(this.v2).sub(this.v1).normalize(), n }
                    copy(t) { return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }
                    toJSON() { const t = super.toJSON(); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }
                }
                lh.prototype.isLineCurve = !0;
                class ch extends Yc {
                    constructor(t = new pi, e = new pi) { super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e }
                    getPoint(t, e = new pi) { const n = e; return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n }
                    getPointAt(t, e) { return this.getPoint(t, e) }
                    copy(t) { return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }
                    toJSON() { const t = super.toJSON(); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }
                }
                class hh extends Yc {
                    constructor(t = new Jn, e = new Jn, n = new Jn) { super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n }
                    getPoint(t, e = new Jn) {
                        const n = e,
                            i = this.v0,
                            r = this.v1,
                            s = this.v2;
                        return n.set(rh(t, i.x, r.x, s.x), rh(t, i.y, r.y, s.y)), n
                    }
                    copy(t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }
                    toJSON() { const t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }
                }
                hh.prototype.isQuadraticBezierCurve = !0;
                class uh extends Yc {
                    constructor(t = new pi, e = new pi, n = new pi) { super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n }
                    getPoint(t, e = new pi) {
                        const n = e,
                            i = this.v0,
                            r = this.v1,
                            s = this.v2;
                        return n.set(rh(t, i.x, r.x, s.x), rh(t, i.y, r.y, s.y), rh(t, i.z, r.z, s.z)), n
                    }
                    copy(t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }
                    toJSON() { const t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }
                }
                uh.prototype.isQuadraticBezierCurve3 = !0;
                class dh extends Yc {
                    constructor(t = []) { super(), this.type = "SplineCurve", this.points = t }
                    getPoint(t, e = new Jn) {
                        const n = e,
                            i = this.points,
                            r = (i.length - 1) * t,
                            s = Math.floor(r),
                            o = r - s,
                            a = i[0 === s ? s : s - 1],
                            l = i[s],
                            c = i[s > i.length - 2 ? i.length - 1 : s + 1],
                            h = i[s > i.length - 3 ? i.length - 1 : s + 2];
                        return n.set(ih(o, a.x, l.x, c.x, h.x), ih(o, a.y, l.y, c.y, h.y)), n
                    }
                    copy(t) {
                        super.copy(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push(n.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.points = [];
                        for (let e = 0, n = this.points.length; e < n; e++) {
                            const n = this.points[e];
                            t.points.push(n.toArray())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push((new Jn).fromArray(n))
                        }
                        return this
                    }
                }
                dh.prototype.isSplineCurve = !0;
                var ph = Object.freeze({ __proto__: null, ArcCurve: Jc, CatmullRomCurve3: nh, CubicBezierCurve: oh, CubicBezierCurve3: ah, EllipseCurve: Zc, LineCurve: lh, LineCurve3: ch, QuadraticBezierCurve: hh, QuadraticBezierCurve3: uh, SplineCurve: dh });
                class mh extends Yc {
                    constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 }
                    add(t) { this.curves.push(t) }
                    closePath() {
                        const t = this.curves[0].getPoint(0),
                            e = this.curves[this.curves.length - 1].getPoint(1);
                        t.equals(e) || this.curves.push(new lh(e, t))
                    }
                    getPoint(t, e) {
                        const n = t * this.getLength(),
                            i = this.getCurveLengths();
                        let r = 0;
                        for (; r < i.length;) {
                            if (i[r] >= n) {
                                const t = i[r] - n,
                                    s = this.curves[r],
                                    o = s.getLength(),
                                    a = 0 === o ? 0 : 1 - t / o;
                                return s.getPointAt(a, e)
                            }
                            r++
                        }
                        return null
                    }
                    getLength() { const t = this.getCurveLengths(); return t[t.length - 1] }
                    updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() }
                    getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const t = []; let e = 0; for (let n = 0, i = this.curves.length; n < i; n++) e += this.curves[n].getLength(), t.push(e); return this.cacheLengths = t, t }
                    getSpacedPoints(t = 40) { const e = []; for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t)); return this.autoClose && e.push(e[0]), e }
                    getPoints(t = 12) {
                        const e = [];
                        let n;
                        for (let i = 0, r = this.curves; i < r.length; i++) {
                            const s = r[i],
                                o = s && s.isEllipseCurve ? 2 * t : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t,
                                a = s.getPoints(o);
                            for (let t = 0; t < a.length; t++) {
                                const i = a[t];
                                n && n.equals(i) || (e.push(i), n = i)
                            }
                        }
                        return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
                    }
                    copy(t) {
                        super.copy(t), this.curves = [];
                        for (let e = 0, n = t.curves.length; e < n; e++) {
                            const n = t.curves[e];
                            this.curves.push(n.clone())
                        }
                        return this.autoClose = t.autoClose, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.autoClose = this.autoClose, t.curves = [];
                        for (let e = 0, n = this.curves.length; e < n; e++) {
                            const n = this.curves[e];
                            t.curves.push(n.toJSON())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                        for (let e = 0, n = t.curves.length; e < n; e++) {
                            const n = t.curves[e];
                            this.curves.push((new ph[n.type]).fromJSON(n))
                        }
                        return this
                    }
                }
                class fh extends mh {
                    constructor(t) { super(), this.type = "Path", this.currentPoint = new Jn, t && this.setFromPoints(t) }
                    setFromPoints(t) { this.moveTo(t[0].x, t[0].y); for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y); return this }
                    moveTo(t, e) { return this.currentPoint.set(t, e), this }
                    lineTo(t, e) { const n = new lh(this.currentPoint.clone(), new Jn(t, e)); return this.curves.push(n), this.currentPoint.set(t, e), this }
                    quadraticCurveTo(t, e, n, i) { const r = new hh(this.currentPoint.clone(), new Jn(t, e), new Jn(n, i)); return this.curves.push(r), this.currentPoint.set(n, i), this }
                    bezierCurveTo(t, e, n, i, r, s) { const o = new oh(this.currentPoint.clone(), new Jn(t, e), new Jn(n, i), new Jn(r, s)); return this.curves.push(o), this.currentPoint.set(r, s), this }
                    splineThru(t) {
                        const e = [this.currentPoint.clone()].concat(t),
                            n = new dh(e);
                        return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
                    }
                    arc(t, e, n, i, r, s) {
                        const o = this.currentPoint.x,
                            a = this.currentPoint.y;
                        return this.absarc(t + o, e + a, n, i, r, s), this
                    }
                    absarc(t, e, n, i, r, s) { return this.absellipse(t, e, n, n, i, r, s), this }
                    ellipse(t, e, n, i, r, s, o, a) {
                        const l = this.currentPoint.x,
                            c = this.currentPoint.y;
                        return this.absellipse(t + l, e + c, n, i, r, s, o, a), this
                    }
                    absellipse(t, e, n, i, r, s, o, a) {
                        const l = new Zc(t, e, n, i, r, s, o, a);
                        if (this.curves.length > 0) {
                            const t = l.getPoint(0);
                            t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                        }
                        this.curves.push(l);
                        const c = l.getPoint(1);
                        return this.currentPoint.copy(c), this
                    }
                    copy(t) { return super.copy(t), this.currentPoint.copy(t.currentPoint), this }
                    toJSON() { const t = super.toJSON(); return t.currentPoint = this.currentPoint.toArray(), t }
                    fromJSON(t) { return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this }
                }
                class gh extends fh {
                    constructor(t) { super(t), this.uuid = Gn(), this.type = "Shape", this.holes = [] }
                    getPointsHoles(t) { const e = []; for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t); return e }
                    extractPoints(t) { return { shape: this.getPoints(t), holes: this.getPointsHoles(t) } }
                    copy(t) {
                        super.copy(t), this.holes = [];
                        for (let e = 0, n = t.holes.length; e < n; e++) {
                            const n = t.holes[e];
                            this.holes.push(n.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.uuid = this.uuid, t.holes = [];
                        for (let e = 0, n = this.holes.length; e < n; e++) {
                            const n = this.holes[e];
                            t.holes.push(n.toJSON())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
                        for (let e = 0, n = t.holes.length; e < n; e++) {
                            const n = t.holes[e];
                            this.holes.push((new fh).fromJSON(n))
                        }
                        return this
                    }
                }

                function vh(t, e, n, i, r) {
                    let s, o;
                    if (r === function(t, e, n, i) { let r = 0; for (let s = e, o = n - i; s < n; s += i) r += (t[o] - t[s]) * (t[s + 1] + t[o + 1]), o = s; return r }(t, e, n, i) > 0)
                        for (s = e; s < n; s += i) o = zh(s, t[s], t[s + 1], o);
                    else
                        for (s = n - i; s >= e; s -= i) o = zh(s, t[s], t[s + 1], o);
                    return o && Ih(o, o.next) && (Uh(o), o = o.next), o
                }

                function yh(t, e) {
                    if (!t) return t;
                    e || (e = t);
                    let n, i = t;
                    do {
                        if (n = !1, i.steiner || !Ih(i, i.next) && 0 !== Ph(i.prev, i, i.next)) i = i.next;
                        else {
                            if (Uh(i), i = e = i.prev, i === i.next) break;
                            n = !0
                        }
                    } while (n || i !== e);
                    return e
                }

                function xh(t, e, n, i, r, s, o) {
                    if (!t) return;
                    !o && s && function(t, e, n, i) {
                        let r = t;
                        do { null === r.z && (r.z = Ah(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next } while (r !== t);
                        r.prevZ.nextZ = null, r.prevZ = null,
                            function(t) {
                                let e, n, i, r, s, o, a, l, c = 1;
                                do {
                                    for (n = t, t = null, s = null, o = 0; n;) {
                                        for (o++, i = n, a = 0, e = 0; e < c && (a++, i = i.nextZ, i); e++);
                                        for (l = c; a > 0 || l > 0 && i;) 0 !== a && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, a--) : (r = i, i = i.nextZ, l--), s ? s.nextZ = r : t = r, r.prevZ = s, s = r;
                                        n = i
                                    }
                                    s.nextZ = null, c *= 2
                                } while (o > 1)
                            }(r)
                    }(t, i, r, s);
                    let a, l, c = t;
                    for (; t.prev !== t.next;)
                        if (a = t.prev, l = t.next, s ? bh(t, i, r, s) : _h(t)) e.push(a.i / n), e.push(t.i / n), e.push(l.i / n), Uh(t), t = l.next, c = l.next;
                        else if ((t = l) === c) { o ? 1 === o ? xh(t = wh(yh(t), e, n), e, n, i, r, s, 2) : 2 === o && Mh(t, e, n, i, r, s) : xh(yh(t), e, n, i, r, s, 1); break }
                }

                function _h(t) {
                    const e = t.prev,
                        n = t,
                        i = t.next;
                    if (Ph(e, n, i) >= 0) return !1;
                    let r = t.next.next;
                    for (; r !== t.prev;) {
                        if (Rh(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Ph(r.prev, r, r.next) >= 0) return !1;
                        r = r.next
                    }
                    return !0
                }

                function bh(t, e, n, i) {
                    const r = t.prev,
                        s = t,
                        o = t.next;
                    if (Ph(r, s, o) >= 0) return !1;
                    const a = r.x < s.x ? r.x < o.x ? r.x : o.x : s.x < o.x ? s.x : o.x,
                        l = r.y < s.y ? r.y < o.y ? r.y : o.y : s.y < o.y ? s.y : o.y,
                        c = r.x > s.x ? r.x > o.x ? r.x : o.x : s.x > o.x ? s.x : o.x,
                        h = r.y > s.y ? r.y > o.y ? r.y : o.y : s.y > o.y ? s.y : o.y,
                        u = Ah(a, l, e, n, i),
                        d = Ah(c, h, e, n, i);
                    let p = t.prevZ,
                        m = t.nextZ;
                    for (; p && p.z >= u && m && m.z <= d;) {
                        if (p !== t.prev && p !== t.next && Rh(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) && Ph(p.prev, p, p.next) >= 0) return !1;
                        if (p = p.prevZ, m !== t.prev && m !== t.next && Rh(r.x, r.y, s.x, s.y, o.x, o.y, m.x, m.y) && Ph(m.prev, m, m.next) >= 0) return !1;
                        m = m.nextZ
                    }
                    for (; p && p.z >= u;) {
                        if (p !== t.prev && p !== t.next && Rh(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) && Ph(p.prev, p, p.next) >= 0) return !1;
                        p = p.prevZ
                    }
                    for (; m && m.z <= d;) {
                        if (m !== t.prev && m !== t.next && Rh(r.x, r.y, s.x, s.y, o.x, o.y, m.x, m.y) && Ph(m.prev, m, m.next) >= 0) return !1;
                        m = m.nextZ
                    }
                    return !0
                }

                function wh(t, e, n) {
                    let i = t;
                    do {
                        const r = i.prev,
                            s = i.next.next;
                        !Ih(r, s) && Dh(r, i, i.next, s) && Oh(r, s) && Oh(s, r) && (e.push(r.i / n), e.push(i.i / n), e.push(s.i / n), Uh(i), Uh(i.next), i = t = s), i = i.next
                    } while (i !== t);
                    return yh(i)
                }

                function Mh(t, e, n, i, r, s) {
                    let o = t;
                    do {
                        let t = o.next.next;
                        for (; t !== o.prev;) {
                            if (o.i !== t.i && Ch(o, t)) { let a = Fh(o, t); return o = yh(o, o.next), a = yh(a, a.next), xh(o, e, n, i, r, s), void xh(a, e, n, i, r, s) }
                            t = t.next
                        }
                        o = o.next
                    } while (o !== t)
                }

                function Sh(t, e) { return t.x - e.x }

                function Th(t, e) {
                    if (e = function(t, e) {
                            let n = e;
                            const i = t.x,
                                r = t.y;
                            let s, o = -1 / 0;
                            do {
                                if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                                    const t = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                    if (t <= i && t > o) {
                                        if (o = t, t === i) { if (r === n.y) return n; if (r === n.next.y) return n.next }
                                        s = n.x < n.next.x ? n : n.next
                                    }
                                }
                                n = n.next
                            } while (n !== e);
                            if (!s) return null;
                            if (i === o) return s;
                            const a = s,
                                l = s.x,
                                c = s.y;
                            let h, u = 1 / 0;
                            n = s;
                            do { i >= n.x && n.x >= l && i !== n.x && Rh(r < c ? i : o, r, l, c, r < c ? o : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x), Oh(n, t) && (h < u || h === u && (n.x > s.x || n.x === s.x && Eh(s, n))) && (s = n, u = h)), n = n.next } while (n !== a);
                            return s
                        }(t, e), e) {
                        const n = Fh(e, t);
                        yh(e, e.next), yh(n, n.next)
                    }
                }

                function Eh(t, e) { return Ph(t.prev, t, e.prev) < 0 && Ph(e.next, t, t.next) < 0 }

                function Ah(t, e, n, i, r) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 }

                function Lh(t) {
                    let e = t,
                        n = t;
                    do {
                        (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
                    } while (e !== t);
                    return n
                }

                function Rh(t, e, n, i, r, s, o, a) { return (r - o) * (e - a) - (t - o) * (s - a) >= 0 && (t - o) * (i - a) - (n - o) * (e - a) >= 0 && (n - o) * (s - a) - (r - o) * (i - a) >= 0 }

                function Ch(t, e) {
                    return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                        let n = t;
                        do {
                            if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Dh(n, n.next, t, e)) return !0;
                            n = n.next
                        } while (n !== t);
                        return !1
                    }(t, e) && (Oh(t, e) && Oh(e, t) && function(t, e) {
                        let n = t,
                            i = !1;
                        const r = (t.x + e.x) / 2,
                            s = (t.y + e.y) / 2;
                        do { n.y > s != n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next } while (n !== t);
                        return i
                    }(t, e) && (Ph(t.prev, t, e.prev) || Ph(t, e.prev, e)) || Ih(t, e) && Ph(t.prev, t, t.next) > 0 && Ph(e.prev, e, e.next) > 0)
                }

                function Ph(t, e, n) { return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y) }

                function Ih(t, e) { return t.x === e.x && t.y === e.y }

                function Dh(t, e, n, i) {
                    const r = Bh(Ph(t, e, n)),
                        s = Bh(Ph(t, e, i)),
                        o = Bh(Ph(n, i, t)),
                        a = Bh(Ph(n, i, e));
                    return r !== s && o !== a || !(0 !== r || !Nh(t, n, e)) || !(0 !== s || !Nh(t, i, e)) || !(0 !== o || !Nh(n, t, i)) || !(0 !== a || !Nh(n, e, i))
                }

                function Nh(t, e, n) { return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y) }

                function Bh(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 }

                function Oh(t, e) { return Ph(t.prev, t, t.next) < 0 ? Ph(t, e, t.next) >= 0 && Ph(t, t.prev, e) >= 0 : Ph(t, e, t.prev) < 0 || Ph(t, t.next, e) < 0 }

                function Fh(t, e) {
                    const n = new Hh(t.i, t.x, t.y),
                        i = new Hh(e.i, e.x, e.y),
                        r = t.next,
                        s = e.prev;
                    return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, s.next = i, i.prev = s, i
                }

                function zh(t, e, n, i) { const r = new Hh(t, e, n); return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r }

                function Uh(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) }

                function Hh(t, e, n) { this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 }
                class kh {
                    static area(t) { const e = t.length; let n = 0; for (let i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y; return .5 * n }
                    static isClockWise(t) { return kh.area(t) < 0 }
                    static triangulateShape(t, e) {
                        const n = [],
                            i = [],
                            r = [];
                        Gh(t), Vh(n, t);
                        let s = t.length;
                        e.forEach(Gh);
                        for (let t = 0; t < e.length; t++) i.push(s), s += e[t].length, Vh(n, e[t]);
                        const o = function(t, e, n = 2) {
                            const i = e && e.length,
                                r = i ? e[0] * n : t.length;
                            let s = vh(t, 0, r, n, !0);
                            const o = [];
                            if (!s || s.next === s.prev) return o;
                            let a, l, c, h, u, d, p;
                            if (i && (s = function(t, e, n, i) { const r = []; let s, o, a, l, c; for (s = 0, o = e.length; s < o; s++) a = e[s] * i, l = s < o - 1 ? e[s + 1] * i : t.length, c = vh(t, a, l, i, !1), c === c.next && (c.steiner = !0), r.push(Lh(c)); for (r.sort(Sh), s = 0; s < r.length; s++) Th(r[s], n), n = yh(n, n.next); return n }(t, e, s, n)), t.length > 80 * n) {
                                a = c = t[0], l = h = t[1];
                                for (let e = n; e < r; e += n) u = t[e], d = t[e + 1], u < a && (a = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
                                p = Math.max(c - a, h - l), p = 0 !== p ? 1 / p : 0
                            }
                            return xh(s, o, n, a, l, p), o
                        }(n, i);
                        for (let t = 0; t < o.length; t += 3) r.push(o.slice(t, t + 3));
                        return r
                    }
                }

                function Gh(t) {
                    const e = t.length;
                    e > 2 && t[e - 1].equals(t[0]) && t.pop()
                }

                function Vh(t, e) { for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y) }
                class Wh extends is {
                    constructor(t = new gh([new Jn(.5, .5), new Jn(-.5, .5), new Jn(-.5, -.5), new Jn(.5, -.5)]), e = {}) {
                        super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: t, options: e }, t = Array.isArray(t) ? t : [t];
                        const n = this,
                            i = [],
                            r = [];
                        for (let e = 0, n = t.length; e < n; e++) s(t[e]);

                        function s(t) {
                            const s = [],
                                o = void 0 !== e.curveSegments ? e.curveSegments : 12,
                                a = void 0 !== e.steps ? e.steps : 1;
                            let l = void 0 !== e.depth ? e.depth : 1,
                                c = void 0 === e.bevelEnabled || e.bevelEnabled,
                                h = void 0 !== e.bevelThickness ? e.bevelThickness : .2,
                                u = void 0 !== e.bevelSize ? e.bevelSize : h - .1,
                                d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                                p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                            const m = e.extrudePath,
                                f = void 0 !== e.UVGenerator ? e.UVGenerator : jh;
                            void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);
                            let g, v, y, x, _, b = !1;
                            m && (g = m.getSpacedPoints(a), b = !0, c = !1, v = m.computeFrenetFrames(a, !1), y = new pi, x = new pi, _ = new pi), c || (p = 0, h = 0, u = 0, d = 0);
                            const w = t.extractPoints(o);
                            let M = w.shape;
                            const S = w.holes;
                            if (!kh.isClockWise(M)) {
                                M = M.reverse();
                                for (let t = 0, e = S.length; t < e; t++) {
                                    const e = S[t];
                                    kh.isClockWise(e) && (S[t] = e.reverse())
                                }
                            }
                            const T = kh.triangulateShape(M, S),
                                E = M;
                            for (let t = 0, e = S.length; t < e; t++) {
                                const e = S[t];
                                M = M.concat(e)
                            }

                            function A(t, e, n) { return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t) }
                            const L = M.length,
                                R = T.length;

                            function C(t, e, n) {
                                let i, r, s;
                                const o = t.x - e.x,
                                    a = t.y - e.y,
                                    l = n.x - t.x,
                                    c = n.y - t.y,
                                    h = o * o + a * a,
                                    u = o * c - a * l;
                                if (Math.abs(u) > Number.EPSILON) {
                                    const u = Math.sqrt(h),
                                        d = Math.sqrt(l * l + c * c),
                                        p = e.x - a / u,
                                        m = e.y + o / u,
                                        f = ((n.x - c / d - p) * c - (n.y + l / d - m) * l) / (o * c - a * l);
                                    i = p + o * f - t.x, r = m + a * f - t.y;
                                    const g = i * i + r * r;
                                    if (g <= 2) return new Jn(i, r);
                                    s = Math.sqrt(g / 2)
                                } else {
                                    let t = !1;
                                    o > Number.EPSILON ? l > Number.EPSILON && (t = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(c) && (t = !0), t ? (i = -a, r = o, s = Math.sqrt(h)) : (i = o, r = a, s = Math.sqrt(h / 2))
                                }
                                return new Jn(i / s, r / s)
                            }
                            const P = [];
                            for (let t = 0, e = E.length, n = e - 1, i = t + 1; t < e; t++, n++, i++) n === e && (n = 0), i === e && (i = 0), P[t] = C(E[t], E[n], E[i]);
                            const I = [];
                            let D, N = P.concat();
                            for (let t = 0, e = S.length; t < e; t++) {
                                const e = S[t];
                                D = [];
                                for (let t = 0, n = e.length, i = n - 1, r = t + 1; t < n; t++, i++, r++) i === n && (i = 0), r === n && (r = 0), D[t] = C(e[t], e[i], e[r]);
                                I.push(D), N = N.concat(D)
                            }
                            for (let t = 0; t < p; t++) {
                                const e = t / p,
                                    n = h * Math.cos(e * Math.PI / 2),
                                    i = u * Math.sin(e * Math.PI / 2) + d;
                                for (let t = 0, e = E.length; t < e; t++) {
                                    const e = A(E[t], P[t], i);
                                    F(e.x, e.y, -n)
                                }
                                for (let t = 0, e = S.length; t < e; t++) {
                                    const e = S[t];
                                    D = I[t];
                                    for (let t = 0, r = e.length; t < r; t++) {
                                        const r = A(e[t], D[t], i);
                                        F(r.x, r.y, -n)
                                    }
                                }
                            }
                            const B = u + d;
                            for (let t = 0; t < L; t++) {
                                const e = c ? A(M[t], N[t], B) : M[t];
                                b ? (x.copy(v.normals[0]).multiplyScalar(e.x), y.copy(v.binormals[0]).multiplyScalar(e.y), _.copy(g[0]).add(x).add(y), F(_.x, _.y, _.z)) : F(e.x, e.y, 0)
                            }
                            for (let t = 1; t <= a; t++)
                                for (let e = 0; e < L; e++) {
                                    const n = c ? A(M[e], N[e], B) : M[e];
                                    b ? (x.copy(v.normals[t]).multiplyScalar(n.x), y.copy(v.binormals[t]).multiplyScalar(n.y), _.copy(g[t]).add(x).add(y), F(_.x, _.y, _.z)) : F(n.x, n.y, l / a * t)
                                }
                            for (let t = p - 1; t >= 0; t--) {
                                const e = t / p,
                                    n = h * Math.cos(e * Math.PI / 2),
                                    i = u * Math.sin(e * Math.PI / 2) + d;
                                for (let t = 0, e = E.length; t < e; t++) {
                                    const e = A(E[t], P[t], i);
                                    F(e.x, e.y, l + n)
                                }
                                for (let t = 0, e = S.length; t < e; t++) {
                                    const e = S[t];
                                    D = I[t];
                                    for (let t = 0, r = e.length; t < r; t++) {
                                        const r = A(e[t], D[t], i);
                                        b ? F(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : F(r.x, r.y, l + n)
                                    }
                                }
                            }

                            function O(t, e) {
                                let n = t.length;
                                for (; --n >= 0;) {
                                    const i = n;
                                    let r = n - 1;
                                    r < 0 && (r = t.length - 1);
                                    for (let t = 0, n = a + 2 * p; t < n; t++) {
                                        const n = L * t,
                                            s = L * (t + 1);
                                        U(e + i + n, e + r + n, e + r + s, e + i + s)
                                    }
                                }
                            }

                            function F(t, e, n) { s.push(t), s.push(e), s.push(n) }

                            function z(t, e, r) {
                                H(t), H(e), H(r);
                                const s = i.length / 3,
                                    o = f.generateTopUV(n, i, s - 3, s - 2, s - 1);
                                k(o[0]), k(o[1]), k(o[2])
                            }

                            function U(t, e, r, s) {
                                H(t), H(e), H(s), H(e), H(r), H(s);
                                const o = i.length / 3,
                                    a = f.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1);
                                k(a[0]), k(a[1]), k(a[3]), k(a[1]), k(a[2]), k(a[3])
                            }

                            function H(t) { i.push(s[3 * t + 0]), i.push(s[3 * t + 1]), i.push(s[3 * t + 2]) }

                            function k(t) { r.push(t.x), r.push(t.y) }! function() {
                                const t = i.length / 3;
                                if (c) {
                                    let t = 0,
                                        e = L * t;
                                    for (let t = 0; t < R; t++) {
                                        const n = T[t];
                                        z(n[2] + e, n[1] + e, n[0] + e)
                                    }
                                    t = a + 2 * p, e = L * t;
                                    for (let t = 0; t < R; t++) {
                                        const n = T[t];
                                        z(n[0] + e, n[1] + e, n[2] + e)
                                    }
                                } else {
                                    for (let t = 0; t < R; t++) {
                                        const e = T[t];
                                        z(e[2], e[1], e[0])
                                    }
                                    for (let t = 0; t < R; t++) {
                                        const e = T[t];
                                        z(e[0] + L * a, e[1] + L * a, e[2] + L * a)
                                    }
                                }
                                n.addGroup(t, i.length / 3 - t, 0)
                            }(),
                            function() {
                                const t = i.length / 3;
                                let e = 0;
                                O(E, e), e += E.length;
                                for (let t = 0, n = S.length; t < n; t++) {
                                    const n = S[t];
                                    O(n, e), e += n.length
                                }
                                n.addGroup(t, i.length / 3 - t, 1)
                            }()
                        }
                        this.setAttribute("position", new Yr(i, 3)), this.setAttribute("uv", new Yr(r, 2)), this.computeVertexNormals()
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return function(t, e, n) {
                            if (n.shapes = [], Array.isArray(t))
                                for (let e = 0, i = t.length; e < i; e++) {
                                    const i = t[e];
                                    n.shapes.push(i.uuid)
                                } else n.shapes.push(t.uuid);
                            return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
                        }(this.parameters.shapes, this.parameters.options, t)
                    }
                    static fromJSON(t, e) {
                        const n = [];
                        for (let i = 0, r = t.shapes.length; i < r; i++) {
                            const r = e[t.shapes[i]];
                            n.push(r)
                        }
                        const i = t.options.extrudePath;
                        return void 0 !== i && (t.options.extrudePath = (new ph[i.type]).fromJSON(i)), new Wh(n, t.options)
                    }
                }
                const jh = {
                    generateTopUV: function(t, e, n, i, r) {
                        const s = e[3 * n],
                            o = e[3 * n + 1],
                            a = e[3 * i],
                            l = e[3 * i + 1],
                            c = e[3 * r],
                            h = e[3 * r + 1];
                        return [new Jn(s, o), new Jn(a, l), new Jn(c, h)]
                    },
                    generateSideWallUV: function(t, e, n, i, r, s) {
                        const o = e[3 * n],
                            a = e[3 * n + 1],
                            l = e[3 * n + 2],
                            c = e[3 * i],
                            h = e[3 * i + 1],
                            u = e[3 * i + 2],
                            d = e[3 * r],
                            p = e[3 * r + 1],
                            m = e[3 * r + 2],
                            f = e[3 * s],
                            g = e[3 * s + 1],
                            v = e[3 * s + 2];
                        return Math.abs(a - h) < Math.abs(o - c) ? [new Jn(o, 1 - l), new Jn(c, 1 - u), new Jn(d, 1 - m), new Jn(f, 1 - v)] : [new Jn(a, 1 - l), new Jn(h, 1 - u), new Jn(p, 1 - m), new Jn(g, 1 - v)]
                    }
                };
                class qh extends kc {
                    constructor(t = 1, e = 0) {
                        const n = (1 + Math.sqrt(5)) / 2;
                        super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronGeometry", this.parameters = { radius: t, detail: e }
                    }
                    static fromJSON(t) { return new qh(t.radius, t.detail) }
                }
                class Xh extends is {
                    constructor(t = [new Jn(0, .5), new Jn(.5, 0), new Jn(0, -.5)], e = 12, n = 0, i = 2 * Math.PI) {
                        super(), this.type = "LatheGeometry", this.parameters = { points: t, segments: e, phiStart: n, phiLength: i }, e = Math.floor(e), i = Vn(i, 0, 2 * Math.PI);
                        const r = [],
                            s = [],
                            o = [],
                            a = 1 / e,
                            l = new pi,
                            c = new Jn;
                        for (let r = 0; r <= e; r++) {
                            const h = n + r * a * i,
                                u = Math.sin(h),
                                d = Math.cos(h);
                            for (let n = 0; n <= t.length - 1; n++) l.x = t[n].x * u, l.y = t[n].y, l.z = t[n].x * d, s.push(l.x, l.y, l.z), c.x = r / e, c.y = n / (t.length - 1), o.push(c.x, c.y)
                        }
                        for (let n = 0; n < e; n++)
                            for (let e = 0; e < t.length - 1; e++) {
                                const i = e + n * t.length,
                                    s = i,
                                    o = i + t.length,
                                    a = i + t.length + 1,
                                    l = i + 1;
                                r.push(s, o, l), r.push(o, a, l)
                            }
                        if (this.setIndex(r), this.setAttribute("position", new Yr(s, 3)), this.setAttribute("uv", new Yr(o, 2)), this.computeVertexNormals(), i === 2 * Math.PI) {
                            const n = this.attributes.normal.array,
                                i = new pi,
                                r = new pi,
                                s = new pi,
                                o = e * t.length * 3;
                            for (let e = 0, a = 0; e < t.length; e++, a += 3) i.x = n[a + 0], i.y = n[a + 1], i.z = n[a + 2], r.x = n[o + a + 0], r.y = n[o + a + 1], r.z = n[o + a + 2], s.addVectors(i, r).normalize(), n[a + 0] = n[o + a + 0] = s.x, n[a + 1] = n[o + a + 1] = s.y, n[a + 2] = n[o + a + 2] = s.z
                        }
                    }
                    static fromJSON(t) { return new Xh(t.points, t.segments, t.phiStart, t.phiLength) }
                }
                class Yh extends kc {
                    constructor(t = 1, e = 0) { super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronGeometry", this.parameters = { radius: t, detail: e } }
                    static fromJSON(t) { return new Yh(t.radius, t.detail) }
                }
                class Zh extends is {
                    constructor(t = .5, e = 1, n = 8, i = 1, r = 0, s = 2 * Math.PI) {
                        super(), this.type = "RingGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: n, phiSegments: i, thetaStart: r, thetaLength: s }, n = Math.max(3, n);
                        const o = [],
                            a = [],
                            l = [],
                            c = [];
                        let h = t;
                        const u = (e - t) / (i = Math.max(1, i)),
                            d = new pi,
                            p = new Jn;
                        for (let t = 0; t <= i; t++) {
                            for (let t = 0; t <= n; t++) {
                                const i = r + t / n * s;
                                d.x = h * Math.cos(i), d.y = h * Math.sin(i), a.push(d.x, d.y, d.z), l.push(0, 0, 1), p.x = (d.x / e + 1) / 2, p.y = (d.y / e + 1) / 2, c.push(p.x, p.y)
                            }
                            h += u
                        }
                        for (let t = 0; t < i; t++) {
                            const e = t * (n + 1);
                            for (let t = 0; t < n; t++) {
                                const i = t + e,
                                    r = i,
                                    s = i + n + 1,
                                    a = i + n + 2,
                                    l = i + 1;
                                o.push(r, s, l), o.push(s, a, l)
                            }
                        }
                        this.setIndex(o), this.setAttribute("position", new Yr(a, 3)), this.setAttribute("normal", new Yr(l, 3)), this.setAttribute("uv", new Yr(c, 2))
                    }
                    static fromJSON(t) { return new Zh(t.innerRadius, t.outerRadius, t.thetaSegments, t.phiSegments, t.thetaStart, t.thetaLength) }
                }
                class Jh extends is {
                    constructor(t = new gh([new Jn(0, .5), new Jn(-.5, -.5), new Jn(.5, -.5)]), e = 12) {
                        super(), this.type = "ShapeGeometry", this.parameters = { shapes: t, curveSegments: e };
                        const n = [],
                            i = [],
                            r = [],
                            s = [];
                        let o = 0,
                            a = 0;
                        if (!1 === Array.isArray(t)) l(t);
                        else
                            for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(o, a, e), o += a, a = 0;

                        function l(t) {
                            const o = i.length / 3,
                                l = t.extractPoints(e);
                            let c = l.shape;
                            const h = l.holes;
                            !1 === kh.isClockWise(c) && (c = c.reverse());
                            for (let t = 0, e = h.length; t < e; t++) { const e = h[t];!0 === kh.isClockWise(e) && (h[t] = e.reverse()) }
                            const u = kh.triangulateShape(c, h);
                            for (let t = 0, e = h.length; t < e; t++) {
                                const e = h[t];
                                c = c.concat(e)
                            }
                            for (let t = 0, e = c.length; t < e; t++) {
                                const e = c[t];
                                i.push(e.x, e.y, 0), r.push(0, 0, 1), s.push(e.x, e.y)
                            }
                            for (let t = 0, e = u.length; t < e; t++) {
                                const e = u[t],
                                    i = e[0] + o,
                                    r = e[1] + o,
                                    s = e[2] + o;
                                n.push(i, r, s), a += 3
                            }
                        }
                        this.setIndex(n), this.setAttribute("position", new Yr(i, 3)), this.setAttribute("normal", new Yr(r, 3)), this.setAttribute("uv", new Yr(s, 2))
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return function(t, e) {
                            if (e.shapes = [], Array.isArray(t))
                                for (let n = 0, i = t.length; n < i; n++) {
                                    const i = t[n];
                                    e.shapes.push(i.uuid)
                                } else e.shapes.push(t.uuid);
                            return e
                        }(this.parameters.shapes, t)
                    }
                    static fromJSON(t, e) {
                        const n = [];
                        for (let i = 0, r = t.shapes.length; i < r; i++) {
                            const r = e[t.shapes[i]];
                            n.push(r)
                        }
                        return new Jh(n, t.curveSegments)
                    }
                }
                class Kh extends is {
                    constructor(t = 1, e = 32, n = 16, i = 0, r = 2 * Math.PI, s = 0, o = Math.PI) {
                        super(), this.type = "SphereGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: i, phiLength: r, thetaStart: s, thetaLength: o }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n));
                        const a = Math.min(s + o, Math.PI);
                        let l = 0;
                        const c = [],
                            h = new pi,
                            u = new pi,
                            d = [],
                            p = [],
                            m = [],
                            f = [];
                        for (let d = 0; d <= n; d++) {
                            const g = [],
                                v = d / n;
                            let y = 0;
                            0 == d && 0 == s ? y = .5 / e : d == n && a == Math.PI && (y = -.5 / e);
                            for (let n = 0; n <= e; n++) {
                                const a = n / e;
                                h.x = -t * Math.cos(i + a * r) * Math.sin(s + v * o), h.y = t * Math.cos(s + v * o), h.z = t * Math.sin(i + a * r) * Math.sin(s + v * o), p.push(h.x, h.y, h.z), u.copy(h).normalize(), m.push(u.x, u.y, u.z), f.push(a + y, 1 - v), g.push(l++)
                            }
                            c.push(g)
                        }
                        for (let t = 0; t < n; t++)
                            for (let i = 0; i < e; i++) {
                                const e = c[t][i + 1],
                                    r = c[t][i],
                                    o = c[t + 1][i],
                                    l = c[t + 1][i + 1];
                                (0 !== t || s > 0) && d.push(e, r, l), (t !== n - 1 || a < Math.PI) && d.push(r, o, l)
                            }
                        this.setIndex(d), this.setAttribute("position", new Yr(p, 3)), this.setAttribute("normal", new Yr(m, 3)), this.setAttribute("uv", new Yr(f, 2))
                    }
                    static fromJSON(t) { return new Kh(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength) }
                }
                class Qh extends kc {
                    constructor(t = 1, e = 0) { super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronGeometry", this.parameters = { radius: t, detail: e } }
                    static fromJSON(t) { return new Qh(t.radius, t.detail) }
                }
                class $h extends is {
                    constructor(t = 1, e = .4, n = 8, i = 6, r = 2 * Math.PI) {
                        super(), this.type = "TorusGeometry", this.parameters = { radius: t, tube: e, radialSegments: n, tubularSegments: i, arc: r }, n = Math.floor(n), i = Math.floor(i);
                        const s = [],
                            o = [],
                            a = [],
                            l = [],
                            c = new pi,
                            h = new pi,
                            u = new pi;
                        for (let s = 0; s <= n; s++)
                            for (let d = 0; d <= i; d++) {
                                const p = d / i * r,
                                    m = s / n * Math.PI * 2;
                                h.x = (t + e * Math.cos(m)) * Math.cos(p), h.y = (t + e * Math.cos(m)) * Math.sin(p), h.z = e * Math.sin(m), o.push(h.x, h.y, h.z), c.x = t * Math.cos(p), c.y = t * Math.sin(p), u.subVectors(h, c).normalize(), a.push(u.x, u.y, u.z), l.push(d / i), l.push(s / n)
                            }
                        for (let t = 1; t <= n; t++)
                            for (let e = 1; e <= i; e++) {
                                const n = (i + 1) * t + e - 1,
                                    r = (i + 1) * (t - 1) + e - 1,
                                    o = (i + 1) * (t - 1) + e,
                                    a = (i + 1) * t + e;
                                s.push(n, r, a), s.push(r, o, a)
                            }
                        this.setIndex(s), this.setAttribute("position", new Yr(o, 3)), this.setAttribute("normal", new Yr(a, 3)), this.setAttribute("uv", new Yr(l, 2))
                    }
                    static fromJSON(t) { return new $h(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc) }
                }
                class tu extends is {
                    constructor(t = 1, e = .4, n = 64, i = 8, r = 2, s = 3) {
                        super(), this.type = "TorusKnotGeometry", this.parameters = { radius: t, tube: e, tubularSegments: n, radialSegments: i, p: r, q: s }, n = Math.floor(n), i = Math.floor(i);
                        const o = [],
                            a = [],
                            l = [],
                            c = [],
                            h = new pi,
                            u = new pi,
                            d = new pi,
                            p = new pi,
                            m = new pi,
                            f = new pi,
                            g = new pi;
                        for (let o = 0; o <= n; ++o) {
                            const y = o / n * r * Math.PI * 2;
                            v(y, r, s, t, d), v(y + .01, r, s, t, p), f.subVectors(p, d), g.addVectors(p, d), m.crossVectors(f, g), g.crossVectors(m, f), m.normalize(), g.normalize();
                            for (let t = 0; t <= i; ++t) {
                                const r = t / i * Math.PI * 2,
                                    s = -e * Math.cos(r),
                                    p = e * Math.sin(r);
                                h.x = d.x + (s * g.x + p * m.x), h.y = d.y + (s * g.y + p * m.y), h.z = d.z + (s * g.z + p * m.z), a.push(h.x, h.y, h.z), u.subVectors(h, d).normalize(), l.push(u.x, u.y, u.z), c.push(o / n), c.push(t / i)
                            }
                        }
                        for (let t = 1; t <= n; t++)
                            for (let e = 1; e <= i; e++) {
                                const n = (i + 1) * (t - 1) + (e - 1),
                                    r = (i + 1) * t + (e - 1),
                                    s = (i + 1) * t + e,
                                    a = (i + 1) * (t - 1) + e;
                                o.push(n, r, a), o.push(r, s, a)
                            }

                        function v(t, e, n, i, r) {
                            const s = Math.cos(t),
                                o = Math.sin(t),
                                a = n / e * t,
                                l = Math.cos(a);
                            r.x = i * (2 + l) * .5 * s, r.y = i * (2 + l) * o * .5, r.z = i * Math.sin(a) * .5
                        }
                        this.setIndex(o), this.setAttribute("position", new Yr(a, 3)), this.setAttribute("normal", new Yr(l, 3)), this.setAttribute("uv", new Yr(c, 2))
                    }
                    static fromJSON(t) { return new tu(t.radius, t.tube, t.tubularSegments, t.radialSegments, t.p, t.q) }
                }
                class eu extends is {
                    constructor(t = new uh(new pi(-1, -1, 0), new pi(-1, 1, 0), new pi(1, 1, 0)), e = 64, n = 1, i = 8, r = !1) {
                        super(), this.type = "TubeGeometry", this.parameters = { path: t, tubularSegments: e, radius: n, radialSegments: i, closed: r };
                        const s = t.computeFrenetFrames(e, r);
                        this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals;
                        const o = new pi,
                            a = new pi,
                            l = new Jn;
                        let c = new pi;
                        const h = [],
                            u = [],
                            d = [],
                            p = [];

                        function m(r) {
                            c = t.getPointAt(r / e, c);
                            const l = s.normals[r],
                                d = s.binormals[r];
                            for (let t = 0; t <= i; t++) {
                                const e = t / i * Math.PI * 2,
                                    r = Math.sin(e),
                                    s = -Math.cos(e);
                                a.x = s * l.x + r * d.x, a.y = s * l.y + r * d.y, a.z = s * l.z + r * d.z, a.normalize(), u.push(a.x, a.y, a.z), o.x = c.x + n * a.x, o.y = c.y + n * a.y, o.z = c.z + n * a.z, h.push(o.x, o.y, o.z)
                            }
                        }! function() {
                            for (let t = 0; t < e; t++) m(t);
                            m(!1 === r ? e : 0),
                                function() {
                                    for (let t = 0; t <= e; t++)
                                        for (let n = 0; n <= i; n++) l.x = t / e, l.y = n / i, d.push(l.x, l.y)
                                }(),
                                function() {
                                    for (let t = 1; t <= e; t++)
                                        for (let e = 1; e <= i; e++) {
                                            const n = (i + 1) * (t - 1) + (e - 1),
                                                r = (i + 1) * t + (e - 1),
                                                s = (i + 1) * t + e,
                                                o = (i + 1) * (t - 1) + e;
                                            p.push(n, r, o), p.push(r, s, o)
                                        }
                                }()
                        }(), this.setIndex(p), this.setAttribute("position", new Yr(h, 3)), this.setAttribute("normal", new Yr(u, 3)), this.setAttribute("uv", new Yr(d, 2))
                    }
                    toJSON() { const t = super.toJSON(); return t.path = this.parameters.path.toJSON(), t }
                    static fromJSON(t) { return new eu((new ph[t.path.type]).fromJSON(t.path), t.tubularSegments, t.radius, t.radialSegments, t.closed) }
                }
                class nu extends is {
                    constructor(t = null) {
                        if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: t }, null !== t) {
                            const e = [],
                                n = new Set,
                                i = new pi,
                                r = new pi;
                            if (null !== t.index) {
                                const s = t.attributes.position,
                                    o = t.index;
                                let a = t.groups;
                                0 === a.length && (a = [{ start: 0, count: o.count, materialIndex: 0 }]);
                                for (let t = 0, l = a.length; t < l; ++t) {
                                    const l = a[t],
                                        c = l.start;
                                    for (let t = c, a = c + l.count; t < a; t += 3)
                                        for (let a = 0; a < 3; a++) {
                                            const l = o.getX(t + a),
                                                c = o.getX(t + (a + 1) % 3);
                                            i.fromBufferAttribute(s, l), r.fromBufferAttribute(s, c), !0 === iu(i, r, n) && (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z))
                                        }
                                }
                            } else {
                                const s = t.attributes.position;
                                for (let t = 0, o = s.count / 3; t < o; t++)
                                    for (let o = 0; o < 3; o++) {
                                        const a = 3 * t + o,
                                            l = 3 * t + (o + 1) % 3;
                                        i.fromBufferAttribute(s, a), r.fromBufferAttribute(s, l), !0 === iu(i, r, n) && (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z))
                                    }
                            }
                            this.setAttribute("position", new Yr(e, 3))
                        }
                    }
                }

                function iu(t, e, n) {
                    const i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
                        r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
                    return !0 !== n.has(i) && !0 !== n.has(r) && (n.add(i, r), !0)
                }
                var ru = Object.freeze({ __proto__: null, BoxGeometry: Ms, BoxBufferGeometry: Ms, CircleGeometry: zc, CircleBufferGeometry: zc, ConeGeometry: Hc, ConeBufferGeometry: Hc, CylinderGeometry: Uc, CylinderBufferGeometry: Uc, DodecahedronGeometry: Gc, DodecahedronBufferGeometry: Gc, EdgesGeometry: Xc, ExtrudeGeometry: Wh, ExtrudeBufferGeometry: Wh, IcosahedronGeometry: qh, IcosahedronBufferGeometry: qh, LatheGeometry: Xh, LatheBufferGeometry: Xh, OctahedronGeometry: Yh, OctahedronBufferGeometry: Yh, PlaneGeometry: Vs, PlaneBufferGeometry: Vs, PolyhedronGeometry: kc, PolyhedronBufferGeometry: kc, RingGeometry: Zh, RingBufferGeometry: Zh, ShapeGeometry: Jh, ShapeBufferGeometry: Jh, SphereGeometry: Kh, SphereBufferGeometry: Kh, TetrahedronGeometry: Qh, TetrahedronBufferGeometry: Qh, TorusGeometry: $h, TorusBufferGeometry: $h, TorusKnotGeometry: tu, TorusKnotBufferGeometry: tu, TubeGeometry: eu, TubeBufferGeometry: eu, WireframeGeometry: nu });
                class su extends Lr {
                    constructor(t) { super(), this.type = "ShadowMaterial", this.color = new Br(0), this.transparent = !0, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this }
                }
                su.prototype.isShadowMaterial = !0;
                class ou extends Lr {
                    constructor(t) { super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Br(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Br(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = an, this.normalScale = new Jn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this }
                }
                ou.prototype.isMeshStandardMaterial = !0;
                class au extends ou {
                    constructor(t) { super(), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Jn(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() { return Vn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1) }, set: function(t) { this.ior = (1 + .4 * t) / (1 - .4 * t) } }), this.sheenColor = new Br(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = .01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Br(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Br(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(t) }
                    get sheen() { return this._sheen }
                    set sheen(t) { this._sheen > 0 != t > 0 && this.version++, this._sheen = t }
                    get clearcoat() { return this._clearcoat }
                    set clearcoat(t) { this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t }
                    get transmission() { return this._transmission }
                    set transmission(t) { this._transmission > 0 != t > 0 && this.version++, this._transmission = t }
                    copy(t) { return super.copy(t), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this }
                }
                au.prototype.isMeshPhysicalMaterial = !0;
                class lu extends Lr {
                    constructor(t) { super(), this.type = "MeshPhongMaterial", this.color = new Br(16777215), this.specular = new Br(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Br(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = an, this.normalScale = new Jn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Z, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this }
                }
                lu.prototype.isMeshPhongMaterial = !0;
                class cu extends Lr {
                    constructor(t) { super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Br(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Br(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = an, this.normalScale = new Jn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this }
                }
                cu.prototype.isMeshToonMaterial = !0;
                class hu extends Lr {
                    constructor(t) { super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = an, this.normalScale = new Jn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this }
                }
                hu.prototype.isMeshNormalMaterial = !0;
                class uu extends Lr {
                    constructor(t) { super(), this.type = "MeshLambertMaterial", this.color = new Br(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Br(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Z, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t) }
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this }
                }
                uu.prototype.isMeshLambertMaterial = !0;
                class du extends Lr {
                    constructor(t) { super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Br(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = an, this.normalScale = new Jn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this }
                }
                du.prototype.isMeshMatcapMaterial = !0;
                class pu extends gc {
                    constructor(t) { super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t) }
                    copy(t) { return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this }
                }
                pu.prototype.isLineDashedMaterial = !0;
                var mu = Object.freeze({ __proto__: null, ShadowMaterial: su, SpriteMaterial: Nl, RawShaderMaterial: to, ShaderMaterial: As, PointsMaterial: Ac, MeshPhysicalMaterial: au, MeshStandardMaterial: ou, MeshPhongMaterial: lu, MeshToonMaterial: cu, MeshNormalMaterial: hu, MeshLambertMaterial: uu, MeshDepthMaterial: ml, MeshDistanceMaterial: fl, MeshBasicMaterial: Or, MeshMatcapMaterial: du, LineDashedMaterial: pu, LineBasicMaterial: gc, Material: Lr });
                const fu = {
                    arraySlice: function(t, e, n) { return fu.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n) },
                    convertArray: function(t, e, n) { return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t) },
                    isTypedArray: function(t) { return ArrayBuffer.isView(t) && !(t instanceof DataView) },
                    getKeyframeOrder: function(t) {
                        const e = t.length,
                            n = new Array(e);
                        for (let t = 0; t !== e; ++t) n[t] = t;
                        return n.sort((function(e, n) { return t[e] - t[n] })), n
                    },
                    sortedArray: function(t, e, n) {
                        const i = t.length,
                            r = new t.constructor(i);
                        for (let s = 0, o = 0; o !== i; ++s) { const i = n[s] * e; for (let n = 0; n !== e; ++n) r[o++] = t[i + n] }
                        return r
                    },
                    flattenJSON: function(t, e, n, i) {
                        let r = 1,
                            s = t[0];
                        for (; void 0 !== s && void 0 === s[i];) s = t[r++];
                        if (void 0 === s) return;
                        let o = s[i];
                        if (void 0 !== o)
                            if (Array.isArray(o))
                                do { o = s[i], void 0 !== o && (e.push(s.time), n.push.apply(n, o)), s = t[r++] } while (void 0 !== s);
                            else if (void 0 !== o.toArray)
                            do { o = s[i], void 0 !== o && (e.push(s.time), o.toArray(n, n.length)), s = t[r++] } while (void 0 !== s);
                        else
                            do { o = s[i], void 0 !== o && (e.push(s.time), n.push(o)), s = t[r++] } while (void 0 !== s)
                    },
                    subclip: function(t, e, n, i, r = 30) {
                        const s = t.clone();
                        s.name = e;
                        const o = [];
                        for (let t = 0; t < s.tracks.length; ++t) {
                            const e = s.tracks[t],
                                a = e.getValueSize(),
                                l = [],
                                c = [];
                            for (let t = 0; t < e.times.length; ++t) { const s = e.times[t] * r; if (!(s < n || s >= i)) { l.push(e.times[t]); for (let n = 0; n < a; ++n) c.push(e.values[t * a + n]) } }
                            0 !== l.length && (e.times = fu.convertArray(l, e.times.constructor), e.values = fu.convertArray(c, e.values.constructor), o.push(e))
                        }
                        s.tracks = o;
                        let a = 1 / 0;
                        for (let t = 0; t < s.tracks.length; ++t) a > s.tracks[t].times[0] && (a = s.tracks[t].times[0]);
                        for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * a);
                        return s.resetDuration(), s
                    },
                    makeClipAdditive: function(t, e = 0, n = t, i = 30) {
                        i <= 0 && (i = 30);
                        const r = n.tracks.length,
                            s = e / i;
                        for (let e = 0; e < r; ++e) {
                            const i = n.tracks[e],
                                r = i.ValueTypeName;
                            if ("bool" === r || "string" === r) continue;
                            const o = t.tracks.find((function(t) { return t.name === i.name && t.ValueTypeName === r }));
                            if (void 0 === o) continue;
                            let a = 0;
                            const l = i.getValueSize();
                            i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
                            let c = 0;
                            const h = o.getValueSize();
                            o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
                            const u = i.times.length - 1;
                            let d;
                            if (s <= i.times[0]) {
                                const t = a,
                                    e = l - a;
                                d = fu.arraySlice(i.values, t, e)
                            } else if (s >= i.times[u]) {
                                const t = u * l + a,
                                    e = t + l - a;
                                d = fu.arraySlice(i.values, t, e)
                            } else {
                                const t = i.createInterpolant(),
                                    e = a,
                                    n = l - a;
                                t.evaluate(s), d = fu.arraySlice(t.resultBuffer, e, n)
                            }
                            "quaternion" === r && (new di).fromArray(d).normalize().conjugate().toArray(d);
                            const p = o.times.length;
                            for (let t = 0; t < p; ++t) {
                                const e = t * h + c;
                                if ("quaternion" === r) di.multiplyQuaternionsFlat(o.values, e, d, 0, o.values, e);
                                else { const t = h - 2 * c; for (let n = 0; n < t; ++n) o.values[e + n] -= d[n] }
                            }
                        }
                        return t.blendMode = qe, t
                    }
                };
                class gu {
                    constructor(t, e, n, i) { this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {} }
                    evaluate(t) {
                        const e = this.parameterPositions;
                        let n = this._cachedIndex,
                            i = e[n],
                            r = e[n - 1];
                        t: {
                            e: {
                                let s;n: {
                                    i: if (!(t < i)) {
                                        for (let s = n + 2;;) { if (void 0 === i) { if (t < r) break i; return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r) } if (n === s) break; if (r = i, i = e[++n], t < i) break e }
                                        s = e.length;
                                        break n
                                    }if (t >= r) break t; {
                                        const o = e[1];
                                        t < o && (n = 2, r = o);
                                        for (let s = n - 2;;) { if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i); if (n === s) break; if (i = r, r = e[--n - 1], t >= r) break e }
                                        s = n, n = 0
                                    }
                                }
                                for (; n < s;) {
                                    const i = n + s >>> 1;
                                    t < e[i] ? s = i : n = i + 1
                                }
                                if (i = e[n], r = e[n - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                                if (void 0 === i) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, t)
                            }
                            this._cachedIndex = n,
                            this.intervalChanged_(n, r, i)
                        }
                        return this.interpolate_(n, r, t, i)
                    }
                    getSettings_() { return this.settings || this.DefaultSettings_ }
                    copySampleValue_(t) {
                        const e = this.resultBuffer,
                            n = this.sampleValues,
                            i = this.valueSize,
                            r = t * i;
                        for (let t = 0; t !== i; ++t) e[t] = n[r + t];
                        return e
                    }
                    interpolate_() { throw new Error("call to abstract method") }
                    intervalChanged_() {}
                }
                gu.prototype.beforeStart_ = gu.prototype.copySampleValue_, gu.prototype.afterEnd_ = gu.prototype.copySampleValue_;
                class vu extends gu {
                    constructor(t, e, n, i) { super(t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: Ge, endingEnd: Ge } }
                    intervalChanged_(t, e, n) {
                        const i = this.parameterPositions;
                        let r = t - 2,
                            s = t + 1,
                            o = i[r],
                            a = i[s];
                        if (void 0 === o) switch (this.getSettings_().endingStart) {
                            case Ve:
                                r = t, o = 2 * e - n;
                                break;
                            case We:
                                r = i.length - 2, o = e + i[r] - i[r + 1];
                                break;
                            default:
                                r = t, o = n
                        }
                        if (void 0 === a) switch (this.getSettings_().endingEnd) {
                            case Ve:
                                s = t, a = 2 * n - e;
                                break;
                            case We:
                                s = 1, a = n + i[1] - i[0];
                                break;
                            default:
                                s = t - 1, a = e
                        }
                        const l = .5 * (n - e),
                            c = this.valueSize;
                        this._weightPrev = l / (e - o), this._weightNext = l / (a - n), this._offsetPrev = r * c, this._offsetNext = s * c
                    }
                    interpolate_(t, e, n, i) {
                        const r = this.resultBuffer,
                            s = this.sampleValues,
                            o = this.valueSize,
                            a = t * o,
                            l = a - o,
                            c = this._offsetPrev,
                            h = this._offsetNext,
                            u = this._weightPrev,
                            d = this._weightNext,
                            p = (n - e) / (i - e),
                            m = p * p,
                            f = m * p,
                            g = -u * f + 2 * u * m - u * p,
                            v = (1 + u) * f + (-1.5 - 2 * u) * m + (-.5 + u) * p + 1,
                            y = (-1 - d) * f + (1.5 + d) * m + .5 * p,
                            x = d * f - d * m;
                        for (let t = 0; t !== o; ++t) r[t] = g * s[c + t] + v * s[l + t] + y * s[a + t] + x * s[h + t];
                        return r
                    }
                }
                class yu extends gu {
                    constructor(t, e, n, i) { super(t, e, n, i) }
                    interpolate_(t, e, n, i) {
                        const r = this.resultBuffer,
                            s = this.sampleValues,
                            o = this.valueSize,
                            a = t * o,
                            l = a - o,
                            c = (n - e) / (i - e),
                            h = 1 - c;
                        for (let t = 0; t !== o; ++t) r[t] = s[l + t] * h + s[a + t] * c;
                        return r
                    }
                }
                class xu extends gu {
                    constructor(t, e, n, i) { super(t, e, n, i) }
                    interpolate_(t) { return this.copySampleValue_(t - 1) }
                }
                class _u {
                    constructor(t, e, n, i) {
                        if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                        if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                        this.name = t, this.times = fu.convertArray(e, this.TimeBufferType), this.values = fu.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
                    }
                    static toJSON(t) {
                        const e = t.constructor;
                        let n;
                        if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                        else {
                            n = { name: t.name, times: fu.convertArray(t.times, Array), values: fu.convertArray(t.values, Array) };
                            const e = t.getInterpolation();
                            e !== t.DefaultInterpolation && (n.interpolation = e)
                        }
                        return n.type = t.ValueTypeName, n
                    }
                    InterpolantFactoryMethodDiscrete(t) { return new xu(this.times, this.values, this.getValueSize(), t) }
                    InterpolantFactoryMethodLinear(t) { return new yu(this.times, this.values, this.getValueSize(), t) }
                    InterpolantFactoryMethodSmooth(t) { return new vu(this.times, this.values, this.getValueSize(), t) }
                    setInterpolation(t) {
                        let e;
                        switch (t) {
                            case Ue:
                                e = this.InterpolantFactoryMethodDiscrete;
                                break;
                            case He:
                                e = this.InterpolantFactoryMethodLinear;
                                break;
                            case ke:
                                e = this.InterpolantFactoryMethodSmooth
                        }
                        if (void 0 === e) {
                            const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                            if (void 0 === this.createInterpolant) {
                                if (t === this.DefaultInterpolation) throw new Error(e);
                                this.setInterpolation(this.DefaultInterpolation)
                            }
                            return console.warn("THREE.KeyframeTrack:", e), this
                        }
                        return this.createInterpolant = e, this
                    }
                    getInterpolation() {
                        switch (this.createInterpolant) {
                            case this.InterpolantFactoryMethodDiscrete:
                                return Ue;
                            case this.InterpolantFactoryMethodLinear:
                                return He;
                            case this.InterpolantFactoryMethodSmooth:
                                return ke
                        }
                    }
                    getValueSize() { return this.values.length / this.times.length }
                    shift(t) { if (0 !== t) { const e = this.times; for (let n = 0, i = e.length; n !== i; ++n) e[n] += t } return this }
                    scale(t) { if (1 !== t) { const e = this.times; for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t } return this }
                    trim(t, e) {
                        const n = this.times,
                            i = n.length;
                        let r = 0,
                            s = i - 1;
                        for (; r !== i && n[r] < t;) ++r;
                        for (; - 1 !== s && n[s] > e;) --s;
                        if (++s, 0 !== r || s !== i) {
                            r >= s && (s = Math.max(s, 1), r = s - 1);
                            const t = this.getValueSize();
                            this.times = fu.arraySlice(n, r, s), this.values = fu.arraySlice(this.values, r * t, s * t)
                        }
                        return this
                    }
                    validate() {
                        let t = !0;
                        const e = this.getValueSize();
                        e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                        const n = this.times,
                            i = this.values,
                            r = n.length;
                        0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                        let s = null;
                        for (let e = 0; e !== r; e++) {
                            const i = n[e];
                            if ("number" == typeof i && isNaN(i)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i), t = !1; break }
                            if (null !== s && s > i) { console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, s), t = !1; break }
                            s = i
                        }
                        if (void 0 !== i && fu.isTypedArray(i))
                            for (let e = 0, n = i.length; e !== n; ++e) { const n = i[e]; if (isNaN(n)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1; break } }
                        return t
                    }
                    optimize() {
                        const t = fu.arraySlice(this.times),
                            e = fu.arraySlice(this.values),
                            n = this.getValueSize(),
                            i = this.getInterpolation() === ke,
                            r = t.length - 1;
                        let s = 1;
                        for (let o = 1; o < r; ++o) {
                            let r = !1;
                            const a = t[o];
                            if (a !== t[o + 1] && (1 !== o || a !== t[0]))
                                if (i) r = !0;
                                else {
                                    const t = o * n,
                                        i = t - n,
                                        s = t + n;
                                    for (let o = 0; o !== n; ++o) { const n = e[t + o]; if (n !== e[i + o] || n !== e[s + o]) { r = !0; break } }
                                }
                            if (r) {
                                if (o !== s) {
                                    t[s] = t[o];
                                    const i = o * n,
                                        r = s * n;
                                    for (let t = 0; t !== n; ++t) e[r + t] = e[i + t]
                                }++s
                            }
                        }
                        if (r > 0) { t[s] = t[r]; for (let t = r * n, i = s * n, o = 0; o !== n; ++o) e[i + o] = e[t + o];++s }
                        return s !== t.length ? (this.times = fu.arraySlice(t, 0, s), this.values = fu.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this
                    }
                    clone() {
                        const t = fu.arraySlice(this.times, 0),
                            e = fu.arraySlice(this.values, 0),
                            n = new(0, this.constructor)(this.name, t, e);
                        return n.createInterpolant = this.createInterpolant, n
                    }
                }
                _u.prototype.TimeBufferType = Float32Array, _u.prototype.ValueBufferType = Float32Array, _u.prototype.DefaultInterpolation = He;
                class bu extends _u {}
                bu.prototype.ValueTypeName = "bool", bu.prototype.ValueBufferType = Array, bu.prototype.DefaultInterpolation = Ue, bu.prototype.InterpolantFactoryMethodLinear = void 0, bu.prototype.InterpolantFactoryMethodSmooth = void 0;
                class wu extends _u {}
                wu.prototype.ValueTypeName = "color";
                class Mu extends _u {}
                Mu.prototype.ValueTypeName = "number";
                class Su extends gu {
                    constructor(t, e, n, i) { super(t, e, n, i) }
                    interpolate_(t, e, n, i) {
                        const r = this.resultBuffer,
                            s = this.sampleValues,
                            o = this.valueSize,
                            a = (n - e) / (i - e);
                        let l = t * o;
                        for (let t = l + o; l !== t; l += 4) di.slerpFlat(r, 0, s, l - o, s, l, a);
                        return r
                    }
                }
                class Tu extends _u { InterpolantFactoryMethodLinear(t) { return new Su(this.times, this.values, this.getValueSize(), t) } }
                Tu.prototype.ValueTypeName = "quaternion", Tu.prototype.DefaultInterpolation = He, Tu.prototype.InterpolantFactoryMethodSmooth = void 0;
                class Eu extends _u {}
                Eu.prototype.ValueTypeName = "string", Eu.prototype.ValueBufferType = Array, Eu.prototype.DefaultInterpolation = Ue, Eu.prototype.InterpolantFactoryMethodLinear = void 0, Eu.prototype.InterpolantFactoryMethodSmooth = void 0;
                class Au extends _u {}
                Au.prototype.ValueTypeName = "vector";
                class Lu {
                    constructor(t, e = -1, n, i = je) { this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = Gn(), this.duration < 0 && this.resetDuration() }
                    static parse(t) {
                        const e = [],
                            n = t.tracks,
                            i = 1 / (t.fps || 1);
                        for (let t = 0, r = n.length; t !== r; ++t) e.push(Ru(n[t]).scale(i));
                        const r = new this(t.name, t.duration, e, t.blendMode);
                        return r.uuid = t.uuid, r
                    }
                    static toJSON(t) {
                        const e = [],
                            n = t.tracks,
                            i = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode };
                        for (let t = 0, i = n.length; t !== i; ++t) e.push(_u.toJSON(n[t]));
                        return i
                    }
                    static CreateFromMorphTargetSequence(t, e, n, i) {
                        const r = e.length,
                            s = [];
                        for (let t = 0; t < r; t++) {
                            let o = [],
                                a = [];
                            o.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0);
                            const l = fu.getKeyframeOrder(o);
                            o = fu.sortedArray(o, 1, l), a = fu.sortedArray(a, 1, l), i || 0 !== o[0] || (o.push(r), a.push(a[0])), s.push(new Mu(".morphTargetInfluences[" + e[t].name + "]", o, a).scale(1 / n))
                        }
                        return new this(t, -1, s)
                    }
                    static findByName(t, e) {
                        let n = t;
                        if (!Array.isArray(t)) {
                            const e = t;
                            n = e.geometry && e.geometry.animations || e.animations
                        }
                        for (let t = 0; t < n.length; t++)
                            if (n[t].name === e) return n[t];
                        return null
                    }
                    static CreateClipsFromMorphTargetSequences(t, e, n) {
                        const i = {},
                            r = /^([\w-]*?)([\d]+)$/;
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e],
                                s = n.name.match(r);
                            if (s && s.length > 1) {
                                const t = s[1];
                                let e = i[t];
                                e || (i[t] = e = []), e.push(n)
                            }
                        }
                        const s = [];
                        for (const t in i) s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
                        return s
                    }
                    static parseAnimation(t, e) {
                        if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                        const n = function(t, e, n, i, r) {
                                if (0 !== n.length) {
                                    const s = [],
                                        o = [];
                                    fu.flattenJSON(n, s, o, i), 0 !== s.length && r.push(new t(e, s, o))
                                }
                            },
                            i = [],
                            r = t.name || "default",
                            s = t.fps || 30,
                            o = t.blendMode;
                        let a = t.length || -1;
                        const l = t.hierarchy || [];
                        for (let t = 0; t < l.length; t++) {
                            const r = l[t].keys;
                            if (r && 0 !== r.length)
                                if (r[0].morphTargets) {
                                    const t = {};
                                    let e;
                                    for (e = 0; e < r.length; e++)
                                        if (r[e].morphTargets)
                                            for (let n = 0; n < r[e].morphTargets.length; n++) t[r[e].morphTargets[n]] = -1;
                                    for (const n in t) {
                                        const t = [],
                                            s = [];
                                        for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                            const i = r[e];
                                            t.push(i.time), s.push(i.morphTarget === n ? 1 : 0)
                                        }
                                        i.push(new Mu(".morphTargetInfluence[" + n + "]", t, s))
                                    }
                                    a = t.length * (s || 1)
                                } else {
                                    const s = ".bones[" + e[t].name + "]";
                                    n(Au, s + ".position", r, "pos", i), n(Tu, s + ".quaternion", r, "rot", i), n(Au, s + ".scale", r, "scl", i)
                                }
                        }
                        return 0 === i.length ? null : new this(r, a, i, o)
                    }
                    resetDuration() {
                        let t = 0;
                        for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                            const n = this.tracks[e];
                            t = Math.max(t, n.times[n.times.length - 1])
                        }
                        return this.duration = t, this
                    }
                    trim() { for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration); return this }
                    validate() { let t = !0; for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate(); return t }
                    optimize() { for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize(); return this }
                    clone() { const t = []; for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone()); return new this.constructor(this.name, this.duration, t, this.blendMode) }
                    toJSON() { return this.constructor.toJSON(this) }
                }

                function Ru(t) {
                    if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                    const e = function(t) {
                        switch (t.toLowerCase()) {
                            case "scalar":
                            case "double":
                            case "float":
                            case "number":
                            case "integer":
                                return Mu;
                            case "vector":
                            case "vector2":
                            case "vector3":
                            case "vector4":
                                return Au;
                            case "color":
                                return wu;
                            case "quaternion":
                                return Tu;
                            case "bool":
                            case "boolean":
                                return bu;
                            case "string":
                                return Eu
                        }
                        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                    }(t.type);
                    if (void 0 === t.times) {
                        const e = [],
                            n = [];
                        fu.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
                    }
                    return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
                }
                const Cu = { enabled: !1, files: {}, add: function(t, e) {!1 !== this.enabled && (this.files[t] = e) }, get: function(t) { if (!1 !== this.enabled) return this.files[t] }, remove: function(t) { delete this.files[t] }, clear: function() { this.files = {} } };
                class Pu {
                    constructor(t, e, n) {
                        const i = this;
                        let r, s = !1,
                            o = 0,
                            a = 0;
                        const l = [];
                        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) { a++, !1 === s && void 0 !== i.onStart && i.onStart(t, o, a), s = !0 }, this.itemEnd = function(t) { o++, void 0 !== i.onProgress && i.onProgress(t, o, a), o === a && (s = !1, void 0 !== i.onLoad && i.onLoad()) }, this.itemError = function(t) { void 0 !== i.onError && i.onError(t) }, this.resolveURL = function(t) { return r ? r(t) : t }, this.setURLModifier = function(t) { return r = t, this }, this.addHandler = function(t, e) { return l.push(t, e), this }, this.removeHandler = function(t) { const e = l.indexOf(t); return -1 !== e && l.splice(e, 2), this }, this.getHandler = function(t) {
                            for (let e = 0, n = l.length; e < n; e += 2) {
                                const n = l[e],
                                    i = l[e + 1];
                                if (n.global && (n.lastIndex = 0), n.test(t)) return i
                            }
                            return null
                        }
                    }
                }
                const Iu = new Pu;
                class Du {
                    constructor(t) { this.manager = void 0 !== t ? t : Iu, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} }
                    load() {}
                    loadAsync(t, e) { const n = this; return new Promise((function(i, r) { n.load(t, i, e, r) })) }
                    parse() {}
                    setCrossOrigin(t) { return this.crossOrigin = t, this }
                    setWithCredentials(t) { return this.withCredentials = t, this }
                    setPath(t) { return this.path = t, this }
                    setResourcePath(t) { return this.resourcePath = t, this }
                    setRequestHeader(t) { return this.requestHeader = t, this }
                }
                const Nu = {};
                class Bu extends Du {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                        const r = Cu.get(t);
                        if (void 0 !== r) return this.manager.itemStart(t), setTimeout((() => { e && e(r), this.manager.itemEnd(t) }), 0), r;
                        if (void 0 !== Nu[t]) return void Nu[t].push({ onLoad: e, onProgress: n, onError: i });
                        Nu[t] = [], Nu[t].push({ onLoad: e, onProgress: n, onError: i });
                        const s = new Request(t, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" });
                        fetch(s).then((e => {
                            if (200 === e.status || 0 === e.status) {
                                0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                const n = Nu[t],
                                    i = e.body.getReader(),
                                    r = e.headers.get("Content-Length"),
                                    s = r ? parseInt(r) : 0,
                                    o = 0 !== s;
                                let a = 0;
                                return new ReadableStream({
                                    start(t) {
                                        ! function e() {
                                            i.read().then((({ done: i, value: r }) => {
                                                if (i) t.close();
                                                else {
                                                    a += r.byteLength;
                                                    const i = new ProgressEvent("progress", { lengthComputable: o, loaded: a, total: s });
                                                    for (let t = 0, e = n.length; t < e; t++) {
                                                        const e = n[t];
                                                        e.onProgress && e.onProgress(i)
                                                    }
                                                    t.enqueue(r), e()
                                                }
                                            }))
                                        }()
                                    }
                                })
                            }
                            throw Error(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`)
                        })).then((t => {
                            const e = new Response(t);
                            switch (this.responseType) {
                                case "arraybuffer":
                                    return e.arrayBuffer();
                                case "blob":
                                    return e.blob();
                                case "document":
                                    return e.text().then((t => (new DOMParser).parseFromString(t, this.mimeType)));
                                case "json":
                                    return e.json();
                                default:
                                    return e.text()
                            }
                        })).then((e => {
                            Cu.add(t, e);
                            const n = Nu[t];
                            delete Nu[t];
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t];
                                i.onLoad && i.onLoad(e)
                            }
                            this.manager.itemEnd(t)
                        })).catch((e => {
                            const n = Nu[t];
                            delete Nu[t];
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t];
                                i.onError && i.onError(e)
                            }
                            this.manager.itemError(t), this.manager.itemEnd(t)
                        })), this.manager.itemStart(t)
                    }
                    setResponseType(t) { return this.responseType = t, this }
                    setMimeType(t) { return this.mimeType = t, this }
                }
                class Ou extends Du {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = this,
                            s = new Bu(this.manager);
                        s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, (function(n) { try { e(r.parse(JSON.parse(n))) } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) } }), n, i)
                    }
                    parse(t) {
                        const e = [];
                        for (let n = 0; n < t.length; n++) {
                            const i = Lu.parse(t[n]);
                            e.push(i)
                        }
                        return e
                    }
                }
                class Fu extends Du {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = this,
                            s = [],
                            o = new Bc,
                            a = new Bu(this.manager);
                        a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(r.withCredentials);
                        let l = 0;

                        function c(c) {
                            a.load(t[c], (function(t) {
                                const n = r.parse(t, !0);
                                s[c] = { width: n.width, height: n.height, format: n.format, mipmaps: n.mipmaps }, l += 1, 6 === l && (1 === n.mipmapCount && (o.minFilter = xt), o.image = s, o.format = n.format, o.needsUpdate = !0, e && e(o))
                            }), n, i)
                        }
                        if (Array.isArray(t))
                            for (let e = 0, n = t.length; e < n; ++e) c(e);
                        else a.load(t, (function(t) {
                            const n = r.parse(t, !0);
                            if (n.isCubemap) {
                                const t = n.mipmaps.length / n.mipmapCount;
                                for (let e = 0; e < t; e++) { s[e] = { mipmaps: [] }; for (let t = 0; t < n.mipmapCount; t++) s[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]), s[e].format = n.format, s[e].width = n.width, s[e].height = n.height }
                                o.image = s
                            } else o.image.width = n.width, o.image.height = n.height, o.mipmaps = n.mipmaps;
                            1 === n.mipmapCount && (o.minFilter = xt), o.format = n.format, o.needsUpdate = !0, e && e(o)
                        }), n, i);
                        return o
                    }
                }
                class zu extends Du {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                        const r = this,
                            s = Cu.get(t);
                        if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() { e && e(s), r.manager.itemEnd(t) }), 0), s;
                        const o = ei("img");

                        function a() { c(), Cu.add(t, this), e && e(this), r.manager.itemEnd(t) }

                        function l(e) { c(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t) }

                        function c() { o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1) }
                        return o.addEventListener("load", a, !1), o.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(t), o.src = t, o
                    }
                }
                class Uu extends Du {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = new Is,
                            s = new zu(this.manager);
                        s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                        let o = 0;

                        function a(n) { s.load(t[n], (function(t) { r.images[n] = t, o++, 6 === o && (r.needsUpdate = !0, e && e(r)) }), void 0, i) }
                        for (let e = 0; e < t.length; ++e) a(e);
                        return r
                    }
                }
                class Hu extends Du {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = this,
                            s = new oc,
                            o = new Bu(this.manager);
                        return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(r.withCredentials), o.load(t, (function(t) {
                            const n = r.parse(t);
                            n && (void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data), s.wrapS = void 0 !== n.wrapS ? n.wrapS : dt, s.wrapT = void 0 !== n.wrapT ? n.wrapT : dt, s.magFilter = void 0 !== n.magFilter ? n.magFilter : xt, s.minFilter = void 0 !== n.minFilter ? n.minFilter : xt, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (s.encoding = n.encoding), void 0 !== n.flipY && (s.flipY = n.flipY), void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = wt), 1 === n.mipmapCount && (s.minFilter = xt), void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps), s.needsUpdate = !0, e && e(s, n))
                        }), n, i), s
                    }
                }
                class ku extends Du {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = new oi,
                            s = new zu(this.manager);
                        return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function(t) { r.image = t, r.needsUpdate = !0, void 0 !== e && e(r) }), n, i), r
                    }
                }
                class Gu extends fr {
                    constructor(t, e = 1) { super(), this.type = "Light", this.color = new Br(t), this.intensity = e }
                    dispose() {}
                    copy(t) { return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this }
                    toJSON(t) { const e = super.toJSON(t); return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e }
                }
                Gu.prototype.isLight = !0;
                class Vu extends Gu {
                    constructor(t, e, n) { super(t, n), this.type = "HemisphereLight", this.position.copy(fr.DefaultUp), this.updateMatrix(), this.groundColor = new Br(e) }
                    copy(t) { return Gu.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this }
                }
                Vu.prototype.isHemisphereLight = !0;
                const Wu = new Wi,
                    ju = new pi,
                    qu = new pi;
                class Xu {
                    constructor(t) { this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Jn(512, 512), this.map = null, this.mapPass = null, this.matrix = new Wi, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Hs, this._frameExtents = new Jn(1, 1), this._viewportCount = 1, this._viewports = [new li(0, 0, 1, 1)] }
                    getViewportCount() { return this._viewportCount }
                    getFrustum() { return this._frustum }
                    updateMatrices(t) {
                        const e = this.camera,
                            n = this.matrix;
                        ju.setFromMatrixPosition(t.matrixWorld), e.position.copy(ju), qu.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(qu), e.updateMatrixWorld(), Wu.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Wu), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
                    }
                    getViewport(t) { return this._viewports[t] }
                    getFrameExtents() { return this._frameExtents }
                    dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() }
                    copy(t) { return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this }
                    clone() { return (new this.constructor).copy(this) }
                    toJSON() { const t = {}; return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t }
                }
                class Yu extends Xu {
                    constructor() { super(new Rs(50, 1, .5, 500)), this.focus = 1 }
                    updateMatrices(t) {
                        const e = this.camera,
                            n = 2 * Un * t.angle * this.focus,
                            i = this.mapSize.width / this.mapSize.height,
                            r = t.distance || e.far;
                        n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t)
                    }
                    copy(t) { return super.copy(t), this.focus = t.focus, this }
                }
                Yu.prototype.isSpotLightShadow = !0;
                class Zu extends Gu {
                    constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 1) { super(t, e), this.type = "SpotLight", this.position.copy(fr.DefaultUp), this.updateMatrix(), this.target = new fr, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.shadow = new Yu }
                    get power() { return this.intensity * Math.PI }
                    set power(t) { this.intensity = t / Math.PI }
                    dispose() { this.shadow.dispose() }
                    copy(t) { return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this }
                }
                Zu.prototype.isSpotLight = !0;
                const Ju = new Wi,
                    Ku = new pi,
                    Qu = new pi;
                class $u extends Xu {
                    constructor() { super(new Rs(90, 1, .5, 500)), this._frameExtents = new Jn(4, 2), this._viewportCount = 6, this._viewports = [new li(2, 1, 1, 1), new li(0, 1, 1, 1), new li(3, 1, 1, 1), new li(1, 1, 1, 1), new li(3, 0, 1, 1), new li(1, 0, 1, 1)], this._cubeDirections = [new pi(1, 0, 0), new pi(-1, 0, 0), new pi(0, 0, 1), new pi(0, 0, -1), new pi(0, 1, 0), new pi(0, -1, 0)], this._cubeUps = [new pi(0, 1, 0), new pi(0, 1, 0), new pi(0, 1, 0), new pi(0, 1, 0), new pi(0, 0, 1), new pi(0, 0, -1)] }
                    updateMatrices(t, e = 0) {
                        const n = this.camera,
                            i = this.matrix,
                            r = t.distance || n.far;
                        r !== n.far && (n.far = r, n.updateProjectionMatrix()), Ku.setFromMatrixPosition(t.matrixWorld), n.position.copy(Ku), Qu.copy(n.position), Qu.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Qu), n.updateMatrixWorld(), i.makeTranslation(-Ku.x, -Ku.y, -Ku.z), Ju.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ju)
                    }
                }
                $u.prototype.isPointLightShadow = !0;
                class td extends Gu {
                    constructor(t, e, n = 0, i = 1) { super(t, e), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new $u }
                    get power() { return 4 * this.intensity * Math.PI }
                    set power(t) { this.intensity = t / (4 * Math.PI) }
                    dispose() { this.shadow.dispose() }
                    copy(t) { return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this }
                }
                td.prototype.isPointLight = !0;
                class ed extends Xu { constructor() { super(new $s(-5, 5, 5, -5, .5, 500)) } }
                ed.prototype.isDirectionalLightShadow = !0;
                class nd extends Gu {
                    constructor(t, e) { super(t, e), this.type = "DirectionalLight", this.position.copy(fr.DefaultUp), this.updateMatrix(), this.target = new fr, this.shadow = new ed }
                    dispose() { this.shadow.dispose() }
                    copy(t) { return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this }
                }
                nd.prototype.isDirectionalLight = !0;
                class id extends Gu { constructor(t, e) { super(t, e), this.type = "AmbientLight" } }
                id.prototype.isAmbientLight = !0;
                class rd extends Gu {
                    constructor(t, e, n = 10, i = 10) { super(t, e), this.type = "RectAreaLight", this.width = n, this.height = i }
                    get power() { return this.intensity * this.width * this.height * Math.PI }
                    set power(t) { this.intensity = t / (this.width * this.height * Math.PI) }
                    copy(t) { return super.copy(t), this.width = t.width, this.height = t.height, this }
                    toJSON(t) { const e = super.toJSON(t); return e.object.width = this.width, e.object.height = this.height, e }
                }
                rd.prototype.isRectAreaLight = !0;
                class sd {
                    constructor() { this.coefficients = []; for (let t = 0; t < 9; t++) this.coefficients.push(new pi) }
                    set(t) { for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]); return this }
                    zero() { for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0); return this }
                    getAt(t, e) {
                        const n = t.x,
                            i = t.y,
                            r = t.z,
                            s = this.coefficients;
                        return e.copy(s[0]).multiplyScalar(.282095), e.addScaledVector(s[1], .488603 * i), e.addScaledVector(s[2], .488603 * r), e.addScaledVector(s[3], .488603 * n), e.addScaledVector(s[4], n * i * 1.092548), e.addScaledVector(s[5], i * r * 1.092548), e.addScaledVector(s[6], .315392 * (3 * r * r - 1)), e.addScaledVector(s[7], n * r * 1.092548), e.addScaledVector(s[8], .546274 * (n * n - i * i)), e
                    }
                    getIrradianceAt(t, e) {
                        const n = t.x,
                            i = t.y,
                            r = t.z,
                            s = this.coefficients;
                        return e.copy(s[0]).multiplyScalar(.886227), e.addScaledVector(s[1], 1.023328 * i), e.addScaledVector(s[2], 1.023328 * r), e.addScaledVector(s[3], 1.023328 * n), e.addScaledVector(s[4], .858086 * n * i), e.addScaledVector(s[5], .858086 * i * r), e.addScaledVector(s[6], .743125 * r * r - .247708), e.addScaledVector(s[7], .858086 * n * r), e.addScaledVector(s[8], .429043 * (n * n - i * i)), e
                    }
                    add(t) { for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]); return this }
                    addScaledSH(t, e) { for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e); return this }
                    scale(t) { for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t); return this }
                    lerp(t, e) { for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e); return this }
                    equals(t) {
                        for (let e = 0; e < 9; e++)
                            if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                        return !0
                    }
                    copy(t) { return this.set(t.coefficients) }
                    clone() { return (new this.constructor).copy(this) }
                    fromArray(t, e = 0) { const n = this.coefficients; for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i); return this }
                    toArray(t = [], e = 0) { const n = this.coefficients; for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i); return t }
                    static getBasisAt(t, e) {
                        const n = t.x,
                            i = t.y,
                            r = t.z;
                        e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i)
                    }
                }
                sd.prototype.isSphericalHarmonics3 = !0;
                class od extends Gu {
                    constructor(t = new sd, e = 1) { super(void 0, e), this.sh = t }
                    copy(t) { return super.copy(t), this.sh.copy(t.sh), this }
                    fromJSON(t) { return this.intensity = t.intensity, this.sh.fromArray(t.sh), this }
                    toJSON(t) { const e = super.toJSON(t); return e.object.sh = this.sh.toArray(), e }
                }
                od.prototype.isLightProbe = !0;
                class ad extends Du {
                    constructor(t) { super(t), this.textures = {} }
                    load(t, e, n, i) {
                        const r = this,
                            s = new Bu(r.manager);
                        s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function(n) { try { e(r.parse(JSON.parse(n))) } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) } }), n, i)
                    }
                    parse(t) {
                        const e = this.textures;

                        function n(t) { return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t] }
                        const i = new mu[t.type];
                        if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && void 0 !== i.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.sheen && (i.sheen = t.sheen), void 0 !== t.sheenColor && (i.sheenColor = (new Br).setHex(t.sheenColor)), void 0 !== t.sheenRoughness && (i.sheenRoughness = t.sheenRoughness), void 0 !== t.emissive && void 0 !== i.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && void 0 !== i.specular && i.specular.setHex(t.specular), void 0 !== t.specularIntensity && (i.specularIntensity = t.specularIntensity), void 0 !== t.specularColor && void 0 !== i.specularColor && i.specularColor.setHex(t.specularColor), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.transmission && (i.transmission = t.transmission), void 0 !== t.thickness && (i.thickness = t.thickness), void 0 !== t.attenuationDistance && (i.attenuationDistance = t.attenuationDistance), void 0 !== t.attenuationColor && void 0 !== i.attenuationColor && i.attenuationColor.setHex(t.attenuationColor), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.format && (i.format = t.format), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.alphaToCoverage && (i.alphaToCoverage = t.alphaToCoverage), void 0 !== t.premultipliedAlpha && (i.premultipliedAlpha = t.premultipliedAlpha), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? i.vertexColors = t.vertexColors > 0 : i.vertexColors = t.vertexColors), void 0 !== t.uniforms)
                            for (const e in t.uniforms) {
                                const r = t.uniforms[e];
                                switch (i.uniforms[e] = {}, r.type) {
                                    case "t":
                                        i.uniforms[e].value = n(r.value);
                                        break;
                                    case "c":
                                        i.uniforms[e].value = (new Br).setHex(r.value);
                                        break;
                                    case "v2":
                                        i.uniforms[e].value = (new Jn).fromArray(r.value);
                                        break;
                                    case "v3":
                                        i.uniforms[e].value = (new pi).fromArray(r.value);
                                        break;
                                    case "v4":
                                        i.uniforms[e].value = (new li).fromArray(r.value);
                                        break;
                                    case "m3":
                                        i.uniforms[e].value = (new Kn).fromArray(r.value);
                                        break;
                                    case "m4":
                                        i.uniforms[e].value = (new Wi).fromArray(r.value);
                                        break;
                                    default:
                                        i.uniforms[e].value = r.value
                                }
                            }
                        if (void 0 !== t.defines && (i.defines = t.defines), void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
                            for (const e in t.extensions) i.extensions[e] = t.extensions[e];
                        if (void 0 !== t.shading && (i.flatShading = 1 === t.shading), void 0 !== t.size && (i.size = t.size), void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (i.map = n(t.map)), void 0 !== t.matcap && (i.matcap = n(t.matcap)), void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale), void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType), void 0 !== t.normalScale) { let e = t.normalScale;!1 === Array.isArray(e) && (e = [e, e]), i.normalScale = (new Jn).fromArray(e) }
                        return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.specularIntensityMap && (i.specularIntensityMap = n(t.specularIntensityMap)), void 0 !== t.specularColorMap && (i.specularColorMap = n(t.specularColorMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = (new Jn).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmissionMap && (i.transmissionMap = n(t.transmissionMap)), void 0 !== t.thicknessMap && (i.thicknessMap = n(t.thicknessMap)), void 0 !== t.sheenColorMap && (i.sheenColorMap = n(t.sheenColorMap)), void 0 !== t.sheenRoughnessMap && (i.sheenRoughnessMap = n(t.sheenRoughnessMap)), i
                    }
                    setTextures(t) { return this.textures = t, this }
                }
                class ld {
                    static decodeText(t) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t); let e = ""; for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]); try { return decodeURIComponent(escape(e)) } catch (t) { return e } }
                    static extractUrlBase(t) { const e = t.lastIndexOf("/"); return -1 === e ? "./" : t.substr(0, e + 1) }
                    static resolveURL(t, e) { return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t) }
                }
                class cd extends is {
                    constructor() { super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 }
                    copy(t) { return super.copy(t), this.instanceCount = t.instanceCount, this }
                    clone() { return (new this.constructor).copy(this) }
                    toJSON() { const t = super.toJSON(this); return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t }
                }
                cd.prototype.isInstancedBufferGeometry = !0;
                class hd extends Du {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = this,
                            s = new Bu(r.manager);
                        s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function(n) { try { e(r.parse(JSON.parse(n))) } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) } }), n, i)
                    }
                    parse(t) {
                        const e = {},
                            n = {};

                        function i(t, i) {
                            if (void 0 !== e[i]) return e[i];
                            const r = t.interleavedBuffers[i],
                                s = function(t, e) {
                                    if (void 0 !== n[e]) return n[e];
                                    const i = t.arrayBuffers[e],
                                        r = new Uint32Array(i).buffer;
                                    return n[e] = r, r
                                }(t, r.buffer),
                                o = ti(r.type, s),
                                a = new Pl(o, r.stride);
                            return a.uuid = r.uuid, e[i] = a, a
                        }
                        const r = t.isInstancedBufferGeometry ? new cd : new is,
                            s = t.data.index;
                        if (void 0 !== s) {
                            const t = ti(s.type, s.array);
                            r.setIndex(new Ur(t, 1))
                        }
                        const o = t.data.attributes;
                        for (const e in o) {
                            const n = o[e];
                            let s;
                            if (n.isInterleavedBufferAttribute) {
                                const e = i(t.data, n.data);
                                s = new Dl(e, n.itemSize, n.offset, n.normalized)
                            } else {
                                const t = ti(n.type, n.array);
                                s = new(n.isInstancedBufferAttribute ? hc : Ur)(t, n.itemSize, n.normalized)
                            }
                            void 0 !== n.name && (s.name = n.name), void 0 !== n.usage && s.setUsage(n.usage), void 0 !== n.updateRange && (s.updateRange.offset = n.updateRange.offset, s.updateRange.count = n.updateRange.count), r.setAttribute(e, s)
                        }
                        const a = t.data.morphAttributes;
                        if (a)
                            for (const e in a) {
                                const n = a[e],
                                    s = [];
                                for (let e = 0, r = n.length; e < r; e++) {
                                    const r = n[e];
                                    let o;
                                    if (r.isInterleavedBufferAttribute) {
                                        const e = i(t.data, r.data);
                                        o = new Dl(e, r.itemSize, r.offset, r.normalized)
                                    } else {
                                        const t = ti(r.type, r.array);
                                        o = new Ur(t, r.itemSize, r.normalized)
                                    }
                                    void 0 !== r.name && (o.name = r.name), s.push(o)
                                }
                                r.morphAttributes[e] = s
                            }
                        t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
                        const l = t.data.groups || t.data.drawcalls || t.data.offsets;
                        if (void 0 !== l)
                            for (let t = 0, e = l.length; t !== e; ++t) {
                                const e = l[t];
                                r.addGroup(e.start, e.count, e.materialIndex)
                            }
                        const c = t.data.boundingSphere;
                        if (void 0 !== c) {
                            const t = new pi;
                            void 0 !== c.center && t.fromArray(c.center), r.boundingSphere = new Bi(t, c.radius)
                        }
                        return t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r
                    }
                }
                class ud extends Du {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = this,
                            s = "" === this.path ? ld.extractUrlBase(t) : this.path;
                        this.resourcePath = this.resourcePath || s;
                        const o = new Bu(this.manager);
                        o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, (function(n) {
                            let s = null;
                            try { s = JSON.parse(n) } catch (e) { return void 0 !== i && i(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message) }
                            const o = s.metadata;
                            void 0 !== o && void 0 !== o.type && "geometry" !== o.type.toLowerCase() ? r.parse(s, e) : console.error("THREE.ObjectLoader: Can't load " + t)
                        }), n, i)
                    }
                    async loadAsync(t, e) {
                        const n = "" === this.path ? ld.extractUrlBase(t) : this.path;
                        this.resourcePath = this.resourcePath || n;
                        const i = new Bu(this.manager);
                        i.setPath(this.path), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials);
                        const r = await i.loadAsync(t, e),
                            s = JSON.parse(r),
                            o = s.metadata;
                        if (void 0 === o || void 0 === o.type || "geometry" === o.type.toLowerCase()) throw new Error("THREE.ObjectLoader: Can't load " + t);
                        return await this.parseAsync(s)
                    }
                    parse(t, e) {
                        const n = this.parseAnimations(t.animations),
                            i = this.parseShapes(t.shapes),
                            r = this.parseGeometries(t.geometries, i),
                            s = this.parseImages(t.images, (function() { void 0 !== e && e(l) })),
                            o = this.parseTextures(t.textures, s),
                            a = this.parseMaterials(t.materials, o),
                            l = this.parseObject(t.object, r, a, o, n),
                            c = this.parseSkeletons(t.skeletons, l);
                        if (this.bindSkeletons(l, c), void 0 !== e) {
                            let t = !1;
                            for (const e in s)
                                if (s[e] instanceof HTMLImageElement) { t = !0; break }!1 === t && e(l)
                        }
                        return l
                    }
                    async parseAsync(t) {
                        const e = this.parseAnimations(t.animations),
                            n = this.parseShapes(t.shapes),
                            i = this.parseGeometries(t.geometries, n),
                            r = await this.parseImagesAsync(t.images),
                            s = this.parseTextures(t.textures, r),
                            o = this.parseMaterials(t.materials, s),
                            a = this.parseObject(t.object, i, o, s, e),
                            l = this.parseSkeletons(t.skeletons, a);
                        return this.bindSkeletons(a, l), a
                    }
                    parseShapes(t) {
                        const e = {};
                        if (void 0 !== t)
                            for (let n = 0, i = t.length; n < i; n++) {
                                const i = (new gh).fromJSON(t[n]);
                                e[i.uuid] = i
                            }
                        return e
                    }
                    parseSkeletons(t, e) {
                        const n = {},
                            i = {};
                        if (e.traverse((function(t) { t.isBone && (i[t.uuid] = t) })), void 0 !== t)
                            for (let e = 0, r = t.length; e < r; e++) {
                                const r = (new cc).fromJSON(t[e], i);
                                n[r.uuid] = r
                            }
                        return n
                    }
                    parseGeometries(t, e) {
                        const n = {};
                        if (void 0 !== t) {
                            const i = new hd;
                            for (let r = 0, s = t.length; r < s; r++) {
                                let s;
                                const o = t[r];
                                switch (o.type) {
                                    case "BufferGeometry":
                                    case "InstancedBufferGeometry":
                                        s = i.parse(o);
                                        break;
                                    case "Geometry":
                                        console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
                                        break;
                                    default:
                                        o.type in ru ? s = ru[o.type].fromJSON(o, e) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${o.type}"`)
                                }
                                s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), !0 === s.isBufferGeometry && void 0 !== o.userData && (s.userData = o.userData), n[o.uuid] = s
                            }
                        }
                        return n
                    }
                    parseMaterials(t, e) {
                        const n = {},
                            i = {};
                        if (void 0 !== t) {
                            const r = new ad;
                            r.setTextures(e);
                            for (let e = 0, s = t.length; e < s; e++) {
                                const s = t[e];
                                if ("MultiMaterial" === s.type) {
                                    const t = [];
                                    for (let e = 0; e < s.materials.length; e++) {
                                        const i = s.materials[e];
                                        void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)), t.push(n[i.uuid])
                                    }
                                    i[s.uuid] = t
                                } else void 0 === n[s.uuid] && (n[s.uuid] = r.parse(s)), i[s.uuid] = n[s.uuid]
                            }
                        }
                        return i
                    }
                    parseAnimations(t) {
                        const e = {};
                        if (void 0 !== t)
                            for (let n = 0; n < t.length; n++) {
                                const i = t[n],
                                    r = Lu.parse(i);
                                e[r.uuid] = r
                            }
                        return e
                    }
                    parseImages(t, e) {
                        const n = this,
                            i = {};
                        let r;

                        function s(t) { if ("string" == typeof t) { const e = t; return function(t) { return n.manager.itemStart(t), r.load(t, (function() { n.manager.itemEnd(t) }), void 0, (function() { n.manager.itemError(t), n.manager.itemEnd(t) })) }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e) } return t.data ? { data: ti(t.type, t.data), width: t.width, height: t.height } : null }
                        if (void 0 !== t && t.length > 0) {
                            const n = new Pu(e);
                            r = new zu(n), r.setCrossOrigin(this.crossOrigin);
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e],
                                    r = n.url;
                                if (Array.isArray(r)) {
                                    i[n.uuid] = [];
                                    for (let t = 0, e = r.length; t < e; t++) {
                                        const e = s(r[t]);
                                        null !== e && (e instanceof HTMLImageElement ? i[n.uuid].push(e) : i[n.uuid].push(new oc(e.data, e.width, e.height)))
                                    }
                                } else {
                                    const t = s(n.url);
                                    null !== t && (i[n.uuid] = t)
                                }
                            }
                        }
                        return i
                    }
                    async parseImagesAsync(t) {
                        const e = this,
                            n = {};
                        let i;
                        async function r(t) {
                            if ("string" == typeof t) {
                                const n = t,
                                    r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n) ? n : e.resourcePath + n;
                                return await i.loadAsync(r)
                            }
                            return t.data ? { data: ti(t.type, t.data), width: t.width, height: t.height } : null
                        }
                        if (void 0 !== t && t.length > 0) {
                            i = new zu(this.manager), i.setCrossOrigin(this.crossOrigin);
                            for (let e = 0, i = t.length; e < i; e++) {
                                const i = t[e],
                                    s = i.url;
                                if (Array.isArray(s)) {
                                    n[i.uuid] = [];
                                    for (let t = 0, e = s.length; t < e; t++) {
                                        const e = s[t],
                                            o = await r(e);
                                        null !== o && (o instanceof HTMLImageElement ? n[i.uuid].push(o) : n[i.uuid].push(new oc(o.data, o.width, o.height)))
                                    }
                                } else {
                                    const t = await r(i.url);
                                    null !== t && (n[i.uuid] = t)
                                }
                            }
                        }
                        return n
                    }
                    parseTextures(t, e) {
                        function n(t, e) { return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t]) }
                        const i = {};
                        if (void 0 !== t)
                            for (let r = 0, s = t.length; r < s; r++) {
                                const s = t[r];
                                let o;
                                void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
                                const a = e[s.image];
                                Array.isArray(a) ? (o = new Is(a), 6 === a.length && (o.needsUpdate = !0)) : (o = a && a.data ? new oc(a.data, a.width, a.height) : new oi(a), a && (o.needsUpdate = !0)), o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), void 0 !== s.mapping && (o.mapping = n(s.mapping, dd)), void 0 !== s.offset && o.offset.fromArray(s.offset), void 0 !== s.repeat && o.repeat.fromArray(s.repeat), void 0 !== s.center && o.center.fromArray(s.center), void 0 !== s.rotation && (o.rotation = s.rotation), void 0 !== s.wrap && (o.wrapS = n(s.wrap[0], pd), o.wrapT = n(s.wrap[1], pd)), void 0 !== s.format && (o.format = s.format), void 0 !== s.type && (o.type = s.type), void 0 !== s.encoding && (o.encoding = s.encoding), void 0 !== s.minFilter && (o.minFilter = n(s.minFilter, md)), void 0 !== s.magFilter && (o.magFilter = n(s.magFilter, md)), void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy), void 0 !== s.flipY && (o.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (o.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (o.unpackAlignment = s.unpackAlignment), void 0 !== s.userData && (o.userData = s.userData), i[s.uuid] = o
                            }
                        return i
                    }
                    parseObject(t, e, n, i, r) {
                        let s, o, a;

                        function l(t) { return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t] }

                        function c(t) {
                            if (void 0 !== t) {
                                if (Array.isArray(t)) {
                                    const e = [];
                                    for (let i = 0, r = t.length; i < r; i++) {
                                        const r = t[i];
                                        void 0 === n[r] && console.warn("THREE.ObjectLoader: Undefined material", r), e.push(n[r])
                                    }
                                    return e
                                }
                                return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t]
                            }
                        }

                        function h(t) { return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined texture", t), i[t] }
                        switch (t.type) {
                            case "Scene":
                                s = new Cl, void 0 !== t.background && (Number.isInteger(t.background) ? s.background = new Br(t.background) : s.background = h(t.background)), void 0 !== t.environment && (s.environment = h(t.environment)), void 0 !== t.fog && ("Fog" === t.fog.type ? s.fog = new Rl(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (s.fog = new Ll(t.fog.color, t.fog.density)));
                                break;
                            case "PerspectiveCamera":
                                s = new Rs(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (s.focus = t.focus), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.filmGauge && (s.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (s.filmOffset = t.filmOffset), void 0 !== t.view && (s.view = Object.assign({}, t.view));
                                break;
                            case "OrthographicCamera":
                                s = new $s(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.view && (s.view = Object.assign({}, t.view));
                                break;
                            case "AmbientLight":
                                s = new id(t.color, t.intensity);
                                break;
                            case "DirectionalLight":
                                s = new nd(t.color, t.intensity);
                                break;
                            case "PointLight":
                                s = new td(t.color, t.intensity, t.distance, t.decay);
                                break;
                            case "RectAreaLight":
                                s = new rd(t.color, t.intensity, t.width, t.height);
                                break;
                            case "SpotLight":
                                s = new Zu(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                                break;
                            case "HemisphereLight":
                                s = new Vu(t.color, t.groundColor, t.intensity);
                                break;
                            case "LightProbe":
                                s = (new od).fromJSON(t);
                                break;
                            case "SkinnedMesh":
                                o = l(t.geometry), a = c(t.material), s = new rc(o, a), void 0 !== t.bindMode && (s.bindMode = t.bindMode), void 0 !== t.bindMatrix && s.bindMatrix.fromArray(t.bindMatrix), void 0 !== t.skeleton && (s.skeleton = t.skeleton);
                                break;
                            case "Mesh":
                                o = l(t.geometry), a = c(t.material), s = new bs(o, a);
                                break;
                            case "InstancedMesh":
                                o = l(t.geometry), a = c(t.material);
                                const e = t.count,
                                    n = t.instanceMatrix,
                                    i = t.instanceColor;
                                s = new fc(o, a, e), s.instanceMatrix = new hc(new Float32Array(n.array), 16), void 0 !== i && (s.instanceColor = new hc(new Float32Array(i.array), i.itemSize));
                                break;
                            case "LOD":
                                s = new Ql;
                                break;
                            case "Line":
                                s = new wc(l(t.geometry), c(t.material));
                                break;
                            case "LineLoop":
                                s = new Ec(l(t.geometry), c(t.material));
                                break;
                            case "LineSegments":
                                s = new Tc(l(t.geometry), c(t.material));
                                break;
                            case "PointCloud":
                            case "Points":
                                s = new Ic(l(t.geometry), c(t.material));
                                break;
                            case "Sprite":
                                s = new Yl(c(t.material));
                                break;
                            case "Group":
                                s = new bl;
                                break;
                            case "Bone":
                                s = new sc;
                                break;
                            default:
                                s = new fr
                        }
                        if (s.uuid = t.uuid, void 0 !== t.name && (s.name = t.name), void 0 !== t.matrix ? (s.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (s.matrixAutoUpdate = t.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== t.position && s.position.fromArray(t.position), void 0 !== t.rotation && s.rotation.fromArray(t.rotation), void 0 !== t.quaternion && s.quaternion.fromArray(t.quaternion), void 0 !== t.scale && s.scale.fromArray(t.scale)), void 0 !== t.castShadow && (s.castShadow = t.castShadow), void 0 !== t.receiveShadow && (s.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (s.shadow.bias = t.shadow.bias), void 0 !== t.shadow.normalBias && (s.shadow.normalBias = t.shadow.normalBias), void 0 !== t.shadow.radius && (s.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && s.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (s.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (s.visible = t.visible), void 0 !== t.frustumCulled && (s.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (s.renderOrder = t.renderOrder), void 0 !== t.userData && (s.userData = t.userData), void 0 !== t.layers && (s.layers.mask = t.layers), void 0 !== t.children) { const o = t.children; for (let t = 0; t < o.length; t++) s.add(this.parseObject(o[t], e, n, i, r)) }
                        if (void 0 !== t.animations) {
                            const e = t.animations;
                            for (let t = 0; t < e.length; t++) {
                                const n = e[t];
                                s.animations.push(r[n])
                            }
                        }
                        if ("LOD" === t.type) {
                            void 0 !== t.autoUpdate && (s.autoUpdate = t.autoUpdate);
                            const e = t.levels;
                            for (let t = 0; t < e.length; t++) {
                                const n = e[t],
                                    i = s.getObjectByProperty("uuid", n.object);
                                void 0 !== i && s.addLevel(i, n.distance)
                            }
                        }
                        return s
                    }
                    bindSkeletons(t, e) {
                        0 !== Object.keys(e).length && t.traverse((function(t) {
                            if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
                                const n = e[t.skeleton];
                                void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", t.skeleton) : t.bind(n, t.bindMatrix)
                            }
                        }))
                    }
                    setTexturePath(t) { return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t) }
                }
                const dd = { UVMapping: rt, CubeReflectionMapping: st, CubeRefractionMapping: ot, EquirectangularReflectionMapping: at, EquirectangularRefractionMapping: lt, CubeUVReflectionMapping: ct, CubeUVRefractionMapping: ht },
                    pd = { RepeatWrapping: ut, ClampToEdgeWrapping: dt, MirroredRepeatWrapping: pt },
                    md = { NearestFilter: mt, NearestMipmapNearestFilter: ft, NearestMipmapLinearFilter: vt, LinearFilter: xt, LinearMipmapNearestFilter: _t, LinearMipmapLinearFilter: wt };
                class fd extends Du {
                    constructor(t) { super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } }
                    setOptions(t) { return this.options = t, this }
                    load(t, e, n, i) {
                        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                        const r = this,
                            s = Cu.get(t);
                        if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() { e && e(s), r.manager.itemEnd(t) }), 0), s;
                        const o = {};
                        o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader, fetch(t, o).then((function(t) { return t.blob() })).then((function(t) { return createImageBitmap(t, Object.assign(r.options, { colorSpaceConversion: "none" })) })).then((function(n) { Cu.add(t, n), e && e(n), r.manager.itemEnd(t) })).catch((function(e) { i && i(e), r.manager.itemError(t), r.manager.itemEnd(t) })), r.manager.itemStart(t)
                    }
                }
                let gd;
                fd.prototype.isImageBitmapLoader = !0;
                const vd = { getContext: function() { return void 0 === gd && (gd = new(window.AudioContext || window.webkitAudioContext)), gd }, setContext: function(t) { gd = t } };
                class yd extends Du {
                    constructor(t) { super(t) }
                    load(t, e, n, i) {
                        const r = this,
                            s = new Bu(this.manager);
                        s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, (function(n) {
                            try {
                                const t = n.slice(0);
                                vd.getContext().decodeAudioData(t, (function(t) { e(t) }))
                            } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) }
                        }), n, i)
                    }
                }
                class xd extends od {
                    constructor(t, e, n = 1) {
                        super(void 0, n);
                        const i = (new Br).set(t),
                            r = (new Br).set(e),
                            s = new pi(i.r, i.g, i.b),
                            o = new pi(r.r, r.g, r.b),
                            a = Math.sqrt(Math.PI),
                            l = a * Math.sqrt(.75);
                        this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a), this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l)
                    }
                }
                xd.prototype.isHemisphereLightProbe = !0;
                class _d extends od {
                    constructor(t, e = 1) {
                        super(void 0, e);
                        const n = (new Br).set(t);
                        this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
                    }
                }
                _d.prototype.isAmbientLightProbe = !0;
                const bd = new Wi,
                    wd = new Wi;
                class Md {
                    constructor() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Rs, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Rs, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } }
                    update(t) {
                        const e = this._cache;
                        if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
                            e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep;
                            const n = t.projectionMatrix.clone(),
                                i = e.eyeSep / 2,
                                r = i * e.near / e.focus,
                                s = e.near * Math.tan(zn * e.fov * .5) / e.zoom;
                            let o, a;
                            wd.elements[12] = -i, bd.elements[12] = i, o = -s * e.aspect + r, a = s * e.aspect + r, n.elements[0] = 2 * e.near / (a - o), n.elements[8] = (a + o) / (a - o), this.cameraL.projectionMatrix.copy(n), o = -s * e.aspect - r, a = s * e.aspect - r, n.elements[0] = 2 * e.near / (a - o), n.elements[8] = (a + o) / (a - o), this.cameraR.projectionMatrix.copy(n)
                        }
                        this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(wd), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(bd)
                    }
                }
                class Sd {
                    constructor(t = !0) { this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 }
                    start() { this.startTime = Td(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 }
                    stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 }
                    getElapsedTime() { return this.getDelta(), this.elapsedTime }
                    getDelta() {
                        let t = 0;
                        if (this.autoStart && !this.running) return this.start(), 0;
                        if (this.running) {
                            const e = Td();
                            t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                        }
                        return t
                    }
                }

                function Td() { return ("undefined" == typeof performance ? Date : performance).now() }
                const Ed = new pi,
                    Ad = new di,
                    Ld = new pi,
                    Rd = new pi;
                class Cd extends fr {
                    constructor() { super(), this.type = "AudioListener", this.context = vd.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Sd }
                    getInput() { return this.gain }
                    removeFilter() { return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this }
                    getFilter() { return this.filter }
                    setFilter(t) { return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this }
                    getMasterVolume() { return this.gain.gain.value }
                    setMasterVolume(t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this }
                    updateMatrixWorld(t) {
                        super.updateMatrixWorld(t);
                        const e = this.context.listener,
                            n = this.up;
                        if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Ed, Ad, Ld), Rd.set(0, 0, -1).applyQuaternion(Ad), e.positionX) {
                            const t = this.context.currentTime + this.timeDelta;
                            e.positionX.linearRampToValueAtTime(Ed.x, t), e.positionY.linearRampToValueAtTime(Ed.y, t), e.positionZ.linearRampToValueAtTime(Ed.z, t), e.forwardX.linearRampToValueAtTime(Rd.x, t), e.forwardY.linearRampToValueAtTime(Rd.y, t), e.forwardZ.linearRampToValueAtTime(Rd.z, t), e.upX.linearRampToValueAtTime(n.x, t), e.upY.linearRampToValueAtTime(n.y, t), e.upZ.linearRampToValueAtTime(n.z, t)
                        } else e.setPosition(Ed.x, Ed.y, Ed.z), e.setOrientation(Rd.x, Rd.y, Rd.z, n.x, n.y, n.z)
                    }
                }
                class Pd extends fr {
                    constructor(t) { super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] }
                    getOutput() { return this.gain }
                    setNodeSource(t) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this }
                    setMediaElementSource(t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this }
                    setMediaStreamSource(t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this }
                    setBuffer(t) { return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this }
                    play(t = 0) {
                        if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                        if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                        this._startedAt = this.context.currentTime + t;
                        const e = this.context.createBufferSource();
                        return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                    }
                    pause() {
                        if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    stop() {
                        if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    connect() {
                        if (this.filters.length > 0) {
                            this.source.connect(this.filters[0]);
                            for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                            this.filters[this.filters.length - 1].connect(this.getOutput())
                        } else this.source.connect(this.getOutput());
                        return this._connected = !0, this
                    }
                    disconnect() {
                        if (this.filters.length > 0) {
                            this.source.disconnect(this.filters[0]);
                            for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                            this.filters[this.filters.length - 1].disconnect(this.getOutput())
                        } else this.source.disconnect(this.getOutput());
                        return this._connected = !1, this
                    }
                    getFilters() { return this.filters }
                    setFilters(t) { return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this }
                    setDetune(t) { if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this }
                    getDetune() { return this.detune }
                    getFilter() { return this.getFilters()[0] }
                    setFilter(t) { return this.setFilters(t ? [t] : []) }
                    setPlaybackRate(t) {
                        if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    getPlaybackRate() { return this.playbackRate }
                    onEnded() { this.isPlaying = !1 }
                    getLoop() { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop }
                    setLoop(t) {
                        if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    setLoopStart(t) { return this.loopStart = t, this }
                    setLoopEnd(t) { return this.loopEnd = t, this }
                    getVolume() { return this.gain.gain.value }
                    setVolume(t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this }
                }
                const Id = new pi,
                    Dd = new di,
                    Nd = new pi,
                    Bd = new pi;
                class Od extends Pd {
                    constructor(t) { super(t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) }
                    getOutput() { return this.panner }
                    getRefDistance() { return this.panner.refDistance }
                    setRefDistance(t) { return this.panner.refDistance = t, this }
                    getRolloffFactor() { return this.panner.rolloffFactor }
                    setRolloffFactor(t) { return this.panner.rolloffFactor = t, this }
                    getDistanceModel() { return this.panner.distanceModel }
                    setDistanceModel(t) { return this.panner.distanceModel = t, this }
                    getMaxDistance() { return this.panner.maxDistance }
                    setMaxDistance(t) { return this.panner.maxDistance = t, this }
                    setDirectionalCone(t, e, n) { return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this }
                    updateMatrixWorld(t) {
                        if (super.updateMatrixWorld(t), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
                        this.matrixWorld.decompose(Id, Dd, Nd), Bd.set(0, 0, 1).applyQuaternion(Dd);
                        const e = this.panner;
                        if (e.positionX) {
                            const t = this.context.currentTime + this.listener.timeDelta;
                            e.positionX.linearRampToValueAtTime(Id.x, t), e.positionY.linearRampToValueAtTime(Id.y, t), e.positionZ.linearRampToValueAtTime(Id.z, t), e.orientationX.linearRampToValueAtTime(Bd.x, t), e.orientationY.linearRampToValueAtTime(Bd.y, t), e.orientationZ.linearRampToValueAtTime(Bd.z, t)
                        } else e.setPosition(Id.x, Id.y, Id.z), e.setOrientation(Bd.x, Bd.y, Bd.z)
                    }
                }
                class Fd {
                    constructor(t, e = 2048) { this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser) }
                    getFrequencyData() { return this.analyser.getByteFrequencyData(this.data), this.data }
                    getAverageFrequency() { let t = 0; const e = this.getFrequencyData(); for (let n = 0; n < e.length; n++) t += e[n]; return t / e.length }
                }
                class zd {
                    constructor(t, e, n) {
                        let i, r, s;
                        switch (this.binding = t, this.valueSize = n, e) {
                            case "quaternion":
                                i = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                                break;
                            case "string":
                            case "bool":
                                i = this._select, r = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                                break;
                            default:
                                i = this._lerp, r = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                        }
                        this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                    }
                    accumulate(t, e) {
                        const n = this.buffer,
                            i = this.valueSize,
                            r = t * i + i;
                        let s = this.cumulativeWeight;
                        if (0 === s) {
                            for (let t = 0; t !== i; ++t) n[r + t] = n[t];
                            s = e
                        } else {
                            s += e;
                            const t = e / s;
                            this._mixBufferRegion(n, r, 0, t, i)
                        }
                        this.cumulativeWeight = s
                    }
                    accumulateAdditive(t) {
                        const e = this.buffer,
                            n = this.valueSize,
                            i = n * this._addIndex;
                        0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, i, 0, t, n), this.cumulativeWeightAdditive += t
                    }
                    apply(t) {
                        const e = this.valueSize,
                            n = this.buffer,
                            i = t * e + e,
                            r = this.cumulativeWeight,
                            s = this.cumulativeWeightAdditive,
                            o = this.binding;
                        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                            const t = e * this._origIndex;
                            this._mixBufferRegion(n, i, t, 1 - r, e)
                        }
                        s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
                        for (let t = e, r = e + e; t !== r; ++t)
                            if (n[t] !== n[t + e]) { o.setValue(n, i); break }
                    }
                    saveOriginalState() {
                        const t = this.binding,
                            e = this.buffer,
                            n = this.valueSize,
                            i = n * this._origIndex;
                        t.getValue(e, i);
                        for (let t = n, r = i; t !== r; ++t) e[t] = e[i + t % n];
                        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                    }
                    restoreOriginalState() {
                        const t = 3 * this.valueSize;
                        this.binding.setValue(this.buffer, t)
                    }
                    _setAdditiveIdentityNumeric() {
                        const t = this._addIndex * this.valueSize,
                            e = t + this.valueSize;
                        for (let n = t; n < e; n++) this.buffer[n] = 0
                    }
                    _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 }
                    _setAdditiveIdentityOther() {
                        const t = this._origIndex * this.valueSize,
                            e = this._addIndex * this.valueSize;
                        for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
                    }
                    _select(t, e, n, i, r) {
                        if (i >= .5)
                            for (let i = 0; i !== r; ++i) t[e + i] = t[n + i]
                    }
                    _slerp(t, e, n, i) { di.slerpFlat(t, e, t, e, t, n, i) }
                    _slerpAdditive(t, e, n, i, r) {
                        const s = this._workIndex * r;
                        di.multiplyQuaternionsFlat(t, s, t, e, t, n), di.slerpFlat(t, e, t, e, t, s, i)
                    }
                    _lerp(t, e, n, i, r) {
                        const s = 1 - i;
                        for (let o = 0; o !== r; ++o) {
                            const r = e + o;
                            t[r] = t[r] * s + t[n + o] * i
                        }
                    }
                    _lerpAdditive(t, e, n, i, r) {
                        for (let s = 0; s !== r; ++s) {
                            const r = e + s;
                            t[r] = t[r] + t[n + s] * i
                        }
                    }
                }
                const Ud = new RegExp("[\\[\\]\\.:\\/]", "g"),
                    Hd = "[^\\[\\]\\.:\\/]",
                    kd = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                    Gd = /((?:WC+[\/:])*)/.source.replace("WC", Hd),
                    Vd = /(WCOD+)?/.source.replace("WCOD", kd),
                    Wd = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Hd),
                    jd = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Hd),
                    qd = new RegExp("^" + Gd + Vd + Wd + jd + "$"),
                    Xd = ["material", "materials", "bones"];
                class Yd {
                    constructor(t, e, n) { this.path = e, this.parsedPath = n || Yd.parseTrackName(e), this.node = Yd.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound }
                    static create(t, e, n) { return t && t.isAnimationObjectGroup ? new Yd.Composite(t, e, n) : new Yd(t, e, n) }
                    static sanitizeNodeName(t) { return t.replace(/\s/g, "_").replace(Ud, "") }
                    static parseTrackName(t) {
                        const e = qd.exec(t);
                        if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                        const n = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] },
                            i = n.nodeName && n.nodeName.lastIndexOf(".");
                        if (void 0 !== i && -1 !== i) { const t = n.nodeName.substring(i + 1); - 1 !== Xd.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t) }
                        if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                        return n
                    }
                    static findNode(t, e) {
                        if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                        if (t.skeleton) { const n = t.skeleton.getBoneByName(e); if (void 0 !== n) return n }
                        if (t.children) {
                            const n = function(t) { for (let i = 0; i < t.length; i++) { const r = t[i]; if (r.name === e || r.uuid === e) return r; const s = n(r.children); if (s) return s } return null },
                                i = n(t.children);
                            if (i) return i
                        }
                        return null
                    }
                    _getValue_unavailable() {}
                    _setValue_unavailable() {}
                    _getValue_direct(t, e) { t[e] = this.targetObject[this.propertyName] }
                    _getValue_array(t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i] }
                    _getValue_arrayElement(t, e) { t[e] = this.resolvedProperty[this.propertyIndex] }
                    _getValue_toArray(t, e) { this.resolvedProperty.toArray(t, e) }
                    _setValue_direct(t, e) { this.targetObject[this.propertyName] = t[e] }
                    _setValue_direct_setNeedsUpdate(t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0 }
                    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }
                    _setValue_array(t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++] }
                    _setValue_array_setNeedsUpdate(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_arrayElement(t, e) { this.resolvedProperty[this.propertyIndex] = t[e] }
                    _setValue_arrayElement_setNeedsUpdate(t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0 }
                    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }
                    _setValue_fromArray(t, e) { this.resolvedProperty.fromArray(t, e) }
                    _setValue_fromArray_setNeedsUpdate(t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0 }
                    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0 }
                    _getValue_unbound(t, e) { this.bind(), this.getValue(t, e) }
                    _setValue_unbound(t, e) { this.bind(), this.setValue(t, e) }
                    bind() {
                        let t = this.node;
                        const e = this.parsedPath,
                            n = e.objectName,
                            i = e.propertyName;
                        let r = e.propertyIndex;
                        if (t || (t = Yd.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                        if (n) {
                            let i = e.objectIndex;
                            switch (n) {
                                case "materials":
                                    if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    t = t.material.materials;
                                    break;
                                case "bones":
                                    if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    t = t.skeleton.bones;
                                    for (let e = 0; e < t.length; e++)
                                        if (t[e].name === i) { i = e; break }
                                    break;
                                default:
                                    if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    t = t[n]
                            }
                            if (void 0 !== i) {
                                if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                t = t[i]
                            }
                        }
                        const s = t[i];
                        if (void 0 === s) { const n = e.nodeName; return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t) }
                        let o = this.Versioning.None;
                        this.targetObject = t, void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
                        let a = this.BindingType.Direct;
                        if (void 0 !== r) {
                            if ("morphTargetInfluences" === i) {
                                if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                                if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                            }
                            a = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                        } else void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                        this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o]
                    }
                    unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound }
                }
                Yd.Composite = class {
                    constructor(t, e, n) {
                        const i = n || Yd.parseTrackName(e);
                        this._targetGroup = t, this._bindings = t.subscribe_(e, i)
                    }
                    getValue(t, e) {
                        this.bind();
                        const n = this._targetGroup.nCachedObjects_,
                            i = this._bindings[n];
                        void 0 !== i && i.getValue(t, e)
                    }
                    setValue(t, e) { const n = this._bindings; for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e) }
                    bind() { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind() }
                    unbind() { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind() }
                }, Yd.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Yd.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, Yd.prototype.GetterByBindingType = [Yd.prototype._getValue_direct, Yd.prototype._getValue_array, Yd.prototype._getValue_arrayElement, Yd.prototype._getValue_toArray], Yd.prototype.SetterByBindingTypeAndVersioning = [
                    [Yd.prototype._setValue_direct, Yd.prototype._setValue_direct_setNeedsUpdate, Yd.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                    [Yd.prototype._setValue_array, Yd.prototype._setValue_array_setNeedsUpdate, Yd.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                    [Yd.prototype._setValue_arrayElement, Yd.prototype._setValue_arrayElement_setNeedsUpdate, Yd.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                    [Yd.prototype._setValue_fromArray, Yd.prototype._setValue_fromArray_setNeedsUpdate, Yd.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
                ];
                class Zd {
                    constructor() {
                        this.uuid = Gn(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                        const t = {};
                        this._indicesByUUID = t;
                        for (let e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;
                        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                        const e = this;
                        this.stats = { objects: {get total() { return e._objects.length }, get inUse() { return this.total - e.nCachedObjects_ } }, get bindingsPerObject() { return e._bindings.length } }
                    }
                    add() {
                        const t = this._objects,
                            e = this._indicesByUUID,
                            n = this._paths,
                            i = this._parsedPaths,
                            r = this._bindings,
                            s = r.length;
                        let o, a = t.length,
                            l = this.nCachedObjects_;
                        for (let c = 0, h = arguments.length; c !== h; ++c) {
                            const h = arguments[c],
                                u = h.uuid;
                            let d = e[u];
                            if (void 0 === d) { d = a++, e[u] = d, t.push(h); for (let t = 0, e = s; t !== e; ++t) r[t].push(new Yd(h, n[t], i[t])) } else if (d < l) {
                                o = t[d];
                                const a = --l,
                                    c = t[a];
                                e[c.uuid] = d, t[d] = c, e[u] = a, t[a] = h;
                                for (let t = 0, e = s; t !== e; ++t) {
                                    const e = r[t],
                                        s = e[a];
                                    let o = e[d];
                                    e[d] = s, void 0 === o && (o = new Yd(h, n[t], i[t])), e[a] = o
                                }
                            } else t[d] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                        }
                        this.nCachedObjects_ = l
                    }
                    remove() {
                        const t = this._objects,
                            e = this._indicesByUUID,
                            n = this._bindings,
                            i = n.length;
                        let r = this.nCachedObjects_;
                        for (let s = 0, o = arguments.length; s !== o; ++s) {
                            const o = arguments[s],
                                a = o.uuid,
                                l = e[a];
                            if (void 0 !== l && l >= r) {
                                const s = r++,
                                    c = t[s];
                                e[c.uuid] = l, t[l] = c, e[a] = s, t[s] = o;
                                for (let t = 0, e = i; t !== e; ++t) {
                                    const e = n[t],
                                        i = e[s],
                                        r = e[l];
                                    e[l] = i, e[s] = r
                                }
                            }
                        }
                        this.nCachedObjects_ = r
                    }
                    uncache() {
                        const t = this._objects,
                            e = this._indicesByUUID,
                            n = this._bindings,
                            i = n.length;
                        let r = this.nCachedObjects_,
                            s = t.length;
                        for (let o = 0, a = arguments.length; o !== a; ++o) {
                            const a = arguments[o].uuid,
                                l = e[a];
                            if (void 0 !== l)
                                if (delete e[a], l < r) {
                                    const o = --r,
                                        a = t[o],
                                        c = --s,
                                        h = t[c];
                                    e[a.uuid] = l, t[l] = a, e[h.uuid] = o, t[o] = h, t.pop();
                                    for (let t = 0, e = i; t !== e; ++t) {
                                        const e = n[t],
                                            i = e[o],
                                            r = e[c];
                                        e[l] = i, e[o] = r, e.pop()
                                    }
                                } else {
                                    const r = --s,
                                        o = t[r];
                                    r > 0 && (e[o.uuid] = l), t[l] = o, t.pop();
                                    for (let t = 0, e = i; t !== e; ++t) {
                                        const e = n[t];
                                        e[l] = e[r], e.pop()
                                    }
                                }
                        }
                        this.nCachedObjects_ = r
                    }
                    subscribe_(t, e) {
                        const n = this._bindingsIndicesByPath;
                        let i = n[t];
                        const r = this._bindings;
                        if (void 0 !== i) return r[i];
                        const s = this._paths,
                            o = this._parsedPaths,
                            a = this._objects,
                            l = a.length,
                            c = this.nCachedObjects_,
                            h = new Array(l);
                        i = r.length, n[t] = i, s.push(t), o.push(e), r.push(h);
                        for (let n = c, i = a.length; n !== i; ++n) {
                            const i = a[n];
                            h[n] = new Yd(i, t, e)
                        }
                        return h
                    }
                    unsubscribe_(t) {
                        const e = this._bindingsIndicesByPath,
                            n = e[t];
                        if (void 0 !== n) {
                            const i = this._paths,
                                r = this._parsedPaths,
                                s = this._bindings,
                                o = s.length - 1,
                                a = s[o];
                            e[t[o]] = n, s[n] = a, s.pop(), r[n] = r[o], r.pop(), i[n] = i[o], i.pop()
                        }
                    }
                }
                Zd.prototype.isAnimationObjectGroup = !0;
                class Jd {
                    constructor(t, e, n = null, i = e.blendMode) {
                        this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = i;
                        const r = e.tracks,
                            s = r.length,
                            o = new Array(s),
                            a = { endingStart: Ge, endingEnd: Ge };
                        for (let t = 0; t !== s; ++t) {
                            const e = r[t].createInterpolant(null);
                            o[t] = e, e.settings = a
                        }
                        this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Fe, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                    }
                    play() { return this._mixer._activateAction(this), this }
                    stop() { return this._mixer._deactivateAction(this), this.reset() }
                    reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() }
                    isRunning() { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) }
                    isScheduled() { return this._mixer._isActiveAction(this) }
                    startAt(t) { return this._startTime = t, this }
                    setLoop(t, e) { return this.loop = t, this.repetitions = e, this }
                    setEffectiveWeight(t) { return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading() }
                    getEffectiveWeight() { return this._effectiveWeight }
                    fadeIn(t) { return this._scheduleFading(t, 0, 1) }
                    fadeOut(t) { return this._scheduleFading(t, 1, 0) }
                    crossFadeFrom(t, e, n) {
                        if (t.fadeOut(e), this.fadeIn(e), n) {
                            const n = this._clip.duration,
                                i = t._clip.duration,
                                r = i / n,
                                s = n / i;
                            t.warp(1, r, e), this.warp(s, 1, e)
                        }
                        return this
                    }
                    crossFadeTo(t, e, n) { return t.crossFadeFrom(this, e, n) }
                    stopFading() { const t = this._weightInterpolant; return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }
                    setEffectiveTimeScale(t) { return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping() }
                    getEffectiveTimeScale() { return this._effectiveTimeScale }
                    setDuration(t) { return this.timeScale = this._clip.duration / t, this.stopWarping() }
                    syncWith(t) { return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping() }
                    halt(t) { return this.warp(this._effectiveTimeScale, 0, t) }
                    warp(t, e, n) {
                        const i = this._mixer,
                            r = i.time,
                            s = this.timeScale;
                        let o = this._timeScaleInterpolant;
                        null === o && (o = i._lendControlInterpolant(), this._timeScaleInterpolant = o);
                        const a = o.parameterPositions,
                            l = o.sampleValues;
                        return a[0] = r, a[1] = r + n, l[0] = t / s, l[1] = e / s, this
                    }
                    stopWarping() { const t = this._timeScaleInterpolant; return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }
                    getMixer() { return this._mixer }
                    getClip() { return this._clip }
                    getRoot() { return this._localRoot || this._mixer._root }
                    _update(t, e, n, i) {
                        if (!this.enabled) return void this._updateWeight(t);
                        const r = this._startTime;
                        if (null !== r) {
                            const i = (t - r) * n;
                            if (i < 0 || 0 === n) return;
                            this._startTime = null, e = n * i
                        }
                        e *= this._updateTimeScale(t);
                        const s = this._updateTime(e),
                            o = this._updateWeight(t);
                        if (o > 0) {
                            const t = this._interpolants,
                                e = this._propertyBindings;
                            if (this.blendMode === qe)
                                for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(s), e[n].accumulateAdditive(o);
                            else
                                for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(s), e[n].accumulate(i, o)
                        }
                    }
                    _updateWeight(t) {
                        let e = 0;
                        if (this.enabled) {
                            e = this.weight;
                            const n = this._weightInterpolant;
                            if (null !== n) {
                                const i = n.evaluate(t)[0];
                                e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = e, e
                    }
                    _updateTimeScale(t) {
                        let e = 0;
                        if (!this.paused) {
                            e = this.timeScale;
                            const n = this._timeScaleInterpolant;
                            null !== n && (e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e))
                        }
                        return this._effectiveTimeScale = e, e
                    }
                    _updateTime(t) {
                        const e = this._clip.duration,
                            n = this.loop;
                        let i = this.time + t,
                            r = this._loopCount;
                        const s = n === ze;
                        if (0 === t) return -1 === r ? i : s && 1 == (1 & r) ? e - i : i;
                        if (n === Oe) {
                            -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                            t: {
                                if (i >= e) i = e;
                                else {
                                    if (!(i < 0)) { this.time = i; break t }
                                    i = 0
                                }
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                this.time = i,
                                this._mixer.dispatchEvent({ type: "finished", action: this, direction: t < 0 ? -1 : 1 })
                            }
                        } else {
                            if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), i >= e || i < 0) {
                                const n = Math.floor(i / e);
                                i -= e * n, r += Math.abs(n);
                                const o = this.repetitions - r;
                                if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = t > 0 ? e : 0, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t > 0 ? 1 : -1 });
                                else {
                                    if (1 === o) {
                                        const e = t < 0;
                                        this._setEndings(e, !e, s)
                                    } else this._setEndings(!1, !1, s);
                                    this._loopCount = r, this.time = i, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n })
                                }
                            } else this.time = i;
                            if (s && 1 == (1 & r)) return e - i
                        }
                        return i
                    }
                    _setEndings(t, e, n) {
                        const i = this._interpolantSettings;
                        n ? (i.endingStart = Ve, i.endingEnd = Ve) : (i.endingStart = t ? this.zeroSlopeAtStart ? Ve : Ge : We, i.endingEnd = e ? this.zeroSlopeAtEnd ? Ve : Ge : We)
                    }
                    _scheduleFading(t, e, n) {
                        const i = this._mixer,
                            r = i.time;
                        let s = this._weightInterpolant;
                        null === s && (s = i._lendControlInterpolant(), this._weightInterpolant = s);
                        const o = s.parameterPositions,
                            a = s.sampleValues;
                        return o[0] = r, a[0] = e, o[1] = r + t, a[1] = n, this
                    }
                }
                class Kd extends On {
                    constructor(t) { super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 }
                    _bindAction(t, e) {
                        const n = t._localRoot || this._root,
                            i = t._clip.tracks,
                            r = i.length,
                            s = t._propertyBindings,
                            o = t._interpolants,
                            a = n.uuid,
                            l = this._bindingsByRootAndName;
                        let c = l[a];
                        void 0 === c && (c = {}, l[a] = c);
                        for (let t = 0; t !== r; ++t) {
                            const r = i[t],
                                l = r.name;
                            let h = c[l];
                            if (void 0 !== h) s[t] = h;
                            else {
                                if (h = s[t], void 0 !== h) { null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, a, l)); continue }
                                const i = e && e._propertyBindings[t].binding.parsedPath;
                                h = new zd(Yd.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, a, l), s[t] = h
                            }
                            o[t].resultBuffer = h.buffer
                        }
                    }
                    _activateAction(t) {
                        if (!this._isActiveAction(t)) {
                            if (null === t._cacheIndex) {
                                const e = (t._localRoot || this._root).uuid,
                                    n = t._clip.uuid,
                                    i = this._actionsByClip[n];
                                this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e)
                            }
                            const e = t._propertyBindings;
                            for (let t = 0, n = e.length; t !== n; ++t) {
                                const n = e[t];
                                0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                            }
                            this._lendAction(t)
                        }
                    }
                    _deactivateAction(t) {
                        if (this._isActiveAction(t)) {
                            const e = t._propertyBindings;
                            for (let t = 0, n = e.length; t !== n; ++t) {
                                const n = e[t];
                                0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                            }
                            this._takeBackAction(t)
                        }
                    }
                    _initMemoryManager() {
                        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                        const t = this;
                        this.stats = { actions: {get total() { return t._actions.length }, get inUse() { return t._nActiveActions } }, bindings: {get total() { return t._bindings.length }, get inUse() { return t._nActiveBindings } }, controlInterpolants: {get total() { return t._controlInterpolants.length }, get inUse() { return t._nActiveControlInterpolants } } }
                    }
                    _isActiveAction(t) { const e = t._cacheIndex; return null !== e && e < this._nActiveActions }
                    _addInactiveAction(t, e, n) {
                        const i = this._actions,
                            r = this._actionsByClip;
                        let s = r[e];
                        if (void 0 === s) s = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, r[e] = s;
                        else {
                            const e = s.knownActions;
                            t._byClipCacheIndex = e.length, e.push(t)
                        }
                        t._cacheIndex = i.length, i.push(t), s.actionByRoot[n] = t
                    }
                    _removeInactiveAction(t) {
                        const e = this._actions,
                            n = e[e.length - 1],
                            i = t._cacheIndex;
                        n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null;
                        const r = t._clip.uuid,
                            s = this._actionsByClip,
                            o = s[r],
                            a = o.knownActions,
                            l = a[a.length - 1],
                            c = t._byClipCacheIndex;
                        l._byClipCacheIndex = c, a[c] = l, a.pop(), t._byClipCacheIndex = null, delete o.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete s[r], this._removeInactiveBindingsForAction(t)
                    }
                    _removeInactiveBindingsForAction(t) {
                        const e = t._propertyBindings;
                        for (let t = 0, n = e.length; t !== n; ++t) {
                            const n = e[t];
                            0 == --n.referenceCount && this._removeInactiveBinding(n)
                        }
                    }
                    _lendAction(t) {
                        const e = this._actions,
                            n = t._cacheIndex,
                            i = this._nActiveActions++,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    }
                    _takeBackAction(t) {
                        const e = this._actions,
                            n = t._cacheIndex,
                            i = --this._nActiveActions,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    }
                    _addInactiveBinding(t, e, n) {
                        const i = this._bindingsByRootAndName,
                            r = this._bindings;
                        let s = i[e];
                        void 0 === s && (s = {}, i[e] = s), s[n] = t, t._cacheIndex = r.length, r.push(t)
                    }
                    _removeInactiveBinding(t) {
                        const e = this._bindings,
                            n = t.binding,
                            i = n.rootNode.uuid,
                            r = n.path,
                            s = this._bindingsByRootAndName,
                            o = s[i],
                            a = e[e.length - 1],
                            l = t._cacheIndex;
                        a._cacheIndex = l, e[l] = a, e.pop(), delete o[r], 0 === Object.keys(o).length && delete s[i]
                    }
                    _lendBinding(t) {
                        const e = this._bindings,
                            n = t._cacheIndex,
                            i = this._nActiveBindings++,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    }
                    _takeBackBinding(t) {
                        const e = this._bindings,
                            n = t._cacheIndex,
                            i = --this._nActiveBindings,
                            r = e[i];
                        t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                    }
                    _lendControlInterpolant() {
                        const t = this._controlInterpolants,
                            e = this._nActiveControlInterpolants++;
                        let n = t[e];
                        return void 0 === n && (n = new yu(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
                    }
                    _takeBackControlInterpolant(t) {
                        const e = this._controlInterpolants,
                            n = t.__cacheIndex,
                            i = --this._nActiveControlInterpolants,
                            r = e[i];
                        t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
                    }
                    clipAction(t, e, n) {
                        const i = e || this._root,
                            r = i.uuid;
                        let s = "string" == typeof t ? Lu.findByName(i, t) : t;
                        const o = null !== s ? s.uuid : t,
                            a = this._actionsByClip[o];
                        let l = null;
                        if (void 0 === n && (n = null !== s ? s.blendMode : je), void 0 !== a) {
                            const t = a.actionByRoot[r];
                            if (void 0 !== t && t.blendMode === n) return t;
                            l = a.knownActions[0], null === s && (s = l._clip)
                        }
                        if (null === s) return null;
                        const c = new Jd(this, s, e, n);
                        return this._bindAction(c, l), this._addInactiveAction(c, o, r), c
                    }
                    existingAction(t, e) {
                        const n = e || this._root,
                            i = n.uuid,
                            r = "string" == typeof t ? Lu.findByName(n, t) : t,
                            s = r ? r.uuid : t,
                            o = this._actionsByClip[s];
                        return void 0 !== o && o.actionByRoot[i] || null
                    }
                    stopAllAction() { const t = this._actions; for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop(); return this }
                    update(t) {
                        t *= this.timeScale;
                        const e = this._actions,
                            n = this._nActiveActions,
                            i = this.time += t,
                            r = Math.sign(t),
                            s = this._accuIndex ^= 1;
                        for (let o = 0; o !== n; ++o) e[o]._update(i, t, r, s);
                        const o = this._bindings,
                            a = this._nActiveBindings;
                        for (let t = 0; t !== a; ++t) o[t].apply(s);
                        return this
                    }
                    setTime(t) { this.time = 0; for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0; return this.update(t) }
                    getRoot() { return this._root }
                    uncacheClip(t) {
                        const e = this._actions,
                            n = t.uuid,
                            i = this._actionsByClip,
                            r = i[n];
                        if (void 0 !== r) {
                            const t = r.knownActions;
                            for (let n = 0, i = t.length; n !== i; ++n) {
                                const i = t[n];
                                this._deactivateAction(i);
                                const r = i._cacheIndex,
                                    s = e[e.length - 1];
                                i._cacheIndex = null, i._byClipCacheIndex = null, s._cacheIndex = r, e[r] = s, e.pop(), this._removeInactiveBindingsForAction(i)
                            }
                            delete i[n]
                        }
                    }
                    uncacheRoot(t) {
                        const e = t.uuid,
                            n = this._actionsByClip;
                        for (const t in n) {
                            const i = n[t].actionByRoot[e];
                            void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                        }
                        const i = this._bindingsByRootAndName[e];
                        if (void 0 !== i)
                            for (const t in i) {
                                const e = i[t];
                                e.restoreOriginalState(), this._removeInactiveBinding(e)
                            }
                    }
                    uncacheAction(t, e) {
                        const n = this.existingAction(t, e);
                        null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                    }
                }
                Kd.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
                class Qd {
                    constructor(t) { "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t }
                    clone() { return new Qd(void 0 === this.value.clone ? this.value : this.value.clone()) }
                }
                class $d extends Pl {
                    constructor(t, e, n = 1) { super(t, e), this.meshPerAttribute = n }
                    copy(t) { return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this }
                    clone(t) { const e = super.clone(t); return e.meshPerAttribute = this.meshPerAttribute, e }
                    toJSON(t) { const e = super.toJSON(t); return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e }
                }
                $d.prototype.isInstancedInterleavedBuffer = !0;
                class tp {
                    constructor(t, e, n, i, r) { this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0 }
                    set needsUpdate(t) {!0 === t && this.version++ }
                    setBuffer(t) { return this.buffer = t, this }
                    setType(t, e) { return this.type = t, this.elementSize = e, this }
                    setItemSize(t) { return this.itemSize = t, this }
                    setCount(t) { return this.count = t, this }
                }
                tp.prototype.isGLBufferAttribute = !0;
                class ep {
                    constructor(t, e, n = 0, i = 1 / 0) { this.ray = new Vi(t, e), this.near = n, this.far = i, this.camera = null, this.layers = new er, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } }
                    set(t, e) { this.ray.set(t, e) }
                    setFromCamera(t, e) { e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type) }
                    intersectObject(t, e = !0, n = []) { return ip(t, this, n, e), n.sort(np), n }
                    intersectObjects(t, e = !0, n = []) { for (let i = 0, r = t.length; i < r; i++) ip(t[i], this, n, e); return n.sort(np), n }
                }

                function np(t, e) { return t.distance - e.distance }

                function ip(t, e, n, i) { if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i) { const i = t.children; for (let t = 0, r = i.length; t < r; t++) ip(i[t], e, n, !0) } }
                class rp {
                    constructor(t = 1, e = 0, n = 0) { return this.radius = t, this.phi = e, this.theta = n, this }
                    set(t, e, n) { return this.radius = t, this.phi = e, this.theta = n, this }
                    copy(t) { return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this }
                    makeSafe() { const t = 1e-6; return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this }
                    setFromVector3(t) { return this.setFromCartesianCoords(t.x, t.y, t.z) }
                    setFromCartesianCoords(t, e, n) { return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(Vn(e / this.radius, -1, 1))), this }
                    clone() { return (new this.constructor).copy(this) }
                }
                class sp {
                    constructor(t = 1, e = 0, n = 0) { return this.radius = t, this.theta = e, this.y = n, this }
                    set(t, e, n) { return this.radius = t, this.theta = e, this.y = n, this }
                    copy(t) { return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this }
                    setFromVector3(t) { return this.setFromCartesianCoords(t.x, t.y, t.z) }
                    setFromCartesianCoords(t, e, n) { return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this }
                    clone() { return (new this.constructor).copy(this) }
                }
                const op = new Jn;
                class ap {
                    constructor(t = new Jn(1 / 0, 1 / 0), e = new Jn(-1 / 0, -1 / 0)) { this.min = t, this.max = e }
                    set(t, e) { return this.min.copy(t), this.max.copy(e), this }
                    setFromPoints(t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]); return this }
                    setFromCenterAndSize(t, e) { const n = op.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this }
                    clone() { return (new this.constructor).copy(this) }
                    copy(t) { return this.min.copy(t.min), this.max.copy(t.max), this }
                    makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this }
                    isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y }
                    getCenter(t) { return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) }
                    getSize(t) { return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min) }
                    expandByPoint(t) { return this.min.min(t), this.max.max(t), this }
                    expandByVector(t) { return this.min.sub(t), this.max.add(t), this }
                    expandByScalar(t) { return this.min.addScalar(-t), this.max.addScalar(t), this }
                    containsPoint(t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y) }
                    containsBox(t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y }
                    getParameter(t, e) { return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y)) }
                    intersectsBox(t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y) }
                    clampPoint(t, e) { return e.copy(t).clamp(this.min, this.max) }
                    distanceToPoint(t) { return op.copy(t).clamp(this.min, this.max).sub(t).length() }
                    intersect(t) { return this.min.max(t.min), this.max.min(t.max), this }
                    union(t) { return this.min.min(t.min), this.max.max(t.max), this }
                    translate(t) { return this.min.add(t), this.max.add(t), this }
                    equals(t) { return t.min.equals(this.min) && t.max.equals(this.max) }
                }
                ap.prototype.isBox2 = !0;
                const lp = new pi,
                    cp = new pi;
                class hp {
                    constructor(t = new pi, e = new pi) { this.start = t, this.end = e }
                    set(t, e) { return this.start.copy(t), this.end.copy(e), this }
                    copy(t) { return this.start.copy(t.start), this.end.copy(t.end), this }
                    getCenter(t) { return t.addVectors(this.start, this.end).multiplyScalar(.5) }
                    delta(t) { return t.subVectors(this.end, this.start) }
                    distanceSq() { return this.start.distanceToSquared(this.end) }
                    distance() { return this.start.distanceTo(this.end) }
                    at(t, e) { return this.delta(e).multiplyScalar(t).add(this.start) }
                    closestPointToPointParameter(t, e) { lp.subVectors(t, this.start), cp.subVectors(this.end, this.start); const n = cp.dot(cp); let i = cp.dot(lp) / n; return e && (i = Vn(i, 0, 1)), i }
                    closestPointToPoint(t, e, n) { const i = this.closestPointToPointParameter(t, e); return this.delta(n).multiplyScalar(i).add(this.start) }
                    applyMatrix4(t) { return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this }
                    equals(t) { return t.start.equals(this.start) && t.end.equals(this.end) }
                    clone() { return (new this.constructor).copy(this) }
                }
                const up = new pi;
                class dp extends fr {
                    constructor(t, e) {
                        super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
                        const n = new is,
                            i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                        for (let t = 0, e = 1, n = 32; t < n; t++, e++) {
                            const r = t / n * Math.PI * 2,
                                s = e / n * Math.PI * 2;
                            i.push(Math.cos(r), Math.sin(r), 1, Math.cos(s), Math.sin(s), 1)
                        }
                        n.setAttribute("position", new Yr(i, 3));
                        const r = new gc({ fog: !1, toneMapped: !1 });
                        this.cone = new Tc(n, r), this.add(this.cone), this.update()
                    }
                    dispose() { this.cone.geometry.dispose(), this.cone.material.dispose() }
                    update() {
                        this.light.updateMatrixWorld();
                        const t = this.light.distance ? this.light.distance : 1e3,
                            e = t * Math.tan(this.light.angle);
                        this.cone.scale.set(e, e, t), up.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(up), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                    }
                }
                const pp = new pi,
                    mp = new Wi,
                    fp = new Wi;
                class gp extends Tc {
                    constructor(t) {
                        const e = vp(t),
                            n = new is,
                            i = [],
                            r = [],
                            s = new Br(0, 0, 1),
                            o = new Br(0, 1, 0);
                        for (let t = 0; t < e.length; t++) {
                            const n = e[t];
                            n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(o.r, o.g, o.b))
                        }
                        n.setAttribute("position", new Yr(i, 3)), n.setAttribute("color", new Yr(r, 3)), super(n, new gc({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
                    }
                    updateMatrixWorld(t) {
                        const e = this.bones,
                            n = this.geometry,
                            i = n.getAttribute("position");
                        fp.copy(this.root.matrixWorld).invert();
                        for (let t = 0, n = 0; t < e.length; t++) {
                            const r = e[t];
                            r.parent && r.parent.isBone && (mp.multiplyMatrices(fp, r.matrixWorld), pp.setFromMatrixPosition(mp), i.setXYZ(n, pp.x, pp.y, pp.z), mp.multiplyMatrices(fp, r.parent.matrixWorld), pp.setFromMatrixPosition(mp), i.setXYZ(n + 1, pp.x, pp.y, pp.z), n += 2)
                        }
                        n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
                    }
                }

                function vp(t) {
                    const e = [];
                    t && t.isBone && e.push(t);
                    for (let n = 0; n < t.children.length; n++) e.push.apply(e, vp(t.children[n]));
                    return e
                }
                class yp extends bs {
                    constructor(t, e, n) { super(new Kh(e, 4, 2), new Or({ wireframe: !0, fog: !1, toneMapped: !1 })), this.light = t, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() }
                    dispose() { this.geometry.dispose(), this.material.dispose() }
                    update() { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) }
                }
                const xp = new pi,
                    _p = new Br,
                    bp = new Br;
                class wp extends fr {
                    constructor(t, e, n) {
                        super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
                        const i = new Yh(e);
                        i.rotateY(.5 * Math.PI), this.material = new Or({ wireframe: !0, fog: !1, toneMapped: !1 }), void 0 === this.color && (this.material.vertexColors = !0);
                        const r = i.getAttribute("position"),
                            s = new Float32Array(3 * r.count);
                        i.setAttribute("color", new Ur(s, 3)), this.add(new bs(i, this.material)), this.update()
                    }
                    dispose() { this.children[0].geometry.dispose(), this.children[0].material.dispose() }
                    update() {
                        const t = this.children[0];
                        if (void 0 !== this.color) this.material.color.set(this.color);
                        else {
                            const e = t.geometry.getAttribute("color");
                            _p.copy(this.light.color), bp.copy(this.light.groundColor);
                            for (let t = 0, n = e.count; t < n; t++) {
                                const i = t < n / 2 ? _p : bp;
                                e.setXYZ(t, i.r, i.g, i.b)
                            }
                            e.needsUpdate = !0
                        }
                        t.lookAt(xp.setFromMatrixPosition(this.light.matrixWorld).negate())
                    }
                }
                class Mp extends Tc {
                    constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
                        n = new Br(n), i = new Br(i);
                        const r = e / 2,
                            s = t / e,
                            o = t / 2,
                            a = [],
                            l = [];
                        for (let t = 0, c = 0, h = -o; t <= e; t++, h += s) {
                            a.push(-o, 0, h, o, 0, h), a.push(h, 0, -o, h, 0, o);
                            const e = t === r ? n : i;
                            e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3
                        }
                        const c = new is;
                        c.setAttribute("position", new Yr(a, 3)), c.setAttribute("color", new Yr(l, 3)), super(c, new gc({ vertexColors: !0, toneMapped: !1 })), this.type = "GridHelper"
                    }
                }
                class Sp extends Tc {
                    constructor(t = 10, e = 16, n = 8, i = 64, r = 4473924, s = 8947848) {
                        r = new Br(r), s = new Br(s);
                        const o = [],
                            a = [];
                        for (let n = 0; n <= e; n++) {
                            const i = n / e * (2 * Math.PI),
                                l = Math.sin(i) * t,
                                c = Math.cos(i) * t;
                            o.push(0, 0, 0), o.push(l, 0, c);
                            const h = 1 & n ? r : s;
                            a.push(h.r, h.g, h.b), a.push(h.r, h.g, h.b)
                        }
                        for (let e = 0; e <= n; e++) {
                            const l = 1 & e ? r : s,
                                c = t - t / n * e;
                            for (let t = 0; t < i; t++) {
                                let e = t / i * (2 * Math.PI),
                                    n = Math.sin(e) * c,
                                    r = Math.cos(e) * c;
                                o.push(n, 0, r), a.push(l.r, l.g, l.b), e = (t + 1) / i * (2 * Math.PI), n = Math.sin(e) * c, r = Math.cos(e) * c, o.push(n, 0, r), a.push(l.r, l.g, l.b)
                            }
                        }
                        const l = new is;
                        l.setAttribute("position", new Yr(o, 3)), l.setAttribute("color", new Yr(a, 3)), super(l, new gc({ vertexColors: !0, toneMapped: !1 })), this.type = "PolarGridHelper"
                    }
                }
                const Tp = new pi,
                    Ep = new pi,
                    Ap = new pi;
                class Lp extends fr {
                    constructor(t, e, n) {
                        super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1);
                        let i = new is;
                        i.setAttribute("position", new Yr([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
                        const r = new gc({ fog: !1, toneMapped: !1 });
                        this.lightPlane = new wc(i, r), this.add(this.lightPlane), i = new is, i.setAttribute("position", new Yr([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new wc(i, r), this.add(this.targetLine), this.update()
                    }
                    dispose() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() }
                    update() { Tp.setFromMatrixPosition(this.light.matrixWorld), Ep.setFromMatrixPosition(this.light.target.matrixWorld), Ap.subVectors(Ep, Tp), this.lightPlane.lookAt(Ep), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Ep), this.targetLine.scale.z = Ap.length() }
                }
                const Rp = new pi,
                    Cp = new Ls;
                class Pp extends Tc {
                    constructor(t) {
                        const e = new is,
                            n = new gc({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
                            i = [],
                            r = [],
                            s = {},
                            o = new Br(16755200),
                            a = new Br(16711680),
                            l = new Br(43775),
                            c = new Br(16777215),
                            h = new Br(3355443);

                        function u(t, e, n) { d(t, n), d(e, n) }

                        function d(t, e) { i.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === s[t] && (s[t] = []), s[t].push(i.length / 3 - 1) }
                        u("n1", "n2", o), u("n2", "n4", o), u("n4", "n3", o), u("n3", "n1", o), u("f1", "f2", o), u("f2", "f4", o), u("f4", "f3", o), u("f3", "f1", o), u("n1", "f1", o), u("n2", "f2", o), u("n3", "f3", o), u("n4", "f4", o), u("p", "n1", a), u("p", "n2", a), u("p", "n3", a), u("p", "n4", a), u("u1", "u2", l), u("u2", "u3", l), u("u3", "u1", l), u("c", "t", c), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), e.setAttribute("position", new Yr(i, 3)), e.setAttribute("color", new Yr(r, 3)), super(e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
                    }
                    update() {
                        const t = this.geometry,
                            e = this.pointMap;
                        Cp.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Ip("c", e, t, Cp, 0, 0, -1), Ip("t", e, t, Cp, 0, 0, 1), Ip("n1", e, t, Cp, -1, -1, -1), Ip("n2", e, t, Cp, 1, -1, -1), Ip("n3", e, t, Cp, -1, 1, -1), Ip("n4", e, t, Cp, 1, 1, -1), Ip("f1", e, t, Cp, -1, -1, 1), Ip("f2", e, t, Cp, 1, -1, 1), Ip("f3", e, t, Cp, -1, 1, 1), Ip("f4", e, t, Cp, 1, 1, 1), Ip("u1", e, t, Cp, .7, 1.1, -1), Ip("u2", e, t, Cp, -.7, 1.1, -1), Ip("u3", e, t, Cp, 0, 2, -1), Ip("cf1", e, t, Cp, -1, 0, 1), Ip("cf2", e, t, Cp, 1, 0, 1), Ip("cf3", e, t, Cp, 0, -1, 1), Ip("cf4", e, t, Cp, 0, 1, 1), Ip("cn1", e, t, Cp, -1, 0, -1), Ip("cn2", e, t, Cp, 1, 0, -1), Ip("cn3", e, t, Cp, 0, -1, -1), Ip("cn4", e, t, Cp, 0, 1, -1), t.getAttribute("position").needsUpdate = !0
                    }
                    dispose() { this.geometry.dispose(), this.material.dispose() }
                }

                function Ip(t, e, n, i, r, s, o) { Rp.set(r, s, o).unproject(i); const a = e[t]; if (void 0 !== a) { const t = n.getAttribute("position"); for (let e = 0, n = a.length; e < n; e++) t.setXYZ(a[e], Rp.x, Rp.y, Rp.z) } }
                const Dp = new gi;
                class Np extends Tc {
                    constructor(t, e = 16776960) {
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                            i = new Float32Array(24),
                            r = new is;
                        r.setIndex(new Ur(n, 1)), r.setAttribute("position", new Ur(i, 3)), super(r, new gc({ color: e, toneMapped: !1 })), this.object = t, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
                    }
                    update(t) {
                        if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Dp.setFromObject(this.object), Dp.isEmpty()) return;
                        const e = Dp.min,
                            n = Dp.max,
                            i = this.geometry.attributes.position,
                            r = i.array;
                        r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = e.x, r[4] = n.y, r[5] = n.z, r[6] = e.x, r[7] = e.y, r[8] = n.z, r[9] = n.x, r[10] = e.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = e.z, r[15] = e.x, r[16] = n.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = n.x, r[22] = e.y, r[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
                    }
                    setFromObject(t) { return this.object = t, this.update(), this }
                    copy(t) { return Tc.prototype.copy.call(this, t), this.object = t.object, this }
                }
                class Bp extends Tc {
                    constructor(t, e = 16776960) {
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                            i = new is;
                        i.setIndex(new Ur(n, 1)), i.setAttribute("position", new Yr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(i, new gc({ color: e, toneMapped: !1 })), this.box = t, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
                    }
                    updateMatrixWorld(t) {
                        const e = this.box;
                        e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(t))
                    }
                }
                class Op extends wc {
                    constructor(t, e = 1, n = 16776960) {
                        const i = n,
                            r = new is;
                        r.setAttribute("position", new Yr([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), super(r, new gc({ color: i, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = t, this.size = e;
                        const s = new is;
                        s.setAttribute("position", new Yr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), s.computeBoundingSphere(), this.add(new bs(s, new Or({ color: i, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 })))
                    }
                    updateMatrixWorld(t) {
                        let e = -this.plane.constant;
                        Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? f : m, this.lookAt(this.plane.normal), super.updateMatrixWorld(t)
                    }
                }
                const Fp = new pi;
                let zp, Up;
                class Hp extends fr {
                    constructor(t = new pi(0, 0, 1), e = new pi(0, 0, 0), n = 1, i = 16776960, r = .2 * n, s = .2 * r) { super(), this.type = "ArrowHelper", void 0 === zp && (zp = new is, zp.setAttribute("position", new Yr([0, 0, 0, 0, 1, 0], 3)), Up = new Uc(0, .5, 1, 5, 1), Up.translate(0, -.5, 0)), this.position.copy(e), this.line = new wc(zp, new gc({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new bs(Up, new Or({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, r, s) }
                    setDirection(t) {
                        if (t.y > .99999) this.quaternion.set(0, 0, 0, 1);
                        else if (t.y < -.99999) this.quaternion.set(1, 0, 0, 0);
                        else {
                            Fp.set(t.z, 0, -t.x).normalize();
                            const e = Math.acos(t.y);
                            this.quaternion.setFromAxisAngle(Fp, e)
                        }
                    }
                    setLength(t, e = .2 * t, n = .2 * e) { this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix() }
                    setColor(t) { this.line.material.color.set(t), this.cone.material.color.set(t) }
                    copy(t) { return super.copy(t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this }
                }
                class kp extends Tc {
                    constructor(t = 1) {
                        const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                            n = new is;
                        n.setAttribute("position", new Yr(e, 3)), n.setAttribute("color", new Yr([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(n, new gc({ vertexColors: !0, toneMapped: !1 })), this.type = "AxesHelper"
                    }
                    setColors(t, e, n) {
                        const i = new Br,
                            r = this.geometry.attributes.color.array;
                        return i.set(t), i.toArray(r, 0), i.toArray(r, 3), i.set(e), i.toArray(r, 6), i.toArray(r, 9), i.set(n), i.toArray(r, 12), i.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this
                    }
                    dispose() { this.geometry.dispose(), this.material.dispose() }
                }
                class Gp {
                    constructor() { this.type = "ShapePath", this.color = new Br, this.subPaths = [], this.currentPath = null }
                    moveTo(t, e) { return this.currentPath = new fh, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this }
                    lineTo(t, e) { return this.currentPath.lineTo(t, e), this }
                    quadraticCurveTo(t, e, n, i) { return this.currentPath.quadraticCurveTo(t, e, n, i), this }
                    bezierCurveTo(t, e, n, i, r, s) { return this.currentPath.bezierCurveTo(t, e, n, i, r, s), this }
                    splineThru(t) { return this.currentPath.splineThru(t), this }
                    toShapes(t, e) {
                        function n(t) {
                            const e = [];
                            for (let n = 0, i = t.length; n < i; n++) {
                                const i = t[n],
                                    r = new gh;
                                r.curves = i.curves, e.push(r)
                            }
                            return e
                        }

                        function i(t, e) {
                            const n = e.length;
                            let i = !1;
                            for (let r = n - 1, s = 0; s < n; r = s++) {
                                let n = e[r],
                                    o = e[s],
                                    a = o.x - n.x,
                                    l = o.y - n.y;
                                if (Math.abs(l) > Number.EPSILON) {
                                    if (l < 0 && (n = e[s], a = -a, o = e[r], l = -l), t.y < n.y || t.y > o.y) continue;
                                    if (t.y === n.y) { if (t.x === n.x) return !0 } else {
                                        const e = l * (t.x - n.x) - a * (t.y - n.y);
                                        if (0 === e) return !0;
                                        if (e < 0) continue;
                                        i = !i
                                    }
                                } else { if (t.y !== n.y) continue; if (o.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= o.x) return !0 }
                            }
                            return i
                        }
                        const r = kh.isClockWise,
                            s = this.subPaths;
                        if (0 === s.length) return [];
                        if (!0 === e) return n(s);
                        let o, a, l;
                        const c = [];
                        if (1 === s.length) return a = s[0], l = new gh, l.curves = a.curves, c.push(l), c;
                        let h = !r(s[0].getPoints());
                        h = t ? !h : h;
                        const u = [],
                            d = [];
                        let p, m, f = [],
                            g = 0;
                        d[g] = void 0, f[g] = [];
                        for (let e = 0, n = s.length; e < n; e++) a = s[e], p = a.getPoints(), o = r(p), o = t ? !o : o, o ? (!h && d[g] && g++, d[g] = { s: new gh, p }, d[g].s.curves = a.curves, h && g++, f[g] = []) : f[g].push({ h: a, p: p[0] });
                        if (!d[0]) return n(s);
                        if (d.length > 1) {
                            let t = !1;
                            const e = [];
                            for (let t = 0, e = d.length; t < e; t++) u[t] = [];
                            for (let n = 0, r = d.length; n < r; n++) {
                                const r = f[n];
                                for (let s = 0; s < r.length; s++) {
                                    const o = r[s];
                                    let a = !0;
                                    for (let r = 0; r < d.length; r++) i(o.p, d[r].p) && (n !== r && e.push({ froms: n, tos: r, hole: s }), a ? (a = !1, u[r].push(o)) : t = !0);
                                    a && u[n].push(o)
                                }
                            }
                            e.length > 0 && (t || (f = u))
                        }
                        for (let t = 0, e = d.length; t < e; t++) { l = d[t].s, c.push(l), m = f[t]; for (let t = 0, e = m.length; t < e; t++) l.holes.push(m[t].h) }
                        return c
                    }
                }
                const Vp = new Float32Array(1),
                    Wp = new Int32Array(Vp.buffer);
                class jp {
                    static toHalfFloat(t) {
                        t > 65504 && (console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504."), t = 65504), Vp[0] = t;
                        const e = Wp[0];
                        let n = e >> 16 & 32768,
                            i = e >> 12 & 2047;
                        const r = e >> 23 & 255;
                        return r < 103 ? n : r > 142 ? (n |= 31744, n |= (255 == r ? 0 : 1) && 8388607 & e, n) : r < 113 ? (i |= 2048, n |= (i >> 114 - r) + (i >> 113 - r & 1), n) : (n |= r - 112 << 10 | i >> 1, n += 1 & i, n)
                    }
                }
                const qp = 0,
                    Xp = 1,
                    Yp = 0,
                    Zp = 1,
                    Jp = 2;

                function Kp(t) { return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t }

                function Qp(t = []) { return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() { return t.slice() }, t }

                function $p(t, e) { return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Ic(t, e) }

                function tm(t) { return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Yl(t) }

                function em(t, e) { return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Ic(t, e) }

                function nm(t) { return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Ac(t) }

                function im(t) { return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Ac(t) }

                function rm(t) { return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Ac(t) }

                function sm(t, e, n) { return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new pi(t, e, n) }

                function om(t, e) { return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new Ur(t, e).setUsage(En) }

                function am(t, e) { return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Hr(t, e) }

                function lm(t, e) { return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new kr(t, e) }

                function cm(t, e) { return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Gr(t, e) }

                function hm(t, e) { return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Vr(t, e) }

                function um(t, e) { return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Wr(t, e) }

                function dm(t, e) { return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new jr(t, e) }

                function pm(t, e) { return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new qr(t, e) }

                function mm(t, e) { return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Yr(t, e) }

                function fm(t, e) { return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Zr(t, e) }

                function gm(t) { return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new kp(t) }

                function vm(t, e) { return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Np(t, e) }

                function ym(t, e) { return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Tc(new Xc(t.geometry), new gc({ color: void 0 !== e ? e : 16777215 })) }

                function xm(t, e) { return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Tc(new nu(t.geometry), new gc({ color: void 0 !== e ? e : 16777215 })) }

                function _m(t) { return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Bu(t) }

                function bm(t) { return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Hu(t) }

                function wm(t, e, n) { return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new Ds(t, n) }

                function Mm() { console.error("THREE.CanvasRenderer has been removed") }

                function Sm() { console.error("THREE.JSONLoader has been removed.") }
                Yc.create = function(t, e) { return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Yc.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t }, fh.prototype.fromPoints = function(t) { return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t) }, Mp.prototype.setColors = function() { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, gp.prototype.update = function() { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, Du.prototype.extractUrlBase = function(t) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), ld.extractUrlBase(t) }, Du.Handlers = { add: function() { console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.") }, get: function() { console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.") } }, ap.prototype.center = function(t) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t) }, ap.prototype.empty = function() { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, ap.prototype.isIntersectionBox = function(t) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, ap.prototype.size = function(t) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t) }, gi.prototype.center = function(t) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, gi.prototype.empty = function() { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, gi.prototype.isIntersectionBox = function(t) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, gi.prototype.isIntersectionSphere = function(t) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) }, gi.prototype.size = function(t) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t) }, Bi.prototype.empty = function() { return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, Hs.prototype.setFromMatrix = function(t) { return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t) }, hp.prototype.center = function(t) { return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, Kn.prototype.flattenToArrayOffset = function(t, e) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, Kn.prototype.multiplyVector3 = function(t) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, Kn.prototype.multiplyVector3Array = function() { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, Kn.prototype.applyToBufferAttribute = function(t) { return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, Kn.prototype.applyToVector3Array = function() { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") }, Kn.prototype.getInverse = function(t) { return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert() }, Wi.prototype.extractPosition = function(t) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t) }, Wi.prototype.flattenToArrayOffset = function(t, e) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, Wi.prototype.getPosition = function() { return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new pi).setFromMatrixColumn(this, 3) }, Wi.prototype.setRotationFromQuaternion = function(t) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t) }, Wi.prototype.multiplyToArray = function() { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, Wi.prototype.multiplyVector3 = function(t) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, Wi.prototype.multiplyVector4 = function(t) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, Wi.prototype.multiplyVector3Array = function() { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, Wi.prototype.rotateAxis = function(t) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this) }, Wi.prototype.crossVector = function(t) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, Wi.prototype.translate = function() { console.error("THREE.Matrix4: .translate() has been removed.") }, Wi.prototype.rotateX = function() { console.error("THREE.Matrix4: .rotateX() has been removed.") }, Wi.prototype.rotateY = function() { console.error("THREE.Matrix4: .rotateY() has been removed.") }, Wi.prototype.rotateZ = function() { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, Wi.prototype.rotateByAxis = function() { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, Wi.prototype.applyToBufferAttribute = function(t) { return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, Wi.prototype.applyToVector3Array = function() { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, Wi.prototype.makeFrustum = function(t, e, n, i, r, s) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, s) }, Wi.prototype.getInverse = function(t) { return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert() }, Fs.prototype.isIntersectionLine = function(t) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t) }, di.prototype.multiplyVector3 = function(t) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this) }, di.prototype.inverse = function() { return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert() }, Vi.prototype.isIntersectionBox = function(t) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, Vi.prototype.isIntersectionPlane = function(t) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t) }, Vi.prototype.isIntersectionSphere = function(t) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) }, Er.prototype.area = function() { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, Er.prototype.barycoordFromPoint = function(t, e) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e) }, Er.prototype.midpoint = function(t) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t) }, Er.prototypenormal = function(t) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t) }, Er.prototype.plane = function(t) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t) }, Er.barycoordFromPoint = function(t, e, n, i, r) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Er.getBarycoord(t, e, n, i, r) }, Er.normal = function(t, e, n, i) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Er.getNormal(t, e, n, i) }, gh.prototype.extractAllPoints = function(t) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t) }, gh.prototype.extrude = function(t) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Wh(this, t) }, gh.prototype.makeGeometry = function(t) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Jh(this, t) }, Jn.prototype.fromAttribute = function(t, e, n) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, Jn.prototype.distanceToManhattan = function(t) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, Jn.prototype.lengthManhattan = function() { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, pi.prototype.setEulerFromRotationMatrix = function() { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, pi.prototype.setEulerFromQuaternion = function() { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, pi.prototype.getPositionFromMatrix = function(t) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t) }, pi.prototype.getScaleFromMatrix = function(t) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t) }, pi.prototype.getColumnFromMatrix = function(t, e) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t) }, pi.prototype.applyProjection = function(t) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t) }, pi.prototype.fromAttribute = function(t, e, n) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, pi.prototype.distanceToManhattan = function(t) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, pi.prototype.lengthManhattan = function() { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, li.prototype.fromAttribute = function(t, e, n) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, li.prototype.lengthManhattan = function() { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, fr.prototype.getChildByName = function(t) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t) }, fr.prototype.renderDepth = function() { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, fr.prototype.translate = function(t, e) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t) }, fr.prototype.getWorldRotation = function() { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") }, fr.prototype.applyMatrix = function(t) { return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) }, Object.defineProperties(fr.prototype, { eulerOrder: { get: function() { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function(t) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t } }, useQuaternion: { get: function() { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function() { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), bs.prototype.setDrawMode = function() { console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") }, Object.defineProperties(bs.prototype, { drawMode: { get: function() { return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), Xe }, set: function() { console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } } }), rc.prototype.initBones = function() { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, Rs.prototype.setLens = function(t, e) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t) }, Object.defineProperties(Gu.prototype, { onlyShadow: { set: function() { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function(t) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t } }, shadowCameraLeft: { set: function(t) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t } }, shadowCameraRight: { set: function(t) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t } }, shadowCameraTop: { set: function(t) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t } }, shadowCameraBottom: { set: function(t) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t } }, shadowCameraNear: { set: function(t) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t } }, shadowCameraFar: { set: function(t) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t } }, shadowCameraVisible: { set: function() { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function(t) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t } }, shadowDarkness: { set: function() { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function(t) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t } }, shadowMapHeight: { set: function(t) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t } } }), Object.defineProperties(Ur.prototype, { length: { get: function() { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, dynamic: { get: function() { return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === En }, set: function() { console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(En) } } }), Ur.prototype.setDynamic = function(t) { return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? En : Tn), this }, Ur.prototype.copyIndicesArray = function() { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") }, Ur.prototype.setArray = function() { console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, is.prototype.addIndex = function(t) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t) }, is.prototype.addAttribute = function(t, e) { return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Ur(arguments[1], arguments[2]))) }, is.prototype.addDrawCall = function(t, e, n) { void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e) }, is.prototype.clearDrawCalls = function() { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, is.prototype.computeOffsets = function() { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") }, is.prototype.removeAttribute = function(t) { return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t) }, is.prototype.applyMatrix = function(t) { return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) }, Object.defineProperties(is.prototype, { drawcalls: { get: function() { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function() { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), Pl.prototype.setDynamic = function(t) { return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? En : Tn), this }, Pl.prototype.setArray = function() { console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, Wh.prototype.getArrays = function() { console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.") }, Wh.prototype.addShapeList = function() { console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.") }, Wh.prototype.addShape = function() { console.error("THREE.ExtrudeGeometry: .addShape() has been removed.") }, Cl.prototype.dispose = function() { console.error("THREE.Scene: .dispose() has been removed.") }, Qd.prototype.onUpdate = function() { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this }, Object.defineProperties(Lr.prototype, { wrapAround: { get: function() { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function() { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function() { console.warn("THREE.Material: .overdraw has been removed.") }, set: function() { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function() { return console.warn("THREE.Material: .wrapRGB has been removed."), new Br } }, shading: { get: function() { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function(t) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t === v } }, stencilMask: { get: function() { return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask }, set: function(t) { console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t } }, vertexTangents: { get: function() { console.warn("THREE." + this.type + ": .vertexTangents has been removed.") }, set: function() { console.warn("THREE." + this.type + ": .vertexTangents has been removed.") } } }), Object.defineProperties(As.prototype, { derivatives: { get: function() { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function(t) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t } } }), El.prototype.clearTarget = function(t, e, n, i) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i) }, El.prototype.animate = function(t) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t) }, El.prototype.getCurrentRenderTarget = function() { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, El.prototype.getMaxAnisotropy = function() { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, El.prototype.getPrecision = function() { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, El.prototype.resetGLState = function() { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, El.prototype.supportsFloatTextures = function() { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, El.prototype.supportsHalfFloatTextures = function() { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, El.prototype.supportsStandardDerivatives = function() { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, El.prototype.supportsCompressedTextureS3TC = function() { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, El.prototype.supportsCompressedTexturePVRTC = function() { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, El.prototype.supportsBlendMinMax = function() { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, El.prototype.supportsVertexTextures = function() { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, El.prototype.supportsInstancedArrays = function() { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, El.prototype.enableScissorTest = function(t) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t) }, El.prototype.initMaterial = function() { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, El.prototype.addPrePlugin = function() { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, El.prototype.addPostPlugin = function() { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, El.prototype.updateShadowMap = function() { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, El.prototype.setFaceCulling = function() { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, El.prototype.allocTextureUnit = function() { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, El.prototype.setTexture = function() { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, El.prototype.setTexture2D = function() { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, El.prototype.setTextureCube = function() { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") }, El.prototype.getActiveMipMapLevel = function() { return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel() }, Object.defineProperties(El.prototype, { shadowMapEnabled: { get: function() { return this.shadowMap.enabled }, set: function(t) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t } }, shadowMapType: { get: function() { return this.shadowMap.type }, set: function(t) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t } }, shadowMapCullFace: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } }, context: { get: function() { return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext() } }, vr: { get: function() { return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr } }, gammaInput: { get: function() { return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1 }, set: function() { console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.") } }, gammaOutput: { get: function() { return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1 }, set: function(t) { console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? Ke : Je } }, toneMappingWhitePoint: { get: function() { return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1 }, set: function() { console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.") } } }), Object.defineProperties(gl.prototype, { cullFace: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(ci.prototype, { wrapS: { get: function() { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t } }, wrapT: { get: function() { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t } }, magFilter: { get: function() { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t } }, minFilter: { get: function() { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t } }, anisotropy: { get: function() { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t } }, offset: { get: function() { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t } }, repeat: { get: function() { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t } }, format: { get: function() { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t } }, type: { get: function() { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t } }, generateMipmaps: { get: function() { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function(t) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t } } }), Pd.prototype.load = function(t) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); const e = this; return (new yd).load(t, (function(t) { e.setBuffer(t) })), this }, Fd.prototype.getData = function() { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() }, Ps.prototype.updateCubeMap = function(t, e) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e) }, Ps.prototype.clear = function(t, e, n, i) { return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, i) }, ri.crossOrigin = void 0, ri.loadTexture = function(t, e, n, i) {
                    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                    const r = new ku;
                    r.setCrossOrigin(this.crossOrigin);
                    const s = r.load(t, n, void 0, i);
                    return e && (s.mapping = e), s
                }, ri.loadTextureCube = function(t, e, n, i) {
                    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                    const r = new Uu;
                    r.setCrossOrigin(this.crossOrigin);
                    const s = r.load(t, n, void 0, i);
                    return e && (s.mapping = e), s
                }, ri.loadCompressedTexture = function() { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, ri.loadCompressedTextureCube = function() { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") };
                const Tm = { createMultiMaterialObject: function() { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, detach: function() { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, attach: function() { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") } };

                function Em() { console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js") }

                function Am() { return console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"), new is }

                function Lm() { return console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"), new is }

                function Rm() { console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js") }

                function Cm() { console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js") }

                function Pm() { console.error("THREE.ImmediateRenderObject has been removed.") }
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: i } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = i)
            },
            883: function(t, e, n) {
                "use strict";
                var i = this && this.__createBinding || (Object.create ? function(t, e, n, i) { void 0 === i && (i = n), Object.defineProperty(t, i, { enumerable: !0, get: function() { return e[n] } }) } : function(t, e, n, i) { void 0 === i && (i = n), t[i] = e[n] }),
                    r = this && this.__setModuleDefault || (Object.create ? function(t, e) { Object.defineProperty(t, "default", { enumerable: !0, value: e }) } : function(t, e) { t.default = e }),
                    s = this && this.__importStar || function(t) {
                        if (t && t.__esModule) return t;
                        var e = {};
                        if (null != t)
                            for (var n in t) "default" !== n && Object.prototype.hasOwnProperty.call(t, n) && i(e, t, n);
                        return r(e, t), e
                    },
                    o = this && this.__awaiter || function(t, e, n, i) {
                        return new(n || (n = Promise))((function(r, s) {
                            function o(t) { try { l(i.next(t)) } catch (t) { s(t) } }

                            function a(t) { try { l(i.throw(t)) } catch (t) { s(t) } }

                            function l(t) {
                                var e;
                                t.done ? r(t.value) : (e = t.value, e instanceof n ? e : new n((function(t) { t(e) }))).then(o, a)
                            }
                            l((i = i.apply(t, e || [])).next())
                        }))
                    };
                Object.defineProperty(e, "__esModule", { value: !0 }), e.ThreePhysicsComponent = void 0;
                const a = n(217),
                    l = n(784),
                    c = n(205),
                    h = s(n(212)),
                    u = n(212);
                class d extends l.Scene3D {
                    constructor() { super() }
                    init() { return o(this, void 0, void 0, (function*() { this.renderer.setPixelRatio(1), this.renderer.setSize(window.innerWidth, window.innerHeight), document.body.appendChild(this.renderer.domElement) })) }
                    preload() { return o(this, void 0, void 0, (function*() {})) }
                    create() {
                        return o(this, void 0, void 0, (function*() {
                            const t = new h.Scene;
                            this.warpSpeed("-orbitControls", "-ground", "-camera"), t.background = new h.Color("#00A651"), this.renderer.shadowMap.enabled = !0, this.renderer.setSize(window.innerWidth, window.innerHeight);
                            const e = new h.PerspectiveCamera(20, 1, .1, 1e3);
                            this.camera.position.set(0, 40, 0), this.camera.lookAt(0, 0, -5), window.onresize = () => {
                                console.log("resizing");
                                const t = window.innerWidth,
                                    e = window.innerHeight;
                                this.renderer.setSize(t, e), this.camera.aspect = t / e, this.camera.updateProjectionMatrix()
                            }, this.physics.add.ground({ y: -5, width: 500, height: 500 }, { lambert: { color: "#019047" } });
                            const n = new u.MeshPhongMaterial({ color: "#00A651", specular: 328965, shininess: 100, opacity: 0 });
                            let i = 0;
                            (() => {
                                (new a.GLTFLoader).loadAsync("/2021/wp-content/themes/hivcd2021/dice/models/dice_1203.glb").then((t => {
                                    const r = t.scene.children[0];
                                    r.scale.set(2, 2, 2), r.material = n;
                                    for (let t = 0; t < 5; t++) {
                                        const t = r.clone(),
                                            e = new l.ExtendedObject3D;
                                        e.add(t), e.position.z = 20 * Math.random() - 55, e.position.x = 20 * Math.random() - 65, e.position.y = 2 + 25 * Math.random(), e.quaternion.x = (90 * Math.random() - 45) * Math.PI / 180, e.quaternion.z = (90 * Math.random() - 45) * Math.PI / 180, e.rotation.set(100 * Math.PI / 180, 230 * Math.random(), 30 * Math.random()), e.scale.set(2, 2, 2);
                                        let n = 20 * Math.random(),
                                            s = 5 * Math.random();
                                        this.add.existing(e), this.physics.add.existing(e, { shape: "box", width: 1.9, height: 1.9, depth: 1.9, mass: 1 }), e.body.setBounciness(.6), e.body.setFriction(.8), e.body.setVelocity(28 + s, 35 + n, 20 + s), e.body.setAngularVelocity(25 * Math.random() - 10, 25 * Math.random() - 10, 25 * Math.random() - 10), i += 1
                                    }
                                    console.log(i);
                                    const s = new u.Raycaster;
                                    window.addEventListener("pointerdown", (t => {
                                        const n = t.clientX / window.innerWidth * 2 - 1,
                                            o = -t.clientY / window.innerHeight * 2 + 1;
                                        s.setFromCamera({ x: n, y: o }, e);
                                        const a = new h.Vector3;
                                        a.copy(s.ray.direction), a.add(s.ray.origin);
                                        let c = 300;
                                        if (n < 0 && o > 0 && i < c) {
                                            for (let t = 0; t < 5; t++) {
                                                const t = r.clone(),
                                                    e = new l.ExtendedObject3D;
                                                e.add(t), e.position.z = 20 * Math.random() - 55, e.position.x = 20 * Math.random() - 65, e.position.y = 2 + 25 * Math.random(), e.quaternion.x = (90 * Math.random() - 45) * Math.PI / 180, e.quaternion.z = (90 * Math.random() - 45) * Math.PI / 180, e.rotation.set(100 * Math.PI / 180, 230 * Math.random(), 30 * Math.random()), e.scale.set(2, 2, 2);
                                                let n = 20 * Math.random(),
                                                    s = 5 * Math.random();
                                                this.add.existing(e), this.physics.add.existing(e, { shape: "box", width: 1.9, height: 1.9, depth: 1.9, mass: 1 }), e.body.setBounciness(.6), e.body.setFriction(.8), e.body.setVelocity(28 + s, 35 + n, 20 + s), e.body.setAngularVelocity(25 * Math.random() - 10, 25 * Math.random() - 10, 25 * Math.random() - 10), i += 1
                                            }
                                            console.log(i)
                                        } else if (n > 0 && o > 0 && i < c) {
                                            for (let t = 0; t < 5; t++) {
                                                const t = r.clone(),
                                                    e = new l.ExtendedObject3D;
                                                e.add(t), e.position.z = 20 * Math.random() - 50, e.position.x = 60 - 20 * Math.random(), e.position.y = 2 + 20 * Math.random(), e.quaternion.x = -(90 * Math.random() - 45) * Math.PI / 180, e.quaternion.z = (90 * Math.random() - 45) * Math.PI / 180, e.rotation.set(100 * Math.PI / 180, 230 * Math.random(), 30 * Math.random()), e.scale.set(2, 2, 2);
                                                let n = 20 * Math.random(),
                                                    s = 5 * Math.random();
                                                this.add.existing(e), this.physics.add.existing(e, { shape: "box", width: 1.9, height: 1.9, depth: 1.9, mass: 1 }), e.body.setBounciness(.6), e.body.setFriction(.8), e.body.setVelocity(-(25 + s), 40 + n, 15 + s), e.body.setAngularVelocity(25 * Math.random() - 10, 25 * Math.random() - 10, 25 * Math.random() - 10), i += 1
                                            }
                                            console.log(i)
                                        } else if (n < 0 && o < 0 && i < c) {
                                            for (let t = 0; t < 5; t++) {
                                                const t = r.clone(),
                                                    e = new l.ExtendedObject3D;
                                                e.add(t), e.position.z = 40 - 20 * Math.random(), e.position.x = 20 * Math.random() - 55, e.position.y = 2 + 20 * Math.random(), e.quaternion.x = (90 * Math.random() - 45) * Math.PI / 180, e.quaternion.z = -(90 * Math.random() - 45) * Math.PI / 180, e.rotation.set(100 * Math.PI / 180, 230 * Math.random(), 30 * Math.random()), e.scale.set(2, 2, 2);
                                                let n = 20 * Math.random(),
                                                    s = 5 * Math.random();
                                                this.add.existing(e), this.physics.add.existing(e, { shape: "box", width: 1.9, height: 1.9, depth: 1.9, mass: 1 }), e.body.setBounciness(.6), e.body.setFriction(.8), e.body.setVelocity(25 + s, 30 + n, -(15 + s)), e.body.setAngularVelocity(25 * Math.random() - 10, 25 * Math.random() - 10, -(25 * Math.random() - 10)), i += 1
                                            }
                                            console.log(i)
                                        } else {
                                            if (!(n > 0 && o < 0 && i < c)) return;
                                            for (let t = 0; t < 5; t++) {
                                                const t = r.clone(),
                                                    e = new l.ExtendedObject3D;
                                                e.add(t), e.position.z = 40 - 20 * Math.random(), e.position.x = 55 - 20 * Math.random(), e.position.y = 2 + 20 * Math.random(), e.quaternion.x = (90 * Math.random() - 45) * Math.PI / 180, e.quaternion.z = -(90 * Math.random() - 45) * Math.PI / 180, e.rotation.set(100 * Math.PI / 180, 230 * Math.random(), 30 * Math.random()), e.scale.set(2, 2, 2);
                                                let n = 20 * Math.random(),
                                                    s = 5 * Math.random();
                                                this.add.existing(e), this.physics.add.existing(e, { shape: "box", width: 1.9, height: 1.9, depth: 1.9, mass: 1 }), e.body.setBounciness(.6), e.body.setFriction(.8), e.body.setVelocity(-(25 + s), 30 + n, -(15 + s)), e.body.setAngularVelocity(-(25 * Math.random() - 10), 25 * Math.random() - 10, -(25 * Math.random() - 10)), i += 1
                                            }
                                            console.log(i)
                                        }
                                    }))
                                }))
                            })()
                        }))
                    }
                    update() {}
                }
                e.ThreePhysicsComponent = d;
                const p = { scenes: [d], antialias: !0, gravity: { x: 0, y: 10 * -9.81, z: 0 } };
                (0, c.PhysicsLoader)("/ammo", (() => new l.Project(p)))
            },
            70: function(t, e, n) {
                "use strict";
                var i = this && this.__spreadArray || function(t, e) { for (var n = 0, i = e.length, r = t.length; n < i; n++, r++) t[r] = e[n]; return t };
                Object.defineProperty(e, "__esModule", { value: !0 }), e.Events = void 0;
                var r = n(822),
                    s = function(t, e, n) { void 0 === n && (n = !1), this.fn = t, this.context = e, this.once = n },
                    o = function(t, e, n, i, r) { if ("function" != typeof n) throw new TypeError("The listener must be a function"); var o = new s(n, i || t, r); return t._events.has(e) ? t._events.get(e).fn ? t._events.set(e, [t._events.get(e), o]) : t._events.get(e).push(o) : (t._events.set(e, o), t._eventsCount++), t },
                    a = function(t, e) { 0 == --t._eventsCount ? t._events = new Map : t._events.delete(e) },
                    l = function() {
                        function t() { this._events = new Map, this._eventsCount = 0 }
                        return Object.defineProperty(t, "VERSION", { get: function() { return r.VERSION }, enumerable: !1, configurable: !0 }), t.prototype.eventNames = function() { return Array.from(this._events.keys()) }, t.prototype.listeners = function(t) { var e = this._events.get(t); if (!e) return []; if (e.fn) return [e.fn]; for (var n = 0, i = e.length, r = new Array(i); n < i; n++) r[n] = e[n].fn; return r }, t.prototype.listenerCount = function(t) { var e = this._events.get(t); return e ? e.fn ? 1 : e.length : 0 }, t.prototype.emit = function(t) { for (var e, n, r = [], s = 1; s < arguments.length; s++) r[s - 1] = arguments[s]; if (!this._events.has(t)) return !1; var o, a = this._events.get(t); if (a.fn) return a.once && this.removeListener(t, a.fn, void 0, !0), (e = a.fn).call.apply(e, i([a.context], r)), !0; var l = a.length; for (o = 0; o < l; o++) a[o].once && this.removeListener(t, a[o].fn, void 0, !0), (n = a[o].fn).call.apply(n, i([a[o].context], r)); return !0 }, t.prototype.on = function(t, e, n) { return o(this, t, e, n, !1) }, t.prototype.once = function(t, e, n) { return o(this, t, e, n, !0) }, t.prototype.removeListener = function(t, e, n, i) {
                            if (!this._events.has(t)) return this;
                            if (!e) return a(this, t), this;
                            var r = this._events.get(t);
                            if (r.fn) r.fn !== e || i && !r.once || n && r.context !== n || a(this, t);
                            else {
                                for (var s = 0, o = [], l = r.length; s < l; s++)(r[s].fn !== e || i && !r[s].once || n && r[s].context !== n) && o.push(r[s]);
                                o.length ? this._events.set(t, 1 === o.length ? o[0] : o) : a(this, t)
                            }
                            return this
                        }, t.prototype.removeAllListeners = function(t) { return t ? this._events.delete(t) && a(this, t) : (this._events = new Map, this._eventsCount = 0), this }, Object.defineProperty(t.prototype, "off", { get: function() { return this.removeListener }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "addListener", { get: function() { return this.on }, enumerable: !1, configurable: !0 }), t
                    }();
                e.Events = l
            },
            822: (t, e) => {
                "use strict";
                Object.defineProperty(e, "__esModule", { value: !0 }), e.VERSION = void 0, e.VERSION = "0.0.5"
            },
            217: (t, e, n) => {
                "use strict";
                n.r(e), n.d(e, { GLTFLoader: () => r });
                var i = n(212);
                class r extends i.Loader {
                    constructor(t) { super(t), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(t) { return new c(t) })), this.register((function(t) { return new f(t) })), this.register((function(t) { return new g(t) })), this.register((function(t) { return new h(t) })), this.register((function(t) { return new u(t) })), this.register((function(t) { return new d(t) })), this.register((function(t) { return new p(t) })), this.register((function(t) { return new m(t) })), this.register((function(t) { return new a(t) })), this.register((function(t) { return new v(t) })) }
                    load(t, e, n, r) {
                        const s = this;
                        let o;
                        o = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : i.LoaderUtils.extractUrlBase(t), this.manager.itemStart(t);
                        const a = function(e) { r ? r(e) : console.error(e), s.manager.itemError(t), s.manager.itemEnd(t) },
                            l = new i.FileLoader(this.manager);
                        l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(t, (function(n) { try { s.parse(n, o, (function(n) { e(n), s.manager.itemEnd(t) }), a) } catch (t) { a(t) } }), n, a)
                    }
                    setDRACOLoader(t) { return this.dracoLoader = t, this }
                    setDDSLoader() { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') }
                    setKTX2Loader(t) { return this.ktx2Loader = t, this }
                    setMeshoptDecoder(t) { return this.meshoptDecoder = t, this }
                    register(t) { return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this }
                    unregister(t) { return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this }
                    parse(t, e, n, r) {
                        let s;
                        const a = {},
                            c = {};
                        if ("string" == typeof t) s = t;
                        else if (i.LoaderUtils.decodeText(new Uint8Array(t, 0, 4)) === y) {
                            try { a[o.KHR_BINARY_GLTF] = new x(t) } catch (t) { return void(r && r(t)) }
                            s = a[o.KHR_BINARY_GLTF].content
                        } else s = i.LoaderUtils.decodeText(new Uint8Array(t));
                        const h = JSON.parse(s);
                        if (void 0 === h.asset || h.asset.version[0] < 2) return void(r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                        const u = new k(h, { path: e || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder });
                        u.fileLoader.setRequestHeader(this.requestHeader);
                        for (let t = 0; t < this.pluginCallbacks.length; t++) {
                            const e = this.pluginCallbacks[t](u);
                            c[e.name] = e, a[e.name] = !0
                        }
                        if (h.extensionsUsed)
                            for (let t = 0; t < h.extensionsUsed.length; ++t) {
                                const e = h.extensionsUsed[t],
                                    n = h.extensionsRequired || [];
                                switch (e) {
                                    case o.KHR_MATERIALS_UNLIT:
                                        a[e] = new l;
                                        break;
                                    case o.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                        a[e] = new M;
                                        break;
                                    case o.KHR_DRACO_MESH_COMPRESSION:
                                        a[e] = new _(h, this.dracoLoader);
                                        break;
                                    case o.KHR_TEXTURE_TRANSFORM:
                                        a[e] = new b;
                                        break;
                                    case o.KHR_MESH_QUANTIZATION:
                                        a[e] = new S;
                                        break;
                                    default:
                                        n.indexOf(e) >= 0 && void 0 === c[e] && console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".')
                                }
                            }
                        u.setExtensions(a), u.setPlugins(c), u.parse(n, r)
                    }
                }

                function s() { let t = {}; return { get: function(e) { return t[e] }, add: function(e, n) { t[e] = n }, remove: function(e) { delete t[e] }, removeAll: function() { t = {} } } }
                const o = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" };
                class a {
                    constructor(t) { this.parser = t, this.name = o.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } }
                    _markDefs() {
                        const t = this.parser,
                            e = this.parser.json.nodes || [];
                        for (let n = 0, i = e.length; n < i; n++) {
                            const i = e[n];
                            i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && t._addNodeRef(this.cache, i.extensions[this.name].light)
                        }
                    }
                    _loadLight(t) {
                        const e = this.parser,
                            n = "light:" + t;
                        let r = e.cache.get(n);
                        if (r) return r;
                        const s = e.json,
                            o = ((s.extensions && s.extensions[this.name] || {}).lights || [])[t];
                        let a;
                        const l = new i.Color(16777215);
                        void 0 !== o.color && l.fromArray(o.color);
                        const c = void 0 !== o.range ? o.range : 0;
                        switch (o.type) {
                            case "directional":
                                a = new i.DirectionalLight(l), a.target.position.set(0, 0, -1), a.add(a.target);
                                break;
                            case "point":
                                a = new i.PointLight(l), a.distance = c;
                                break;
                            case "spot":
                                a = new i.SpotLight(l), a.distance = c, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, a.angle = o.spot.outerConeAngle, a.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target);
                                break;
                            default:
                                throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type)
                        }
                        return a.position.set(0, 0, 0), a.decay = 2, void 0 !== o.intensity && (a.intensity = o.intensity), a.name = e.createUniqueName(o.name || "light_" + t), r = Promise.resolve(a), e.cache.add(n, r), r
                    }
                    createNodeAttachment(t) {
                        const e = this,
                            n = this.parser,
                            i = n.json.nodes[t],
                            r = (i.extensions && i.extensions[this.name] || {}).light;
                        return void 0 === r ? null : this._loadLight(r).then((function(t) { return n._getNodeRef(e.cache, r, t) }))
                    }
                }
                class l {
                    constructor() { this.name = o.KHR_MATERIALS_UNLIT }
                    getMaterialType() { return i.MeshBasicMaterial }
                    extendParams(t, e, n) {
                        const r = [];
                        t.color = new i.Color(1, 1, 1), t.opacity = 1;
                        const s = e.pbrMetallicRoughness;
                        if (s) {
                            if (Array.isArray(s.baseColorFactor)) {
                                const e = s.baseColorFactor;
                                t.color.fromArray(e), t.opacity = e[3]
                            }
                            void 0 !== s.baseColorTexture && r.push(n.assignTexture(t, "map", s.baseColorTexture))
                        }
                        return Promise.all(r)
                    }
                }
                class c {
                    constructor(t) { this.parser = t, this.name = o.KHR_MATERIALS_CLEARCOAT }
                    getMaterialType(t) { const e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? i.MeshPhysicalMaterial : null }
                    extendMaterialParams(t, e) {
                        const n = this.parser,
                            r = n.json.materials[t];
                        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                        const s = [],
                            o = r.extensions[this.name];
                        if (void 0 !== o.clearcoatFactor && (e.clearcoat = o.clearcoatFactor), void 0 !== o.clearcoatTexture && s.push(n.assignTexture(e, "clearcoatMap", o.clearcoatTexture)), void 0 !== o.clearcoatRoughnessFactor && (e.clearcoatRoughness = o.clearcoatRoughnessFactor), void 0 !== o.clearcoatRoughnessTexture && s.push(n.assignTexture(e, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), void 0 !== o.clearcoatNormalTexture && (s.push(n.assignTexture(e, "clearcoatNormalMap", o.clearcoatNormalTexture)), void 0 !== o.clearcoatNormalTexture.scale)) {
                            const t = o.clearcoatNormalTexture.scale;
                            e.clearcoatNormalScale = new i.Vector2(t, t)
                        }
                        return Promise.all(s)
                    }
                }
                class h {
                    constructor(t) { this.parser = t, this.name = o.KHR_MATERIALS_SHEEN }
                    getMaterialType(t) { const e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? i.MeshPhysicalMaterial : null }
                    extendMaterialParams(t, e) {
                        const n = this.parser,
                            r = n.json.materials[t];
                        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                        const s = [];
                        e.sheenColor = new i.Color(0, 0, 0), e.sheenRoughness = 0, e.sheen = 1;
                        const o = r.extensions[this.name];
                        return void 0 !== o.sheenColorFactor && e.sheenColor.fromArray(o.sheenColorFactor), void 0 !== o.sheenRoughnessFactor && (e.sheenRoughness = o.sheenRoughnessFactor), void 0 !== o.sheenColorTexture && s.push(n.assignTexture(e, "sheenColorMap", o.sheenColorTexture)), void 0 !== o.sheenRoughnessTexture && s.push(n.assignTexture(e, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(s)
                    }
                }
                class u {
                    constructor(t) { this.parser = t, this.name = o.KHR_MATERIALS_TRANSMISSION }
                    getMaterialType(t) { const e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? i.MeshPhysicalMaterial : null }
                    extendMaterialParams(t, e) {
                        const n = this.parser,
                            i = n.json.materials[t];
                        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                        const r = [],
                            s = i.extensions[this.name];
                        return void 0 !== s.transmissionFactor && (e.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && r.push(n.assignTexture(e, "transmissionMap", s.transmissionTexture)), Promise.all(r)
                    }
                }
                class d {
                    constructor(t) { this.parser = t, this.name = o.KHR_MATERIALS_VOLUME }
                    getMaterialType(t) { const e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? i.MeshPhysicalMaterial : null }
                    extendMaterialParams(t, e) {
                        const n = this.parser,
                            r = n.json.materials[t];
                        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                        const s = [],
                            o = r.extensions[this.name];
                        e.thickness = void 0 !== o.thicknessFactor ? o.thicknessFactor : 0, void 0 !== o.thicknessTexture && s.push(n.assignTexture(e, "thicknessMap", o.thicknessTexture)), e.attenuationDistance = o.attenuationDistance || 0;
                        const a = o.attenuationColor || [1, 1, 1];
                        return e.attenuationColor = new i.Color(a[0], a[1], a[2]), Promise.all(s)
                    }
                }
                class p {
                    constructor(t) { this.parser = t, this.name = o.KHR_MATERIALS_IOR }
                    getMaterialType(t) { const e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? i.MeshPhysicalMaterial : null }
                    extendMaterialParams(t, e) { const n = this.parser.json.materials[t]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const i = n.extensions[this.name]; return e.ior = void 0 !== i.ior ? i.ior : 1.5, Promise.resolve() }
                }
                class m {
                    constructor(t) { this.parser = t, this.name = o.KHR_MATERIALS_SPECULAR }
                    getMaterialType(t) { const e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? i.MeshPhysicalMaterial : null }
                    extendMaterialParams(t, e) {
                        const n = this.parser,
                            r = n.json.materials[t];
                        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                        const s = [],
                            o = r.extensions[this.name];
                        e.specularIntensity = void 0 !== o.specularFactor ? o.specularFactor : 1, void 0 !== o.specularTexture && s.push(n.assignTexture(e, "specularIntensityMap", o.specularTexture));
                        const a = o.specularColorFactor || [1, 1, 1];
                        return e.specularColor = new i.Color(a[0], a[1], a[2]), void 0 !== o.specularColorTexture && s.push(n.assignTexture(e, "specularColorMap", o.specularColorTexture).then((function(t) { t.encoding = i.sRGBEncoding }))), Promise.all(s)
                    }
                }
                class f {
                    constructor(t) { this.parser = t, this.name = o.KHR_TEXTURE_BASISU }
                    loadTexture(t) {
                        const e = this.parser,
                            n = e.json,
                            i = n.textures[t];
                        if (!i.extensions || !i.extensions[this.name]) return null;
                        const r = i.extensions[this.name],
                            s = n.images[r.source],
                            o = e.options.ktx2Loader;
                        if (!o) { if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null }
                        return e.loadTextureImage(t, s, o)
                    }
                }
                class g {
                    constructor(t) { this.parser = t, this.name = o.EXT_TEXTURE_WEBP, this.isSupported = null }
                    loadTexture(t) {
                        const e = this.name,
                            n = this.parser,
                            i = n.json,
                            r = i.textures[t];
                        if (!r.extensions || !r.extensions[e]) return null;
                        const s = r.extensions[e],
                            o = i.images[s.source];
                        let a = n.textureLoader;
                        if (o.uri) {
                            const t = n.options.manager.getHandler(o.uri);
                            null !== t && (a = t)
                        }
                        return this.detectSupport().then((function(r) { if (r) return n.loadTextureImage(t, o, a); if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return n.loadTexture(t) }))
                    }
                    detectSupport() {
                        return this.isSupported || (this.isSupported = new Promise((function(t) {
                            const e = new Image;
                            e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function() { t(1 === e.height) }
                        }))), this.isSupported
                    }
                }
                class v {
                    constructor(t) { this.name = o.EXT_MESHOPT_COMPRESSION, this.parser = t }
                    loadBufferView(t) {
                        const e = this.parser.json,
                            n = e.bufferViews[t];
                        if (n.extensions && n.extensions[this.name]) {
                            const t = n.extensions[this.name],
                                i = this.parser.getDependency("buffer", t.buffer),
                                r = this.parser.options.meshoptDecoder;
                            if (!r || !r.supported) { if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null }
                            return Promise.all([i, r.ready]).then((function(e) {
                                const n = t.byteOffset || 0,
                                    i = t.byteLength || 0,
                                    s = t.count,
                                    o = t.byteStride,
                                    a = new ArrayBuffer(s * o),
                                    l = new Uint8Array(e[0], n, i);
                                return r.decodeGltfBuffer(new Uint8Array(a), s, o, l, t.mode, t.filter), a
                            }))
                        }
                        return null
                    }
                }
                const y = "glTF";
                class x {
                    constructor(t) {
                        this.name = o.KHR_BINARY_GLTF, this.content = null, this.body = null;
                        const e = new DataView(t, 0, 12);
                        if (this.header = { magic: i.LoaderUtils.decodeText(new Uint8Array(t.slice(0, 4))), version: e.getUint32(4, !0), length: e.getUint32(8, !0) }, this.header.magic !== y) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                        if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                        const n = this.header.length - 12,
                            r = new DataView(t, 12);
                        let s = 0;
                        for (; s < n;) {
                            const e = r.getUint32(s, !0);
                            s += 4;
                            const n = r.getUint32(s, !0);
                            if (s += 4, 1313821514 === n) {
                                const n = new Uint8Array(t, 12 + s, e);
                                this.content = i.LoaderUtils.decodeText(n)
                            } else if (5130562 === n) {
                                const n = 12 + s;
                                this.body = t.slice(n, n + e)
                            }
                            s += e
                        }
                        if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
                    }
                }
                class _ {
                    constructor(t, e) {
                        if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                        this.name = o.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload()
                    }
                    decodePrimitive(t, e) {
                        const n = this.json,
                            i = this.dracoLoader,
                            r = t.extensions[this.name].bufferView,
                            s = t.extensions[this.name].attributes,
                            o = {},
                            a = {},
                            l = {};
                        for (const t in s) {
                            const e = I[t] || t.toLowerCase();
                            o[e] = s[t]
                        }
                        for (const e in t.attributes) {
                            const i = I[e] || e.toLowerCase();
                            if (void 0 !== s[e]) {
                                const r = n.accessors[t.attributes[e]],
                                    s = L[r.componentType];
                                l[i] = s, a[i] = !0 === r.normalized
                            }
                        }
                        return e.getDependency("bufferView", r).then((function(t) {
                            return new Promise((function(e) {
                                i.decodeDracoFile(t, (function(t) {
                                    for (const e in t.attributes) {
                                        const n = t.attributes[e],
                                            i = a[e];
                                        void 0 !== i && (n.normalized = i)
                                    }
                                    e(t)
                                }), o, l)
                            }))
                        }))
                    }
                }
                class b {
                    constructor() { this.name = o.KHR_TEXTURE_TRANSFORM }
                    extendTexture(t, e) { return void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale || (t = t.clone(), void 0 !== e.offset && t.offset.fromArray(e.offset), void 0 !== e.rotation && (t.rotation = e.rotation), void 0 !== e.scale && t.repeat.fromArray(e.scale), t.needsUpdate = !0), t }
                }
                class w extends i.MeshStandardMaterial {
                    constructor(t) {
                        super(), this.isGLTFSpecularGlossinessMaterial = !0;
                        const e = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                            n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                            r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                            s = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                            o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
                            a = { specular: { value: (new i.Color).setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } };
                        this._extraUniforms = a, this.onBeforeCompile = function(t) {
                            for (const e in a) t.uniforms[e] = a[e];
                            t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", s).replace("#include <lights_physical_fragment>", o)
                        }, Object.defineProperties(this, { specular: { get: function() { return a.specular.value }, set: function(t) { a.specular.value = t } }, specularMap: { get: function() { return a.specularMap.value }, set: function(t) { a.specularMap.value = t, t ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP } }, glossiness: { get: function() { return a.glossiness.value }, set: function(t) { a.glossiness.value = t } }, glossinessMap: { get: function() { return a.glossinessMap.value }, set: function(t) { a.glossinessMap.value = t, t ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV) } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(t)
                    }
                    copy(t) { return super.copy(t), this.specularMap = t.specularMap, this.specular.copy(t.specular), this.glossinessMap = t.glossinessMap, this.glossiness = t.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this }
                }
                class M {
                    constructor() { this.name = o.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"] }
                    getMaterialType() { return w }
                    extendParams(t, e, n) {
                        const r = e.extensions[this.name];
                        t.color = new i.Color(1, 1, 1), t.opacity = 1;
                        const s = [];
                        if (Array.isArray(r.diffuseFactor)) {
                            const e = r.diffuseFactor;
                            t.color.fromArray(e), t.opacity = e[3]
                        }
                        if (void 0 !== r.diffuseTexture && s.push(n.assignTexture(t, "map", r.diffuseTexture)), t.emissive = new i.Color(0, 0, 0), t.glossiness = void 0 !== r.glossinessFactor ? r.glossinessFactor : 1, t.specular = new i.Color(1, 1, 1), Array.isArray(r.specularFactor) && t.specular.fromArray(r.specularFactor), void 0 !== r.specularGlossinessTexture) {
                            const e = r.specularGlossinessTexture;
                            s.push(n.assignTexture(t, "glossinessMap", e)), s.push(n.assignTexture(t, "specularMap", e))
                        }
                        return Promise.all(s)
                    }
                    createMaterial(t) { const e = new w(t); return e.fog = !0, e.color = t.color, e.map = void 0 === t.map ? null : t.map, e.lightMap = null, e.lightMapIntensity = 1, e.aoMap = void 0 === t.aoMap ? null : t.aoMap, e.aoMapIntensity = 1, e.emissive = t.emissive, e.emissiveIntensity = 1, e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap, e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap, e.bumpScale = 1, e.normalMap = void 0 === t.normalMap ? null : t.normalMap, e.normalMapType = i.TangentSpaceNormalMap, t.normalScale && (e.normalScale = t.normalScale), e.displacementMap = null, e.displacementScale = 1, e.displacementBias = 0, e.specularMap = void 0 === t.specularMap ? null : t.specularMap, e.specular = t.specular, e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap, e.glossiness = t.glossiness, e.alphaMap = null, e.envMap = void 0 === t.envMap ? null : t.envMap, e.envMapIntensity = 1, e.refractionRatio = .98, e }
                }
                class S { constructor() { this.name = o.KHR_MESH_QUANTIZATION } }
                class T extends i.Interpolant {
                    constructor(t, e, n, i) { super(t, e, n, i) }
                    copySampleValue_(t) {
                        const e = this.resultBuffer,
                            n = this.sampleValues,
                            i = this.valueSize,
                            r = t * i * 3 + i;
                        for (let t = 0; t !== i; t++) e[t] = n[r + t];
                        return e
                    }
                }
                T.prototype.beforeStart_ = T.prototype.copySampleValue_, T.prototype.afterEnd_ = T.prototype.copySampleValue_, T.prototype.interpolate_ = function(t, e, n, i) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        o = this.valueSize,
                        a = 2 * o,
                        l = 3 * o,
                        c = i - e,
                        h = (n - e) / c,
                        u = h * h,
                        d = u * h,
                        p = t * l,
                        m = p - l,
                        f = -2 * d + 3 * u,
                        g = d - u,
                        v = 1 - f,
                        y = g - u + h;
                    for (let t = 0; t !== o; t++) {
                        const e = s[m + t + o],
                            n = s[m + t + a] * c,
                            i = s[p + t + o],
                            l = s[p + t] * c;
                        r[t] = v * e + y * n + f * i + g * l
                    }
                    return r
                };
                const E = new i.Quaternion;
                class A extends T { interpolate_(t, e, n, i) { const r = super.interpolate_(t, e, n, i); return E.fromArray(r).normalize().toArray(r), r } }
                const L = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array },
                    R = { 9728: i.NearestFilter, 9729: i.LinearFilter, 9984: i.NearestMipmapNearestFilter, 9985: i.LinearMipmapNearestFilter, 9986: i.NearestMipmapLinearFilter, 9987: i.LinearMipmapLinearFilter },
                    C = { 33071: i.ClampToEdgeWrapping, 33648: i.MirroredRepeatWrapping, 10497: i.RepeatWrapping },
                    P = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
                    I = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" },
                    D = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" },
                    N = { CUBICSPLINE: void 0, LINEAR: i.InterpolateLinear, STEP: i.InterpolateDiscrete };

                function B(t, e, n) { for (const i in n.extensions) void 0 === t[i] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = n.extensions[i]) }

                function O(t, e) { void 0 !== e.extras && ("object" == typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras)) }

                function F(t, e) {
                    if (t.updateMorphTargets(), void 0 !== e.weights)
                        for (let n = 0, i = e.weights.length; n < i; n++) t.morphTargetInfluences[n] = e.weights[n];
                    if (e.extras && Array.isArray(e.extras.targetNames)) { const n = e.extras.targetNames; if (t.morphTargetInfluences.length === n.length) { t.morphTargetDictionary = {}; for (let e = 0, i = n.length; e < i; e++) t.morphTargetDictionary[n[e]] = e } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") }
                }

                function z(t) { const e = t.extensions && t.extensions[o.KHR_DRACO_MESH_COMPRESSION]; let n; return n = e ? "draco:" + e.bufferView + ":" + e.indices + ":" + U(e.attributes) : t.indices + ":" + U(t.attributes) + ":" + t.mode, n }

                function U(t) { let e = ""; const n = Object.keys(t).sort(); for (let i = 0, r = n.length; i < r; i++) e += n[i] + ":" + t[n[i]] + ";"; return e }

                function H(t) {
                    switch (t) {
                        case Int8Array:
                            return 1 / 127;
                        case Uint8Array:
                            return 1 / 255;
                        case Int16Array:
                            return 1 / 32767;
                        case Uint16Array:
                            return 1 / 65535;
                        default:
                            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
                    }
                }
                class k {
                    constructor(t = {}, e = {}) { this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new s, this.associations = new Map, this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.textureCache = {}, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new i.ImageBitmapLoader(this.options.manager) : this.textureLoader = new i.TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new i.FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) }
                    setExtensions(t) { this.extensions = t }
                    setPlugins(t) { this.plugins = t }
                    parse(t, e) {
                        const n = this,
                            i = this.json,
                            r = this.extensions;
                        this.cache.removeAll(), this._invokeAll((function(t) { return t._markDefs && t._markDefs() })), Promise.all(this._invokeAll((function(t) { return t.beforeRoot && t.beforeRoot() }))).then((function() { return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")]) })).then((function(e) {
                            const s = { scene: e[0][i.scene || 0], scenes: e[0], animations: e[1], cameras: e[2], asset: i.asset, parser: n, userData: {} };
                            B(r, s, i), O(s, i), Promise.all(n._invokeAll((function(t) { return t.afterRoot && t.afterRoot(s) }))).then((function() { t(s) }))
                        })).catch(e)
                    }
                    _markDefs() {
                        const t = this.json.nodes || [],
                            e = this.json.skins || [],
                            n = this.json.meshes || [];
                        for (let n = 0, i = e.length; n < i; n++) { const i = e[n].joints; for (let e = 0, n = i.length; e < n; e++) t[i[e]].isBone = !0 }
                        for (let e = 0, i = t.length; e < i; e++) {
                            const i = t[e];
                            void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh), void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)), void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
                        }
                    }
                    _addNodeRef(t, e) { void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++) }
                    _getNodeRef(t, e, n) {
                        if (t.refs[e] <= 1) return n;
                        const i = n.clone(),
                            r = (t, e) => {
                                const n = this.associations.get(t);
                                null != n && this.associations.set(e, n);
                                for (const [n, i] of t.children.entries()) r(i, e.children[n])
                            };
                        return r(n, i), i.name += "_instance_" + t.uses[e]++, i
                    }
                    _invokeOne(t) {
                        const e = Object.values(this.plugins);
                        e.push(this);
                        for (let n = 0; n < e.length; n++) { const i = t(e[n]); if (i) return i }
                        return null
                    }
                    _invokeAll(t) {
                        const e = Object.values(this.plugins);
                        e.unshift(this);
                        const n = [];
                        for (let i = 0; i < e.length; i++) {
                            const r = t(e[i]);
                            r && n.push(r)
                        }
                        return n
                    }
                    getDependency(t, e) {
                        const n = t + ":" + e;
                        let i = this.cache.get(n);
                        if (!i) {
                            switch (t) {
                                case "scene":
                                    i = this.loadScene(e);
                                    break;
                                case "node":
                                    i = this.loadNode(e);
                                    break;
                                case "mesh":
                                    i = this._invokeOne((function(t) { return t.loadMesh && t.loadMesh(e) }));
                                    break;
                                case "accessor":
                                    i = this.loadAccessor(e);
                                    break;
                                case "bufferView":
                                    i = this._invokeOne((function(t) { return t.loadBufferView && t.loadBufferView(e) }));
                                    break;
                                case "buffer":
                                    i = this.loadBuffer(e);
                                    break;
                                case "material":
                                    i = this._invokeOne((function(t) { return t.loadMaterial && t.loadMaterial(e) }));
                                    break;
                                case "texture":
                                    i = this._invokeOne((function(t) { return t.loadTexture && t.loadTexture(e) }));
                                    break;
                                case "skin":
                                    i = this.loadSkin(e);
                                    break;
                                case "animation":
                                    i = this.loadAnimation(e);
                                    break;
                                case "camera":
                                    i = this.loadCamera(e);
                                    break;
                                default:
                                    throw new Error("Unknown type: " + t)
                            }
                            this.cache.add(n, i)
                        }
                        return i
                    }
                    getDependencies(t) {
                        let e = this.cache.get(t);
                        if (!e) {
                            const n = this,
                                i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
                            e = Promise.all(i.map((function(e, i) { return n.getDependency(t, i) }))), this.cache.add(t, e)
                        }
                        return e
                    }
                    loadBuffer(t) {
                        const e = this.json.buffers[t],
                            n = this.fileLoader;
                        if (e.type && "arraybuffer" !== e.type) throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
                        if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[o.KHR_BINARY_GLTF].body);
                        const r = this.options;
                        return new Promise((function(t, s) { n.load(i.LoaderUtils.resolveURL(e.uri, r.path), t, void 0, (function() { s(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".')) })) }))
                    }
                    loadBufferView(t) {
                        const e = this.json.bufferViews[t];
                        return this.getDependency("buffer", e.buffer).then((function(t) {
                            const n = e.byteLength || 0,
                                i = e.byteOffset || 0;
                            return t.slice(i, i + n)
                        }))
                    }
                    loadAccessor(t) {
                        const e = this,
                            n = this.json,
                            r = this.json.accessors[t];
                        if (void 0 === r.bufferView && void 0 === r.sparse) return Promise.resolve(null);
                        const s = [];
                        return void 0 !== r.bufferView ? s.push(this.getDependency("bufferView", r.bufferView)) : s.push(null), void 0 !== r.sparse && (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(s).then((function(t) {
                            const s = t[0],
                                o = P[r.type],
                                a = L[r.componentType],
                                l = a.BYTES_PER_ELEMENT,
                                c = l * o,
                                h = r.byteOffset || 0,
                                u = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0,
                                d = !0 === r.normalized;
                            let p, m;
                            if (u && u !== c) {
                                const t = Math.floor(h / u),
                                    n = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + t + ":" + r.count;
                                let c = e.cache.get(n);
                                c || (p = new a(s, t * u, r.count * u / l), c = new i.InterleavedBuffer(p, u / l), e.cache.add(n, c)), m = new i.InterleavedBufferAttribute(c, o, h % u / l, d)
                            } else p = null === s ? new a(r.count * o) : new a(s, h, r.count * o), m = new i.BufferAttribute(p, o, d);
                            if (void 0 !== r.sparse) {
                                const e = P.SCALAR,
                                    n = L[r.sparse.indices.componentType],
                                    l = r.sparse.indices.byteOffset || 0,
                                    c = r.sparse.values.byteOffset || 0,
                                    h = new n(t[1], l, r.sparse.count * e),
                                    u = new a(t[2], c, r.sparse.count * o);
                                null !== s && (m = new i.BufferAttribute(m.array.slice(), m.itemSize, m.normalized));
                                for (let t = 0, e = h.length; t < e; t++) { const e = h[t]; if (m.setX(e, u[t * o]), o >= 2 && m.setY(e, u[t * o + 1]), o >= 3 && m.setZ(e, u[t * o + 2]), o >= 4 && m.setW(e, u[t * o + 3]), o >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") }
                            }
                            return m
                        }))
                    }
                    loadTexture(t) {
                        const e = this.json,
                            n = this.options,
                            i = e.textures[t],
                            r = e.images[i.source];
                        let s = this.textureLoader;
                        if (r.uri) {
                            const t = n.manager.getHandler(r.uri);
                            null !== t && (s = t)
                        }
                        return this.loadTextureImage(t, r, s)
                    }
                    loadTextureImage(t, e, n) {
                        const r = this,
                            s = this.json,
                            o = this.options,
                            a = s.textures[t],
                            l = (e.uri || e.bufferView) + ":" + a.sampler;
                        if (this.textureCache[l]) return this.textureCache[l];
                        const c = self.URL || self.webkitURL;
                        let h = e.uri || "",
                            u = !1;
                        if (void 0 !== e.bufferView) h = r.getDependency("bufferView", e.bufferView).then((function(t) { u = !0; const n = new Blob([t], { type: e.mimeType }); return h = c.createObjectURL(n), h }));
                        else if (void 0 === e.uri) throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
                        const d = Promise.resolve(h).then((function(t) {
                            return new Promise((function(e, r) {
                                let s = e;
                                !0 === n.isImageBitmapLoader && (s = function(t) {
                                    const n = new i.Texture(t);
                                    n.needsUpdate = !0, e(n)
                                }), n.load(i.LoaderUtils.resolveURL(t, o.path), s, void 0, r)
                            }))
                        })).then((function(e) {!0 === u && c.revokeObjectURL(h), e.flipY = !1, a.name && (e.name = a.name); const n = (s.samplers || {})[a.sampler] || {}; return e.magFilter = R[n.magFilter] || i.LinearFilter, e.minFilter = R[n.minFilter] || i.LinearMipmapLinearFilter, e.wrapS = C[n.wrapS] || i.RepeatWrapping, e.wrapT = C[n.wrapT] || i.RepeatWrapping, r.associations.set(e, { textures: t }), e })).catch((function() { return console.error("THREE.GLTFLoader: Couldn't load texture", h), null }));
                        return this.textureCache[l] = d, d
                    }
                    assignTexture(t, e, n) {
                        const i = this;
                        return this.getDependency("texture", n.index).then((function(r) {
                            if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === e && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + e + " not yet supported."), i.extensions[o.KHR_TEXTURE_TRANSFORM]) {
                                const t = void 0 !== n.extensions ? n.extensions[o.KHR_TEXTURE_TRANSFORM] : void 0;
                                if (t) {
                                    const e = i.associations.get(r);
                                    r = i.extensions[o.KHR_TEXTURE_TRANSFORM].extendTexture(r, t), i.associations.set(r, e)
                                }
                            }
                            return t[e] = r, r
                        }))
                    }
                    assignFinalMaterial(t) {
                        const e = t.geometry;
                        let n = t.material;
                        const r = void 0 === e.attributes.tangent,
                            s = void 0 !== e.attributes.color,
                            o = void 0 === e.attributes.normal;
                        if (t.isPoints) {
                            const t = "PointsMaterial:" + n.uuid;
                            let e = this.cache.get(t);
                            e || (e = new i.PointsMaterial, i.Material.prototype.copy.call(e, n), e.color.copy(n.color), e.map = n.map, e.sizeAttenuation = !1, this.cache.add(t, e)), n = e
                        } else if (t.isLine) {
                            const t = "LineBasicMaterial:" + n.uuid;
                            let e = this.cache.get(t);
                            e || (e = new i.LineBasicMaterial, i.Material.prototype.copy.call(e, n), e.color.copy(n.color), this.cache.add(t, e)), n = e
                        }
                        if (r || s || o) {
                            let t = "ClonedMaterial:" + n.uuid + ":";
                            n.isGLTFSpecularGlossinessMaterial && (t += "specular-glossiness:"), r && (t += "derivative-tangents:"), s && (t += "vertex-colors:"), o && (t += "flat-shading:");
                            let e = this.cache.get(t);
                            e || (e = n.clone(), s && (e.vertexColors = !0), o && (e.flatShading = !0), r && (e.normalScale && (e.normalScale.y *= -1), e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)), this.cache.add(t, e), this.associations.set(e, this.associations.get(n))), n = e
                        }
                        n.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv), t.material = n
                    }
                    getMaterialType() { return i.MeshStandardMaterial }
                    loadMaterial(t) {
                        const e = this,
                            n = this.json,
                            r = this.extensions,
                            s = n.materials[t];
                        let a;
                        const l = {},
                            c = s.extensions || {},
                            h = [];
                        if (c[o.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                            const t = r[o.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                            a = t.getMaterialType(), h.push(t.extendParams(l, s, e))
                        } else if (c[o.KHR_MATERIALS_UNLIT]) {
                            const t = r[o.KHR_MATERIALS_UNLIT];
                            a = t.getMaterialType(), h.push(t.extendParams(l, s, e))
                        } else {
                            const n = s.pbrMetallicRoughness || {};
                            if (l.color = new i.Color(1, 1, 1), l.opacity = 1, Array.isArray(n.baseColorFactor)) {
                                const t = n.baseColorFactor;
                                l.color.fromArray(t), l.opacity = t[3]
                            }
                            void 0 !== n.baseColorTexture && h.push(e.assignTexture(l, "map", n.baseColorTexture)), l.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, l.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (h.push(e.assignTexture(l, "metalnessMap", n.metallicRoughnessTexture)), h.push(e.assignTexture(l, "roughnessMap", n.metallicRoughnessTexture))), a = this._invokeOne((function(e) { return e.getMaterialType && e.getMaterialType(t) })), h.push(Promise.all(this._invokeAll((function(e) { return e.extendMaterialParams && e.extendMaterialParams(t, l) }))))
                        }!0 === s.doubleSided && (l.side = i.DoubleSide);
                        const u = s.alphaMode || "OPAQUE";
                        if ("BLEND" === u ? (l.transparent = !0, l.depthWrite = !1) : (l.format = i.RGBFormat, l.transparent = !1, "MASK" === u && (l.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : .5)), void 0 !== s.normalTexture && a !== i.MeshBasicMaterial && (h.push(e.assignTexture(l, "normalMap", s.normalTexture)), l.normalScale = new i.Vector2(1, 1), void 0 !== s.normalTexture.scale)) {
                            const t = s.normalTexture.scale;
                            l.normalScale.set(t, t)
                        }
                        return void 0 !== s.occlusionTexture && a !== i.MeshBasicMaterial && (h.push(e.assignTexture(l, "aoMap", s.occlusionTexture)), void 0 !== s.occlusionTexture.strength && (l.aoMapIntensity = s.occlusionTexture.strength)), void 0 !== s.emissiveFactor && a !== i.MeshBasicMaterial && (l.emissive = (new i.Color).fromArray(s.emissiveFactor)), void 0 !== s.emissiveTexture && a !== i.MeshBasicMaterial && h.push(e.assignTexture(l, "emissiveMap", s.emissiveTexture)), Promise.all(h).then((function() { let n; return n = a === w ? r[o.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(l) : new a(l), s.name && (n.name = s.name), n.map && (n.map.encoding = i.sRGBEncoding), n.emissiveMap && (n.emissiveMap.encoding = i.sRGBEncoding), O(n, s), e.associations.set(n, { materials: t }), s.extensions && B(r, n, s), n }))
                    }
                    createUniqueName(t) { const e = i.PropertyBinding.sanitizeNodeName(t || ""); let n = e; for (let t = 1; this.nodeNamesUsed[n]; ++t) n = e + "_" + t; return this.nodeNamesUsed[n] = !0, n }
                    loadGeometries(t) {
                        const e = this,
                            n = this.extensions,
                            r = this.primitiveCache;

                        function s(t) { return n[o.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function(n) { return V(n, t, e) })) }
                        const a = [];
                        for (let n = 0, l = t.length; n < l; n++) {
                            const l = t[n],
                                c = z(l),
                                h = r[c];
                            if (h) a.push(h.promise);
                            else {
                                let t;
                                t = l.extensions && l.extensions[o.KHR_DRACO_MESH_COMPRESSION] ? s(l) : V(new i.BufferGeometry, l, e), r[c] = { primitive: l, promise: t }, a.push(t)
                            }
                        }
                        return Promise.all(a)
                    }
                    loadMesh(t) {
                        const e = this,
                            n = this.json,
                            r = this.extensions,
                            s = n.meshes[t],
                            o = s.primitives,
                            a = [];
                        for (let t = 0, e = o.length; t < e; t++) {
                            const e = void 0 === o[t].material ? (void 0 === (l = this.cache).DefaultMaterial && (l.DefaultMaterial = new i.MeshStandardMaterial({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: i.FrontSide })), l.DefaultMaterial) : this.getDependency("material", o[t].material);
                            a.push(e)
                        }
                        var l;
                        return a.push(e.loadGeometries(o)), Promise.all(a).then((function(n) {
                            const a = n.slice(0, n.length - 1),
                                l = n[n.length - 1],
                                c = [];
                            for (let n = 0, h = l.length; n < h; n++) {
                                const h = l[n],
                                    u = o[n];
                                let d;
                                const p = a[n];
                                if (4 === u.mode || 5 === u.mode || 6 === u.mode || void 0 === u.mode) d = !0 === s.isSkinnedMesh ? new i.SkinnedMesh(h, p) : new i.Mesh(h, p), !0 !== d.isSkinnedMesh || d.geometry.attributes.skinWeight.normalized || d.normalizeSkinWeights(), 5 === u.mode ? d.geometry = W(d.geometry, i.TriangleStripDrawMode) : 6 === u.mode && (d.geometry = W(d.geometry, i.TriangleFanDrawMode));
                                else if (1 === u.mode) d = new i.LineSegments(h, p);
                                else if (3 === u.mode) d = new i.Line(h, p);
                                else if (2 === u.mode) d = new i.LineLoop(h, p);
                                else {
                                    if (0 !== u.mode) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + u.mode);
                                    d = new i.Points(h, p)
                                }
                                Object.keys(d.geometry.morphAttributes).length > 0 && F(d, s), d.name = e.createUniqueName(s.name || "mesh_" + t), O(d, s), u.extensions && B(r, d, u), e.assignFinalMaterial(d), c.push(d)
                            }
                            for (let n = 0, i = c.length; n < i; n++) e.associations.set(c[n], { meshes: t, primitives: n });
                            if (1 === c.length) return c[0];
                            const h = new i.Group;
                            e.associations.set(h, { meshes: t });
                            for (let t = 0, e = c.length; t < e; t++) h.add(c[t]);
                            return h
                        }))
                    }
                    loadCamera(t) {
                        let e;
                        const n = this.json.cameras[t],
                            r = n[n.type];
                        if (r) return "perspective" === n.type ? e = new i.PerspectiveCamera(i.MathUtils.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === n.type && (e = new i.OrthographicCamera(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), n.name && (e.name = this.createUniqueName(n.name)), O(e, n), Promise.resolve(e);
                        console.warn("THREE.GLTFLoader: Missing camera parameters.")
                    }
                    loadSkin(t) {
                        const e = this.json.skins[t],
                            n = { joints: e.joints };
                        return void 0 === e.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", e.inverseBindMatrices).then((function(t) { return n.inverseBindMatrices = t, n }))
                    }
                    loadAnimation(t) {
                        const e = this.json.animations[t],
                            n = [],
                            r = [],
                            s = [],
                            o = [],
                            a = [];
                        for (let t = 0, i = e.channels.length; t < i; t++) {
                            const i = e.channels[t],
                                l = e.samplers[i.sampler],
                                c = i.target,
                                h = void 0 !== c.node ? c.node : c.id,
                                u = void 0 !== e.parameters ? e.parameters[l.input] : l.input,
                                d = void 0 !== e.parameters ? e.parameters[l.output] : l.output;
                            n.push(this.getDependency("node", h)), r.push(this.getDependency("accessor", u)), s.push(this.getDependency("accessor", d)), o.push(l), a.push(c)
                        }
                        return Promise.all([Promise.all(n), Promise.all(r), Promise.all(s), Promise.all(o), Promise.all(a)]).then((function(n) {
                            const r = n[0],
                                s = n[1],
                                o = n[2],
                                a = n[3],
                                l = n[4],
                                c = [];
                            for (let t = 0, e = r.length; t < e; t++) {
                                const e = r[t],
                                    n = s[t],
                                    h = o[t],
                                    u = a[t],
                                    d = l[t];
                                if (void 0 === e) continue;
                                let p;
                                switch (e.updateMatrix(), e.matrixAutoUpdate = !0, D[d.path]) {
                                    case D.weights:
                                        p = i.NumberKeyframeTrack;
                                        break;
                                    case D.rotation:
                                        p = i.QuaternionKeyframeTrack;
                                        break;
                                    default:
                                        p = i.VectorKeyframeTrack
                                }
                                const m = e.name ? e.name : e.uuid,
                                    f = void 0 !== u.interpolation ? N[u.interpolation] : i.InterpolateLinear,
                                    g = [];
                                D[d.path] === D.weights ? e.traverse((function(t) {!0 === t.isMesh && t.morphTargetInfluences && g.push(t.name ? t.name : t.uuid) })) : g.push(m);
                                let v = h.array;
                                if (h.normalized) {
                                    const t = H(v.constructor),
                                        e = new Float32Array(v.length);
                                    for (let n = 0, i = v.length; n < i; n++) e[n] = v[n] * t;
                                    v = e
                                }
                                for (let t = 0, e = g.length; t < e; t++) { const e = new p(g[t] + "." + D[d.path], n.array, v, f); "CUBICSPLINE" === u.interpolation && (e.createInterpolant = function(t) { return new(this instanceof i.QuaternionKeyframeTrack ? A : T)(this.times, this.values, this.getValueSize() / 3, t) }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), c.push(e) }
                            }
                            const h = e.name ? e.name : "animation_" + t;
                            return new i.AnimationClip(h, void 0, c)
                        }))
                    }
                    createNodeMesh(t) {
                        const e = this.json,
                            n = this,
                            i = e.nodes[t];
                        return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(t) {
                            const e = n._getNodeRef(n.meshCache, i.mesh, t);
                            return void 0 !== i.weights && e.traverse((function(t) {
                                if (t.isMesh)
                                    for (let e = 0, n = i.weights.length; e < n; e++) t.morphTargetInfluences[e] = i.weights[e]
                            })), e
                        }))
                    }
                    loadNode(t) {
                        const e = this.json,
                            n = this.extensions,
                            r = this,
                            s = e.nodes[t],
                            o = s.name ? r.createUniqueName(s.name) : "";
                        return function() {
                            const e = [],
                                n = r._invokeOne((function(e) { return e.createNodeMesh && e.createNodeMesh(t) }));
                            return n && e.push(n), void 0 !== s.camera && e.push(r.getDependency("camera", s.camera).then((function(t) { return r._getNodeRef(r.cameraCache, s.camera, t) }))), r._invokeAll((function(e) { return e.createNodeAttachment && e.createNodeAttachment(t) })).forEach((function(t) { e.push(t) })), Promise.all(e)
                        }().then((function(e) {
                            let a;
                            if (a = !0 === s.isBone ? new i.Bone : e.length > 1 ? new i.Group : 1 === e.length ? e[0] : new i.Object3D, a !== e[0])
                                for (let t = 0, n = e.length; t < n; t++) a.add(e[t]);
                            if (s.name && (a.userData.name = s.name, a.name = o), O(a, s), s.extensions && B(n, a, s), void 0 !== s.matrix) {
                                const t = new i.Matrix4;
                                t.fromArray(s.matrix), a.applyMatrix4(t)
                            } else void 0 !== s.translation && a.position.fromArray(s.translation), void 0 !== s.rotation && a.quaternion.fromArray(s.rotation), void 0 !== s.scale && a.scale.fromArray(s.scale);
                            return r.associations.has(a) || r.associations.set(a, {}), r.associations.get(a).nodes = t, a
                        }))
                    }
                    loadScene(t) {
                        const e = this.json,
                            n = this.extensions,
                            r = this.json.scenes[t],
                            s = this,
                            o = new i.Group;
                        r.name && (o.name = s.createUniqueName(r.name)), O(o, r), r.extensions && B(n, o, r);
                        const a = r.nodes || [],
                            l = [];
                        for (let t = 0, n = a.length; t < n; t++) l.push(G(a[t], o, e, s));
                        return Promise.all(l).then((function() {
                            return s.associations = (t => {
                                const e = new Map;
                                for (const [t, n] of s.associations)(t instanceof i.Material || t instanceof i.Texture) && e.set(t, n);
                                return t.traverse((t => {
                                    const n = s.associations.get(t);
                                    null != n && e.set(t, n)
                                })), e
                            })(o), o
                        }))
                    }
                }

                function G(t, e, n, r) {
                    const s = n.nodes[t];
                    return r.getDependency("node", t).then((function(t) {
                        if (void 0 === s.skin) return t;
                        let e;
                        return r.getDependency("skin", s.skin).then((function(t) { e = t; const n = []; for (let t = 0, i = e.joints.length; t < i; t++) n.push(r.getDependency("node", e.joints[t])); return Promise.all(n) })).then((function(n) {
                            return t.traverse((function(t) {
                                if (!t.isMesh) return;
                                const r = [],
                                    s = [];
                                for (let t = 0, o = n.length; t < o; t++) {
                                    const o = n[t];
                                    if (o) {
                                        r.push(o);
                                        const n = new i.Matrix4;
                                        void 0 !== e.inverseBindMatrices && n.fromArray(e.inverseBindMatrices.array, 16 * t), s.push(n)
                                    } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[t])
                                }
                                t.bind(new i.Skeleton(r, s), t.matrixWorld)
                            })), t
                        }))
                    })).then((function(t) {
                        e.add(t);
                        const i = [];
                        if (s.children) {
                            const e = s.children;
                            for (let s = 0, o = e.length; s < o; s++) {
                                const o = e[s];
                                i.push(G(o, t, n, r))
                            }
                        }
                        return Promise.all(i)
                    }))
                }

                function V(t, e, n) {
                    const r = e.attributes,
                        s = [];

                    function o(e, i) { return n.getDependency("accessor", e).then((function(e) { t.setAttribute(i, e) })) }
                    for (const e in r) {
                        const n = I[e] || e.toLowerCase();
                        n in t.attributes || s.push(o(r[e], n))
                    }
                    if (void 0 !== e.indices && !t.index) {
                        const i = n.getDependency("accessor", e.indices).then((function(e) { t.setIndex(e) }));
                        s.push(i)
                    }
                    return O(t, e),
                        function(t, e, n) {
                            const r = e.attributes,
                                s = new i.Box3;
                            if (void 0 === r.POSITION) return; {
                                const t = n.json.accessors[r.POSITION],
                                    e = t.min,
                                    o = t.max;
                                if (void 0 === e || void 0 === o) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                                if (s.set(new i.Vector3(e[0], e[1], e[2]), new i.Vector3(o[0], o[1], o[2])), t.normalized) {
                                    const e = H(L[t.componentType]);
                                    s.min.multiplyScalar(e), s.max.multiplyScalar(e)
                                }
                            }
                            const o = e.targets;
                            if (void 0 !== o) {
                                const t = new i.Vector3,
                                    e = new i.Vector3;
                                for (let i = 0, r = o.length; i < r; i++) {
                                    const r = o[i];
                                    if (void 0 !== r.POSITION) {
                                        const i = n.json.accessors[r.POSITION],
                                            s = i.min,
                                            o = i.max;
                                        if (void 0 !== s && void 0 !== o) {
                                            if (e.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))), e.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))), e.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))), i.normalized) {
                                                const t = H(L[i.componentType]);
                                                e.multiplyScalar(t)
                                            }
                                            t.max(e)
                                        } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                                    }
                                }
                                s.expandByVector(t)
                            }
                            t.boundingBox = s;
                            const a = new i.Sphere;
                            s.getCenter(a.center), a.radius = s.min.distanceTo(s.max) / 2, t.boundingSphere = a
                        }(t, e, n), Promise.all(s).then((function() {
                            return void 0 !== e.targets ? function(t, e, n) {
                                let i = !1,
                                    r = !1;
                                for (let t = 0, n = e.length; t < n; t++) { const n = e[t]; if (void 0 !== n.POSITION && (i = !0), void 0 !== n.NORMAL && (r = !0), i && r) break }
                                if (!i && !r) return Promise.resolve(t);
                                const s = [],
                                    o = [];
                                for (let a = 0, l = e.length; a < l; a++) {
                                    const l = e[a];
                                    if (i) {
                                        const e = void 0 !== l.POSITION ? n.getDependency("accessor", l.POSITION) : t.attributes.position;
                                        s.push(e)
                                    }
                                    if (r) {
                                        const e = void 0 !== l.NORMAL ? n.getDependency("accessor", l.NORMAL) : t.attributes.normal;
                                        o.push(e)
                                    }
                                }
                                return Promise.all([Promise.all(s), Promise.all(o)]).then((function(e) {
                                    const n = e[0],
                                        s = e[1];
                                    return i && (t.morphAttributes.position = n), r && (t.morphAttributes.normal = s), t.morphTargetsRelative = !0, t
                                }))
                            }(t, e.targets, n) : t
                        }))
                }

                function W(t, e) {
                    let n = t.getIndex();
                    if (null === n) {
                        const e = [],
                            i = t.getAttribute("position");
                        if (void 0 === i) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t;
                        for (let t = 0; t < i.count; t++) e.push(t);
                        t.setIndex(e), n = t.getIndex()
                    }
                    const r = n.count - 2,
                        s = [];
                    if (e === i.TriangleFanDrawMode)
                        for (let t = 1; t <= r; t++) s.push(n.getX(0)), s.push(n.getX(t)), s.push(n.getX(t + 1));
                    else
                        for (let t = 0; t < r; t++) t % 2 == 0 ? (s.push(n.getX(t)), s.push(n.getX(t + 1)), s.push(n.getX(t + 2))) : (s.push(n.getX(t + 2)), s.push(n.getX(t + 1)), s.push(n.getX(t)));
                    s.length / 3 !== r && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                    const o = t.clone();
                    return o.setIndex(s), o
                }
            }
        },
        e = {};

    function n(i) { var r = e[i]; if (void 0 !== r) return r.exports; var s = e[i] = { exports: {} }; return t[i].call(s.exports, s, s.exports, n), s.exports }
    n.d = (t, e) => { for (var i in e) n.o(e, i) && !n.o(t, i) && Object.defineProperty(t, i, { enumerable: !0, get: e[i] }) }, n.g = function() { if ("object" == typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (t) { if ("object" == typeof window) return window } }(), n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), n.r = t => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, n(883)
})();